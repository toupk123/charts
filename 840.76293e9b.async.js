!(function(){"use strict";var vm=Object.defineProperty;var ah=Object.getOwnPropertySymbols,xm=Object.getPrototypeOf,Cm=Object.prototype.hasOwnProperty,_m=Object.prototype.propertyIsEnumerable,ym=Reflect.get;var Ks=Math.pow,un=(Mt,He,De)=>He in Mt?vm(Mt,He,{enumerable:!0,configurable:!0,writable:!0,value:De}):Mt[He]=De,Rr=(Mt,He)=>{for(var De in He||(He={}))Cm.call(He,De)&&un(Mt,De,He[De]);if(ah)for(var De of ah(He))_m.call(He,De)&&un(Mt,De,He[De]);return Mt};var s=(Mt,He,De)=>un(Mt,typeof He!="symbol"?He+"":He,De);var cn=(Mt,He,De)=>ym(xm(Mt),De,He);var V=(Mt,He,De)=>new Promise((Ur,rs)=>{var K=Xt=>{try{lt(De.next(Xt))}catch(ir){rs(ir)}},me=Xt=>{try{lt(De.throw(Xt))}catch(ir){rs(ir)}},lt=Xt=>Xt.done?Ur(Xt.value):Promise.resolve(Xt.value).then(K,me);lt((De=De.apply(Mt,He)).next())});(self.webpackChunkant_design_pro=self.webpackChunkant_design_pro||[]).push([[840],{20840:function(Mt,He,De){var Dr;De.d(He,{A8y:function(){return Ir},DvJ:function(){return Br},Evg:function(){return Fi},ICF:function(){return $},J24:function(){return Ig},Tme:function(){return ee},Woh:function(){return m},dGP:function(){return $g},gww:function(){return og},nY2:function(){return rp},xBN:function(){return Ca}});var Ur=De(34155),rs=De(48764).lW;const T=class T{constructor(t=1,e=1,r=1,i=1){s(this,"r",0);s(this,"g",0);s(this,"b",0);s(this,"a",0);this.setTo(t,e,r,i)}convertToHDRRGB(){return this.r=this.r*Math.pow(2.4,this.a),this.g=this.g*Math.pow(2.4,this.a),this.b=this.b*Math.pow(2.4,this.a),this}unSerialized(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}hexToRGB(t){return this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}hexToRGBA(t){return this.a=(t>>24&255)/255,this.r=(t>>16&255)/255,this.g=(t>>8&255)/255,this.b=(t&255)/255,this}static random(t=1){let e=new T;return e.a=t,e.r=t*Math.random(),e.g=t*Math.random(),e.b=t*Math.random(),e}static randomRGB(t=.5,e=.5,r=.5,i=.5,a=.5,o=.5){let l=new T;return l.a=1,l.r=i+t*Math.random(),l.g=a+e*Math.random(),l.b=o+r*Math.random(),l}static randomGray(t=.5,e=.5){let r=Math.random()*e+t,i=new T;return i.a=1,i.r=r,i.g=r,i.b=r,i}setTo(t,e,r,i){this.r=Math.max(t,0),this.g=Math.max(e,0),this.b=Math.max(r,0),this.a=Math.max(i,0)}setHex(t){if(typeof t!="string"||T.NON_HEX_CHARS.test(t)||!T.VALID_HEX_SIZE.test(t))throw new TypeError("Expected a valid hex string");t=t.replace(/^#/,"");let e=1;t.length===8&&(e=Number.parseInt(t.slice(6,8),16)/255,t=t.slice(0,6)),t.length===4&&(e=Number.parseInt(t.slice(3,4).repeat(2),16)/255,t=t.slice(0,3)),t.length===3&&(t=t[0]+t[0]+t[1]+t[1]+t[2]+t[2]);const r=Number.parseInt(t,16),i=r>>16,a=r>>8&255,o=r&255,l=e;this.a=l,this.r=i/255,this.g=a/255,this.b=o/255}getHex(){let t=e=>{e*=255;let r=e.toString(16);return r.length===1&&(r="0"+r),r};return t(this.r)+t(this.g)+t(this.b)+t(this.a)}get rgb(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0]}set rgb(t){this.setTo(t[0]/255,t[1]/255,t[2]/255,this.a)}get rgba(){return[this.r*255>>>0,this.g*255>>>0,this.b*255>>>0,this.a*255>>>0]}set rgba(t){this.setTo(t[0]/255,t[1]/255,t[2]/255,t[3]/255)}clone(){return new T().copyFrom(this)}copyFrom(t){return this.r=t.r,this.g=t.g,this.b=t.b,this.a=t.a,this}copyFromArray(t,e=255){return this.r=t[0]/e,this.g=t[1]/e,this.b=t[2]/e,this.a=t[3]/e,this}copyFromVector(t){return this.r=t.x,this.g=t.y,this.b=t.z,this.a=t.w,this}static hexRGBColor(t,e=null){return e=e||new T,e.hexToRGB(t),e}static lerp(t,e,r,i){let a=i||new T;return a.r=(r.r-e.r)*t+e.r,a.g=(r.g-e.g)*t+e.g,a.b=(r.b-e.b)*t+e.b,a.a=(r.a-e.a)*t+e.a,a}};s(T,"COLOR_RED",new T(1,0,0,1)),s(T,"COLOR_GREEN",new T(0,1,0,1)),s(T,"COLOR_BLUE",new T(0,0,1,1)),s(T,"COLOR_WHITE",new T(1,1,1,1)),s(T,"COLOR_0",new T),s(T,"COLOR_1",new T),s(T,"COLOR_2",new T),s(T,"HEX_CHARACTERS","a-f\\d"),s(T,"MATCH_3OR4_HEX",`#?[${T.HEX_CHARACTERS}]{3}[${T.HEX_CHARACTERS}]?`),s(T,"MATCH_6OR8_HEX",`#?[${T.HEX_CHARACTERS}]{6}([${T.HEX_CHARACTERS}]{2})?`),s(T,"NON_HEX_CHARS",new RegExp(`[^#${T.HEX_CHARACTERS}]`,"gi")),s(T,"VALID_HEX_SIZE",new RegExp(`^${T.MATCH_3OR4_HEX}$|^${T.MATCH_6OR8_HEX}$`,"i")),s(T,"PRIMARY",4149685),s(T,"PRIMARYDARK",3162015),s(T,"ACCENT",16728193),s(T,"WHITE",16777215),s(T,"IVORY",16777200),s(T,"LIGHTYELLOW",16777184),s(T,"YELLOW",16776960),s(T,"SNOW",16775930),s(T,"FLORALWHITE",16775920),s(T,"LEMONCHIFFON",16775885),s(T,"CORNSILK",16775388),s(T,"SEASHELL",16774638),s(T,"LAVENDERBLUSH",16773365),s(T,"PAPAYAWHIP",16773077),s(T,"BLANCHEDALMOND",16772045),s(T,"MISTYROSE",16770273),s(T,"BISQUE",16770244),s(T,"MOCCASIN",16770229),s(T,"NAVAJOWHITE",16768685),s(T,"PEACHPUFF",16767673),s(T,"GOLD",16766720),s(T,"PINK",16761035),s(T,"LIGHTPINK",16758465),s(T,"ORANGE",16753920),s(T,"LIGHTSALMON",16752762),s(T,"DARKORANGE",16747520),s(T,"CORAL",16744272),s(T,"HOTPINK",16738740),s(T,"TOMATO",16737095),s(T,"ORANGERED",16729344),s(T,"DEEPPINK",16716947),s(T,"FUCHSIA",16711935),s(T,"MAGENTA",16711935),s(T,"RED",16711680),s(T,"OLDLACE",16643558),s(T,"LIGHTGOLDENRODYELLOW",16448210),s(T,"LINEN",16445670),s(T,"ANTIQUEWHITE",16444375),s(T,"SALMON",16416882),s(T,"GHOSTWHITE",16316671),s(T,"MINTCREAM",16121850),s(T,"WHITESMOKE",16119285),s(T,"BEIGE",16119260),s(T,"WHEAT",16113331),s(T,"SANDYBROWN",16032864),s(T,"AZURE",15794175),s(T,"HONEYDEW",15794160),s(T,"ALICEBLUE",15792383),s(T,"KHAKI",15787660),s(T,"LIGHTCORAL",15761536),s(T,"PALEGOLDENROD",15657130),s(T,"VIOLET",15631086),s(T,"DARKSALMON",15308410),s(T,"LAVENDER",15132410),s(T,"LIGHTCYAN",14745599),s(T,"BURLYWOOD",14596231),s(T,"PLUM",14524637),s(T,"GAINSBORO",14474460),s(T,"CRIMSON",14423100),s(T,"PALEVIOLETRED",14381203),s(T,"GOLDENROD",14329120),s(T,"ORCHID",14315734),s(T,"THISTLE",14204888),s(T,"LIGHTGREY",13882323),s(T,"TAN",13808780),s(T,"CHOCOLATE",13789470),s(T,"PERU",13468991),s(T,"INDIANRED",13458524),s(T,"MEDIUMVIOLETRED",13047173),s(T,"SILVER",12632256),s(T,"DARKKHAKI",12433259),s(T,"ROSYBROWN",12357519),s(T,"MEDIUMORCHID",12211667),s(T,"DARKGOLDENROD",12092939),s(T,"FIREBRICK",11674146),s(T,"POWDERBLUE",11591910),s(T,"LIGHTSTEELBLUE",11584734),s(T,"PALETURQUOISE",11529966),s(T,"GREENYELLOW",11403055),s(T,"LIGHTBLUE",11393254),s(T,"DARKGRAY",11119017),s(T,"BROWN",10824234),s(T,"SIENNA",10506797),s(T,"DARKORCHID",10040012),s(T,"PALEGREEN",10025880),s(T,"DARKVIOLET",9699539),s(T,"MEDIUMPURPLE",9662683),s(T,"LIGHTGREEN",9498256),s(T,"DARKSEAGREEN",9419919),s(T,"SADDLEBROWN",9127187),s(T,"DARKMAGENTA",9109643),s(T,"DARKRED",9109504),s(T,"BLUEVIOLET",9055202),s(T,"LIGHTSKYBLUE",8900346),s(T,"SKYBLUE",8900331),s(T,"GRAY",8421504),s(T,"OLIVE",8421376),s(T,"PURPLE",8388736),s(T,"MAROON",8388608),s(T,"AQUAMARINE",8388564),s(T,"CHARTREUSE",8388352),s(T,"LAWNGREEN",8190976),s(T,"MEDIUMSLATEBLUE",8087790),s(T,"LIGHTSLATEGRAY",7833753),s(T,"SLATEGRAY",7372944),s(T,"OLIVEDRAB",7048739),s(T,"SLATEBLUE",6970061),s(T,"DIMGRAY",6908265),s(T,"MEDIUMAQUAMARINE",6737322),s(T,"CORNFLOWERBLUE",6591981),s(T,"CADETBLUE",6266528),s(T,"DARKOLIVEGREEN",5597999),s(T,"INDIGO",4915330),s(T,"MEDIUMTURQUOISE",4772300),s(T,"DARKSLATEBLUE",4734347),s(T,"STEELBLUE",4620980),s(T,"ROYALBLUE",4286945),s(T,"TURQUOISE",4251856),s(T,"MEDIUMSEAGREEN",3978097),s(T,"LIMEGREEN",3329330),s(T,"DARKSLATEGRAY",3100495),s(T,"SEAGREEN",3050327),s(T,"FORESTGREEN",2263842),s(T,"LIGHTSEAGREEN",2142890),s(T,"DODGERBLUE",2003199),s(T,"MIDNIGHTBLUE",1644912),s(T,"AQUA",65535),s(T,"CYAN",65535),s(T,"SPRINGGREEN",65407),s(T,"LIME",65280),s(T,"MEDIUMSPRINGGREEN",64154),s(T,"DARKTURQUOISE",52945),s(T,"DEEPSKYBLUE",49151),s(T,"DARKCYAN",35723),s(T,"TEAL",32896),s(T,"GREEN",32768),s(T,"DARKGREEN",25600),s(T,"BLUE",255),s(T,"MEDIUMBLUE",205),s(T,"DARKBLUE",139),s(T,"NAVY",128),s(T,"BLACK",0);let K=T;class me{static start(t){this._startTime=performance.now(),this._timeLabel=t}static end(){console.log(this._timeLabel,performance.now()-this._startTime)}}s(me,"time",0),s(me,"frame",0),s(me,"delta",0),s(me,"_startTime",0),s(me,"_timeLabel","");class lt{constructor(t=null,e=null){s(this,"target");s(this,"currentTarget");s(this,"type");s(this,"data");s(this,"param");s(this,"time",0);s(this,"delay",0);s(this,"mouseCode",0);s(this,"ctrlKey");s(this,"metaKey");s(this,"altKey");s(this,"shiftKey");s(this,"targetTouches");s(this,"changedTouches");s(this,"touches");s(this,"_stopImmediatePropagation",!1);s(this,"view");this.type=t,this.data=e}stopImmediatePropagation(){this._stopImmediatePropagation=!0}reset(){this._stopImmediatePropagation=!1}get isStopImmediatePropagation(){return this._stopImmediatePropagation}}class Xt{constructor(t=null,e=null,r=null,i=null,a=0){s(this,"id",0);s(this,"current");this.type=t,this.thisObject=e,this.handler=r,this.param=i,this.priority=a}equalCurrentListener(t,e,r,i){return this.type==t&&this.thisObject==r&&this.handler==e&&this.param==i}dispose(){this.handler=null,this.thisObject=null,this.param=null,this.priority=0}}s(Xt,"event_id_count",0);class ir{constructor(){s(this,"listeners",{});s(this,"data")}dispatchEvent(t){var e=this.listeners[t.type];if(e!=null){e=e.slice();for(var r=0;r<e.length;r++){var i=e[r];if(i.handler){try{t.param=i.param,t.currentTarget=i,i.thisObject,i.handler.call(i.thisObject,t)}catch(a){}if(t.isStopImmediatePropagation)break}}}}destroy(){for(var t in this.listeners)for(var e=this.listeners[t];e.length>0;){var r=e[0];r.handler=null,r.thisObject=null,e.splice(0,1)}}addEventListener(t,e,r,i=null,a=0){if(this.listeners[t]==null&&(this.listeners[t]=[]),!this.hasEventListener(t,e,r)){var o=new Xt(t,r,e,i,a);return o.id=++Xt.event_id_count,o.current=this,this.listeners[t].push(o),this.listeners[t].sort(function(l,h){return h.priority-l.priority}),o.id}for(let l=0;l<this.listeners[t].length;l++){let h=this.listeners[t][l];if(h.equalCurrentListener(t,e,r,i))return h.id}return 0}removeEventListener(t,e,r){if(this.hasEventListener(t,e,r))for(var i=0;i<this.listeners[t].length;i++){var a=this.listeners[t][i];if(a.equalCurrentListener(t,e,r,a.param)){a.handler=null,a.thisObject=null,this.listeners[t].splice(i,1);return}}}removeEventListenerAt(t){for(var e in this.listeners)for(var r=0;r<this.listeners[e].length;r++){var i=this.listeners[e][r];if(i.id==t)return i.handler=null,i.thisObject=null,this.listeners[e].splice(r,1),!0}return!1}removeAllEventListener(t=null){let e;if(t){if(this.listeners[t]){for(var r=0;r<this.listeners[t].length;r++)e=this.listeners[t][r],e.dispose(),this.listeners[t].splice(r,1);delete this.listeners[t]}}else for(let i in this.listeners){for(var r=0;r<this.listeners[i].length;r++)e=this.listeners[i][r],e.dispose(),this.listeners[i].splice(r,1);delete this.listeners[i]}}containEventListener(t){return this.listeners[t]==null?!1:this.listeners[t].length>0}hasEventListener(t,e=null,r=null){if(this.listeners[t]==null)return!1;if(r&&e)for(var i=0;i<this.listeners[t].length;i++){var a=this.listeners[t][i];if(a.equalCurrentListener(t,e,r,a.param))return!0}return!1}}class ar extends lt{constructor(){super(...arguments);s(this,"keyCode",0)}}s(ar,"KEY_DOWN","onKeyDown"),s(ar,"KEY_UP","onKeyUp");class F extends lt{constructor(){super(...arguments);s(this,"pointerId");s(this,"pointerType","onPointer");s(this,"isPrimary");s(this,"pressure");s(this,"mouseX");s(this,"mouseY");s(this,"movementX");s(this,"movementY");s(this,"deltaX");s(this,"deltaY");s(this,"deltaZ")}reset(){super.reset(),this.mouseX=0,this.mouseY=0,this.movementX=0,this.movementY=0,this.deltaX=0,this.deltaY=0,this.deltaZ=0}}s(F,"PICK_OVER","onPickOver"),s(F,"PICK_CLICK","onPickClick"),s(F,"PICK_OUT","onPickOut"),s(F,"PICK_MOVE","onPickMove"),s(F,"PICK_UP","onPickUp"),s(F,"PICK_DOWN","onPickDown"),s(F,"POINTER_RIGHT_CLICK","onPointerRightClick"),s(F,"POINTER_CLICK","onPointerClick"),s(F,"POINTER_MOVE","onPointerMove"),s(F,"POINTER_DOWN","onPointerDown"),s(F,"POINTER_UP","onPointerUp"),s(F,"POINTER_OUT","onPointerOut"),s(F,"POINTER_OVER","onPointerOver"),s(F,"POINTER_WHEEL","onPointerWheel");class Xe extends lt{constructor(){super(...arguments);s(this,"pointerId");s(this,"pointerType","onPickGUI");s(this,"isPrimary");s(this,"pressure");s(this,"mouseX");s(this,"mouseY");s(this,"movementX");s(this,"movementY");s(this,"deltaX");s(this,"deltaY");s(this,"deltaZ")}reset(){super.reset(),this.mouseX=0,this.mouseY=0,this.movementX=0,this.movementY=0,this.deltaX=0,this.deltaY=0,this.deltaZ=0}}s(Xe,"PICK_OVER_GUI","onPickOverGUI"),s(Xe,"PICK_CLICK_GUI","onPickClickGUI"),s(Xe,"PICK_OUT_GUI","onPickOutGUI"),s(Xe,"PICK_UP_GUI","onPickUpGUI"),s(Xe,"PICK_DOWN_GUI","onPickDownGUI");const z=class z{constructor(t=0,e=0,r=0,i=0){s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"w",1);s(this,"index",0);this.set(t,e,r,i),this.index=z._index++}static get ZERO(){return new z(0,0,0)}static get ONE(){return new z(1,1,1)}static get LEFT(){return new z(-1,0,0)}static get RIGHT(){return new z(1,0,0)}static get UP(){return new z(0,1,0)}static get DOWN(){return new z(0,-1,0)}static get BACK(){return new z(0,0,-1)}static get FORWARD(){return new z(0,0,1)}set a(t){this.w=t}set r(t){this.x=t}set g(t){this.y=t}set b(t){this.z=t}get a(){return this.w}get r(){return this.x}get g(){return this.y}get b(){return this.z}get length(){return Math.sqrt(this.lengthSquared)}get lengthSquared(){return this.x*this.x+this.y*this.y+this.z*this.z}get position(){return this}static getTowPointbyDir(t,e,r,i,a){a==z.Z_AXIS?(e.x=t.y,e.y=-t.x,r.x=-t.y,r.y=t.x,e.scaleBy(i*.5),r.scaleBy(i*.5)):a==z.Y_AXIS&&(e.x=t.z,e.z=-t.x,r.x=-t.z,r.z=t.x,e.scaleBy(i*.5),r.scaleBy(i*.5))}static pointToLine(t,e,r){let i=0,a,o,l;if(a=z.distance(t,e),o=z.distance(t,r),l=z.distance(e,r),l<=1e-6||o<=1e-6)return i=0,i;if(a<=1e-6||l*l>=a*a+o*o)return i=o,i;if(o*o>=a*a+l*l)return i=l,i;let h=(a+o+l)/2;return i=2*Math.sqrt(h*(h-a)*(h-o)*(h-l))/a,i}static dot(t,e){return t.x*e.x+t.y*e.y+t.z*e.z}static getPoints(t,e){let r=[];for(let i=0;i<t;i++){const a=new z(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);r.push(a)}return r}static getPointNumbers(t,e){let r=[];for(let i=0;i<t;i++)r.push(Math.random()*e-e*.5,Math.random()*e-e*.5,Math.random()*e-e*.5);return r}static getAngle(t,e){let r=t.dotProduct(e)/(t.length*e.length);return Math.acos(r)*180/Math.PI}static sqrMagnitude(t){return t.x*t.x+t.y*t.y+t.z*t.z}static getZYAngle(t,e){return this.calAngle(t.y,t.z,e.y,e.z)}static sub(t,e,r=null){return r=r||new z,r.x=t.x-e.x,r.y=t.y-e.y,r.z=t.z-e.z,r}static add(t,e,r=null){return r=r||new z,r.x=t.x+e.x,r.y=t.y+e.y,r.z=t.z+e.z,r}static smoothDamp(t,e,r,i,a,o){return null}static distance(t,e){var r=t.x-e.x,i=t.y-e.y,a=t.z-e.z;return Math.sqrt(r*r+i*i+a*a)}static squareDistance(t,e){var r=t.x-e.x,i=t.y-e.y,a=t.z-e.z;return r*r+i*i+a*a}static distanceXZ(t,e){var r=t.x-e.x,i=0,a=t.z-e.z;return Math.sqrt(r*r+i*i+a*a)}set(t,e,r,i=1){return this.x=t,this.y=e,this.z=r,this.w=i,this}add(t,e=null){e||(e=new z);var r=this.x,i=this.y,a=this.z,o=this.w,l=t.x,h=t.y,u=t.z,c=t.w;return e.setTo(r+l,i+h,a+u,o+c),e}subVectors(t,e){return this.x=t.x-e.x,this.y=t.y-e.y,this.z=t.z-e.z,this}addScalar(t){return this.x+=t,this.y+=t,this.z+=t,this}subScalar(t){return this.x-=t,this.y-=t,this.z-=t,this}min(t,e=this){return e.x=Math.min(this.x,t.x),e.y=Math.min(this.y,t.y),e.z=Math.min(this.z,t.z),e}max(t,e=this){return e.x=Math.max(this.x,t.x),e.y=Math.max(this.y,t.y),e.z=Math.max(this.z,t.z),e}distanceToSquared(t){let e=this.x-t.x,r=this.y-t.y,i=this.z-t.z;return e*e+r*r+i*i}addXYZW(t,e,r,i,a=null){a||(a=new z);var o=this.x,l=this.y,h=this.z,u=this.w,c=t,f=e,d=r,p=i;return a.setTo(o+c,l+f,h+d,u+p),a}clone(){return new z(this.x,this.y,this.z,this.w)}copyFrom(t){var e=this;return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,e}decrementBy(t){this.x-=t.x,this.y-=t.y,this.z-=t.z}dotProduct(t){return this.x*t.x+this.y*t.y+this.z*t.z}equals(t,e=!1){return this.x==t.x&&this.y==t.y&&this.z==t.z&&(!e||this.w==t.w)}incrementBy(t){this.x+=t.x,this.y+=t.y,this.z+=t.z}divide(t){return t instanceof z?new z(this.x/t.x,this.y/t.y,this.z/t.z):(this.x=this.x/t,this.y=this.y/t,this.z=this.z/t,this)}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}normalize(t=1){let e=this;if(this.length!=0){var r=t/this.length;return this.x*=r,this.y*=r,this.z*=r,e}return e}applyQuaternion(t){const e=this.x,r=this.y,i=this.z,a=t.x,o=t.y,l=t.z,h=t.w,u=h*e+o*i-l*r,c=h*r+l*e-a*i,f=h*i+a*r-o*e,d=-a*e-o*r-l*i;return this.x=u*h+d*-a+c*-l-f*-o,this.y=c*h+d*-o+f*-a-u*-l,this.z=f*h+d*-l+u*-o-c*-a,this}applyMatrix4(t){return t.transformPoint(this,this)}scaleBy(t){return this.x*=t,this.y*=t,this.z*=t,this}mul(t){let e=new z;return e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}scale(t){return this.x*=t.x,this.y*=t.y,this.z*=t.z,this}scaleToRef(t,e){return e||(e=new z),e.x=this.x*t,e.y=this.y*t,e.z=this.z*t,e}setTo(t,e,r,i=1){this.x=t,this.y=e,this.z=r,this.w=i}copy(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}subtract(t,e=null){return e||(e=new z),e.setTo(this.x-t.x,this.y-t.y,this.z-t.z),e}multiply(t,e=null){e||(e=new z);var r=this.x,i=this.y,a=this.z,o=t.x,l=t.y,h=t.z;return e.setTo(r*o,i*l,a*h),e}divided(t,e=null){e||(e=new z);var r=this.x,i=this.y,a=this.z,o=t.x,l=t.y,h=t.z;return e.setTo(r/o,i/l,a/h),e}div(t,e){e||(e=new z);var r=this.x,i=this.y,a=this.z,o=this.w;return e.setTo(r/t,i/t,a/t,o/t),e}lerp(t,e,r){var i=t.x,a=t.y,o=t.z,l=t.w,h=e.x,u=e.y,c=e.z,f=e.w;this.x=(h-i)*r+i,this.y=(u-a)*r+a,this.z=(c-o)*r+o,this.w=(f-l)*r+l}clamp(t,e){return this.x=Math.max(t.x,Math.min(e.x,this.x)),this.y=Math.max(t.y,Math.min(e.y,this.y)),this.z=Math.max(t.z,Math.min(e.z,this.z)),this}toString(){return"<"+this.x+", "+this.y+", "+this.z+">"}normalizeToWay2D_XY(){let t=Math.abs(this.x),e=Math.abs(this.y);t>e?this.x>0?this.copyFrom(z.RIGHT):this.copyFrom(z.LEFT):this.y>0?this.copyFrom(z.DOWN):this.copyFrom(z.UP)}toArray(){return[this.x,this.y,this.z]}copyToBytes(t){t.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this.x,!0),t.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,this.y,!0),t.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,this.z,!0)}crossProduct(t,e=null){return e=e||new z,e.x=this.y*t.z-this.z*t.y,e.y=this.z*t.x-this.x*t.z,e.z=this.x*t.y-this.y*t.x,e.w=1,e}crossVectors(t,e){return t.crossProduct(e,this),this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this}setFromArray(t,e=0){this.x=t[e],this.y=t[e+1],this.z=t[e+2]}divideScalar(t){return this.multiplyScalar(1/t)}clampLength(t,e){let r=this.length;return this.divideScalar(r||1).multiplyScalar(Math.max(t,Math.min(e,r)))}setScalar(t){return this.x=t,this.y=t,this.z=t,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this.z+=t.z*e,this}static calAngle(t,e,r,i){const a=l(r,i,t,e);let o=Math.acos(a)*180/Math.PI;return r<t&&(o=-o),o;function l(u,c,f,d){let p=[u-f,c-d];return h(p,[0,-1])}function h(u,c){let f=u[0]*c[0]+u[1]*c[1],d=Math.sqrt(u[0]*u[0]+u[1]*u[1])*Math.sqrt(c[0]*c[0]+c[1]*c[1]);return f/d}}static pointInsideTriangle(t,e,r,i){return z.HELP_0.setTo(t.x,t.z,0),z.HELP_1.setTo(e.x,e.z,0),z.HELP_2.setTo(r.x,r.z,0),z.HELP_3.setTo(i.x,i.z,0),z.pointInsideTriangle2d()}static pointInsideTriangle2d(){return z.productXY(z.HELP_1,z.HELP_2,z.HELP_3)>=0?z.productXY(z.HELP_1,z.HELP_2,z.HELP_0)>=0&&z.productXY(z.HELP_2,z.HELP_3,z.HELP_0)>=0&&z.productXY(z.HELP_3,z.HELP_1,z.HELP_0)>=0:z.productXY(z.HELP_1,z.HELP_2,z.HELP_0)<=0&&z.productXY(z.HELP_2,z.HELP_3,z.HELP_0)<=0&&z.productXY(z.HELP_3,z.HELP_1,z.HELP_0)<=0}static productXY(t,e,r){var i=(t.x-r.x)*(e.y-r.y)-(t.y-r.y)*(e.x-r.x);return i>-1e-5&&i<1e-5&&(i=0),i}static serialize(t){return new z(t.x,t.y,t.z,t.w)}};s(z,"MAX",new z(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE)),s(z,"MIN",new z(Number.MIN_VALUE,Number.MIN_VALUE,Number.MIN_VALUE)),s(z,"SAFE_MAX",new z(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),s(z,"SAFE_MIN",new z(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER)),s(z,"X_AXIS",new z(1,0,0)),s(z,"neg_X_AXIS",new z(-1,0,0)),s(z,"Y_AXIS",new z(0,1,0)),s(z,"Z_AXIS",new z(0,0,1)),s(z,"HELP_0",new z),s(z,"HELP_1",new z),s(z,"HELP_2",new z),s(z,"EPSILON",1e-5),s(z,"HELP_3",new z),s(z,"HELP_4",new z),s(z,"HELP_5",new z),s(z,"HELP_6",new z),s(z,"_index",0);let g=z;class sh{constructor(t){s(this,"canvasX");s(this,"canvasY");s(this,"identifier");s(this,"clientX");s(this,"clientY");s(this,"pageX");s(this,"pageY");s(this,"screenX");s(this,"screenY");this.canvasX=t.clientX,this.canvasY=t.clientY,this.identifier=t.identifier,this.clientX=t.clientX,this.clientY=t.clientY,this.pageX=t.pageX,this.pageY=t.pageY,this.screenX=t.screenX,this.screenY=t.screenY}}class oh extends ir{constructor(){super(...arguments);s(this,"canvasX",0);s(this,"canvasY",0);s(this,"isMouseDown",!1);s(this,"canvas");s(this,"mouseX",0);s(this,"mouseY",0);s(this,"wheelDelta",0);s(this,"mouseOffsetX",0);s(this,"mouseOffsetY",0);s(this,"mouseLastX",0);s(this,"mouseLastY",0);s(this,"_time",0);s(this,"_keyStatus");s(this,"_mouseStatus");s(this,"_isTouchStart");s(this,"_keyEvent3d");s(this,"_pointerEvent3D");s(this,"_windowsEvent3d");s(this,"mouseLock",!1);s(this,"_oldPosition1",null);s(this,"_oldPosition2",null);s(this,"_downTime",0)}initCanvas(e){this.canvas=e;let r=0,i=0,a=0,o=0;e.onpointerdown=h=>{r=performance.now(),i=h.clientX,a=h.clientY,o=h.button,this.mouseStart(h),e.setPointerCapture(h.pointerId)},e.onpointerup=h=>{this.mouseEnd(h),h.button===o&&performance.now()-r<300&&Math.abs(i-h.clientX)<20&&Math.abs(a-h.clientY)<20&&(h.button===0?this.mouseClick(h):this.rightClick(h)),e.releasePointerCapture(h.pointerId)},e.onpointerenter=h=>{this.mouseOver(h)},e.onpointermove=h=>{this.mouseMove(h)},e.onpointercancel=h=>{e.releasePointerCapture(h.pointerId),this.mouseEnd(h)},e.addEventListener("wheel",h=>this.mouseWheel(h),{passive:!1}),window.addEventListener("keydown",h=>this.keyDown(h),!0),window.addEventListener("keyup",h=>this.keyUp(h),!0),e.oncontextmenu=function(){return!1};let l=this.canvas.getBoundingClientRect();this.canvasX=l.left,this.canvasY=l.top,this._keyStatus={},this._mouseStatus={},this._isTouchStart=!1,this._keyEvent3d=new ar,this._pointerEvent3D=new F,this._windowsEvent3d=new lt}useMouseLock(){this.mouseLock||(this.canvas.requestPointerLock(),this.mouseLock=!0,document.addEventListener("mousemove",e=>this.onMouseLockMove(e),!1))}releaseMouseLock(){this.mouseLock=!1,document.exitPointerLock(),document.removeEventListener("mousemove",e=>this.onMouseLockMove(e),!1)}onMouseLockMove(e){this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=e.movementX,this.mouseOffsetY=e.movementY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=F.POINTER_MOVE,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.movementX=e.movementX,this._pointerEvent3D.movementY=e.movementY,this.dispatchEvent(this._pointerEvent3D)}onPinch(e,r,i,a){this._oldPosition1=new g(e,r),this._oldPosition2=new g(i,a)}onSwipe(e,r){this.mouseX=e,this.mouseY=r,this._oldPosition1=null,this._oldPosition2=null,this._time=new Date().getTime()}GetTargetTouches(e){for(var r=new Array,i=0;i<e.length;i++){var a=new sh(e[i]);r.push(a)}return r}rightClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=F.POINTER_RIGHT_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}mouseClick(e){this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.mouseX=e.clientX-this.canvasX,this._pointerEvent3D.mouseY=e.clientY-this.canvasY,this._pointerEvent3D.type=F.POINTER_CLICK,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this.dispatchEvent(this._pointerEvent3D)}mouseEnd(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._mouseStatus[this._pointerEvent3D.mouseCode]=!1,this._pointerEvent3D.type=F.POINTER_UP,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseStart(e){this.isMouseDown=!0,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.mouseCode=e.button,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId?e.pointerId:0,this._pointerEvent3D.pointerType=e.pointerType?e.pointerType:0,this._pointerEvent3D.isPrimary=e.isPrimary?e.isPrimary:0,this._pointerEvent3D.pressure=e.pressure?e.pressure:0,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.type=F.POINTER_DOWN,this.dispatchEvent(this._pointerEvent3D)}mouseMove(e){this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=F.POINTER_MOVE,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.movementX=e.movementX,this._pointerEvent3D.movementY=e.movementY,this.dispatchEvent(this._pointerEvent3D)}mouseOver(e){this.isMouseDown=!1,this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,this._pointerEvent3D.reset(),this._pointerEvent3D.type=F.POINTER_OVER,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.pointerId=e.pointerId,this._pointerEvent3D.pointerType=e.pointerType,this._pointerEvent3D.isPrimary=e.isPrimary,this._pointerEvent3D.pressure=e.pressure,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this.dispatchEvent(this._pointerEvent3D)}mouseWheel(e){e.preventDefault(),this.mouseLastX=this.mouseX,this.mouseLastY=this.mouseY,this.mouseX=e.clientX-this.canvasX,this.mouseY=e.clientY-this.canvasY,this.mouseOffsetX=this.mouseX-this.mouseLastX,this.mouseOffsetY=this.mouseY-this.mouseLastY,"wheelDelta"in e?(this._pointerEvent3D.delay=e.wheelDelta,this.wheelDelta=e.wheelDelta):"delta"in e&&(this.wheelDelta=e.delta),this._pointerEvent3D.reset(),this._pointerEvent3D.type=F.POINTER_WHEEL,this._pointerEvent3D.ctrlKey=e.ctrlKey,this._pointerEvent3D.metaKey=e.metaKey,this._pointerEvent3D.altKey=e.altKey,this._pointerEvent3D.shiftKey=e.shiftKey,this._pointerEvent3D.mouseX=this.mouseX,this._pointerEvent3D.mouseY=this.mouseY,this._pointerEvent3D.deltaX=e.deltaX,this._pointerEvent3D.deltaY=e.deltaY,this._pointerEvent3D.deltaZ=e.deltaZ,this.dispatchEvent(this._pointerEvent3D)}keyDown(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyEvent3d.ctrlKey=e.ctrlKey,this._keyEvent3d.altKey=e.altKey,this._keyEvent3d.shiftKey=e.shiftKey,this._keyStatus[e.keyCode]||(this._keyStatus[e.keyCode]=!0,this._keyEvent3d.type=ar.KEY_DOWN,this.dispatchEvent(this._keyEvent3d))}keyUp(e){this._keyEvent3d.reset(),this._keyEvent3d.keyCode=e.keyCode,this._keyStatus[e.keyCode]=!1,this._keyEvent3d.type=ar.KEY_UP,this.dispatchEvent(this._keyEvent3d)}GetSlideAngle(e,r){return Math.atan2(r,e)*180/Math.PI}GetSlideDirection(e,r,i,a){var o=r-a,l=i-e,h=0;if(Math.abs(l)<2&&Math.abs(o)<2)return h;var u=this.GetSlideAngle(l,o);return u>=-45&&u<45?h=4:u>=45&&u<135?h=1:u>=-135&&u<-45?h=2:(u>=135&&u<=180||u>=-180&&u<-135)&&(h=3),h}}const nh="0.8.5-dev.5";class Wr extends lt{}s(Wr,"RESIZE","resize");class lh extends ir{constructor(){super(...arguments);s(this,"adapter");s(this,"device");s(this,"context");s(this,"aspect");s(this,"presentationSize",[0,0]);s(this,"presentationFormat");s(this,"canvas");s(this,"windowWidth");s(this,"windowHeight");s(this,"canvasConfig");s(this,"_pixelRatio",1);s(this,"_resizeEvent")}get pixelRatio(){return this._pixelRatio}init(e){return V(this,null,function*(){if(this.canvasConfig=e,e&&e.canvas){if(this.canvas=e.canvas,this.canvas===null)throw new Error("no Canvas");this.canvas.style.width||(this.canvas.style.width=this.canvas.width+"px"),this.canvas.style.height||(this.canvas.style.height=this.canvas.height+"px")}else this.canvas=document.createElement("canvas"),this.canvas.style.position="absolute",this.canvas.style.top="0px",this.canvas.style.left="0px",this.canvas.style.width="100%",this.canvas.style.height="100%",this.canvas.style.zIndex=e!=null&&e.zIndex?e.zIndex.toString():"0",document.body.appendChild(this.canvas);if(e&&e.backgroundImage?(this.canvas.style.background=`url(${e.backgroundImage})`,this.canvas.style["background-size"]="cover",this.canvas.style["background-position"]="center"):this.canvas.style.background="transparent",this.canvas.style["touch-action"]="none",this.canvas.style["object-fit"]="cover",navigator.gpu===void 0)throw new Error("Your browser does not support WebGPU!");if(this.adapter=yield navigator.gpu.requestAdapter({powerPreference:"high-performance"}),this.adapter==null)throw new Error("Your browser does not support WebGPU!");if(this.device=yield this.adapter.requestDevice({requiredFeatures:["bgra8unorm-storage","depth-clip-control","depth32float-stencil8","indirect-first-instance","rg11b10ufloat-renderable"],requiredLimits:{minUniformBufferOffsetAlignment:256,maxStorageBufferBindingSize:this.adapter.limits.maxStorageBufferBindingSize}}),this.device==null)throw new Error("Your browser does not support WebGPU!");return this.device.label="device",this.presentationFormat=navigator.gpu.getPreferredCanvasFormat(),this.context=this.canvas.getContext("webgpu"),this.context.configure({device:this.device,format:this.presentationFormat,usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.RENDER_ATTACHMENT,alphaMode:"premultiplied",colorSpace:"srgb"}),this._resizeEvent=new Wr(Wr.RESIZE,{width:this.windowWidth,height:this.windowHeight}),new ResizeObserver(()=>{this.updateSize(),It.destroyTexture()}).observe(this.canvas),this.updateSize(),!0})}updateSize(){var i;this._pixelRatio=((i=this.canvasConfig)==null?void 0:i.devicePixelRatio)||window.devicePixelRatio||1,this._pixelRatio=Math.min(this._pixelRatio,2);let e=Math.floor(this.canvas.clientWidth*this._pixelRatio),r=Math.floor(this.canvas.clientHeight*this._pixelRatio);(e!=this.windowWidth||r!=this.windowHeight)&&(this.canvas.width=this.windowWidth=e,this.canvas.height=this.windowHeight=r,this.presentationSize[0]=this.windowWidth,this.presentationSize[1]=this.windowHeight,this.aspect=this.windowWidth/this.windowHeight,this._resizeEvent.data.width=this.windowWidth,this._resizeEvent.data.height=this.windowHeight,this.dispatchEvent(this._resizeEvent))}}let E=new lh;var ye=(n=>(n[n.Default=1]="Default",n[n.IgnoreDepthPass=2]="IgnoreDepthPass",n[n.Sky=6]="Sky",n[n.Particle=10]="Particle",n[n.SkinnedMesh=16]="SkinnedMesh",n[n.MorphTarget=32]="MorphTarget",n[n.Terrain=64]="Terrain",n[n.UI=128]="UI",n[n.Reflection=256]="Reflection",n[n.ReflectionDebug=512]="ReflectionDebug",n[n.Graphic3D=1024]="Graphic3D",n))(ye||{});class sr{static addMask(t,e){return t|e}static removeMask(t,e){return t&~e}static hasMask(t,e){return(t&e)==e}}const _e=class _e{constructor(t=0,e=0){s(this,"x",0);s(this,"y",0);this.x=t,this.y=e}static getAngle(t,e){return Math.atan2(e.y-t.y,e.x-t.x)}static slerp(t,e,r){let i=new _e,a=t.dot(e);if(a<0&&(e.x=-e.x,e.y=-e.y,a=-a),a>.9995)return i.x=t.x+r*(e.x-t.x),i.y=t.y+r*(e.y-t.y),i;let o=Math.acos(a),l=Math.sin(o),h=Math.sin((1-r)*o)/l,u=Math.sin(r*o)/l;return i.x=h*t.x+u*e.x,i.y=h*t.y+u*e.y,i}static lerp(t,e,r){return _e.HELP_0.copyFrom(t),_e.HELP_1.copyFrom(e),_e.HELP_0.scale(r),_e.HELP_1.scale(1-r),new _e(_e.HELP_0.x+_e.HELP_1.x,_e.HELP_0.y+_e.HELP_1.y)}set(t=0,e=0){return this.x=t,this.y=e,this}distance(t){return Math.sqrt(Math.pow(this.x-t.x,2)+Math.pow(this.y-t.y,2))}add(t,e){return e=e||new _e,e.x=this.x+t.x,e.y=this.y+t.y,e}sub(t,e){return e=e||new _e,e.x=this.x-t.x,e.y=this.y-t.y,e}scale(t){return this.x=this.x*t,this.y=this.y*t,this}multiply(t,e){return e=e||new _e,e.x=this.x*t,e.y=this.y*t,e}multiplyScaler(t){return this.x*=t,this.y*=t,this}divide(t,e){return e=e||new _e,e.x=this.x/t,e.y=this.y/t,e}neg(t){return t||(t=new _e),t.x=-t.x,t.y=-t.y,t}abs(){return Math.sqrt(this.x*this.x+this.y*this.y)}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}getAngle(t){return Math.atan2(t.y-this.y,t.x-this.x)}unt(t){t=t||new _e;let e=this.abs();return t.x=this.x/e,t.y=this.y/e,t}angleTo(t){let e=t.x-this.x,r=t.y-this.y;return Math.atan2(r,e)}equals(t){return Math.abs(this.x-t.x)<1e-6&&Math.abs(this.y-t.y)<1e-6}pal(t){let e=this.unt(),r=t.unt();return e.equals(r)?1:e.equals(r.neg())?-1:0}clone(){return new _e(this.x,this.y)}copyFrom(t){return this.x=t.x,this.y=t.y,this}addScaledVector(t,e){return this.x+=t.x*e,this.y+=t.y*e,this}dot(t){return this.x*t.x+this.y*t.y}normalize(){let t=this.abs();return this.x=this.x/t,this.y=this.y/t,this}addInPlace(t){return this.x+=t.x,this.y+=t.y,this}addScalar(t){return this.x+=t,this.y+=t,this}clampScalar(t,e){return this.x=Math.max(t,Math.min(e,this.x)),this.y=Math.max(t,Math.min(e,this.y)),this}};s(_e,"HELP_0",new _e),s(_e,"HELP_1",new _e),s(_e,"HELP_2",new _e),s(_e,"ZERO",new _e(0,0)),s(_e,"SAFE_MAX",new _e(Number.MAX_SAFE_INTEGER,Number.MAX_SAFE_INTEGER)),s(_e,"SAFE_MIN",new _e(Number.MIN_SAFE_INTEGER,Number.MIN_SAFE_INTEGER));let he=_e;const ne=class ne{constructor(t=0,e=0,r=0,i=0){s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"w",1);this.x=t,this.y=e,this.z=r,this.w=i}get width(){return this.z}get height(){return this.w}static crossVectors(t,e,r){r=r||new ne;var i=t.x,a=t.y,o=t.z,l=e.x,h=e.y,u=e.z;return r.x=a*u-o*h,r.y=o*l-i*u,r.z=i*h-a*l,r}static distance(t,e){let r=t.x-e.x,i=t.y-e.y,a=t.z-e.z,o=t.w-e.w;return Math.sqrt(r*r+i*i+a*a+o*o)}set(t,e,r,i){return this.x=t,this.y=e,this.z=r,this.w=i,this}multiplyScalar(t){return this.x*=t,this.y*=t,this.z*=t,this.w*=t,this}copyFrom(t){return this.x=t.x,this.y=t.y,this.z=t.z,this.w=t.w,this}clone(){return new ne(this.x,this.y,this.z,this.w)}};s(ne,"X_AXIS",new ne(1,0,0)),s(ne,"Y_AXIS",new ne(0,1,0)),s(ne,"Z_AXIS",new ne(0,0,1)),s(ne,"HELP_0",new ne),s(ne,"HELP_1",new ne),s(ne,"HELP_2",new ne),s(ne,"EPSILON",1e-5),s(ne,"HELP_3",new ne),s(ne,"HELP_4",new ne),s(ne,"HELP_5",new ne),s(ne,"HELP_6",new ne),s(ne,"ZERO",new ne),s(ne,"ONE",new ne(1,1,1,1)),s(ne,"LEFT",new ne(-1,0,0)),s(ne,"RIGHT",new ne(1,0,0)),s(ne,"UP",new ne(0,-1,0)),s(ne,"DOWN",new ne(0,1,0)),s(ne,"BACK",new ne(0,0,-1)),s(ne,"FORWARD",new ne(0,0,1));let ae=ne;function fn(n,t){let e=n.__NonSerialize__;e||(e=n.__NonSerialize__={},e.__NonSerialize__=!0),e[t]=!0}function dn(n,t){let e;for(;n&&(n=n.__proto__,n&&(e=n.__NonSerialize__),!e););return e&&e[t]}function ha(n,t,e,r,i){let a=n.__EditorInspector__;a||(a=n.__EditorInspector__=new Map);let o=a.get(n.constructor.name);o||(o=new Map,a.set(n.constructor.name,o)),o.set(t,{p1:e,p2:r,p3:i})}function Sm(n){let t,e=n,r=[];for(;e;){if(r.indexOf(e.constructor.name)!=-1){e=e.__proto__;continue}r.push(e.constructor.name),e=e.__proto__}for(r=r.reverse(),e=n;e&&(e=e.__proto__,e&&(t=e.__EditorInspector__),!t););let i=new Map;if(t)for(let a=0;a<r.length;a++){const o=r[a];let l=t.get(o);l&&l.forEach((h,u)=>{i.set(u,h)})}return i}function or(n,t,e,r,i){let a=window.__Component__;a||(a=window.__Component__={}),a[t]=n}function hh(n){let t=window.__Component__;return t[n]?t[n]:null}function ci(n,t,e,r,i){let a=window.__shader__;a||(a=window.__shader__={}),a[t]=n}function uh(n){let t=window.__shader__;return t[n]?t[n]:null}var ch=Object.defineProperty,gn=(n,t,e,r)=>{for(var i=void 0,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=o(t,e,i)||i);return i&&ch(t,e,i),i};const js=(Dr=class{constructor(){s(this,"__refection");s(this,"__size",0)}getValueType(){if(!this.__refection){let t=this;this.__refection=[];for(const e in t)if(!dn(this,e)){const r=t[e];let i={name:e,type:r.constructor.name};this.__refection.push(i)}}return this.__refection}static getValueSize(t){switch(t.constructor.name){case"Boolean":return 1*4;case"Number":return 1*4;case"f32":return 1*4;case"i32":return 1*4;case"u32":return 1*4;case"Float32Array":return t.byteLength;case"Vector2":return 2*4;case"Vector3":return 3*4;case"Vector4":return 4*4;case"Color":return 4*4;case"Array":let e=0;for(let r=0,i=t.length;r<i;r++)e+=Dr.getValueSize(t[r]);return e}return 0}static Ref(t){return this.Get(t).getValueType()}static Get(t){let e=Dr.__cacheStruct.get(t.prototype);return e||(e=new t,Dr.__cacheStruct.set(t.prototype,e)),e}static GetSize(t){let e=this.Get(t);if(e.__size==0){for(const r in e)if(!dn(e,r)){const i=e[r];e.__size+=Dr.getValueSize(i)}e.__size>4&&(e.__size=Math.ceil(e.__size/4)*4)}return e.__size}},s(Dr,"__cacheStruct",new Map),Dr);gn([fn],js.prototype,"__refection"),gn([fn],js.prototype,"__size");let is=js;class fh{constructor(){s(this,"byteOffset");s(this,"byteSize");s(this,"offset",0);s(this,"dataBytes")}get x(){return this.dataBytes.getFloat32(0*Float32Array.BYTES_PER_ELEMENT,!0)}set x(t){this.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,t,!0)}get y(){return this.dataBytes.getFloat32(1*Float32Array.BYTES_PER_ELEMENT,!0)}set y(t){this.dataBytes.setFloat32(1*Float32Array.BYTES_PER_ELEMENT,t,!0)}get z(){return this.dataBytes.getFloat32(2*Float32Array.BYTES_PER_ELEMENT,!0)}set z(t){this.dataBytes.setFloat32(2*Float32Array.BYTES_PER_ELEMENT,t,!0)}get w(){return this.dataBytes.getFloat32(3*Float32Array.BYTES_PER_ELEMENT,!0)}set w(t){this.dataBytes.setFloat32(3*Float32Array.BYTES_PER_ELEMENT,t,!0)}setX(t){this.x=t}setXY(t,e){this.x=t,this.y=e}setXYZ(t,e,r){this.x=t,this.y=e,this.z=r}setXYZW(t,e,r,i){this.x=t,this.y=e,this.z=r,this.w=i}setVector2Array(t){for(let e=0;e<t.length;e++){const r=t[e];this.dataBytes.setFloat32((e*2+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((e*2+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0)}}setVector3Array(t){for(let e=0;e<t.length;e++){const r=t[e];this.dataBytes.setFloat32((e*3+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((e*3+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((e*3+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0)}}setVector4Array(t){for(let e=0;e<t.length;e++){const r=t[e];this.dataBytes.setFloat32((e*4+0)*Float32Array.BYTES_PER_ELEMENT,r.x,!0),this.dataBytes.setFloat32((e*4+1)*Float32Array.BYTES_PER_ELEMENT,r.y,!0),this.dataBytes.setFloat32((e*4+2)*Float32Array.BYTES_PER_ELEMENT,r.z,!0),this.dataBytes.setFloat32((e*4+3)*Float32Array.BYTES_PER_ELEMENT,r.w,!0)}}setColorArray(t){for(let e=0;e<t.length;e++){const r=t[e];this.dataBytes.setFloat32((e*4+0)*Float32Array.BYTES_PER_ELEMENT,r.r,!0),this.dataBytes.setFloat32((e*4+1)*Float32Array.BYTES_PER_ELEMENT,r.g,!0),this.dataBytes.setFloat32((e*4+2)*Float32Array.BYTES_PER_ELEMENT,r.b,!0),this.dataBytes.setFloat32((e*4+3)*Float32Array.BYTES_PER_ELEMENT,r.a,!0)}}setInt8(t,e=0){this.dataBytes.setInt8(e*Int8Array.BYTES_PER_ELEMENT,t)}getInt8(t=0){return this.dataBytes.getInt8(t*Int8Array.BYTES_PER_ELEMENT)}setInt16(t,e=0){this.dataBytes.setInt16(e*Int16Array.BYTES_PER_ELEMENT,t,!0)}getInt16(t=0){return this.dataBytes.getInt16(t*Int16Array.BYTES_PER_ELEMENT,!0)}setInt32(t,e=0){this.dataBytes.setInt32(e*Int32Array.BYTES_PER_ELEMENT,t,!0)}getInt32(t=0){return this.dataBytes.getInt32(t*Int32Array.BYTES_PER_ELEMENT,!0)}setFloat(t,e=0){this.dataBytes.setFloat32(e*Float32Array.BYTES_PER_ELEMENT,t,!0)}getFloat(t=0){return this.dataBytes.getFloat32(t*Float32Array.BYTES_PER_ELEMENT,!0)}setUint8(t,e=0){this.dataBytes.setUint8(e*Uint8Array.BYTES_PER_ELEMENT,t)}getUint8(t=0){return this.dataBytes.getUint8(t*Uint8Array.BYTES_PER_ELEMENT)}setUint16(t,e=0){this.dataBytes.setUint16(e*Uint16Array.BYTES_PER_ELEMENT,t,!0)}getUint16(t=0){return this.dataBytes.getUint16(t*Uint16Array.BYTES_PER_ELEMENT,!0)}setUint32(t,e=0){this.dataBytes.setUint32(e*Uint32Array.BYTES_PER_ELEMENT,t,!0)}getUint32(t=0){return this.dataBytes.getUint32(t*Uint32Array.BYTES_PER_ELEMENT,!0)}setArray(t,e){for(let r=0;r<e.length;r++){const i=e[r];this.dataBytes.setFloat32((t+r)*Float32Array.BYTES_PER_ELEMENT,i,!0)}}setFloat32Array(t,e){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Float32Array.BYTES_PER_ELEMENT,e.length).set(e)}setFloatArray(t,e){let r;e instanceof Float32Array?r=e:r=new Float32Array(e),new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Float32Array.BYTES_PER_ELEMENT,r.length).set(r)}setArrayBuffer(t,e){e instanceof Uint8Array?this.setUint8Array(t,e):e instanceof Uint16Array?this.setUint16Array(t,e):e instanceof Uint32Array?this.setUint32Array(t,e):e instanceof Int8Array?this.setInt8Array(t,e):e instanceof Int16Array?this.setInt16Array(t,e):e instanceof Int32Array?this.setInt32Array(t,e):e instanceof Float32Array&&this.setFloat32Array(t,e)}setInt8Array(t,e){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Int8Array.BYTES_PER_ELEMENT).set(e)}setInt16Array(t,e){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Int16Array.BYTES_PER_ELEMENT).set(e)}setInt32Array(t,e){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Int32Array.BYTES_PER_ELEMENT).set(e)}setUint8Array(t,e){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Uint8Array.BYTES_PER_ELEMENT).set(e)}setUint16Array(t,e){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Uint16Array.BYTES_PER_ELEMENT).set(e)}setUint32Array(t,e){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+t*Uint32Array.BYTES_PER_ELEMENT).set(e)}setData(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e,!0)}setVector2(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e.x,!0),this.dataBytes.setFloat32((t+1)*Float32Array.BYTES_PER_ELEMENT,e.y,!0)}setVector3(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e.x,!0),this.dataBytes.setFloat32((t+1)*Float32Array.BYTES_PER_ELEMENT,e.y,!0),this.dataBytes.setFloat32((t+2)*Float32Array.BYTES_PER_ELEMENT,e.z,!0)}setVector4(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e.x,!0),this.dataBytes.setFloat32((t+1)*Float32Array.BYTES_PER_ELEMENT,e.y,!0),this.dataBytes.setFloat32((t+2)*Float32Array.BYTES_PER_ELEMENT,e.z,!0),this.dataBytes.setFloat32((t+3)*Float32Array.BYTES_PER_ELEMENT,e.w,!0)}setColor(t,e){this.dataBytes.setFloat32(t*Float32Array.BYTES_PER_ELEMENT,e.r,!0),this.dataBytes.setFloat32((t+1)*Float32Array.BYTES_PER_ELEMENT,e.g,!0),this.dataBytes.setFloat32((t+2)*Float32Array.BYTES_PER_ELEMENT,e.b,!0),this.dataBytes.setFloat32((t+3)*Float32Array.BYTES_PER_ELEMENT,e.a,!0)}getData(t){return this.dataBytes.getFloat32(t*Float32Array.BYTES_PER_ELEMENT,!0)}writeFloat(t){this.dataBytes.setFloat32(this.offset,t,!0),this.offset+=Float32Array.BYTES_PER_ELEMENT}writeInt8(t){this.dataBytes.setInt8(this.offset,t),this.offset+=Int8Array.BYTES_PER_ELEMENT}writeInt16(t){this.dataBytes.setInt16(this.offset,t,!0),this.offset+=Int16Array.BYTES_PER_ELEMENT}writeInt32(t){this.dataBytes.setInt32(this.offset,t,!0),this.offset+=Int32Array.BYTES_PER_ELEMENT}writeUint8(t){this.dataBytes.setUint8(this.offset,t),this.offset+=Uint8Array.BYTES_PER_ELEMENT}writeUint16(t){this.dataBytes.setUint16(this.offset,t,!0),this.offset+=Uint16Array.BYTES_PER_ELEMENT}writeUint32(t){this.dataBytes.setUint32(this.offset,t,!0),this.offset+=Uint32Array.BYTES_PER_ELEMENT}writeVector2(t){this.writeFloat(t.x),this.writeFloat(t.y)}writeVector3(t){this.writeFloat(t.x),this.writeFloat(t.y),this.writeFloat(t.z)}writeVector4(t){this.writeFloat(t.x),this.writeFloat(t.y),this.writeFloat(t.z),this.writeFloat(t.w)}writeRGBColor(t){this.writeFloat(t.r),this.writeFloat(t.g),this.writeFloat(t.b)}writeArray(t){for(let e=0;e<t.length;e++){const r=t[e];this.writeFloat(r)}}writeFloat32Array(t){new Float32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeInt8Array(t){new Int8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeInt16Array(t){new Int16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeInt32Array(t){new Int32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeUint8Array(t){new Uint8Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeUint16Array(t){new Uint16Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}writeUint32Array(t){new Uint32Array(this.dataBytes.buffer,this.dataBytes.byteOffset+this.offset).set(t),this.offset+=t.byteLength}reset(){this.offset=0}destroy(){this.byteOffset=null,this.byteSize=null,this.offset=null,this.dataBytes=null}}class ua{constructor(){s(this,"shareDataBuffer");s(this,"_byteOffset",0)}allocation(t){this.shareDataBuffer&&this.shareDataBuffer.byteLength<t?this._byteOffset=0:this.shareDataBuffer=new ArrayBuffer(t)}allocation_node(t){if(this._byteOffset+t>this.shareDataBuffer.byteLength)return console.error("memory not enough!",this._byteOffset,t,this.shareDataBuffer.byteLength),null;let e=new fh;return e.byteOffset=this._byteOffset,e.byteSize=t,e.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,e.byteSize),this._byteOffset+=e.byteSize,e}allocation_memory(t){return this._byteOffset+t.byteSize>this.shareDataBuffer.byteLength?(console.error("memory not enough!",this._byteOffset,t.byteSize,this.shareDataBuffer.byteLength),null):(t.byteOffset=this._byteOffset,t.dataBytes=new DataView(this.shareDataBuffer,this._byteOffset,t.byteSize),this._byteOffset+=t.byteSize,t)}reset(){this._byteOffset=0}destroy(t){this.shareDataBuffer=null,this._byteOffset=0}}class fi{constructor(){s(this,"bufferType");s(this,"buffer");s(this,"memory");s(this,"memoryNodes");s(this,"seek");s(this,"outFloat32Array");s(this,"byteSize");s(this,"usage");s(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE);s(this,"mapAsyncBuffersOutstanding",0);s(this,"mapAsyncReady");s(this,"_readBuffer");s(this,"_dataView");s(this,"_readFlag",!1);this.mapAsyncReady=[]}debug(){}reset(t=!1,e=0,r){this.seek=0,this.memory.reset(),t&&this.createBuffer(this.usage,e,r)}setBoolean(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(t,r)),r.setX(e?1:0)}readBoole(t){let e=this.memoryNodes.get(t);return e?e.getFloat()!=0:null}setFloat(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(t,r)),r.setX(e)}getFloat(t){let e=this.memoryNodes.get(t);return e?e.getFloat():null}setInt8(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(t,r)),r.setInt8(e)}getInt8(t){let e=this.memoryNodes.get(t);return e?e.getInt8():null}setInt16(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(t,r)),r.setInt16(e)}getInt16(t){let e=this.memoryNodes.get(t);return e?e.getInt16():null}setInt32(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(t,r)),r.setInt32(e)}getInt32(t){let e=this.memoryNodes.get(t);return e?e.getInt32():null}setUint8(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*1),this.memoryNodes.set(t,r)),r.setUint8(e)}getUint8(t){let e=this.memoryNodes.get(t);return e?e.getUint8():null}setUint16(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*2),this.memoryNodes.set(t,r)),r.setUint16(e)}getUint16(t){let e=this.memoryNodes.get(t);return e?e.getUint16():null}setUint32(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(1*4),this.memoryNodes.set(t,r)),r.setUint32(e)}getUint32(t){let e=this.memoryNodes.get(t);return e?e.getUint32():null}setVector2(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(2*4),this.memoryNodes.set(t,r)),r.setXY(e.x,e.y)}getVector2(t){let e=this.memoryNodes.get(t);return e?new he(e.x,e.y):null}setVector3(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(3*4),this.memoryNodes.set(t,r)),r.setXYZ(e.x,e.y,e.z)}getVector3(t){let e=this.memoryNodes.get(t);return e?new g(e.x,e.y,e.z):null}setVector4(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(t,r)),r.setXYZW(e.x,e.y,e.z,e.w)}getVector4(t){let e=this.memoryNodes.get(t);return e?new ae(e.x,e.y,e.z,e.w):null}setVector4Array(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(4*4*e.length),this.memoryNodes.set(t,r)),r.setVector4Array(e)}setColor(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(4*4),this.memoryNodes.set(t,r)),r.setXYZW(e.r,e.g,e.b,e.a)}getColor(t){let e=this.memoryNodes.get(t);return e?new K(e.x,e.y,e.z,e.w):null}setColorArray(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(4*4*e.length),this.memoryNodes.set(t,r)),r.setColorArray(e)}setMatrix(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(16*4),this.memoryNodes.set(t,r)),r.setFloatArray(0,e.rawData)}setMatrixArray(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(16*4*e.length),this.memoryNodes.set(t,r));for(let i=0;i<e.length;i++){const a=e[i];r.setFloatArray(i*16,a.rawData)}}setArray(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(e.length*4),this.memoryNodes.set(t,r)),r.setArray(0,e)}setFloat32Array(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(e.length*4),this.memoryNodes.set(t,r)),r.setFloat32Array(0,e)}setInt32Array(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(e.length*4),this.memoryNodes.set(t,r)),r.setInt32Array(0,e)}setUint32Array(t,e){let r=this.memoryNodes.get(t);r||(r=this.memory.allocation_node(e.length*4),this.memoryNodes.set(t,r)),r.setUint32Array(0,e)}setStruct(t,e,r,i){let a=is.Ref(t);is.GetSize(t);let o=e,l=this.memoryNodes.get(o);l.reset();let h=r;i&&(h=h[i]);for(let u=0;u<a.length;u++){const c=a[u];let f=h[c.name];this.writeValue(l,c,f)}}writeValue(t,e,r){switch(e.type){case"Boolean":t.writeFloat(r);break;case"Number":t.writeFloat(r);break;case"Float32Array":t.writeFloat32Array(r);break;case"Float64Array":t.writeFloat32Array(new Float32Array(r));break;case"Vector2":t.writeVector2(r);break;case"Vector3":t.writeVector3(r);break;case"Vector4":t.writeVector4(r);break;case"Color":t.writeRGBColor(r);break;case"Array":t.writeArray(r);break}}setStructArray(t,e,r){let i=e.length;for(let a=0;a<i;a++){const o=e[a];this.setStruct(t,a,o,r)}}clean(){this._dataView.fill(0,0,this._dataView.length)}apply(){E.device.queue.writeBuffer(this.buffer,0,this.memory.shareDataBuffer)}mapAsyncWrite(t,e){let r;t instanceof Float64Array?r=new Float32Array(t):r=t;let i=E.device;if(r.length>0){let a=null;for(;this.mapAsyncReady.length&&(a=this.mapAsyncReady.shift(),a.usedSize!=r.byteLength);)a.destroy(),this.mapAsyncBuffersOutstanding--,a=null;a||(a=i.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),a.usedSize=r.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>20&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let o=new Float32Array(r.buffer,r.byteOffset,e);new Float32Array(a.getMappedRange(0,e*4)).set(o),a.unmap();const l=i.createCommandEncoder();l.copyBufferToBuffer(a,0,this.buffer,0,e*4),i.queue.submit([l.finish()]),a.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(a))}}destroy(){this.memoryNodes&&this.memoryNodes.forEach(t=>{t.destroy()}),this.bufferType=null,this.seek=null,this.byteSize=null,this.usage=null,this.visibility=null,this.outFloat32Array=null,this.buffer&&this.buffer.destroy(),this.buffer=null,this.memory&&this.memory.destroy(),this.memory=null,this._readBuffer&&this._readBuffer.destroy()}createBuffer(t,e,r,i){let a=E.device;this.buffer&&this.destroy(),this.byteSize=e*4,this.usage=t,this.buffer=a.createBuffer({label:i,size:this.byteSize,usage:t,mappedAtCreation:!1}),this.memory=new ua,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer),this.memory.allocation(this.byteSize),r&&(this.memory.allocation_node(r.length*4).setArrayBuffer(0,r),this.apply())}resizeBuffer(t,e){this.createBuffer(this.usage,t,e)}createNewBuffer(t,e){let r=E.device,i=e*4,a=t;return this.buffer&&this.destroy(),r.createBuffer({size:i,usage:a,mappedAtCreation:!1})}createBufferByStruct(t,e,r){let i=is.GetSize(e),a=i*r,o=E.device;this.buffer=o.createBuffer({label:"StructStorageGPUBuffer",size:a,usage:t,mappedAtCreation:!1}),this.memory=new ua,this.memoryNodes=new Map,this._dataView=new Float32Array(this.memory.shareDataBuffer),this.memory.allocation(a);for(let l=0;l<r;l++){let h=l,u=this.memoryNodes.get(h);u||(u=this.memory.allocation_node(i),this.memoryNodes.set(h,u))}}readBuffer(t=!1){this.outFloat32Array||(this.outFloat32Array=new Float32Array(this.memory.shareDataBuffer.byteLength/4)),this._readBuffer||(this._readBuffer=E.device.createBuffer({size:this.memory.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}));let e=this.read();return t?e:this.outFloat32Array}read(){return V(this,null,function*(){if(!this._readFlag){this._readFlag=!0;let t=E.device.createCommandEncoder();t.copyBufferToBuffer(this.buffer,0,this._readBuffer,0,this.memory.shareDataBuffer.byteLength),E.device.queue.submit([t.finish()]),yield this._readBuffer.mapAsync(GPUMapMode.READ);const e=this._readBuffer.getMappedRange();this.outFloat32Array.set(new Float32Array(e),0),this._readBuffer.unmap(),this._readFlag=!1}return this.outFloat32Array})}}var vr=(n=>(n[n.IndicesGPUBuffer=0]="IndicesGPUBuffer",n[n.VertexGPUBuffer=1]="VertexGPUBuffer",n[n.UniformGPUBuffer=2]="UniformGPUBuffer",n[n.StorageGPUBuffer=3]="StorageGPUBuffer",n[n.ComputeGPUBuffer=4]="ComputeGPUBuffer",n[n.MaterialDataUniformGPUBuffer=5]="MaterialDataUniformGPUBuffer",n[n.StructStorageGPUBuffer=6]="StructStorageGPUBuffer",n))(vr||{});class be extends fi{constructor(t,e=0,r){super(),this.bufferType=vr.StorageGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|e,t,r,"StorageGPUBuffer")}}class Ct extends fi{constructor(t,e){super(),this.bufferType=vr.UniformGPUBuffer,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC,t,e,"UniformGPUBuffer")}genUniformNodes(){}}class Ft{static getMorphTargetShaderBinding(t,e){return`
            fn blendMorphTargetPosition(vertexID:i32, posIn:vec3<f32>) -> vec3<f32>{
                let offset:i32 = vertexID * 3;
                var pos = posIn * morphTargetConfig.morphBaseInfluence;
                pos += vec3<f32>(morphTargetOpPositions[offset], morphTargetOpPositions[offset + 1], morphTargetOpPositions[offset + 2]);
                return pos;
            }

            #if USE_MORPHNORMALS
                fn blendMorphTargetNormal(vertexID:i32, normalIn:vec3<f32>) -> vec3<f32>{
                    let offset:i32 = vertexID * 3;
                    var normal = normalIn * morphTargetConfig.morphBaseInfluence;
                    normal += vec3<f32>(morphTargetOpNormals[offset], morphTargetOpNormals[offset + 1], morphTargetOpNormals[offset + 2]);
                    return normal;
                }
            #endif

            struct MorphTargetConfigData {
                morphBaseInfluence:f32,
                morphTargetCount:f32,
                totalVertexCount:f32,
                computeWorkGroupXY:f32,
            };
            
            @group(${t}) @binding(${e})
            var<uniform> morphTargetConfig: MorphTargetConfigData;
            
            @group(${t}) @binding(${e+1})
            var<storage,read> morphTargetOpPositions: array<f32>;

            #if USE_MORPHNORMALS
                @group(${t}) @binding(${e+2})
                var<storage,read> morphTargetOpNormals: array<f32>;
            #endif
`}static getMorphTargetCalcVertex(){return`
            vertexPosition = blendMorphTargetPosition(i32(vertex.vIndex), vertexPosition);

            #if USE_MORPHNORMALS
                vertexNormal = blendMorphTargetNormal(i32(vertex.vIndex), vertexNormal);
            #endif
        `}}s(Ft,"CsMain",`
        struct MorphTargetConfigData {
            morphBaseInfluence:f32,
            morphTargetCount:f32,
            totalVertexCount:f32,
            computeWorkGroupXY:f32,
        };

        @group(0) @binding(0) var<uniform> morphTargetConfig: MorphTargetConfigData;
        @group(0) @binding(1) var<storage, read> morphTargetInfluence : array<f32>;
        @group(0) @binding(2) var<storage, read> morphTargetPositions : array<f32>;
        @group(0) @binding(3) var<storage, read_write> morphTargetOpPositions : array<f32>;
        
        #if USE_MORPHNORMALS
            @group(0) @binding(4) var<storage, read> morphTargetNormals : array<f32>;
            @group(0) @binding(5) var<storage, read_write> morphTargetOpNormals : array<f32>;
        #endif
        
        @compute @workgroup_size( 8 , 8 , 1 )
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
        {
            let vertexIndex:i32 = i32(globalInvocation_id.y) * i32(morphTargetConfig.computeWorkGroupXY) + i32(globalInvocation_id.x);
        
            let morphTargetCount:i32 = i32(morphTargetConfig.morphTargetCount);
            let totalVertexCount:i32 = i32(morphTargetConfig.totalVertexCount);
            var vertexPosition:vec3<f32> = vec3<f32>(0.0);
            var vertexNormal:vec3<f32> = vec3<f32>(0.0);
            if(vertexIndex < totalVertexCount)
            {
                for(var i:i32 = 0; i < morphTargetCount; i ++){
                    let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                    let morphPosition = vec3<f32>(morphTargetPositions[offset], morphTargetPositions[offset + 1], morphTargetPositions[offset + 2]);
                    vertexPosition += morphTargetInfluence[i] * morphPosition;
                }

                var writeOffset = vertexIndex * 3;
                //op position
                morphTargetOpPositions[writeOffset] = vertexPosition.x;
                morphTargetOpPositions[writeOffset + 1] = vertexPosition.y;
                morphTargetOpPositions[writeOffset + 2] = vertexPosition.z;

                #if USE_MORPHNORMALS
                    for(var i:i32 = 0; i < morphTargetCount; i ++){
                        let offset:i32 = (i * totalVertexCount + vertexIndex) * 3;
                        let morphNormal = vec3<f32>(morphTargetNormals[offset], morphTargetNormals[offset + 1], morphTargetNormals[offset + 2]);
                        vertexNormal += morphTargetInfluence[i] * morphNormal;
                    }

                    //op normal
                    morphTargetOpNormals[writeOffset] = vertexNormal.x;
                    morphTargetOpNormals[writeOffset + 1] = vertexNormal.y;
                    morphTargetOpNormals[writeOffset + 2] = vertexNormal.z;
                #endif
            }
        }
`);let kt=function(n=16,t=16){var e="0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz".split(""),r=[],i;if(t=t||e.length,n)for(i=0;i<n;i++)r[i]=e[0|Math.random()*t];else{var a;for(r[8]=r[13]=r[18]=r[23]="-",r[14]="4",i=0;i<36;i++)r[i]||(a=0|Math.random()*16,r[i]=e[i==19?a&3|8:a])}return r.join("")},pn=1e6,mn=function(){return pn++,pn},Im=function(n,t){let e=0,r=n.length;for(e=0;e<r;e++)if(n[e]==t)return!0;return!1},bm=function(n,t){let e=0,r=n.length;for(e=0;e<r;e++)if(n[e]==t)return e;return-1},qs=(...n)=>function(...t){n.forEach(e=>e.apply(this,t))};var _t=(n=>(n[n.Number=0]="Number",n[n.Vector2=1]="Vector2",n[n.Vector3=2]="Vector3",n[n.Vector4=3]="Vector4",n[n.Color=4]="Color",n[n.Float32Array=5]="Float32Array",n))(_t||{});class di{constructor(t){s(this,"size");s(this,"memoryInfo");s(this,"bindOnChange");s(this,"_data");s(this,"_type",_t.Number);s(this,"_x",0);s(this,"_y",0);s(this,"_z",0);s(this,"_w",0);this.data=t}get data(){return this._data}set data(t){this._data=t,this._type=_t.Number,t instanceof he?(this.size=2,this._x=t.x,this._y=t.y,this._type=_t.Vector2):t instanceof g?(this.size=3,this._x=t.x,this._y=t.y,this._z=t.z,this._type=_t.Vector3):t instanceof ae?(this.size=4,this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this._type=_t.Vector4):t instanceof K?(this.size=4,this._x=t.r,this._y=t.g,this._z=t.b,this._w=t.a,this._type=_t.Color):t instanceof Float32Array?(this.size=t.length,this._type=_t.Float32Array):(this.size=1,this._x=t,this._data=t,this._type=_t.Number)}getColor(t){return t?t.copyFrom(this._data):t=this._data,t}get color(){return new K(this._data.r,this._data.g,this._data.b,this._data.a)}set color(t){(this._x!=t.r||this._y!=t.g||this._z!=t.b||this._w!=t.a)&&(this._data.r=t.r,this._data.g=t.g,this._data.b=t.b,this._data.a=t.a,this._x=t.r,this._y=t.g,this._z=t.b,this._w=t.a,this.onChange())}get value(){return this._x}set value(t){this._x!=t&&(this._data=t,this._x=t,this.onChange())}get vector2(){return this._data}set vector2(t){(this._x!=t.x||this._y!=t.y)&&(this._data.x=t.x,this._data.y=t.y,this._x=t.x,this._y=t.y,this.onChange())}get vector3(){return this._data}set vector3(t){(this._x!=t.x||this._y!=t.y||this._z!=t.z)&&(this._data.x=t.x,this._data.y=t.y,this._data.z=t.z,this._x=t.x,this._y=t.y,this._z=t.z,this.onChange())}get vector4(){return this._data}set vector4(t){(this._x!=t.x||this._y!=t.y||this._z!=t.z||this._w!=t.w)&&(this._data.x=t.x,this._data.y=t.y,this._data.z=t.z,this._data.w=t.w,this._x=t.x,this._y=t.y,this._z=t.z,this._w=t.w,this.onChange())}onChange(){this.bindOnChange&&this.bindOnChange()}float32Array(t){this._data.set(t),this.onChange()}update(){switch(this._type){case _t.Number:this.memoryInfo.dataBytes.setFloat32(0*Float32Array.BYTES_PER_ELEMENT,this._data,!0);break;case _t.Vector2:this.memoryInfo.setVector2(0,this._data);break;case _t.Vector3:this.memoryInfo.setVector3(0,this._data);break;case _t.Vector4:this.memoryInfo.setVector4(0,this._data);break;case _t.Color:this.memoryInfo.setColor(0,this._data);break;case _t.Float32Array:this.memoryInfo.setFloat32Array(0,this._data);break}}}class An{constructor(){s(this,"instanceID");s(this,"shaderVariant");s(this,"vsEntryPoint","main");s(this,"fsEntryPoint","main");s(this,"bindGroups");s(this,"shaderReflection");s(this,"defineValue");s(this,"constValues");s(this,"uniforms");s(this,"materialDataUniformBuffer");s(this,"_bufferDic");s(this,"_shaderChange",!0);s(this,"_valueChange",!1);this.instanceID=kt(),this.defineValue={},this.constValues={},this.uniforms={},this._bufferDic=new Map}noticeShaderChange(){this._shaderChange=!0}noticeValueChange(){this._valueChange=!0}setStorageBuffer(t,e){this._bufferDic.has(t)?this._bufferDic.set(t,e):(this._bufferDic.set(t,e),this.noticeBufferChange(t))}setStructStorageBuffer(t,e){this._bufferDic.has(t)?(this._bufferDic.set(t,e),this.noticeBufferChange(t)):this._bufferDic.set(t,e)}setUniformBuffer(t,e){this._bufferDic.has(t)?(this._bufferDic.set(t,e),this.noticeBufferChange(t)):this._bufferDic.set(t,e)}setDefine(t,e){(this.defineValue[t]==null||this.defineValue[t]!=e)&&(this.defineValue[t]=e,this.noticeValueChange(),this.noticeShaderChange()),this.defineValue[t]=e}hasDefine(t){return this.defineValue[t]!=null}deleteDefine(t){delete this.defineValue[t],this.noticeShaderChange()}setUniformFloat(t,e){this.uniforms[t]?this.uniforms[t].value=e:(this.uniforms[t]=new di(e),this.noticeValueChange())}setUniformVector2(t,e){this.uniforms[t]?this.uniforms[t].vector2=e:(this.uniforms[t]=new di(e),this.noticeValueChange())}setUniformVector3(t,e){this.uniforms[t]?this.uniforms[t].vector3=e:this.uniforms[t]=new di(e)}setUniformVector4(t,e){this.uniforms[t]?this.uniforms[t].vector4=e:this.uniforms[t]=new di(e)}setUniformColor(t,e){this.uniforms[t]?this.uniforms[t].color=e:this.uniforms[t]=new di(e)}setUniformArray(t,e){this.uniforms[t]?this.uniforms[t].float32Array(e):this.uniforms[t]=new di(e)}setUniform(t,e){this.uniforms[t]?this.uniforms[t].data=e:this.uniforms[t]=new di(e)}getUniform(t){return this.uniforms[t].data}getUniformFloat(t){return this.uniforms[t].data}getUniformVector2(t){return this.uniforms[t].data}getUniformVector3(t){return this.uniforms[t].data}getUniformVector4(t){return this.uniforms[t].data}getUniformColor(t){return this.uniforms[t].color}getBuffer(t){return this._bufferDic[t].data}noticeBufferChange(t){}applyUniform(){this.materialDataUniformBuffer&&this._valueChange&&this.materialDataUniformBuffer.apply()}destroy(t){}}var gi=(n=>(n[n.u32=1]="u32",n[n.f32=1]="f32",n[n["vec2<f32>"]=2]="vec2<f32>",n[n["vec3<f32>"]=3]="vec3<f32>",n[n["vec4<f32>"]=4]="vec4<f32>",n[n.float32=1]="float32",n[n.float32x2=2]="float32x2",n[n.float32x3=3]="float32x3",n[n.float32x4=4]="float32x4",n))(gi||{});let Wt={clamp_to_edge:"clamp-to-edge",repeat:"repeat",mirror_repeat:"mirror-repeat"},wm={zero:"zero",one:"one",src:"src",one_minus_src:"one-minus-src",src_alpha:"src-alpha",one_minus_src_alpha:"one-minus-src-alpha",dst:"dst",one_minus_dst:"one-minus-dst",dst_alpha:"dst-alpha",one_minus_dst_alpha:"one-minus-dst-alpha",src_alpha_saturated:"src-alpha-saturated",constant:"constant",one_minus_constant:"one-minus-constant"};const Tm={srcFactor:"one",dstFactor:"zero",operation:"add"},Em={compare:"always",failOp:"keep",depthFailOp:"keep",passOp:"keep"};let ct={never:"never",less:"less",equal:"equal",less_equal:"less-equal",greater:"greater",not_equal:"not-equal",greater_equal:"greater-equal",always:"always"},Pt={none:"none",front:"front",back:"back"},pi={nearest:"nearest",linear:"linear"},dh={point_list:"point-list",line_list:"line-list",line_strip:"line-strip",triangle_list:"triangle-list",triangle_strip:"triangle-strip"},j={r8unorm:"r8unorm",r8snorm:"r8snorm",r8uint:"r8uint",r8sint:"r8sint",r16uint:"r16uint",r16sint:"r16sint",r16float:"r16float",rg8unorm:"rg8unorm",rg8snorm:"rg8snorm",rg8uint:"rg8uint",rg8sint:"rg8sint",r32uint:"r32uint",r32sint:"r32sint",r32float:"r32float",rg16uint:"rg16uint",rg16sint:"rg16sint",rg16float:"rg16float",rgba8unorm:"rgba8unorm",rgba8unorm_srgb:"rgba8unorm-srgb",rgba8snorm:"rgba8snorm",rgba8uint:"rgba8uint",rgba8sint:"rgba8sint",bgra8unorm:"bgra8unorm",bgra8unorm_srgb:"bgra8unorm-srgb",rgb9e5ufloat:"rgb9e5ufloat",rgb10a2unorm:"rgb10a2unorm",rg11b10ufloat:"rg11b10ufloat",rg32uint:"rg32uint",rg32sint:"rg32sint",rg32float:"rg32float",rgba16uint:"rgba16uint",rgba16sint:"rgba16sint",rgba16float:"rgba16float",rgba32uint:"rgba32uint",rgba32sint:"rgba32sint",rgba32float:"rgba32float",stencil8:"stencil8",depth16unorm:"depth16unorm",depth24plus:"depth24plus",depth24plus_stencil8:"depth24plus-stencil8",depth32float:"depth32float",bc1_rgba_unorm:"bc1-rgba-unorm",bc1_rgba_unorm_srgb:"bc1-rgba-unorm-srgb",bc2_rgba_unorm:"bc2-rgba-unorm",bc2_rgba_unorm_srgb:"bc2-rgba-unorm-srgb",bc3_rgba_unorm:"bc3-rgba-unorm",bc3_rgba_unorm_srgb:"bc3-rgba-unorm-srgb",bc4_r_unorm:"bc4-r-unorm",bc4_r_snorm:"bc4-r-snorm",bc5_rg_unorm:"bc5-rg-unorm",bc5_rg_snorm:"bc5-rg-snorm",bc6h_rgb_ufloat:"bc6h-rgb-ufloat",bc6h_rgb_float:"bc6h-rgb-float",bc7_rgba_unorm:"bc7-rgba-unorm",bc7_rgba_unorm_srgb:"bc7-rgba-unorm-srgb",depth24unorm_stencil8:"depth24unorm-stencil8",depth32float_stencil8:"depth32float-stencil8"},as={uint8x2:"uint8x2",uint8x4:"uint8x4",sint8x2:"sint8x2",sint8x4:"sint8x4",unorm8x2:"unorm8x2",unorm8x4:"unorm8x4",snorm8x2:"snorm8x2",snorm8x4:"snorm8x4",uint16x2:"uint16x2",uint16x4:"uint16x4",sint16x2:"sint16x2",sint16x4:"sint16x4",unorm16x2:"unorm16x2",unorm16x4:"unorm16x4",snorm16x2:"snorm16x2",snorm16x4:"snorm16x4",float16x2:"float16x2",float16x4:"float16x4",float32:"float32",float32x2:"float32x2",float32x3:"float32x3",float32x4:"float32x4",uint32:"uint32",uint32x2:"uint32x2",uint32x3:"uint32x3",uint32x4:"uint32x4",sint32:"sint32",sint32x2:"sint32x2",sint32x3:"sint32x3",sint32x4:"sint32x4"},Bm={vertex:"vertex",instance:"instance"},gh=[null,as.float32,as.float32x2,as.float32x3,as.float32x4],ph=`
        var<private> colorSet : array<vec3<f32>, 9> = array<vec3<f32>, 9>(
            vec3<f32>(1.0, 0.0, 0.0),
            vec3<f32>(1.0, 0.5, 0.0),
            vec3<f32>(0.5, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.0),
            vec3<f32>(0.0, 1.0, 0.5),
            vec3<f32>(0.0, 0.5, 1.0),
            vec3<f32>(0.0, 0.0, 1.0),
            vec3<f32>(0.5, 0.0, 1.0),
            vec3<f32>(1.0, 0.0, 0.5)
        );

        #if DEBUG_CLUSTER
        fn debugCluster(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              var tileID : u32 = getClusterId3().z;
              let clusterDebug = vec4<f32>(colorSet[tileID % 9u], 1.0);
              // ORI_FragmentOutput.color = clusterDebug ;
            #endif
          }
      
          fn debugClusterBox(fragCoord:vec4<f32>) {
            #if USE_LIGHT
              let clusterId3 : vec3<u32> = getClusterId3();
              let px = f32(clusterId3.x) / clustersUniform.clusterTileX ;
              let py = f32(clusterId3.y) / clustersUniform.clusterTileY ;
              let pz = f32(clusterId3.z) / clustersUniform.clusterTileZ ;
              // ORI_FragmentOutput.color = vec4<f32>(px,py,pz, 1.0);

              var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
              // ORI_FragmentOutput.color = vec4<f32>(screenUV.x,screenUV.y,0.0, 1.0);

              // let clusterId : u32 = getClusterIndex();
              // let cluster = clusterBuffer[clusterId];
        
              // let midPoint : vec3<f32> = (cluster.maxPoint.xyz - cluster.minPoint.xyz) * vec3<f32>(0.5);
              // let center : vec3<f32> = cluster.minPoint.xyz + midPoint;
              // let radius : f32 = length(midPoint) ;
        
              // let fragToBoundsCenter : vec3<f32> = ORI_VertexVarying.viewPosition.xyz - center;
              // let distToBoundsCenter : f32 = length(fragToBoundsCenter);
              // let normDist : f32 = distToBoundsCenter / radius;
              // ORI_FragmentOutput.color = vec4<f32>(normDist,normDist,normDist, 1.0);
            #endif
          }
      
          fn debugClusterLightCount(fragCoord:vec4<f32>){
            #if USE_LIGHT
            //LightIndex
              let cluster : LightIndex = getCluster();
              let lightCount : u32 = u32(cluster.count);
              let lightFactor : f32 = f32(lightCount) / f32(clustersUniform.maxNumLightsPerCluster);
              // ORI_FragmentOutput.color =  mix(vec4<f32>(0.0, 0.0,0.0, 1.0), vec4<f32>(1.0, 1.0, 1.0, 1.0), vec4<f32>(lightFactor, lightFactor, lightFactor, lightFactor));
            #endif
          }
          #endif
    `;class ss{}s(ss,"sky_vs_frag_wgsl",`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
      @location(auto) fragUV: vec2<f32>,
      @location(auto) vClipPos: vec4<f32>,
      @location(auto) vWorldPos: vec4<f32>,
      @location(auto) vWorldNormal: vec3<f32>,
      @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    @vertex
    fn main( 
      @builtin(instance_index) index : u32,
      @location(auto) position: vec3<f32>,
      @location(auto) normal: vec3<f32>,
      @location(auto) uv: vec2<f32>
    ) -> VertexOutput {
      ORI_VertexOut.fragUV = uv;
      let modelMat = models.matrix[u32(index)];
      let vm = modelMat;
      let normalMatrix = mat3x3<f32>(vm[0].xyz,vm[1].xyz,vm[2].xyz);
	    ORI_VertexOut.vWorldNormal = normalize( normalMatrix * normal );
      ORI_VertexOut.vWorldPos = modelMat * vec4<f32>(position.xyz,1.0) ;
      
      var fixProjMat = globalUniform.projMat ;
      fixProjMat[2].z = 1.0 ;//99999.0 / (99999.0 - 1.0) ;
      fixProjMat[3].z = -1.0 ;//(-1.0 * 99999.0) / (99999.0 - 1.0) ;

      var fixViewMat = globalUniform.viewMat ;
      fixViewMat[3].x = 0.0 ;
      fixViewMat[3].y = 0.0 ;
      fixViewMat[3].z = 0.0 ;

      var clipPos = fixProjMat * fixViewMat * ORI_VertexOut.vWorldPos;
      clipPos.z = clipPos.w;
      ORI_VertexOut.vClipPos = clipPos ;
      ORI_VertexOut.member = clipPos;
      return ORI_VertexOut;
    }
  `),s(ss,"sky_fs_frag_wgsl",`
    #include "GlobalUniform"
    #include "MathShader"
    #include "BitUtil"
    #include "ColorUtil_frag"
    #include "FragmentOutput"

    struct uniformData {
        exposure: f32,
        roughness: f32
    };

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_cube<f32>;

    @group(2) @binding(0)
    var<uniform> global: uniformData;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>,@location(auto) vClipPos: vec4<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32> , @builtin(position) fragCoord : vec4<f32> ) -> FragmentOutput {
        let maxLevel: u32 = textureNumLevels(baseMap);
        let dir = normalize(vWorldPos.xyz);
        var textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(dir.xyz), global.roughness * f32(maxLevel) ).xyz;
        #if IS_HDR_SKY
          textureColor = LinearToGammaSpace(textureColor);
        #endif

        // let o_Target: vec4<f32> = globalUniform.hdrExposure * vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure ;
        let o_Target: vec4<f32> = vec4<f32>(textureColor, 1.0) * globalUniform.skyExposure;
        let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
        let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
        let ORI_NORMALMATRIX = transpose(inverse( nMat ));
       
        var vNormal = (ORI_NORMALMATRIX * -vWorldNormal );
        var gBuffer = packGBuffer(
          -globalUniform.far,
          vec3f(0.0),
          o_Target.rgb,
          vec3f(0.0),
          vNormal
        ) ;
      var fragmentOutput:FragmentOutput;
      #if USE_CASTREFLECTION
        fragmentOutput.gBuffer = gBuffer ;
      #else
        fragmentOutput.color = o_Target ;
        fragmentOutput.gBuffer = gBuffer ;
      #endif
      return fragmentOutput;
    }

    fn packGBuffer(depth:f32, albedo:vec3f,hdrLighting:vec3f,rmao:vec3f,normal:vec3f) -> vec4f{
        var gBuffer : vec4f ;
        var octUVNormal = (octEncode(normalize(normal)) + 1.0) * 0.5 ;

        var yc = f32(r11g11b9_to_float(vec3f(octUVNormal,0.0))) ;
        #if USE_CASTREFLECTION
          var rgbm = EncodeRGBM(hdrLighting);
          var zc = f32(pack4x8unorm(vec4f(rgbm.rgb,0.0))) ;
          var wc = f32(pack4x8unorm(vec4f(rmao.rg,rgbm.a,0.0)));
        #else
          var zc = f32(vec4fToFloat_7bits(vec4f(albedo.rgb,0.0)));
          var wc = f32(r22g8_to_float(vec2f(f32(0.0),rmao.g)));
        #endif
    
        gBuffer.x = depth  ;
        gBuffer.y = yc ;
        gBuffer.z = zc ;
        gBuffer.w = wc ;
        return gBuffer ;
    }
    `);let mh=`
#include "BRDF_frag"
#include "ClusterLight"
#include "ShadowMapping_frag"

#if USE_IES_PROFILE
  #include "IESProfiles_frag"
#endif



const PI2 = 3.1415926 * 3.1415926 ;

fn sampleLighting(light:LightData,direction:vec3f,iblSpecularResult:vec3f , intensity :f32 , shadow:f32 ) -> vec3f{
  var ret = vec3f(0.0);
  var normalDir  = fragData.N;
  var viewDir    = fragData.V;

  var lightDir   = normalize(-direction.xyz);
  var halfDir    = normalize(lightDir + viewDir);
  var reflectDir = normalize(reflect(-viewDir,normalDir));

  var NdotH = max(0.00001,dot(normalDir,halfDir));
  var NdotL = max(0.00001,dot(normalDir,lightDir));
  var NdotV = max(0.00001,dot(normalDir,viewDir));
  var HdotL = max(0.00001,dot(halfDir,lightDir));

  var baseColor = fragData.Albedo.rgb ; 
  var metallic = fragData.Metallic ;
  var roughness = fragData.Roughness ;

  var lightColor = getHDRColor( light.lightColor.rgb , light.linear )  ;
  var att = max(0.0,intensity);
  
  var lighting:vec3f = lightContribution(NdotH,NdotL,NdotV,HdotL,fragData.Roughness,fragData.Albedo.rgb / 3.14, metallic ,shadow,fragData.F0,lightColor.rgb);
  // lighting = fragData.F0 / 3.1415926 * NdotL ;
  lighting = ACESToneMapping(lighting,att);
  // ret += lighting ;
  return lighting ;
}

fn directLighting( light:LightData , iblSpecularResult : vec3f) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    #if USE_LIGHT
      var L = normalize(light.direction.xyz) ;
      #if USE_BRDF
        var shadow = directShadowVisibility[(light.castShadow)] ;
        var att = light.intensity;
        color = sampleLighting(light,L,iblSpecularResult,att, shadow);
      #endif 
    #endif 
    return color;
}

fn directDulLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.85 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 * roughness,metallic) ;
      color += 0.15 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 * roughness,metallic) ;
    #endif 
  #endif 
  return color;
}

fn directHairLighting( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,  roughness:f32 , metallic:f32 , light:LightData , shadowBias:f32 ) -> vec3<f32> {
  var color = vec3<f32>(0.0) ;
  #if USE_LIGHT
    var L = -normalize(light.direction.xyz) ;
    let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
    var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
    var att = light.intensity;
    if(light.castShadow>=0){
        #if USE_SHADOWMAPING
          for (var j: i32 = 0; j < 8; j += 1) {
              if(j == light.castShadow){
                att *= directShadowVisibility[j] ; 
              }
          }
        #endif
    }
    #if USE_LAMBERT
      color = vec3<f32>(1.0,1.0,1.0) ;
    #endif 
    
    #if USE_BRDF
      color = 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.85 ,metallic) ;
      color += 0.5 * simpleBRDF(albedo,N,V,L,att,lightColor,0.15 ,metallic) ;
    #endif 
  #endif 
  return color;
}


fn pointLighting( WP:vec3<f32>, light:LightData , iblSpecularResult : vec3f ) -> vec3<f32> {
    var color = vec3<f32>(0.0) ;
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir);
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }
    if( abs(dist) < light.range ){
        var L = dir ;
        var atten = 1.0 ;
        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001)  ;

        // if( light.castShadow >= 0 )
        // {
        //     #if USE_SHADOWMAPING
        //       for (var j: i32 = 0; j < 8; j += 1) {
        //           if(j == light.castShadow){
        //             atten *= pointShadows[j] ; 
        //           }
        //       }
        //     #endif
        // }

        var shadow = pointShadows[i32(light.castShadow)] ;

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        atten *= sphere_unit(light.range,light.intensity) ;

        color = sampleLighting(light,-L,iblSpecularResult,atten,shadow);
    } 
    return color ;
}

fn pointAtt( WP:vec3<f32>, light:LightData ) -> f32 {
  var atten = 0.0 ;
  let lightPos = light.position.xyz;
  var dir = lightPos.xyz - WP ;
  let dist = length(dir);
  if(dist != 0.0){
    dir *= 1.0 / dist ;
  }
  if( abs(dist) < light.range ){
      var L = dir ;
      atten = 1.0 - smoothstep(0.0,light.range,dist) ;
      atten *= 1.0 / max(light.radius,0.001)  ;
      var shadow = pointShadows[i32(light.castShadow)] ;
      #if USE_IES_PROFILE
          atten *= getLightIESProfileAtt(WP,light);
      #endif
      atten *= sphere_unit(light.range,light.intensity) ;
  } 
  return atten ;
}

fn getDistanceAtten(  light:LightData , dist : f32 ) -> f32 {
  return 1.0 - smoothstep(0.0,light.range,dist) ;
}

fn spotLighting( WP:vec3<f32>, light:LightData , iblSpecularResult : vec3f) -> vec3<f32> {
    let lightPos = light.position.xyz;
    var dir = lightPos.xyz - WP ;
    let dist = length(dir) ;
    if(dist != 0.0){
      dir *= 1.0 / dist ;
    }

    var color = vec3<f32>(0.0) ;
    if( abs(dist) < light.range * 2.0 ){
        var L = dir ;
        let theta = dot(-L, normalize(light.direction));
        let angle = acos(theta) ;
        var atten = 1.0 ;
        var lightColor = light.lightColor.rgb  ;

        atten = 1.0 - smoothstep(0.0,light.range,dist) ;
        atten *= 1.0 / max(light.radius,0.001) ;
        if(angle < light.outerCutOff){
          if(angle > light.innerCutOff){
            atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
          }
        }else{
            atten = 0.0 ;
        }

        var shadow = pointShadows[i32(light.castShadow)] ;

        #if USE_IES_PROFILE
            atten *= getLightIESProfileAtt(WP,light);
        #endif

        atten *= sphere_unit(light.range, light.intensity) ;

        color = sampleLighting(light,-L,iblSpecularResult,atten,shadow);
    }
    return  color ;
}

fn sphere_unit( radius:f32 , intensity:f32 ) -> f32 {
  return intensity / (4.0 * PI2 * radius * radius) ;
}
`,Ah=`
  #include 'BitUtil'
  // fn getViewPosition(z:f32,uv:vec2f) -> vec3f {
  //   let pvMatrix = globalUniform.projMat * globalUniform.viewMat ;
  //   let worldPos = getWorldPosition(z,uv) ;
  //   var viewPos = pvMatrix * worldPos ;
  //   return viewPos.xyz;
  // }

  

  struct TBN_ret{
    tan:vec3f,
    bit:vec3f,
  }
  
  fn TBN( N:vec3f) -> mat3x3<f32>{
    //Returns the simple tangent space matrix
    var Nb : vec3f;
    var Nt : vec3f;
    if (abs(N.y)>0.999) {
        Nb = vec3f(1.0,0.0,0.0);
        Nt = vec3f(0.0,0.0,1.0);
    } else {
      Nb = normalize(cross(N,vec3f(0.0,1.0,0.0)));
      Nt = normalize(cross(Nb,N));
    }

    var mat3 = mat3x3<f32>(
      Nb.x,Nt.x,N.x,
      Nb.y,Nt.y,N.y,
      Nb.z,Nt.z,N.z
    );

    return mat3;
  }

  fn TBN_out( N : vec3f ) -> TBN_ret {
      var tbn_ret : TBN_ret;
      //Returns the simple tangent space directions
      if (abs(N.y)>0.999) {
          tbn_ret.tan = vec3f(1.0,0.0,0.0);
          tbn_ret.bit = vec3f(0.0,0.0,1.0);
      } else {
          tbn_ret.tan = normalize(cross(N,vec3f(0.0,1.0,0.0)));
          tbn_ret.bit = normalize(cross(tbn_ret.tan,N));
      }

      return tbn_ret;
  }


  fn ARand21( uv: vec2f) -> f32 {
      //Returns 1D noise from 2D
      return fract(sin(uv.x*uv.y)*403.125+cos(dot(uv,vec2f(13.18273,51.2134)))*173.137);
  }

fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
  let x:f32 = position.x;
  let y:f32 = position.y;
  let z:f32 = position.z;

  let qx:f32 = q.x;
  let qy:f32 = q.y;
  let qz:f32 = q.z;
  let qw:f32 = q.w;

  let ix:f32 = qw * x + qy * z - qz * y;
  let iy:f32 = qw * y + qz * x - qx * z;
  let iz:f32 = qw * z + qx * y - qy * x;
  let iw:f32 = -qx * x - qy * y - qz * z;

  var ret: vec3<f32>;
  ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
  ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
  ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

  return ret;
}

fn inverse( m:mat3x3<f32>) -> mat3x3<f32>{
  var a00 = m[0][0];
  var a01 = m[0][1];
  var a02 = m[0][2];
  var a10 = m[1][0];
  var a11 = m[1][1];
  var a12 = m[1][2];
  var a20 = m[2][0];
  var a21 = m[2][1];
  var a22 = m[2][2];

  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;

  var det = a00 * b01 + a01 * b11 + a02 * b21 ;
  return mat3x3<f32>(
      vec3<f32>(b01/ det, (-a22 * a01 + a02 * a21)/ det, (a12 * a01 - a02 * a11)/ det),
      vec3<f32>(b11/ det, (a22 * a00 - a02 * a20)/ det, (-a12 * a00 + a02 * a10)/ det),
      vec3<f32>(b21/ det, (-a21 * a00 + a01 * a20)/ det, (a11 * a00 - a01 * a10)/ det)
  );
}

fn dir_to_faceId(pt:vec3<f32>) -> i32 {
    //**** nx px ny py nz pz
    var abs_x = abs(pt.x);
    var abs_y = abs(pt.y);
    var abs_z = abs(pt.z);
    var coord = max(max(abs_x, abs_y), abs_z);
    if(coord == -pt.x){  return 0;}
    if(coord == pt.x) { return 1;}

    if(coord == -pt.y){  return 2;}
    if(coord == pt.y) { return 3;}

    if(coord == -pt.z) { return 4;}
    return 5;
  }

  const us = 1.0 /6.0 ;
  fn uv_2_xyz(u:f32,v:f32) -> vec3f 
  {
    let face = floor(u / us);
    var uu = (u - face * us) / us ;

    var uc = 2.0 * uu - 1.0;
    var vc = 2.0 * v - 1.0;
    var xyz = vec3f(0,0,0);

    if(face == 0.0){
    // x,y,z = 1.0,vc,-uc
      xyz = vec3f(1.0,-vc,uc);
    }else if(face == 1.0){
    // x,y,z = -1.0,vc,uc
      xyz = vec3f(-1.0,-vc,-uc);
    }else if(face == 2.0){
    // x,y,z = uc,1.0,-vc
      xyz = vec3f(uc,1.0,-vc);
    }else if(face == 3.0){
    // x,y,z = uc,-1.0,vc
      xyz = vec3f(uc,-1.0,vc);
    }else if(face == 4.0){
    // x,y,z = uc,vc,1.0
      xyz = vec3f(-uc,-vc,1.0);
    }else if(face == 5.0){
    // x,y,z = -uc,vc,-1.0
      xyz = vec3f(uc,-vc,-1.0);
    }
    return xyz ;
  }

  fn convert_xyz_to_cube_uv(x:f32, y:f32, z:f32 ) -> vec2f
  {
    var dir = vec3f(x, y, z);
    var absX = abs(dir.x);
    var absY = abs(dir.y);
    var absZ = abs(dir.z);

    var isXPositive = 0;
    if(dir.x > 0.0){isXPositive = 1;}
    var isYPositive = 0;
    if(dir.y > 0.0){isYPositive = 1;}
    var isZPositive = 0;
    if(dir.z > 0.0){isZPositive = 1;}

    var maxAxis:f32 = 0.0;
    var uc:f32 = 0.0;
    var vc:f32 = 0.0;

    // POSITIVE X
    if (isXPositive == 1 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from +z to -z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = -z;
      vc = y;
    }
    // NEGATIVE X
    if (isXPositive ==0 && absX >= absY && absX >= absZ) {
      // u (0 to 1) goes from -z to +z
      // v (0 to 1) goes from -y to +y
      maxAxis = absX;
      uc = z;
      vc = y;
    }
    // POSITIVE Y
    if (isYPositive==1 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from +z to -z
      maxAxis = absY;
      uc = x;
      vc = -z;
    }
    // NEGATIVE Y
    if (isYPositive ==0 && absY >= absX && absY >= absZ) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -z to +z
      maxAxis = absY;
      uc = x;
      vc = z;
    }
    // POSITIVE Z
    if (isZPositive == 1&& absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from -x to +x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = x;
      vc = y;
    }
    // NEGATIVE Z
    if (isZPositive ==0 && absZ >= absX && absZ >= absY) {
      // u (0 to 1) goes from +x to -x
      // v (0 to 1) goes from -y to +y
      maxAxis = absZ;
      uc = -x;
      vc = y;
    }

    // Convert range from -1 to 1 to 0 to 1
    var u = 0.5f * (uc / maxAxis + 1.0f);
    var v = 0.5f * (vc / maxAxis + 1.0f);

    return vec2f(u, v);
  }

    // Returns \xB11
    fn signNotZero( v1:vec2<f32>) -> vec2<f32> {
        var v:vec2<f32> = v1;
        if(v.x >= 0.0){
            v.x = 1.0;
        }else{
            v.x = -1.0;
        }
        if(v.y >= 0.0){
            v.y = 1.0;
        }else{
            v.y= -1.0;
        }
        return v;
    }

    fn octEncode( v:vec3<f32> ) -> vec2<f32> {
        var l1norm = abs(v.x) + abs(v.y) + abs(v.z);
        var result = v.xy * (1.0 / l1norm);
        if (v.z < 0.0) {
            result = (1.0 - abs(result.yx)) * signNotZero(result.xy);
        }
        return result;
    }

    // Returns a unit vector. Argument o is an octahedral vector packed via octEncode,on the [-1, +1] square*/
    fn octDecode( o:vec2<f32> ) -> vec3<f32> {
        var v = vec3<f32>(o.x, o.y, 1.0 - abs(o.x) - abs(o.y));
        if (v.z < 0.0) {
            var tmp = (1.0 - abs(v.yx)) * signNotZero(v.xy);
            v.x = tmp.x;
            v.y = tmp.y;
        }
        return normalize(v);
    }

    fn Linear01Depth(z:f32,near:f32,far:f32)-> f32{
        let ZBufferZ = (-1.0+(far/near)) / far;
        let ZBufferW = near /far ;
        return 1.0 / (ZBufferZ * z + ZBufferW) ;
    }

    
    fn LinearizeDepth( depth:f32 , nearPlane:f32 , farPlane:f32 )-> f32 {
      var z = depth * 2.0 - 1.0;
      return (2.0 * nearPlane * farPlane) / (farPlane + nearPlane - z * (farPlane - nearPlane));
    }

    fn logDepth(depth : f32, far:f32) -> f32 {
      return log2(depth + 1.0) * 2.0 / (log(far + 1.0) / 0.6931471805599453) * 0.5;
    }

    fn log2Depth(depth:f32, near:f32, far:f32) -> f32 {
      let Fcoef:f32 = 2.0 / log2(far + 1.0);
      var result:f32 = (log2(max(1e-6, 1.0 + depth)) * Fcoef - 1.0);
      result = (1.0 + result) / 2.0;
      return result * depth;
    }

    fn log2DepthFixPersp(depth:f32, near:f32, far:f32) -> f32 {
      let flogz:f32 = 1.0 + depth;
      let Fcoef_half:f32 = (2.0 / log2(far + 1.0)) * 0.5;
      var result:f32 = log2(flogz) * Fcoef_half;
      result = (1.0 + result) / 2.0;
      return result;
    }


    fn QuaternionToMatrix(q: vec4<f32>) -> mat4x4<f32> {
      // If q is guaranteed to be a unit quaternion, s will always
      // be 1.  In that case, this calculation can be optimized out.
      //float norm = GetNorm (q);
      //float s = (norm > 0.0) ? 2.0/norm : 0;

      var result: mat4x4<f32>;
  
      // Precalculate coordinate products
      let x = q.x * 2.0;
      let y = q.y * 2.0;
      let z = q.z * 2.0;
      let xx = q.x * x;
      let yy = q.y * y;
      let zz = q.z * z;
      let xy = q.x * y;
      let xz = q.x * z;
      let yz = q.y * z;
      let wx = q.w * x;
      let wy = q.w * y;
      let wz = q.w * z;
  
      // Calculate 3x3 matrix from orthonormal basis
      result[0][0] = 1.0 - (yy + zz);
      result[0][1] = xy + wz;
      result[0][2] = xz - wy;
      result[0][3] = 0.0;
  
      result[1][0] = xy - wz;
      result[1][1] = 1.0 - (xx + zz);
      result[1][2] = yz + wx;
      result[1][3] = 0.0;
  
      result[2][0] = xz + wy;
      result[2][1] = yz - wx;
      result[2][2] = 1.0 - (xx + yy);
      result[2][3] = 0.0;
  
      result[3][0] = 0.0;
      result[3][1] = 0.0;
      result[3][2] = 0.0;
      result[3][3] = 1.0;

      return result;
    }

    fn MakeScaleMatrix(scale: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          scale.x, 0.0, 0.0, 0.0,
          0.0, scale.y, 0.0, 0.0,
          0.0, 0.0, scale.z, 0.0,
          0.0, 0.0, 0.0, 1.0,
        );
    }

    fn MakeRotationMatrix(rotationQuaternion: vec4<f32>) -> mat4x4<f32> {
        return QuaternionToMatrix(rotationQuaternion);
    }

    fn MakeTranslationMatrix(translation: vec3<f32>) -> mat4x4<f32> {
        return mat4x4<f32>(
          1.0, 0.0, 0.0, 0.0,
          0.0, 1.0, 0.0, 0.0,
          0.0, 0.0, 1.0, 0.0,
          translation.x, translation.y, translation.z, 1.0,
        );
    }

    fn MakeMatrix4x4(scale: vec3<f32>, rotationQuaternion: vec4<f32>, translation: vec3<f32>) -> mat4x4<f32> {
        var scaleMat: mat4x4<f32> = MakeScaleMatrix(scale);
        var rotationMat: mat4x4<f32> = MakeRotationMatrix(rotationQuaternion);
        var translationMat: mat4x4<f32> = MakeTranslationMatrix(translation);
        return translationMat * scaleMat * rotationMat;
    }

    fn mixMatrix4x4(a: mat4x4<f32>, b: mat4x4<f32>, t:f32) -> mat4x4<f32> {
      return a * (1.0 - t) + b * t;
      // return mat4x4<f32>(
      //   mix(a[0], b[0], t),
      //   mix(a[1], b[1], t),
      //   mix(a[2], b[2], t),
      //   mix(a[3], b[3], t)
      // );
    }

    fn decodeDepth( color:vec4<f32> ) -> f32{
      var depth = 0.0 ;
      const bitShifts = vec4<f32>(1.0 / (256.0 * 256.0 * 256.0), 1.0 / (256.0 * 256.0), 1.0 / 256.0, 1.0); 
      depth = dot(color, bitShifts);
      return depth;
    }

    fn encodeDepth( depth:f32 ) -> vec4<f32>{
      const bitSh  = vec4<f32>(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
      const bitMsk = vec4<f32>(0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
      var comp:vec4<f32>;
      comp  = depth * bitSh;
      comp  = fract(comp);
      comp -= comp.xxyz * bitMsk;
      return comp;
    }

    fn calculateBillboardMatrix2(eye:vec3f,pos:vec3f,up:vec3f) -> mat3x3<f32> {
      
      let zAxis: vec3f = -normalize(pos.xyz - eye);
      var xAxis: vec3f = cross(up,zAxis);
      xAxis = normalize(cross(zAxis,xAxis));
      let yAxis = normalize(cross(zAxis, xAxis));
      return mat3x3<f32>(xAxis, yAxis, zAxis);
    }

    struct SH9Struct{
      SHAr:vec4f,
      SHAg:vec4f,
      SHAb:vec4f,
      SHBr:vec4f,
      SHBg:vec4f,
      SHBb:vec4f,
      SHC:vec4f,
    }

    fn ShadeSH9 ( normal:vec4f , sh9:SH9Struct) -> vec3f
    {
      var x1:vec3f = vec3f(0.0);
      var x2:vec3f = vec3f(0.0);
      var x3:vec3f = vec3f(0.0);
      
      // Linear + constant polynomial terms
      x1.r = dot(sh9.SHAr,normal);
      x1.g = dot(sh9.SHAg,normal);
      x1.b = dot(sh9.SHAb,normal);
      
      // 4 of the quadratic polynomials
      var vB = normal.xyzz * normal.yzzx;
      x2.r = dot(sh9.SHBr,vB);
      x2.g = dot(sh9.SHBg,vB);
      x2.b = dot(sh9.SHBb,vB);
      
      // Final quadratic polynomial
      var vC = normal.x*normal.x - normal.y*normal.y;
      x3 = sh9.SHC.rgb * vC;
      return x1 + x2 + x3;
    } 

    fn clipViewUV(viewRectangle:vec4f,size:vec2f,fragCoord:vec2f) -> vec2u {
        let subViewUV = (fragCoord - viewRectangle.xy) / viewRectangle.zw ;
        return vec2u(subViewUV*size) ;
    }

    fn insideRectangle( point:vec2f , rec:vec4f) -> bool {
      if( point.x > rec.x &&  point.y > rec.y &&  point.x < (rec.x + rec.z ) &&  point.y < (rec.y + rec.w ) ){
         return true ;
      }
      return false;
    }

    fn convert_cube_uv_to_xyz( index:i32,  u:f32,  v:f32) -> vec3f
    {
      var ret : vec3f ;
      // convert range 0 to 1 to -1 to 1
      var uc = 2.0f * u - 1.0f;
      var vc = 2.0f * v - 1.0f;
      switch (index)
      {
        case 0: {
          ret.x =  1.0f; 
          ret.y =    vc; 
          ret.z =   -uc; 
          break;
        }	// POSITIVE X
        case 1: {
          ret.x = -1.0f; 
          ret.y =    vc; 
          ret.z =    uc; 
          break;
        }	// NEGATIVE X
        case 2: {
          ret.x =    uc; 
          ret.y =  1.0f; 
          ret.z =   -vc; 
          break;
        }	// POSITIVE Y
        case 3: {
          ret.x =    uc; 
          ret.y = -1.0f; 
          ret.z =    vc; 
          break;
        }	// NEGATIVE Y
        case 4: {
          ret.x =    uc; 
          ret.y =    vc; 
          ret.z =  1.0f; 
          break;
        }	// POSITIVE Z
        case 5: {
          ret.x =   -uc; 
          ret.y =    vc; 
          ret.z = -1.0f; 
          break;
        }	// NEGATIVE Z
        default:{
          ret = vec3f(0.0);
        }
      }
      return ret ;
    }

    fn convert_cube_uv_to_normal( index:i32, u:f32, v:f32) -> vec3f
    {
      var ret : vec3f ;
      // convert range 0 to 1 to -1 to 1
      var uc = 2.0f * u - 1.0f;
      var vc = 2.0f * v - 1.0f;
      switch (index)
      {
        case 0: {
          ret.x =  1.0f; 
          ret.y =    vc; 
          ret.z =   -uc; 
          break;
        }	// POSITIVE X
        case 1: {
          ret.x = -1.0f; 
          ret.y =    vc; 
          ret.z =    uc; 
          break;
        }	// NEGATIVE X
        case 2: {
          ret.x =    uc; 
          ret.y =  1.0f; 
          ret.z =   -vc; 
          break;
        }	// POSITIVE Y
        case 3: {
          ret.x =    uc; 
          ret.y = -1.0f; 
          ret.z =    vc; 
          break;
        }	// NEGATIVE Y
        case 4: {
          ret.x =    uc; 
          ret.y =    vc; 
          ret.z =  1.0f; 
          break;
        }	// POSITIVE Z
        case 5: {
          ret.x =   -uc; 
          ret.y =    vc; 
          ret.z = -1.0f; 
          break;
        }	// NEGATIVE Z
        default:{
          ret = vec3f(0.0);
        }
      }
      return ret ;
    }

    fn UvToDir( uv1:vec2f) -> vec3f{
      var uv = uv1 ;
      uv *= vec2f(2.0*3.1415926535897932384626433832795, 3.1415926535897932384626433832795);
      var theta = uv.y;
      var phi = uv.x + 3.1415926535897932384626433832795 * 0.5 ;
      // var phi = uv.x ;
      var dir = vec3f(0.0,0.0,0.0);
      dir.x = sin(phi) * sin(theta) * -1;
      dir.y = cos(theta) * -1;
      dir.z = cos(phi) * sin(theta);
      return dir;
    }

    fn DirTOUV( a_coords:vec3f ) ->vec2f
    {
      var coords = normalize(a_coords);
      var lon = atan2(coords.z, coords.x);
      var lat = acos(coords.y);
      var sphereCoords = vec2f(lon, lat) * (1.0 / 3.1415926535897932384626433832795);
      return vec2f(sphereCoords.x * 0.5 + 0.5 , 1.0 - sphereCoords.y);
      // return vec2f(sphereCoords.y, (sphereCoords.x * 0.5 ));
    }
    
`,vh=`
          #if USE_CUSTOMUNIFORM
          #else
              struct MaterialUniform {
                  baseColor: vec4<f32>,
                  emissiveColor: vec4<f32>,
                  materialF0: vec4<f32>,
                  specularColor: vec4<f32>,

                  envIntensity: f32,
                  normalScale: f32,
                  roughness: f32,
                  metallic: f32,

                  ao: f32,
                  roughness_min: f32,
                  roughness_max: f32,
                  metallic_min: f32,

                  metallic_max: f32,
                  emissiveIntensity: f32,
                  alphaCutoff: f32,
                  ior: f32,

                  clearcoatColor: vec4<f32>,

                  clearcoatWeight: f32,
                  clearcoatFactor: f32,
                  clearcoatRoughnessFactor: f32,
                  clearcoatIor: f32,

                  baseMapOffsetSize:vec4<f32>,
                  normalMapOffsetSize:vec4<f32>,
                  emissiveMapOffsetSize:vec4<f32>,
                  roughnessMapOffsetSize:vec4<f32>,
                  metallicMapOffsetSize:vec4<f32>,
                  aoMapOffsetSize:vec4<f32>,
              };
        #endif
      
        @group(2) @binding(0)
        var<uniform> materialUniform: MaterialUniform;
      `,xh=`


#if USE_CUSTOMUNIFORM
#else
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,
      baseColor: vec4<f32>,
      alphaCutoff: f32,
    };
#endif


@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Ch=`
    #include "Common_frag"
    #include "GlobalUniform"

    fn UnLit(){
        let alpha = ORI_ShadingInput.BaseColor.a ;
        var viewColor = vec4<f32>(ORI_ShadingInput.BaseColor.rgb * alpha , alpha) ;
        let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
        let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
        let ORI_NORMALMATRIX = transpose(inverse( nMat ));
        var vNormal = normalize(ORI_NORMALMATRIX * (ORI_VertexVarying.vWorldNormal ));
        let gBuffer = packNHMDGBuffer(
            ORI_VertexVarying.fragCoord.z,
            vec3f(0.0),
            viewColor.rgb,
            // vec3f(0.5),
            vec3f(1.0,0.0,0.0),
            vNormal,
            alpha
          ) ;
  
          #if USE_CASTREFLECTION
            ORI_FragmentOutput.gBuffer = gBuffer ;
          #else
            ORI_FragmentOutput.gBuffer = gBuffer ;
            ORI_FragmentOutput.color = viewColor ;
          #endif
    }

    fn debugFragmentOut(){

    }
`;class ca{static groupBindingAndFunctions(t,e){return`
            struct JointsMatrix {
                matrix : array<mat4x4<f32>>
            };

            @group(${t}) @binding(${e})
            var<storage, read> jointsMatrixIndexTable: array<f32>;

            @group(${t}) @binding(${e+1})
            var<storage, read> jointsInverseMatrix: JointsMatrix;

            @group(${t}) @binding(${e+2})
            var<storage, read> jointsIndexMapingTable: array<f32>;

            const MAX_JOINT_NUM = 8;
            fn getSkeletonWorldMatrix(joints: array<f32, MAX_JOINT_NUM>, weights: array<f32, MAX_JOINT_NUM>, num: u32) -> mat4x4<f32> {
                var result: mat4x4<f32>;
                for(var i: u32 = 0; i < num; i = i + 1) {
                    let jointId = i32(joints[i]);
                    let jointIndex = u32(jointsIndexMapingTable[jointId]);
                    let jointMatrixIndex = u32(jointsMatrixIndexTable[jointIndex]);
                    let joint = models.matrix[jointMatrixIndex] * jointsInverseMatrix.matrix[jointId] * weights[i];
                    result += joint;
                }
                return result;
            }

            fn getSkeletonWorldMatrix_4(joints: vec4<f32>, weights: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints.x, joints.y, joints.z, joints.w,
                    0, 0, 0, 0,
                ), array<f32, MAX_JOINT_NUM>(
                    weights.x, weights.y, weights.z, weights.w,
                    0, 0, 0, 0,
                ), 4);
            }
    
            fn getSkeletonWorldMatrix_8(joints0: vec4<f32>, weights0: vec4<f32>, joints1: vec4<f32>, weights1: vec4<f32>) -> mat4x4<f32> {
                return getSkeletonWorldMatrix(array<f32, MAX_JOINT_NUM>(
                    joints0.x, joints0.y, joints0.z, joints0.w,
                    joints1.x, joints1.y, joints1.z, joints1.w,
                ), array<f32, MAX_JOINT_NUM>(
                    weights0.x, weights0.y, weights0.z, weights0.w,
                    weights1.x, weights1.y, weights1.z, weights1.w,
                ), 8);
            }
        `}}let _h=`
    var<private> PI: f32 = 3.14159265359;
    #if USE_METAHUMAN
        ${Ft.getMorphTargetShaderBinding(3,0)}
        ${ca.groupBindingAndFunctions(3,2)} 
    #else
        #if USE_MORPHTARGETS
            ${Ft.getMorphTargetShaderBinding(3,0)}
        #endif

        #if USE_SKELETON
            ${ca.groupBindingAndFunctions(3,0)} 
        #endif
    #endif

    struct VertexAttributes{
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

        #if USE_METAHUMAN
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif
        #else
            #if USE_TANGENT
                @location(auto) TANGENT: vec4<f32>,
            #endif

            #if USE_SKELETON
                #if USE_TANGENT
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #else
                    @location(auto) joints0: vec4<f32>,
                    @location(auto) weights0: vec4<f32>,
                    #if USE_JOINT_VEC8
                        @location(auto) joints1: vec4<f32>,
                        @location(auto) weights1: vec4<f32>,
                    #endif
                #endif
            #endif

            #if USE_MORPHTARGETS
                #if USE_TANGENT
                    @location(auto) vIndex: f32,
                #else
                    @location(auto) vIndex: f32,
                #endif
            #endif

        #endif
    }

    struct VertexOutput {
    @location(auto) index: f32,
    @location(auto) varying_UV0: vec2<f32>,
    @location(auto) varying_UV1: vec2<f32>,
    @location(auto) varying_ViewPos: vec4<f32>,
    @location(auto) varying_Clip: vec4<f32>,
    @location(auto) varying_WPos: vec4<f32>,
    @location(auto) varying_WNormal: vec3<f32>,
    @location(auto) varying_Color: vec4<f32>,

    #if USE_SHADOWMAPING
        @location(auto) varying_ShadowPos: vec4<f32>,
    #endif

    #if USE_TANGENT
        @location(auto) varying_Tangent: vec4<f32>,
    #endif
   

    @builtin(position) member: vec4<f32>
    };

    var<private> ORI_VertexOut: VertexOutput ;

    fn ORI_Vert(vertex:VertexAttributes){
    var vertexPosition = vertex.position;
    var vertexNormal = vertex.normal;

    #if USE_METAHUMAN
        ${Ft.getMorphTargetCalcVertex()}    
        #if USE_JOINT_VEC8
            let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
            ORI_MATRIX_M *= skeletonNormal ;
        #else
            let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
            ORI_MATRIX_M *= skeletonNormal ;
        #endif
    #else 
        #if USE_MORPHTARGETS
            ${Ft.getMorphTargetCalcVertex()}    
        #endif

        #if USE_SKELETON
            #if USE_JOINT_VEC8
                let skeletonNormal = getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
                ORI_MATRIX_M *= skeletonNormal ;
            #else
                let skeletonNormal = getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
                ORI_MATRIX_M *= skeletonNormal ;
            #endif
        #endif
    #endif
    
    ORI_NORMALMATRIX = transpose(inverse( mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ));
   
    #if USE_TANGENT
        ORI_VertexOut.varying_Tangent = vec4f(normalize(ORI_NORMALMATRIX * vertex.TANGENT.xyz),vertex.TANGENT.w)  ;
    #endif

    var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));
    var viewPosition = ORI_MATRIX_V * worldPos;
    var clipPosition = ORI_MATRIX_P * viewPosition ;

    #if USE_LOGDEPTH
        clipPosition.z = log2Depth(clipPosition.w, globalUniform.near, globalUniform.far);
    #endif

    ORI_CameraWorldDir = normalize(ORI_CAMERAMATRIX[3].xyz - worldPos.xyz) ;

    ORI_VertexOut.index = f32(vertex.index) ;

    ORI_VertexOut.varying_UV0 = vertex.uv.xy ;

    ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;

    ORI_VertexOut.varying_ViewPos = viewPosition ;
    ORI_VertexOut.varying_Clip = clipPosition ;
    ORI_VertexOut.varying_WPos = worldPos ;
    ORI_VertexOut.varying_WPos.w = f32(vertex.index);
    ORI_VertexOut.varying_WNormal = normalize(ORI_NORMALMATRIX * vertexNormal.xyz) ;

    ORI_VertexOut.member = clipPosition ;
    }
`,yh=`
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,
  baseColor: vec4<f32>,
  rectClip: vec4<f32>,
  alphaCutoff: f32,
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;
`,Sh=`
    struct IrradianceVolumeData {
        //0
        orientationIndex:f32,
            hysteresis:f32,
            OctRTSideSize:f32,
            OctRTMaxSize:f32,

            //1
            startX:f32,
            startY:f32,
            startZ:f32,
            ProbeSpace:f32,

            //2
            gridXCount:f32,
            gridYCount:f32,
            gridZCount:f32,
            maxDistance:f32,

            //3
            depthSharpness:f32,
            ProbeSourceTextureSize:f32,
            ProbeSize:f32,
            bounceIntensity:f32,

            //4
            probeRoughness:f32,
            normalBias:f32,
            irradianceChebyshevBias:f32,
            rayNumber:f32,

            //5
            irradianceDistanceBias:f32,
            indirectIntensity:f32,
            ddgiGamma:f32,
            lerpHysteresis:f32,
            //6

            debugX:f32,
            debugY:f32,
            debugZ:f32,
            slot0:f32,

            //..
            v7:vec4<f32>,
    }
`,Ih=`
    #include "MathShader"
    #include "FastMathShader"
    #include "InstanceUniform"

    var<private> ORI_MATRIX_P: mat4x4<f32>;
    var<private> ORI_MATRIX_V: mat4x4<f32>;
    var<private> ORI_MATRIX_M: mat4x4<f32>;
    var<private> ORI_MATRIX_PV: mat4x4<f32>;
    var<private> ORI_MATRIX_PVInv: mat4x4<f32>;
    var<private> ORI_MATRIX_World: mat4x4<f32>;
    var<private> ORI_CAMERAMATRIX: mat4x4<f32>;
    var<private> ORI_NORMALMATRIX: mat3x3<f32>;
    var<private> ORI_CameraWorldDir: vec3<f32>;
    var<private> ORI_ViewDir: vec3<f32>;

    fn TIME() -> vec3f {
        return vec3f(globalUniform.frame, globalUniform.time , globalUniform.delta);
    }

    fn TIME_frame() -> f32 {
        return globalUniform.frame ;
    }

    fn TIME_time() -> f32 {
        return globalUniform.time ;
    }

    fn TIME_delta() -> f32 {
        return globalUniform.delta ;
    }

    fn MOUSE() -> vec2f {
        return vec2f( globalUniform.mouseX, globalUniform.mouseY) ;
    }

    fn SCREEN() -> vec2f {
        return vec2f( globalUniform.windowWidth, globalUniform.windowHeight) ;
    }

    fn ProjectionParams() -> vec3f {
        return vec3f( globalUniform.near, globalUniform.far,1.0 + 1.0 / globalUniform.far) ;
    }

    fn vertex_inline(vertex:VertexAttributes){
        ORI_MATRIX_P = globalUniform.projMat ;
        ORI_MATRIX_V = globalUniform.viewMat ;
        ORI_MATRIX_PV = ORI_MATRIX_P * ORI_MATRIX_V ;
        ORI_MATRIX_PVInv = globalUniform.pvMatrixInv ;
        ORI_CAMERAMATRIX = globalUniform.cameraWorldMatrix ;

        ORI_MATRIX_M = models.matrix[u32(vertex.index)];
            
        #if USE_INSTANCEDRAW
            let modelID = instanceDrawID.matrixIDs[vertex.index];
            ORI_MATRIX_M = models.matrix[modelID];
        #endif
    }
`,bh=`
  #include "GlobalUniform"
  #include "FragmentVarying"
  #include "FragmentOutput"
  #include "ShadingInput"
  #include "ColorUtil_frag"
  #include "BitUtil"

  var<private> ORI_FragmentOutput: FragmentOutput;
  var<private> ORI_VertexVarying: FragmentVarying;
  var<private> ORI_ShadingInput: ShadingInput;
  var<private> viewDir:vec3<f32>;
  var<private> modelIndex:u32;
  
  @fragment
  fn FragMain( vertex_varying:FragmentVarying ) -> FragmentOutput {
   
    modelIndex = u32(round(vertex_varying.index)) ; 

    ORI_VertexVarying = vertex_varying;
    ORI_VertexVarying.vWorldNormal = normalize(vertex_varying.vWorldNormal);
    ORI_FragmentOutput.color = vec4<f32>(1.0, 0.0, 0.0, 1.0);
    viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;

    frag();
    
    #if USE_DEBUG
      debugFragmentOut();
    #endif

    #if USE_DEFAULTFRAGOUT
      // let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
      // let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
      // let ORI_NORMALMATRIX = transpose(inverse( nMat ));
      // var vNormal = normalize(ORI_NORMALMATRIX * (ORI_VertexVarying.vWorldNormal));

      // let gBuffer = packNHMDGBuffer(
      //   ORI_VertexVarying.fragCoord.z,
      //   ORI_ShadingInput.BaseColor.rgb,
      //   ORI_ShadingInput.BaseColor.rgb,
      //   vec3f(ORI_ShadingInput.Roughness,ORI_ShadingInput.Metallic,ORI_ShadingInput.AmbientOcclusion),
      //   ORI_ShadingInput.Normal,
      //   ORI_ShadingInput.Opacity
      // ) ;
    #endif

    #if USE_OUTDEPTH
      #if USE_LOGDEPTH
        ORI_FragmentOutput.out_depth = log2DepthFixPersp(ORI_VertexVarying.fragPosition.w, globalUniform.near, globalUniform.far);
      #else
        ORI_FragmentOutput.out_depth = ORI_ShadingInput.FragDepth ;
      #endif
    #endif

    return ORI_FragmentOutput ;
  }


  fn packNHMDGBuffer(depth:f32, albedo:vec3f,hdrLighting:vec3f,rmao:vec3f,normal:vec3f,alpha:f32) -> vec4f  {
      var gBuffer : vec4f ;
      var octUVNormal = (octEncode(normalize( (normal) )) + 1.0) * 0.5 ;
      var yc = f32(r11g11b9_to_float(vec3f(octUVNormal,rmao.r))) ;
      #if USE_CASTREFLECTION
        var rgbm = EncodeRGBM(hdrLighting);
        var zc = f32(pack4x8unorm(vec4f(rgbm.rgb,0.0))) ;
        var wc = f32(pack4x8unorm(vec4f(rmao.rg,rgbm.a,0.0)));
      #else
        var zc = f32(vec4fToFloat_7bits(vec4f(albedo.rgb,alpha)));
        var wc = f32(r22g8_to_float(vec2f(f32(modelIndex)/f_r22g8.r,rmao.g)));
      #endif

      gBuffer.x = depth  ;
      gBuffer.y = yc ;
      gBuffer.z = zc ;
      gBuffer.w = wc ;
      return gBuffer ;
  }

  fn transformUV( uv:vec2f , offsetScale:vec4f ) -> vec2f{
     return uv * offsetScale.zw + offsetScale.xy ;
  }

`,wh=`
    #include "WorldMatrixUniform"
    #include "VertexAttributes_vert"
    #include "GlobalUniform"
    #include "Inline_vert"
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }
`,Th=`
    @group(1) @binding(auto)
    var brdflutMapSampler: sampler;
    @group(1) @binding(auto)
    var brdflutMap: texture_2d<f32>;
`,Eh=`
    @group(1) @binding(auto)
    var prefilterMapSampler: sampler;
    @group(1) @binding(auto)
    var prefilterMap: texture_cube<f32>;
    @group(1) @binding(auto)
    var envMapSampler: sampler;
    @group(1) @binding(auto)
    var envMap: texture_cube<f32>;
`;class nr{}s(nr,"Cascades",4);let vn=`

  #include "MathShader"

  struct GlobalUniform {

    projMat: mat4x4<f32>,
    viewMat: mat4x4<f32>,
    cameraWorldMatrix: mat4x4<f32>,
    pvMatrixInv : mat4x4<f32>,
    viewToWorld : mat4x4<f32>,
    shadowMatrix: array<mat4x4<f32>, 8u>,

    csmShadowBias: vec4<f32>,

    csmMatrix: array<mat4x4<f32>,${nr.Cascades}>,
    
    shadowLights:mat4x4<f32>,

    reflectionProbeSize:f32,
    reflectionProbeMaxCount:f32,
    reflectionMapWidth:f32,
    reflectionMapHeight:f32,

    reflectionCount:f32,
    test2:f32,
    test3:f32,
    test4:f32,

    CameraPos: vec3<f32>,
    frame: f32,
    SH:  array<vec4f, 9u> ,

    time: f32,
    delta: f32,
    shadowBias: f32,
    skyExposure: f32,

    renderPassState:f32,
    quadScale: f32,
    hdrExposure: f32,
    renderState_left: i32,

    renderState_right: i32,
    renderState_split: f32,
    mouseX: f32,
    mouseY: f32,

    windowWidth: f32,
    windowHeight: f32,
    near: f32,
    far: f32,

    pointShadowBias: f32,
    shadowMapSize: f32,
    shadowSoft: f32,
    enableCSM:f32,


    csmMargin:f32,
    nDirShadowStart: i32,
    nDirShadowEnd: i32,
    nPointShadowStart: i32,

    nPointShadowEnd: i32,
    cameraForward:vec3f,

    frustumPlanes: array<vec4f, 6u>,

  };

  @group(0) @binding(0)
  var<uniform> globalUniform: GlobalUniform;

  fn getViewPosition(z:f32,uv:vec2f) -> vec3f {
    let pvMatrixInv = globalUniform.pvMatrixInv ;
    let clip = vec4<f32>((uv * 2.0 - 1.0) , z , 1.0);
    var viewPos = pvMatrixInv * clip ;
    return viewPos.xyz / viewPos.w ;
  }

  fn getWorldPosition(z:f32,uv:vec2f) -> vec3f {
    let viewToWorld = globalUniform.viewToWorld ;
    let clip = vec4<f32>((uv * 2.0 - 1.0) , z , 1.0);
    var worldPos = viewToWorld * clip ;
    worldPos = worldPos / worldPos.w ;
    return worldPos.xyz ;
  }

  var<private> NORMALMATRIX_INV : mat3x3<f32> ;
  var<private> NORMALMATRIX : mat3x3<f32> ;
  fn useNormalMatrix()  {
     let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
     let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
     NORMALMATRIX = transpose(inverse( nMat ));
  }

  fn useNormalMatrixInv()  {
    let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
    let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
    NORMALMATRIX_INV = transpose(( nMat ));
  }

  fn getWorldNormal(viewNormal:vec3f) -> vec3f {
    var worldNormal = NORMALMATRIX_INV * viewNormal ;
    return normalize(worldNormal.xyz);
  }

  fn getViewNormal(worldNormal:vec3f) -> vec3f {
    var viewNormal = globalUniform.viewMat * vec4f(worldNormal,0.0) ;
    return normalize(viewNormal.xyz);
  }
`,Bh=`
    #if USE_INSTANCEDRAW
        struct InstanceUniform {
            matrixIDs : array<i32>
        };
        @group(2) @binding(7)
        var<storage, read> instanceDrawID : InstanceUniform;
    #endif
`,xn=`
    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;
`,Dh=`
  fn pow2(  x : f32 ) -> f32
  {
      return x * x;
  }

  fn pow2v3(  x : vec3f ) -> vec3f
  {
      return x * x;
  }


  fn pow3(  x : f32 ) -> f32
  {
      var xx = x*x;
      return x * xx;
  }

  fn pow4(  x : f32 ) -> f32
  {
      var xx = x*x;
      return xx * xx;
  }

  fn pow5(x: f32) -> f32 {
      var x2 = x * x;
      return x2 * x2 * x;
  }

  fn rcp( x:f32 ) -> f32
  {
      return 1.0 / x;
  }

  fn rsqrt3( a : vec3<f32> ) -> vec3<f32>
  {
    return pow(a, vec3<f32>(-0.5));
  }

  fn rsqrt( a : f32 ) -> f32
  {
    return pow(a, -0.5);
  }

  fn squareF( a : f32 ) -> f32
  {
    return a * a;
  }

  fn squareV2( a : vec2f ) -> vec2f
  {
    return a * a;
  }

  fn squareV3( a : vec3f ) -> vec3f
  {
    return a * a;
  }

  fn sqrtFast(  x : f32  ) -> f32 
  {
    var i = i32(x);
    i = 0x1FBD1DF5 + (i / 2 );
    return f32(i);
  }

  fn lengthFast(  v :vec3<f32> ) -> f32
  {
    var LengthSqr = dot(v,v);
    return sqrtFast( LengthSqr );
  }

  fn asinFast( x:f32 )-> f32
  {
      return (0.5 * PI) - acosFast(x);
  }

  fn acosFast( inX: f32 ) -> f32
  {
      var x = abs(inX);
      var res = -0.156583 * x + (0.5 * PI);
      res *= sqrt(1.0 - x);

    if(inX >= 0.0){
      return res ;
    }else{
      return PI - res ;
    }
  }

  fn acosFast4( inX : f32 )-> f32
  {
    var x1 = abs(inX);
    var x2 = x1 * x1;
    var x3 = x2 * x1;
    var s = 0.0 ;

    s = -0.2121144 * x1 + 1.5707288;
    s = 0.0742610 * x2 + s;
    s = -0.0187293 * x3 + s;
    s = sqrt(1.0 - x1) * s;

    // acos function mirroring
    // check per platform if compiles to a selector - no branch neeeded
    if(inX >= 0.0){
      return s ;
    }else{
      return PI - s ;
    }
  }
`,Mh=`

    fn perturbNormal(  worldPos:vec3<f32>,  surf_norm:vec3<f32>,  mapN:vec3<f32> , normalScale:f32 , face:f32 ) -> vec3<f32> {
        var q0 = vec3<f32>( dpdx( worldPos.x ), dpdx( worldPos.y ), dpdx( worldPos.z ) );
        var q1 = vec3<f32>( dpdy( worldPos.x ), dpdy( worldPos.y ), dpdy( worldPos.z ) );
        var st0 = dpdx( ORI_VertexVarying.fragUV0.xy );
        var st1 = dpdy( ORI_VertexVarying.fragUV0.xy );
        var N = surf_norm;
        var q0perp = cross( N, q0 );
        var q1perp = cross( q1, N );

        // #if USE_TANGENT
        //     var T = ORI_VertexVarying.TANGENT.xyz ;
        // #else
            var T = q1perp * st0.x + q0perp * st1.x;
        // #endif
        
        var B = q1perp * st0.y + q0perp * st1.y;

        var det = max( dot( T, T ), dot( B, B ) );
        var scale = 1.0 ;
        if( det != 0.0 ){
            scale = inverseSqrt( det ) ;
        }

        // #if USE_TANGENT
        //     scale = scale * ORI_VertexVarying.TANGENT.w ;
        // #endif

        scale *= normalScale;
        return normalize( (T * ( -mapN.x * scale ) + B * ( mapN.y * scale ) + N * mapN.z ) * face ) ;
    }

    fn unpackNormalMap( normal : vec3<f32> ) -> vec3<f32>
    {
        var normalTex = vec3<f32>( normal.xyz * 2.0 - 1.0 ) ;
        return (normalTex);
    }

    fn unPackNormal(normal : vec3<f32> , height:f32 ) -> vec3<f32>{
        var face = 1.0 ;
        if(ORI_VertexVarying.face){
            face = 1.0 ;
        }else{
            face = -1.0 ;
        }

        #if USE_RGNORMAL
            return unPackRGNormal(normal,height,face);
        #else
            var n = normal ;
            #if USE_NORMALFILPY
            n.y = 1.0 - n.y ; 
            #endif
            
            var mapNormal: vec3<f32> = n ;//unpackNormalMap(n) ;
            return perturbNormal(ORI_VertexVarying.vWorldPos.xyz , ORI_VertexVarying.vWorldNormal.xyz , mapNormal , height , face  ) ;
        #endif
    }

    fn unPackRGNormal(normal : vec3<f32> , height:f32 , face:f32) -> vec3<f32> {
        var d = normal.rg * 2.0 - 1.0 ;
        var l = 1.0 - saturate(dot(d,d));
        var s = sqrt(l);
        var rg = d * height ; 
        var mapNormal = vec3<f32>(rg,s);
        var outN = perturbNormal(ORI_VertexVarying.vWorldPos.xyz,ORI_VertexVarying.vWorldNormal,mapNormal,1.0,face) ;
        return outN ;
    }
`,Ph=`
    struct FragmentVarying {
        @location(auto) index: f32,
        @location(auto) fragUV0: vec2<f32>,
        @location(auto) fragUV1: vec2<f32>,
        @location(auto) viewPosition: vec4<f32>,
        @location(auto) fragPosition: vec4<f32>,
        @location(auto) vWorldPos: vec4<f32>,
        @location(auto) vWorldNormal: vec3<f32>,
        @location(auto) vColor: vec4<f32>,

        #if USE_SHADOWMAPING
            @location(auto) vShadowPos: vec4<f32>,
        #endif

        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif
        
        @builtin(front_facing) face: bool,
        @builtin(position) fragCoord : vec4<f32>
    };
`,Cn=`
    #if USE_CASTREFLECTION
        struct FragmentOutput {
            @location(auto) gBuffer: vec4<f32>,
            #if USE_OUTDEPTH
                @builtin(frag_depth) out_depth: f32
            #endif
        };
    #else
        struct FragmentOutput {
            @location(auto) color: vec4<f32>,
            @location(auto) gBuffer: vec4<f32>,
            #if USE_OUTDEPTH
                @builtin(frag_depth) out_depth: f32
            #endif
        };
    #endif
`,Rh=`
    struct ShadingInput{
        BaseColor:vec4<f32>,

        Roughness:f32,
        Metallic:f32,
        Specular:f32,

        EmissiveColor:vec4<f32>,
        SurfaceColor:vec4<f32>,

        Normal:vec3<f32>,
        HairNormal:vec3<f32>,
        Tangent:vec4<f32>,

        WorldPositionOffset:vec3<f32>,
        AmbientOcclusion:f32,

        PixelDepthOffset:f32,

        Opacity:f32,
        OpacityMask:f32,

        Refraction:f32,
        FragDepth:f32,

        SSS:vec3f,

        // color:vec4f ,
        // normal:vec3f,
        // alpha:f32,
        // roughness:f32,
        // metallic:f32,
        // occlusion:f32,
        // specularColor:vec4f ,
        // specularIntensity:vec4f ,
        // emissiveColor:vec4f,
        // emissiveIntensity:f32,
        // shadow:f32,
        // ior:f32,
        // alphaClip:f32,

        // position:vec4f,
        // depth:f32
    }
`,Uh=`
    #if USE_IES_PROFILE 
        @group(1) @binding(auto)
        var iesTextureArrayMapSampler : sampler;
        @group(1) @binding(auto)
        var iesTextureArrayMap: texture_2d_array<f32> ;
    #endif

    fn getLightIESProfileAtt( wPos : vec3<f32> , light:LightData ) -> f32
    {
        #if USE_IES_PROFILE 
            let tangent = vec3<f32>(1.0,0.0,0.0);
            let lightBitangent = normalize( cross( tangent, light.direction ) );
            let lightMatrix = mat4x4( vec4<f32>(light.direction.xyz, 0.0), vec4<f32>(lightBitangent.xyz, 0.0), vec4<f32>(tangent.xyz, 0.0), vec4<f32>(0.0, 0.0, 0.0, 1.0) );
            let lightMatrixInv = transpose(lightMatrix);
            let lightPos = light.position.xyz;
            let l = lightPos - wPos; 
            let toLight = normalize(l);
            let localToLight = (vec4<f32>(toLight.xyz, 0.0) * lightMatrixInv).xyz;
            let dotProd = dot(toLight, light.direction);
            let angle = asin(dotProd);
            let normAngle = (angle / PI) + 0.5 ;
            let tangentAngle = atan2( -localToLight.z, -localToLight.x ); 
            let normTangentAngle = tangentAngle / (PI * 2.0) + 0.5 ;
            if(light.ies >= 0.0){
                return textureSampleLevel(iesTextureArrayMap, iesTextureArrayMapSampler, vec2<f32>(normAngle , normTangentAngle) , i32(light.ies) , 0.0).r ;
            }else{
                return 1.0;
            }
        #else 
            return 1.0;
        #endif
    }

`,Lh=`
    @group(1) @binding(auto) var shadowMapSampler: sampler;
    @group(1) @binding(auto) var shadowMap: texture_depth_2d_array;
    @group(1) @binding(auto) var pointShadowMapSampler: sampler;
    @group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array;

    var<private> directShadowVisibility: array<f32, 8>;
    var<private> pointShadows: array<f32, 8>;
    var<private> shadowWeight: f32 = 1.0 ;

    fn useShadow(){
        directShadowVisibility = array<f32, 8>( 1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        pointShadows = array<f32, 8>(1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0) ;
        directShadowMaping(globalUniform.shadowBias);
        pointShadowMapCompare(globalUniform.pointShadowBias);
    }

    fn calcBasicBias(shadowWorldSize:f32, shadowDepthTexSize:f32, near:f32, far:f32) -> f32{
      var bias = shadowWorldSize / shadowDepthTexSize;
      bias = bias / (far - near);
      return bias * 2.0;
    }

    const dirCount:i32 = 8 ;
    const pointCount:i32 = 8 ;
    const csmCount:i32 = ${nr.Cascades} ;
    var<private> csmLevel:i32 = -1;
    fn directShadowMaping(shadowBias: f32)  {

        let enableCSM:bool = globalUniform.enableCSM > 0.5;
        for (var i: i32 = 0; i < dirCount ; i = i + 1) {
          if( i >= globalUniform.nDirShadowStart && i < globalUniform.nDirShadowEnd ){
            let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
            let light = lightBuffer[u32(ldx)] ;
            var shadowIndex = i32(light.castShadow);
            var visibility = 1.0;
            var shadowMatrix:mat4x4<f32>;
            #if USE_CSM
              if(enableCSM && shadowIndex == 0){
                var totalWeight = 0.0;
                visibility = 0.0;
                var validCount = 0;
                for(var csm:i32 = 0; csm < csmCount; csm ++){
                  var csmShadowBias = globalUniform.csmShadowBias[csm] * shadowBias;
                  shadowMatrix = globalUniform.csmMatrix[csm];
                  let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, csm, csmShadowBias);
                  if(csmShadowResult.y < 0.5){
                    validCount ++;

                    var uv = 2.0 * csmShadowResult.zw - vec2<f32>(1.0);
                    uv = saturate(vec2<f32>(1.0) - abs(uv));
                    uv /= clamp(globalUniform.csmMargin, 0.01, 0.5);
                    var weight:f32 = min(uv.x, 1.0);
                    weight = min(weight, uv.y);

                    if(validCount == 1 && csm == csmCount - 1){
                      visibility = 1.0 - weight + csmShadowResult.x * weight;
                      totalWeight = 1.0;
                    }else{
                      weight *= 1.0 - totalWeight;
                      visibility += csmShadowResult.x * weight;
                      totalWeight += weight;
                    }
                    // if(weight < 1.0){
                    //   visibility += 0.1;
                    // }
                    if(validCount >= 2 || totalWeight >= 0.99){
                      csmLevel = csm;
                      break;
                    }
                  }
                }
                totalWeight += 0.0001;
                if(validCount == 0){
                  visibility = 1.0;
                }else{
                  visibility = visibility / totalWeight ;
                }
              }else{
                shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
                if(enableCSM) {
                  shadowIndex += csmCount - 1;
                }
                visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
              }
            #else
              shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
              visibility = directShadowMapingIndex(light, shadowMatrix, shadowIndex, shadowBias).x;
            #endif 
            directShadowVisibility[i] = visibility;
          }
        }

    }

    fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, depthTexIndex:i32, shadowBias:f32) -> vec4<f32>
    {
      var visibility = 1.0;
      var isOutSideArea:f32 = 1.0;
      var varying_shadowUV:vec2<f32> = vec2<f32>(0.0);
      #if USE_SHADOWMAPING
        var shadowPosTmp = matrix * vec4<f32>(ORI_VertexVarying.vWorldPos.xyz, 1.0);
        var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
        varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
        if (varying_shadowUV.x <= 1.0
          && varying_shadowUV.x >= 0.0
          && varying_shadowUV.y <= 1.0
          && varying_shadowUV.y >= 0.0
          && shadowPosTmp.z <= 1.0
          && shadowPosTmp.z >= 0.0)
        {
          visibility = 0.0;
          isOutSideArea = 0.0;
          var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize) ;
          var totalWeight = 0.0;
          // var NoL = (dot(normalize(ORI_VertexVarying.vWorldNormal), normalize(-light.direction)));
          // let v = max(NoL, 0.0) ;
          // var bias = max(0.05 * (dot(normalize(fragData.N), normalize(-light.direction)) ), -shadowBias); 
          var bias = -0.005 * max(dot(fragData.N, -light.direction) , 0.0 ); 
          bias = clamp(bias, 0, 0.01) + -shadowBias;

          // var bias = shadowBias / v;
          let bound = 1 ;
          for (var y = -bound; y <= bound; y++) {
            for (var x = -bound; x <= bound; x++) {
                var offset = vec2<f32>(f32(x), f32(y)) ;
                var offsetUV = offset * uvOnePixel ;
                var weight = min(length(offset),1.0) ;
                var depth = textureSampleLevel(shadowMap, shadowMapSampler, varying_shadowUV + offsetUV , depthTexIndex, 0);
                if ((shadowPos.z - bias ) < depth) {
                  visibility += weight ;
                  totalWeight += weight;
                }else{
                  totalWeight += 1.0;
                }
            }
          }
          visibility /= totalWeight;
      }
      #endif
      return vec4<f32>(visibility, isOutSideArea, varying_shadowUV);
    }

    fn pointShadowMapCompare(shadowBias: f32){
      let worldPos = ORI_VertexVarying.vWorldPos.xyz;
      let offset = 0.1;

      for (var i: i32 = 0; i < pointCount ; i = i + 1) {
        if( i >= globalUniform.nPointShadowStart && i < globalUniform.nPointShadowEnd ){
          let ldx = globalUniform.shadowLights[u32(i) / 4u][u32(i) % 4u];
          let light = lightBuffer[u32(ldx)] ;

          #if USE_SHADOWMAPING
              let lightPos = light.position.xyz;
              var shadow = 0.0;
              let frgToLight = worldPos - lightPos.xyz;
              var dir: vec3<f32> = normalize(frgToLight);
              var len = length(frgToLight);
              var bias = max(shadowBias * globalUniform.far * (1.0 - dot(ORI_ShadingInput.Normal, dir)), 0.005);
  
          #if USE_PCF_SHADOW
              let samples = 4.0;
              let sampleOffset = offset / (samples * 0.5);
              for (var x: f32 = -offset; x < offset; x += sampleOffset) {
                for (var y: f32 = -offset; y < offset; y += sampleOffset) {
                  for (var z: f32 = -offset; z < offset; z += sampleOffset) {
                    let offsetDir = normalize(dir.xyz + vec3<f32>(x, y, z));
                    var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                    depth *= globalUniform.far;
                    if ((len - bias) > depth) {
                      shadow += 1.0 * dot(offsetDir, dir.xyz);
                    }
                  }
                }
              }
              shadow = min(max(shadow / (samples * samples * samples), 0.0), 1.0);
            #endif
  
          #if USE_SOFT_SHADOW
              let vDis = length(globalUniform.CameraPos.xyz - worldPos.xyz);
              let sampleRadies = globalUniform.shadowSoft;
              let samples = 20;
              for (var j: i32 = 0; j < samples; j += 1) {
                let offsetDir = normalize(dir.xyz + sampleOffsetDir[j] * sampleRadies);
                var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, offsetDir, light.castShadow, 0);
                depth *= globalUniform.far;
                if ((len - bias) > depth) {
                  shadow += 1.0 * dot(offsetDir, dir.xyz);
                }
              }
              shadow = min(max(shadow / f32(samples), 0.0), 1.0);
          #endif
  
          #if USE_HARD_SHADOW
              var depth = textureSampleLevel(pointShadowMap, pointShadowMapSampler, dir.xyz, light.castShadow, 0);
              depth *= globalUniform.far;
              if ((len - bias) > depth) {
                shadow = 1.0;
              }
          #endif
              for (var j = 0; j < pointCount ; j+=1 ) {
                  if(i32(light.castShadow) == j){
                    pointShadows[j] = 1.0 - shadow ;
                  }
              }
          #endif
        }
        }
    }

    #if USE_SOFT_SHADOW
      var<private>sampleOffsetDir : array<vec3<f32>, 20> = array<vec3<f32>, 20>(
        vec3<f32>(1.0, 1.0, 1.0), vec3<f32>(1.0, -1.0, 1.0), vec3<f32>(-1.0, -1.0, 1.0), vec3<f32>(-1.0, 1.0, 1.0),
        vec3<f32>(1.0, 1.0, -1.0), vec3<f32>(1.0, -1.0, -1.0), vec3<f32>(-1.0, -1.0, -1.0), vec3<f32>(-1.0, 1.0, -1.0),
        vec3<f32>(1.0, 1.0, 0.0), vec3<f32>(1.0, -1.0, 0.0), vec3<f32>(-1.0, -1.0, 0.0), vec3<f32>(-1.0, 1.0, 0.0),
        vec3<f32>(1.0, 0.0, 1.0), vec3<f32>(-1.0, 0.0, 1.0), vec3<f32>(1.0, 0.0, -1.0), vec3<f32>(-1.0, 0.0, -1.0),
        vec3<f32>(0.0, 1.0, 1.0), vec3<f32>(0.0, -1.0, 1.0), vec3<f32>(0.0, -1.0, -1.0), vec3<f32>(0.0, 1.0, -1.0),
      );
    #endif
`,Oh=`
#include "IrradianceVolumeData_frag"
    struct IrradianceField {
        probeStartPosition: vec4<f32>,
        probeCounts:vec4<f32>,
        probeStep:f32,
        irradianceTextureWidth:f32,
        irradianceTextureHeight:f32,
        irradianceProbeSideLength:f32,
    };

    @group(1) @binding(auto)
    var irradianceMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var irradianceDepthMapSampler: sampler;
    @group(1) @binding(auto)
    var irradianceDepthMap: texture_2d<f32>;
    @group(2) @binding(7)
    var<uniform> irradianceData : IrradianceVolumeData ;

    var<private> irradianceFieldSurface: IrradianceField;
    var<private> energyPreservation: f32 = 0.85;
    var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

    fn getIrradianceFieldSurface() -> IrradianceField{
        let data = irradianceData ;
        irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
        irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
        irradianceFieldSurface.probeStep = data.ProbeSpace;
        irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
        irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
        return irradianceFieldSurface;
    }

    fn rotateDir(n:vec3<f32>) -> vec3<f32>{
       return normalize(applyQuaternion(-n, quaternion));
    }

    fn square1f(v:f32) -> f32 {
        return v * v ;
     }

   fn square(v:vec3<f32>) -> vec3<f32>{
      return v*v;
   }

    fn getIrradiance() -> vec4<f32>{
        var irradiance = sampleIrradianceField();
        var outerVolumeFactor:f32 = getOuterVolume(irradianceFieldSurface, ORI_VertexVarying.vWorldPos.xyz);
        irradiance *= outerVolumeFactor;
       return irradiance ;
    }
    
    fn debugProbe(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0);
        return probeIrradiance;
    }
    
    fn debugProbeDepth(id:i32) -> vec4<f32>{
        getIrradianceFieldSurface();
        var direction = normalize(ORI_VertexVarying.vWorldNormal);
        direction = applyQuaternion(-direction, quaternion);
        var probeTextureUV : vec2<f32> = textureCoordFromDirection(normalize(direction),
            id,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);
        
        var probeIrradiance: vec4<f32> = textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV ,0.0);
        probeIrradiance.x = probeIrradiance.x / irradianceData.maxDistance;
        probeIrradiance.y = 0.0;
        probeIrradiance.z = 0.0;
        probeIrradiance.w = 1.0;
        return probeIrradiance;
    }
    
    fn getOuterVolume(L:IrradianceField, position:vec3<f32>) -> f32{
        let halfWidth:vec3<f32> = 0.5 * (L.probeCounts.xyz - 1.0) * L.probeStep;
        let edgeWidth:vec3<f32> = halfWidth + L.probeStep;
        let centerPosition:vec3<f32> = halfWidth + L.probeStartPosition.xyz;
        let clampPos = min(edgeWidth, abs(position - centerPosition));
        
        let factorX = getOuterAxis(clampPos.x, edgeWidth.x, L.probeStep);
        let factorY = getOuterAxis(clampPos.y, edgeWidth.y, L.probeStep);
        let factorZ = getOuterAxis(clampPos.z, edgeWidth.z, L.probeStep);
        return factorX * factorY * factorZ;
    }
    
    fn getOuterAxis(current:f32, edge:f32, space:f32) -> f32{
        return clamp((edge - current) / space, 0.0, 1.0);
    }

    fn getBaseGridCoord(L:IrradianceField, X:vec3<f32>) -> vec3<i32> {
        var offsetIndex = (X - L.probeStartPosition.xyz) / irradianceFieldSurface.probeStep;
        return clamp(vec3<i32>(offsetIndex.xyz), vec3<i32>(0), vec3<i32>(L.probeCounts.xyz) - 1);
    }

    fn gridCoordToProbeIndex(L:IrradianceField, grid:vec3<i32>) -> i32
    {
        return grid.x + i32(L.probeCounts.x) * grid.z + grid.y * i32(L.probeCounts.z * L.probeCounts.x);
    }

    fn gridCoordToPosition(L:IrradianceField, grid:vec3<i32>) -> vec3<f32>
    {
        var pos:vec3<f32> = vec3<f32>(grid.xyz) * L.probeStep + L.probeStartPosition.xyz;
        return pos;
    }

    fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
    {
        var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
        uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
        uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
        return uv ;
    }

    fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
    {
        var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
        var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
        var offsetZ = probeID / blockCount ;

        var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

        var blockOffset = vec2<f32>(0.0);
        blockOffset.x = f32(offsetX) * size;
        blockOffset.y = f32(offsetY) * size + f32(offsetZ) * irradianceFieldSurface.probeCounts.z * size;

        let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
        var probeCounts:vec3<f32> = irradianceFieldSurface.probeCounts.xyz;

        var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
        var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

        pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

        return pixelCoord + 1.0 ;
    }

    fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
    {
      var pixelCoord = pixelCoord0;
      let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
      let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
      let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
      let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
      let col:i32 = pixelCoord.y / pixelCountYMax;
      pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
      pixelCoord.y = pixelCoord.y % pixelCountYMax;
      return pixelCoord;
    }

    var<private> wpNormal:vec3<f32> ;
    fn sampleIrradianceField() -> vec4<f32>{
        wpNormal = ORI_ShadingInput.Normal.xyz ;
        var wo:vec3<f32> = ORI_CameraWorldDir ;
        var wsN:vec3<f32> = normalize(wpNormal);
        var direction:vec3<f32> = wpNormal;
        var worldPosition: vec3<f32> = ORI_VertexVarying.vWorldPos.xyz;
   
        getIrradianceFieldSurface();

        let surfaceBias = (wsN + 3.0 * wo) * irradianceData.normalBias ;

        var irradiance = vec3<f32>(0.0, 0.0, 0.0);
        var accumulatedWeights = 0.0;
        var biasedWorldPosition = (worldPosition + surfaceBias);

        var baseProbeCoords: vec3<i32> = getBaseGridCoord(irradianceFieldSurface, worldPosition);
        
        var baseProbeWorldPosition: vec3<f32> = gridCoordToPosition(irradianceFieldSurface, baseProbeCoords) ;
        
        var gridSpaceDistance = (biasedWorldPosition - baseProbeWorldPosition);

        // alpha is how far from the floor(currentVertex) position. on [0, 1] for each axis.
        var alpha: vec3<f32> = clamp(gridSpaceDistance / (irradianceFieldSurface.probeStep), vec3<f32>(0.0), vec3<f32>(1.0));
        // let irradianceDir = rotateDir(wsN.xyz);
        // Iterate over adjacent probe cage
        for (var i:i32 = 0; i < 8; i = i + 1) {
            var adjacentProbeOffset : vec3<i32> = vec3<i32>(i, i32(f32(i) * 0.5), i32(f32(i) * 0.25)) & vec3<i32>(1);
            var adjacentProbeCoords: vec3<i32> = clamp(baseProbeCoords + adjacentProbeOffset, vec3<i32>(0),  vec3<i32>(irradianceFieldSurface.probeCounts.xyz) - 1) ;
            
            var adjacentProbeIndex :i32 = gridCoordToProbeIndex(irradianceFieldSurface, adjacentProbeCoords);
            var adjacentProbeWorldPosition :vec3<f32> = gridCoordToPosition(irradianceFieldSurface, adjacentProbeCoords) ;//+ (wsN + 3.0 * w_o) * globalUniform.normalBias;
         
            var worldPosToAdjProbe = normalize(adjacentProbeWorldPosition - worldPosition);
            var biasedPosToAdjProbe = normalize(adjacentProbeWorldPosition - biasedWorldPosition);
            var biasedPosToAdjProbeDist = length(adjacentProbeWorldPosition - biasedWorldPosition);

            let trilinear = max(vec3<f32>(0.001), mix(1.0 - alpha, alpha, vec3<f32>(adjacentProbeOffset)));
            let trilinearWeight = (trilinear.x * trilinear.y * trilinear.z);
            var weight = 1.0;

            var wrapShading = (dot(worldPosToAdjProbe, direction) + 1.0) * 0.5;
            weight *= (wrapShading * wrapShading) + 0.2;

            var depthDir = -biasedPosToAdjProbe;//probe - world
            depthDir = applyQuaternion(depthDir, quaternion);
            var probeTextureUV : vec2<f32> = textureCoordFromDirection(depthDir.xyz,
                adjacentProbeIndex,
                irradianceFieldSurface.irradianceTextureWidth,
                irradianceFieldSurface.irradianceTextureHeight,
                irradianceFieldSurface.irradianceProbeSideLength);

            var filteredDistance : vec2<f32> = 2.0 * textureSampleLevel(irradianceDepthMap, irradianceDepthMapSampler, probeTextureUV,0.0).rg ;
           
            var variance = abs((filteredDistance.x * filteredDistance.x) - filteredDistance.y);

            var chebyshevWeight = 1.0;
            if(biasedPosToAdjProbeDist > filteredDistance.x ) // occluded
            {
                var v = biasedPosToAdjProbeDist - filteredDistance.x ;
                chebyshevWeight = variance / (variance + (v * v));
                // Increase the contrast in the weight
                chebyshevWeight = max((chebyshevWeight * chebyshevWeight * chebyshevWeight), 0.0);
            }

            weight *= max(0.05, chebyshevWeight);
            weight = max(0.000001, weight);

            let crushThreshold = 0.2;
            if (weight < crushThreshold)
            {
                weight *= (weight * weight) * (1.0 / (crushThreshold * crushThreshold));
            }

            weight *= trilinearWeight;
            
            //worldPosToAdjProbe
            let rotateDir = applyQuaternion(-direction, quaternion);
            probeTextureUV = textureCoordFromDirection((rotateDir),
            adjacentProbeIndex,
            irradianceFieldSurface.irradianceTextureWidth,
            irradianceFieldSurface.irradianceTextureHeight,
            irradianceFieldSurface.irradianceProbeSideLength);

            var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, probeTextureUV ,0.0).xyz;

            var exponent =  irradianceData.ddgiGamma * 0.5;
            probeIrradiance = pow(probeIrradiance, vec3<f32>(exponent));
            
            irradiance += (weight * probeIrradiance);
            accumulatedWeights += weight;
        }

        if(accumulatedWeights == 0.0){
            return vec4<f32>(0.0, 0.0, 0.0,1.0);
        }

        irradiance *= (1.0 / accumulatedWeights);   
        irradiance *= irradiance;                   

        irradiance *= 6.2831853071795864;
        irradiance *= irradianceData.indirectIntensity;
        return vec4<f32>(irradiance,1.0) ;
    }

`,Nh=`
#include "Clearcoat_frag"
    #include "EnvMap_frag"
    #include "BrdfLut_frag"
    #include "ColorUtil_frag"
    #include "SHCommon_frag"
    
    struct FragData {
        Ao: f32,
        Metallic: f32,
        Roughness: f32,

        Albedo: vec4<f32>,
        Emissive: vec3<f32>,
        Specular: vec3<f32>,

        N: vec3<f32>,
        V: vec3<f32>,
        R: vec3<f32>,
        T: vec3<f32>,

        F0: vec3<f32>,
        F: vec3<f32>,
        KS: vec3<f32>,
        KD: vec3<f32>,

        Alpha: f32,
        Shadow: f32,
        Indirect: f32,
        Reflectance: f32,

        NoV: f32,
        FaceDirection:f32,

        ClearcoatRoughness:f32,
        ClearcoatFactor:f32,
        ClearcoatIor:f32,
        EnvColor: vec3<f32>,
        Irradiance: vec3<f32>,

        LightChannel: vec3<f32>
    };

    var<private> fragData: FragData;

    struct BxDFContext
    {
        NoV : f32 ,
        NoL : f32 ,
        VoL : f32 ,
        NoH : f32 ,
        HoL : f32 ,
        VoH : f32
    };

    fn getContext( N:vec3<f32>, V:vec3<f32>, H:vec3<f32>, L:vec3<f32> ) -> BxDFContext
    {
        var Context:BxDFContext ;
        Context.NoL = saturate(dot(N, L));
        Context.NoV = saturate(dot(N, V));
        Context.VoL = saturate(dot(V, L));
        Context.NoH = saturate(dot(N, H));
        Context.VoH = saturate(dot(V, H));
        Context.HoL = saturate(dot(H, L));
        return Context ;
    }

    // convert roughness to mipmapLevel
    fn roughnessToMipmapLevel( roughness: f32 , mipmapCount:i32 ) -> f32{
        let level = roughness * (1.7 - 0.7 * roughness );
        return level * f32(mipmapCount);
    }

    fn IORToF0(ior:f32)->f32{
        var dc = ior - 1.0 ;
        dc *= dc ;
        var dt = ior + 1.0 ;
        dt *= dt ;
        return dc / dt ;
    }

    fn Fd90( NoL:f32, roughness:f32) -> f32
    {
        return (2.0 * NoL * roughness) + 0.4;
    }

  

    fn KDisneyTerm( NoL:f32, NoV:f32 , roughness:f32) -> f32
    {
        return (1.0 + Fd90(NoL, roughness) * pow(1.0 - NoL, 5.0)) * (1.0 + Fd90(NoV, roughness) * pow(1.0 - NoV, 5.0));
    }

    fn FresnelSchlick( NoV:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);
    }

    fn FresnelTerm( cosA:f32,  F0:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return F0 + (1.0 - F0) * t;
    }

    fn FresnelLerp( cosA:f32, F0:vec3<f32> , F90:vec3<f32>) -> vec3<f32>
    {
        let t = pow5( 1.0 - cosA );
        return mix( F0 ,F90,t ) ;
    }

    fn FresnelSchlickRoughness( NoV:f32,  F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(roughness), F0) - F0) * pow(1.0 - NoV, 5.0);
    }

    fn DistributionGGX( NdotH:f32 ,  roughness:f32 ) -> f32
    {
        let alpha = roughness * roughness;
        let alpha2 = roughness * roughness;

        let NdotH2 = NdotH * NdotH;

        let nom   = alpha2;
        var denom = (NdotH2 * (alpha2 - 1.0) + 1.0);
        denom = PI * denom * denom;

        return nom / denom;
    }

    // [Heitz 2014, "Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs"]
    fn Vis_SmithJoint( NoV : f32 ,  NoL : f32 ,  a2 : f32) -> f32
    {
        var Vis_SmithV = NoL * sqrt(NoV * (NoV - NoV * a2) + a2);
        var Vis_SmithL = NoV * sqrt(NoL * (NoL - NoL * a2) + a2);
        return 0.5 * rcp(Vis_SmithV + Vis_SmithL);
    }

    fn Vis_SmithJointApprox( NoV : f32 ,  NoL : f32 ,  a2 : f32 ) -> f32
    {
        let a = sqrt(a2);
        let Vis_SmithV = NoL * ( NoV * ( 1.0 - a ) + a );
        let Vis_SmithL = NoV * ( NoL * ( 1.0 - a ) + a );
        return 0.5 * rcp( Vis_SmithV + Vis_SmithL );
    }

    fn GeometrySchlickGGX( NdotV : f32 , roughness : f32 ) -> f32
    {
        //roughness compute ks
        let r = (roughness + 1.0);
        let k = (r*r) / 8.0;

        let nom   = NdotV;
        let denom = NdotV * (1.0 - k) + k;
        
        return nom / denom;
    }
    
    fn GeometrySmith( NdotV:f32 , NdotL:f32 , roughness : f32) -> f32
    {
        // let NdotV = max(dot(N, V), 0.0);
        // let NdotL = max(dot(N, L), 0.0);
        let ggx1 = GeometrySchlickGGX(NdotV, roughness);
        let ggx2 = GeometrySchlickGGX(NdotL, roughness);
        return ggx1 * ggx2;
    }

    fn GeometryAttenuationGGXSmith( NdotL:f32,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn colorLinear( colorVector:vec3<f32> ) -> vec3<f32>
    {
        var linearColor = pow(colorVector.rgb, vec3<f32>(2.2));
        return linearColor;
    }

    fn computeFresnelSchlick( NoV:f32 , F0:vec3<f32>) -> vec3<f32>
    {
        return F0 + (1.0 - F0) * pow(clamp(1.0 - NoV,0.0,1.0), 5.0);
    }

    fn computeFresnelSchlickRoughness(NoV:f32 , F0:vec3<f32>,  roughness:f32) -> vec3<f32>
    {
        return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(clamp(1.0 - fragData.NoV,0.0,1.0), 5.0);
    }

    fn computeDistributionGGX( N:vec3<f32>,  H:vec3<f32>,  roughness:f32) -> f32
    {
        var alpha = roughness * roughness;
        var alpha2 = alpha * alpha; 

        var NdotH = saturate(dot(N, H));
        var NdotH2 = NdotH * NdotH;

        return (alpha2) / (PI * (NdotH2 * (alpha2 - 1.0) + 1.0) * (NdotH2 * (alpha2 - 1.0) + 1.0));
    }

    fn D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        var d = ( NoH * roughness - NoH ) * NoH + 1.0;	// 2 mad
        return roughness / ( PI*d*d );					// 4 mul, 1 rcp
    }

    fn computeGeometryAttenuationGGXSmith( NdotL:f32 ,  NdotV:f32,  roughness:f32) -> f32
    {
        var NdotL2 = NdotL * NdotL;
        var NdotV2 = NdotV * NdotV;
        var kRough2 = roughness * roughness + 0.0001;

        var ggxL = (2.0 * NdotL) / (NdotL + sqrt(NdotL2 + kRough2 * (1.0 - NdotL2)));
        var ggxV = (2.0 * NdotV) / (NdotV + sqrt(NdotV2 + kRough2 * (1.0 - NdotV2)));

        return ggxL * ggxV;
    }

    fn Vis_Smith(  NoL:f32 ,  NoV:f32,  a2:f32 )-> f32
    {
        var Vis_SmithV = NoV + sqrt( NoV * (NoV - NoV * a2) + a2 );
        var Vis_SmithL = NoL + sqrt( NoL * (NoL - NoL * a2) + a2 );
        return rcp( Vis_SmithV * Vis_SmithL );
    }

    fn F_Function( HdotL:f32, F0:vec3f ) -> vec3f
  {
      var fresnel = exp2((-5.55473 * HdotL - 6.98316) * HdotL);
      return mix(vec3f(fresnel),vec3f(1.0),F0);
  }

  fn D_Function( NdotH:f32, roughness:f32) ->f32
  {
      var a      = roughness*roughness;
      var a2     = a*a;
      var NdotH2 = NdotH*NdotH;
      var nom   = a2;
      var denom = (NdotH2 * (a2 - 1.0) + 1.0);
      denom = PI * denom * denom;
      return nom / denom;
  }

  //G\u9879 \u51E0\u4F55\u51FD\u6570
  fn G_SubFunction( NdotW : f32,  K : f32)->f32
  {
      return NdotW / mix(NdotW,1.0,K);
  }

  fn G_Function( NdotL: f32, NdotV: f32, roughness: f32)->f32
  {
      var K = (1.0+roughness) * (1.0+roughness) / 8.0;
      return G_SubFunction(NdotL,K) * G_SubFunction(NdotV,K);
  }
  
  fn DGF_Function( NdotH:f32, NdotL:f32,NdotV:f32, HdotL:f32, roughness:f32, shadow:f32, F0:vec3f , lightColor:vec3f )-> vec3f
  {
      var  D = D_Function(NdotH,roughness);
      var  G = G_Function(NdotL,NdotV,roughness);
      var F = F_Function(HdotL,F0);
      // var light_BRDF = saturate(( D * G * F ) / (4 * NdotL * NdotV + 0.001));
      let light_BRDF = ( D * G * F ) / (4.0 * NdotV * NdotL + 0.001);
      return light_BRDF * lightColor * NdotL * PI * shadow;
  }

  fn LightDiffuse_Function( HdotL:f32, NdotL:f32 ,  baseColor:vec3f,  metallic:f32,  shadow:f32, F0:vec3f, lightColor:vec3f) -> vec3f
  {
      var KS = F_Function(HdotL,F0);
      var KD = (1 - KS) * (1 - metallic);
      return KD * baseColor * lightColor.rgb * NdotL * shadow; 
  }

  fn lightContribution( NdotH:f32, NdotL:f32, NdotV:f32, HdotL:f32, roughness:f32, baseColor:vec3f, metallic:f32, shadow:f32, F0:vec3f, lightColor:vec3f ) ->vec3f
  {
      return LightDiffuse_Function(HdotL,NdotL,baseColor,metallic,shadow,F0,lightColor) + DGF_Function(NdotH,NdotL,NdotV,HdotL,roughness,shadow,F0,lightColor);
  }

    fn simpleBRDF( albedo:vec3<f32>, N:vec3<f32>, V:vec3<f32>,L:vec3<f32>,att:f32,lightColor:vec3<f32>,roughness:f32 ,metallic:f32)-> vec3<f32>{
        let H = normalize(V + L);
        let Context:BxDFContext = getContext(N,V,H,L);
        let alpha = roughness * roughness;
        let a2 = alpha * alpha;
        let F0 = mix(vec3<f32>(materialUniform.materialF0.rgb), albedo.rgb , metallic);
        let D = D_GGX( Context.NoH , a2);
        let G = Vis_SmithJointApprox(Context.NoV,Context.NoL, a2 );
        let F = FresnelSchlick(Context.VoH, vec3<f32>(F0));
        let specular = ( D * G * F ) / (4.0 * Context.NoV * Context.NoL + 0.001);
        
        // let kS = exp2( (-5.55473 * Context.HoL - 6.98316) * Context.HoL );
        let kS = F ;
        var kd = 1.0 - kS ;
        kd *= 1.0 - metallic ;

        #if USE_SRGB_ALBEDO
            var diffuse = kd ;
        #else 
            var diffuse = kd * (albedo.rgb / PI ) ;
        #endif

        let lightAtt = Context.NoL * lightColor * att ; 
        var diffuseColor = diffuse * lightAtt; 
        // diffuseColor = vec3f(0.0) ; 
        var specularColor = specular * lightAtt; 
        var col = (diffuseColor + specularColor ) ;
        return vec3f(col) ;
    }

    fn getSpecularDominantDir (  N : vec3<f32> , R : vec3<f32> , roughness : f32 ) -> vec3<f32>
    {
        var smoothness = saturate (1.0 - roughness );
        var lerpFactor = smoothness * ( sqrt ( smoothness ) + roughness );
        // The result is not normalized as we fetch in a cubemap
        return mix (N, R, lerpFactor );
    }

    fn approximateSpecularIBL( specularColor:vec3<f32> , roughness:f32 , R:vec3<f32> , NoV:f32 ) -> vec3<f32> {
       
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD) * f32(MAX_REFLECTION_LOD);
        fragData.EnvColor = (textureSampleLevel(prefilterMap, prefilterMapSampler, getSpecularDominantDir(fragData.N,R,roughness) , mip ).rgb);
        fragData.EnvColor = globalUniform.skyExposure * (fragData.EnvColor);
        var envBRDF = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2<f32>(NoV, roughness) , 0.0 ) ;
        return (specularColor.rgb * envBRDF.x + envBRDF.y) ;
    }

    fn fresnel_coat(n:vec3<f32>,v:vec3<f32>,ior:f32) -> f32 {
        var f0 = (1.0-ior)/(1.0+ior);
        f0 = f0 * f0  ;
        let fr = pow((f0 + (1.0 - f0)*(1.0 - abs( max(dot(n,v),0.0) ))) , 5.0 ) ;  
        return fr ;
    }

    fn reflectEnvMap(n:vec3<f32> , v:vec3<f32> , roughness:f32) -> vec3<f32> {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(envMap)) ;
        let mip = roughnessToMipmapLevel(roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var prefilteredColor: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(envMap, envMapSampler, R , mip ).rgb);
        prefilteredColor = LinearToGammaSpace(prefilteredColor);
        return prefilteredColor ;
    }

    fn Specular_D_GGX( NoH:f32,  roughness:f32 ) -> f32
    {
        let a2 = roughness * roughness ;
        let f = (NoH * a2 - NoH) * NoH + 1.0;
        return a2 / (PI * f * f) ;
    }

    fn V_Kelemen( LoH : f32 ) -> f32 {
        return 0.25 / (LoH * LoH);
    }

    fn F_Schlick( f0:vec3<f32> ,  f90 : f32 ,  VoH : f32 ) -> vec3<f32> {
        return f0 + (f90 - f0) * pow(1.0 - VoH,5.0);
    }

    fn F_Schlick2(  SpecularColor:vec3<f32>,  VoH :f32 )-> vec3<f32> {
        var Fc = pow5( 1.0 - VoH );
        let rt = clamp(50.0 * SpecularColor.g,0.0,1.0) ;
        return rt * Fc + (1.0 - Fc) * SpecularColor;
    }

    fn oneMinusReflectivity ( metallic : f32 , F0:f32 ) -> f32 {
        let range = 1.0 - F0;
        return range - metallic * range;
    }

    //https://google.github.io/filament/Filament.html materialsystem/clearcoatmodel/clearcoatparameterization
    fn CoatSpecular_brdf( f:vec3<f32>, s:vec3<f32>, n:vec3<f32> , v:vec3<f32> , l:vec3<f32> , att:f32 , layer :vec3<f32> , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let H = normalize(v + l); 
        let VdotNc = max(dot(v,n),0.0);
        let LdotNc = max(dot(l,n),0.0);
        let NoH = max(dot(n,H),0.0);
        let LoH = saturate(dot(l, H))  ;
        let NoL = max(dot(n,l),0.0);

        let Fd = f ; 
        let Fr = s ; 

        let factor = clamp(clearcoatRoughnessFactor,0.089,1.0);
        let clearCoatRoughness = factor * factor ;

        let Dc = D_GGX( NoH , factor ) ;
        let Vc = V_Kelemen( LoH ) * NoL ;
        let Fc = F_Schlick(vec3<f32>(0.04), 2.0 , LoH); 
        let Frc = (Dc * Vc) * Fc ;
        // return layer * vec3<f32>((Fd + Fr * (1.0 - Fc)) * (1.0 - Fc) + Frc) * ( 0.5 + NoL * 0.5 ) ;
        return vec3<f32>(Frc) ;
    }

    #if USE_CLEARCOAT
    fn approximate_coating(base:vec3<f32> , clearColor: vec3<f32>, n:vec3<f32> , v:vec3<f32> , light:LightData , clearcoatRoughnessFactor:f32 ) -> vec3<f32> {
        let factor = clamp(clearcoatRoughnessFactor,0.084,1.0);
        var clearcoatAlpha = factor * factor + fragData.ClearcoatRoughness;

        // var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
        var att = light.intensity ;
        let l = light.direction ;
   
        let NdotV = max(dot(n,v),0.0);
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // let mip = roughnessToMipmapLevel(clearcoatAlpha,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( v , n ) * n - v ;
        var envIBL: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, R , MAX_REFLECTION_LOD * clearcoatRoughnessFactor ).rgb) ;
        // envIBL = LinearToGammaSpace(envIBL);

        let clearCoat = materialUniform.clearcoatFactor ;
        // let f = FresnelSchlickRoughness( max(dot(n,v),0.0) , vec3<f32>(0.0) , clearcoatAlpha ) ;
        let clearcoat_brdf =  CoatSpecular_brdf( vec3<f32>(0.04) , vec3<f32>( 0.04 ) , n , v , -l , att , vec3<f32>( 0.04 ) , factor ) ;

        // return clearcoat_brdf;+ fragData.ClearcoatRoughness 
        return mix(base, clearcoat_brdf,materialUniform.clearcoatWeight ) ;
    }
    #endif
   

    fn EnvBRDF( SpecularColor : vec3f , Roughness : f32 , NoV : f32) -> vec3f
    {
        // brdflutMap, brdflutMapSampler
        var AB = textureSampleLevel( brdflutMap, brdflutMapSampler, vec2f( NoV, Roughness ), 0.0 ).rg;
        var GF = SpecularColor * AB.x + saturate( 50.0 * SpecularColor.g ) * AB.y;
        return GF;
    }

    fn EnvBRDF_FD90( F0: vec3f , F90: vec3f ,  Roughness: f32,  NoV: f32)-> vec3f
    {
        // Importance sampled preintegrated G * F
        var AB = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2f(NoV, Roughness), 0.0).rg;
        var GF = F0 * AB.x + F90 * AB.y;
        return GF;
    }

    fn IBLEnv( V:vec3f , N:vec3f , Roughness : f32) -> vec3f 
    {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(prefilterMap));
        let mip = roughnessToMipmapLevel(Roughness,MAX_REFLECTION_LOD);
        let R = 2.0 * dot( V , N ) * N - V ;
        var envIBL: vec3<f32> = textureSampleLevel(prefilterMap, prefilterMapSampler, R , mip ).rgb ;
        return envIBL;
    }

    fn IBLEnv2( R:vec3f , Roughness : f32) -> vec3f 
    {
        let MAX_REFLECTION_LOD  = i32(textureNumLevels(reflectionMap));
        let mip = roughnessToMipmapLevel(Roughness,MAX_REFLECTION_LOD);
        var envIBL: vec3<f32> ;
        // envIBL = textureSampleLevel(envMap, envMapSampler, R , mip * 12.0 ).rgb ;
        envIBL = getReflectionsEnv(R,ORI_VertexVarying.vWorldPos.xyz, mip).rgb ;
        envIBL = gammaToLiner(envIBL);
        return envIBL;
    }


    fn F_indirect_Function( NdotV:f32, roughness:f32, F0:vec3f) -> vec3f
    {
        var fresnel = exp2((-5.55473 * NdotV - 6.98316) * NdotV);
        return F0 + fresnel * saturate(1.0 - roughness - F0);
    }


     fn indirectionDiffuse_Function( NdotV:f32, normalDir:vec3f, metallic:f32, baseColor:vec3f, roughness:f32, occlusion:f32, F0:vec3f)-> vec3f 
     {
        //  var SHColor = SH9(normalDir,globalUniform.SH).rgb * globalUniform.skyExposure ;
         var SHColor = fragData.Irradiance.rgb ;
         
         var KS = F_indirect_Function(NdotV,roughness,F0);
         var KD = (1.0 - KS) * (1.0 - metallic); 
         return SHColor * KD * baseColor * occlusion;
        //  return SHColor ;
     }
 
     fn indirectionSpec_Function( reflectDir:vec3f, roughness:f32, NdotV:f32,occlusion:f32, F0:vec3f )-> vec3f 
     {
         var mipRoughness = roughness * (1.7 - 0.7 * roughness) ;
         var env : vec3f ;
         #if USE_CASTREFLECTION
            env = textureSampleLevel(envMap, envMapSampler, reflectDir , mipRoughness * 12.0 ).rgb ;
         #else
            useSphereReflection();
            env = getReflectionsEnv(reflectDir,ORI_VertexVarying.vWorldPos.xyz, mipRoughness).rgb ;
        #endif

        //  env *= 0.45 ;
         var indirectionCube: vec3<f32> = globalUniform.skyExposure * env ;
         var F_IndirectionLight = F_indirect_Function(NdotV,roughness,F0);

         var AB = LUT_Approx(roughness,NdotV);
        //  var AB = textureSampleLevel(brdflutMap, brdflutMapSampler, vec2f(NdotV, roughness), 0.0).rg;
         var indirectionSpecFactor = indirectionCube.rgb * (F_IndirectionLight * AB.r + AB.g) ;
         return indirectionSpecFactor * occlusion;
     }

     const  c0 = vec4f(-1, -0.0275, -0.572, 0.022 );
     const  c1 = vec4f(1, 0.0425, 1.04, -0.04 );
     fn LUT_Approx( roughness:f32,  NoV:f32 )->vec2f
     {
         // [ Lazarov 2013, "Getting More Physical in Call of Duty: Black Ops II" ]
         // Adaptation to fit our G term.
         var r = roughness * c0 + c1;
         var a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;
         var AB = vec2f( -1.04, 1.04 ) * a004 + r.zw;
         return saturate(AB);
     }

`,Fh=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "BitUtil"
  #include "Common_frag"
  #include "GlobalUniform"
  #include "SHCommon_frag"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"
  #include "ReflectionCG"
 
  //ORI_ShadingInput
  fn initFragData() {
      // fragData.Albedo = vec4f(gammaToLiner(ORI_ShadingInput.BaseColor.rgb),ORI_ShadingInput.BaseColor.w) ;
      fragData.Albedo = vec4f((ORI_ShadingInput.BaseColor.rgb),ORI_ShadingInput.BaseColor.w) ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.0001,1.0) * 1.85 ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = gammaToLiner(ORI_ShadingInput.EmissiveColor.rgb) * materialUniform.emissiveIntensity ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;

      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(0.04), fragData.Albedo.rgb , fragData.Metallic);
      // fragData.F0 = gammaToLiner(fragData.F0);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      fragData.ClearcoatIor = materialUniform.clearcoatIor ;
      fragData.ClearcoatFactor = materialUniform.clearcoatFactor;
        
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness *= getClearcoatRoughness() ;
        fragData.ClearcoatFactor *= getClearcoatWeight() ;
      #endif
  }

  fn BxDFShading(){
      initFragData();

      let sunLight = lightBuffer[0] ;

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          #if USE_CASTREFLECTION
              irradiance += globalUniform.hdrExposure * (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
          #else
              useSphereReflection();
              irradiance = getReflectionsEnv(fragData.N,ORI_VertexVarying.vWorldPos.xyz,1.0) ;
          #endif
       #endif
      fragData.Irradiance = irradiance.rgb ;

      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.Albedo.rgb , fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      //***********lighting-PBR part********* 
      
      //***********indirect-specular part********* 
      var surReduction = 1.0/(fragData.Roughness * fragData.Roughness + 1.0);
      var grazingTerm = saturate(1.0 - fragData.Roughness + kD);
      var surfaceReduction = 1.0 / (pow(fragData.Roughness,2.0) + 1.0);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;  
      var iblSpecularResult = fresnelLerp * surReduction ;
      //***********indirect-specular part********* 

      //***********lighting-PBR part********* 
      var diffuseColor = mix(fragData.Albedo.rgb,vec3f(0.04),fragData.Metallic);
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting(ORI_VertexVarying.vWorldPos.xyz, light ,iblSpecularResult) ;
              break;
            }
            case DirectLightType: {
              specColor += directLighting(light,iblSpecularResult);
              // specColor = iblSpecularResult;
              break;
            }
            case SpotLightType: {
              specColor += spotLighting( ORI_VertexVarying.vWorldPos.xyz, light ,iblSpecularResult) ;
              break;
            }
            default: {
              break;
            }
          }
      }

      //***********indirect-ambient part********* 
      // var kdLast = (1.0 - 0.04) * (1.0 - fragData.Metallic);    
      var iblDiffuseResult : vec3f ;

      let MAX_LOD  = i32(textureNumLevels(prefilterMap)) ;
      let mip = roughnessToMipmapLevel(fragData.Roughness,MAX_LOD) * f32(MAX_LOD) * 0.5;
    
      var indirectionDiffuse = indirectionDiffuse_Function(fragData.NoV,fragData.N,fragData.Metallic,fragData.Albedo.rgb,fragData.Roughness,fragData.Ao,fragData.F0);
      iblDiffuseResult += indirectionDiffuse / 3.14;

      var indirectionSpec    = indirectionSpec_Function(fragData.R,fragData.Roughness,fragData.NoV,fragData.Ao,gammaToLiner(fragData.F0));
      #if USE_CASTREFLECTION
        indirectionSpec *= globalUniform.hdrExposure ;
      #endif

      var color = vec3f(iblDiffuseResult + indirectionSpec + specColor)  ;
      // var color = vec3f(indirectionDiffuse )  ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
           
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
            let light = getLight(i32(i));
            switch (light.lightType) {
              case PointLightType: {
                var lightColor = light.lightColor.rgb  ;
                var att = pointAtt(ORI_VertexVarying.vWorldPos.xyz, light);
                clearCoatColor += ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , fragData.ClearcoatIor , clearNormal ,  light.direction , fragData.V , clearcoatRoughness , lightColor,  att );
                break;
              }
              case DirectLightType: {
                var lightColor = getHDRColor( light.lightColor.rgb , light.linear )  ;
                var att = max(0.0,light.intensity);
                clearCoatColor += ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , fragData.ClearcoatIor , clearNormal ,  light.direction , fragData.V , clearcoatRoughness , lightColor,  att );
                break;
              }
              case SpotLightType: {
                // var lightColor = light.lightColor.rgb  ;
                // var att = pointAtt(ORI_VertexVarying.vWorldPos.xyz, light);
                // clearCoatColor += ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , 1.5 , clearNormal ,  light.direction , fragData.V , clearcoatRoughness , lightColor,  att );
                break;
              }
              default: {
                break;
              }
            }
        }
       
        color = clearCoatColor ;
      #endif
      
        var retColor = (LinearToGammaSpace(color.rgb));
        retColor += fragData.Emissive.xyz ;

        var viewColor = vec4<f32>( retColor.rgb * fragData.Albedo.w, fragData.Albedo.a) ;

        let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
        let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
        let ORI_NORMALMATRIX = transpose(inverse( nMat ));

        var vNormal = ORI_VertexVarying.vWorldNormal.rgb ;

        let gBuffer = packNHMDGBuffer(
          ORI_VertexVarying.fragCoord.z,
          fragData.Albedo.rgb,
          viewColor.rgb,
          vec3f(fragData.Roughness,fragData.Metallic,fragData.Ao),
          vNormal,
          fragData.Albedo.a
        ) ;

        #if USE_CASTREFLECTION
          ORI_FragmentOutput.gBuffer = gBuffer ;
        #else
          ORI_FragmentOutput.gBuffer = gBuffer ;
          ORI_FragmentOutput.color = viewColor ;
        #endif
  }

  `,kh=`
    #if USE_CLEARCOAT_ROUGHNESS
    @group(1) @binding(auto)
    var clearCoatRoughnessMapSampler: sampler;
    @group(1) @binding(auto)
    var clearCoatRoughnessMap: texture_2d<f32>;

    fn getClearcoatRoughness() -> f32{
        let clearcoatRoughness = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).g;
        return clearcoatRoughness;
    }

    fn getClearcoatWeight() -> f32{
        let clearcoatWeight = textureSample(clearCoatRoughnessMap, clearCoatRoughnessMapSampler, ORI_VertexVarying.fragUV0.xy).r;
        return clearcoatWeight;
    }
    #else
    fn getClearcoatRoughness() -> f32{
        return 1.0;
    }
    fn getClearcoatWeight() -> f32{
        return 1.0;
    }
    #endif

    #if USE_CLEARCOAT
    fn ClearCoat_BRDF( baseColor:vec3<f32>, clearCoatColor:vec3<f32> , clearCoatIor:f32 ,N:vec3<f32>, L:vec3<f32> ,  V:vec3<f32> , clearCoatPerceptualRoughness:f32 ,lightColor:vec3f, att:f32) -> vec3<f32> {
        var factor = clamp(clearCoatPerceptualRoughness, 0.0001, 1.0);
        var clearCoatRoughness = factor ;
        let lightDir = -L ;
        let H = normalize( V + lightDir);
        // let LoH = dot(lightDir,H);
        let NoV = max(dot(N,V),0.00001);
        // let NoL = max(dot(N,lightDir),0.00001);
        // let NoH = max(dot(N,H),0.00001);

        // let clearSpeclur = IBLEnv2(fragData.R,clearCoatRoughness);
        // let F0 = IORToF0(clearCoatIor);
        // let Fr = FresnelSchlickRoughness( NoV , vec3<f32>(clearCoatColor) , clearCoatRoughness ) ;
        // var Fd = clearCoatColor ;
        // clear coat BRDF
        // var Dc = D_GGX(NoH,clearCoatRoughness);
        // var Vc = V_Kelemen(LoH) * NoL;
        // var Fc = F_Schlick2( vec3<f32>(F0) , NoV) ;
        // var Frc = (Dc * Vc) * Fc;
        // base layer attenuation for energy compensation
        // let oneMinusFc  = 1.0 - Fc;

        // let brdfSpecular = clearSpeclur * ((Fd + Fr * oneMinusFc) * oneMinusFc + Frc)  * att * lightColor; 
        var iblSpecular = vec3<f32>(0.0);
        // return brdfSpecular ;

        iblSpecular = indirectionSpec_Function(fragData.R,clearCoatRoughness,NoV,1.0,(clearCoatColor * att * vec3f(IORToF0(clearCoatIor))));
        // iblSpecular = IBLEnv2(fragData.R,clearCoatRoughness);
        // return mix(baseColor , brdfSpecular + iblSpecular ,fragData.ClearcoatFactor) ;
        // return vec3f(baseColor + (clearCoatColor * iblSpecular) * fragData.ClearcoatFactor) ;
        return mix(baseColor , (clearCoatColor * iblSpecular) , fragData.ClearcoatFactor) ;
        // return iblSpecular ;
    }
    #endif
`,zh=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        ORI_ShadingInput.BaseColor = materialUniform.baseColor ;
        ORI_ShadingInput.Roughness = materialUniform.roughness  ;
        ORI_ShadingInput.Metallic = materialUniform.metallic ;
        ORI_ShadingInput.Specular = 0.5 ;
        ORI_ShadingInput.AmbientOcclusion = 1.0 ;
        ORI_ShadingInput.EmissiveColor = vec4<f32>(0.0);

        ORI_ShadingInput.Normal = ORI_VertexVarying.vWorldNormal.rgb ;

        BxDFShading();
    }
`,Gh=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BxDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
   
        let baseMapOffsetSize = materialUniform.baseMapOffsetSize;
        var uv = transformUV(ORI_VertexVarying.fragUV0,baseMapOffsetSize) ; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            // ORI_ShadingInput.BaseColor = sRGBToLinear(ORI_ShadingInput.BaseColor.rgb)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>( ORI_ShadingInput.BaseColor * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(gammaToLiner(ORI_ShadingInput.BaseColor.rgb),ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor *= vec4f(materialUniform.baseColor.rgba)  ;
        #endif

        let roughnessMapOffsetSize = materialUniform.roughnessMapOffsetSize;
        var uv4 = transformUV(ORI_VertexVarying.fragUV0,roughnessMapOffsetSize); 
        var maskTex = textureSample(maskMap, maskMapSampler, uv4 );
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif

                discard;
            }
        #endif

        useShadow();

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    

        ORI_ShadingInput.Metallic = metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            let aoMapOffsetSize = materialUniform.aoMapOffsetSize;
            var aoMapOffsetSizeUV = transformUV(ORI_VertexVarying.fragUV0,aoMapOffsetSize); 
            var aoMap = textureSample(aoMap, aoMapSampler, ORI_VertexVarying.fragUV0 );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;
        ORI_ShadingInput.Specular = 1.0 ;

        let emissiveMapOffsetSize = materialUniform.emissiveMapOffsetSize;
        var emissiveUV = transformUV(ORI_VertexVarying.fragUV0,emissiveMapOffsetSize) ;
        #if USE_EMISSIVEMAP
            var emissiveMapColor = textureSample(emissiveMap, emissiveMapSampler , emissiveUV ) ;
            let emissiveColor = materialUniform.emissiveColor.rgb * emissiveMapColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor.rgb,1.0);
        #else
            let emissiveColor = materialUniform.emissiveColor.rgb * materialUniform.emissiveIntensity ;
            ORI_ShadingInput.EmissiveColor = vec4<f32>(emissiveColor,1.0);
        #endif

        let normalMapOffsetSize = materialUniform.normalMapOffsetSize;
        var nomralUV = transformUV(ORI_VertexVarying.fragUV0,normalMapOffsetSize) ;
        var Normal = textureSample(normalMap,normalMapSampler,nomralUV).rgb ;
        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        ORI_ShadingInput.Normal = normal ;
     
        BxDFShading();

        // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(normal.rgb),1.0) ;
    }
`,Qh=`
#include "ClusterDebug_frag" 

        fn debugPosition(){
            //ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,1.0);
        }

        fn debugMeshID(){
            let meshIDColor = u32(round(ORI_VertexVarying.vWorldPos.w) ) ;
            let color = colorSet[ meshIDColor % 9u] ;
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(color.rgb),1.0);
        }

        fn debugNormal(){
            // ORI_FragmentOutput.color = vec4<f32>(ORI_ShadingInput.Normal.xyz,1.0);
        }

        fn debugUV(){
            // ORI_FragmentOutput.color = vec4<f32>(ORI_VertexVarying.fragUV0.xy,0.0,1.0);
        }

        fn debugColor(){
            // ORI_FragmentOutput.color = vec4<f32>(fragData.Albedo.rgb,1.0);
        }

        fn debugDiffuse(){
            // ORI_FragmentOutput.color = vec4<f32>( fragData.LightChannel.rgb,1.0);
        }

        fn debugAmbient(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3f(fragData.Alpha) ,1.0);
        }
        
        fn debugEmissive(){
            // ORI_FragmentOutput.color = vec4<f32>(fragData.Emissive.rgb,1.0);
        }

        fn debugEnvment(){
            // ORI_FragmentOutput.color = vec4<f32>(fragData.EnvColor.rgb,1.0);
        }

        fn debugAo(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Ao),1.0);
        }

        fn debugRoughness(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Roughness),1.0);
        }

        fn debugMetallic(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Metallic),1.0);
        }

        fn debugIrradiance(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.Irradiance),1.0);
        }

        fn debugTangent(){
            // ORI_FragmentOutput.color = vec4<f32>(vec3<f32>(fragData.T),1.0);
        }

        fn debugFragmentOut(){
            if(ORI_VertexVarying.fragCoord.x > globalUniform.renderState_split) {
                switch (globalUniform.renderState_right)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              } else {
                switch (globalUniform.renderState_left)
                {
                  case 0: {
                    debugPosition();
                  }
                  case 1: {
                    debugColor();
                  }
                  case 2: {
                    debugNormal();
                  }
                  case 3: {
                    debugIrradiance();
                  }
                  case 4: {
                    debugTangent();
                  }
                  case 5: {
                    // debugTangent();
                  }
                  case 6: {
                    debugEmissive();
                  }
                  case 7: {
                    debugEnvment();
                  }
                  case 8: {
                    debugAo();
                  }
                  case 9: {
                    debugRoughness();
                  }
                  case 10: {
                    debugMetallic();
                  }
                  case 11: {
                    debugDiffuse();
                  }
                  case 12: {
                    debugAmbient();
                  }
                  case 13: {
                    debugMeshID();
                  }
                  case 14: {
                    #if DEBUG_CLUSTER
                      debugCluster( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 15: {
                    #if DEBUG_CLUSTER
                      debugClusterBox( ORI_VertexVarying.fragCoord );
                    #endif
                  }
                  case 16: {
                    #if DEBUG_CLUSTER
                      debugClusterLightCount( vec4<f32>(ORI_VertexVarying.fragCoord.xyz,0.0));
                      #endif
                  }
                  default: {
                  }
                }
              }
        }
`,Vh=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct MaterialUniform {
    x:f32,
    y:f32,
    width:f32,
    height:f32,
    };

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) position: vec4<f32>
    };

    @vertex
    fn main(@builtin(vertex_index) vertexIndex : u32, @builtin(instance_index) index : u32 ) -> VertexOutput {
        const pos = array(
        vec2(-1.0, -1.0), vec2(1.0, -1.0), vec2(-1.0, 1.0),
        vec2(-1.0, 1.0), vec2(1.0, -1.0), vec2(1.0, 1.0),
        );
        const uv = array(
        vec2(1.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), 
        vec2(1.0, 0.0), vec2(0.0, 1.0), vec2(0.0, 0.0),
        );
        let id = u32(index) ;
        var output : VertexOutput;
        output.fragUV = uv[vertexIndex] ;
        output.position = vec4<f32>(pos[vertexIndex] , 0.0, 1.0) ;
        return output ;
    }
`,Yh=`
#include "WorldMatrixUniform"
      #include "GlobalUniform"
   
      struct MaterialUniform {
        x:f32,
        y:f32,
        width:f32,
        height:f32,
      };

      struct VertexOutput {
          @location(auto) fragUV: vec2<f32>,
          @builtin(position) member: vec4<f32>
      };

      @vertex
      fn main(@builtin(instance_index) index : u32,@location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        //   let id = u32(index) ;
        //   let worldMatrix = models.matrix[id];
        //   let windowSize = vec2<f32>(globalUniform.windowWidth,globalUniform.windowHeight) ;
        //   let pos = worldMatrix[3].xy ;
        //   let size = vec2<f32>(worldMatrix[0].x,worldMatrix[1].y) / windowSize ;
          let uv = vec2(((TEXCOORD_1.xy * 2.0) - vec2<f32>(1.0))) ;// / windowSize * size - offset ;
          return VertexOutput(TEXCOORD_1, vec4<f32>(uv, 0.0, 1.0));
      }
`,Hh=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var color: vec4<f32> = textureSample(baseMap, baseMapSampler, uv );

        return FragmentOutput(color);
    }
`,Xh=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    }; 

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_2d ;

    fn Linear01Depth(  z : f32 ) -> f32
    {
        return 1.0 / (1.0 * z + 5000.0);
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var depth = textureSample(baseMap, baseMapSampler, uv , vec2<i32>(0) ) ;
        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,Wh=`
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> fragUV1: vec2<f32>;
    var<private> o_Target: vec4<f32>;

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_depth_cube ;

    fn uvToXYZ( face : i32 ,  uv : vec2<f32> ) -> vec3<f32>
    {
        var out : vec3<f32> ;
        if(face == 0){
            out = vec3<f32>( 1.0, uv.y, -uv.x);
        }else if(face == 1){
            out = vec3<f32>( -1.0, uv.y, uv.x);
        }else if(face == 2){
            out = vec3<f32>( uv.x, -1.0, uv.y);
        }else if(face == 3){
            out = vec3<f32>( uv.x,  1.0, -uv.y);
        }else if(face == 4){
            out = vec3<f32>( uv.x, uv.y, 1.0);
        }else{	
            out = vec3<f32>( -uv.x, uv.y, -1.0);
        }
        return out ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var uv = fragUV ;
        uv.y = 1.0 - uv.y ;
        var ii = 0.16 ;
        var ouv = vec3<f32>(0.0);
        if(uv.x < ii * 6.0){
            ouv = uvToXYZ(5,uv/ii);
        }
        if(uv.x < ii * 5.0){
            ouv = uvToXYZ(4,uv/ii);
        }
        if(uv.x < ii * 4.0){
            ouv = uvToXYZ(3,uv/ii);
        } 
        if(uv.x < ii * 3.0){
            ouv = uvToXYZ(2,uv/ii);
        }
        if(uv.x < ii * 2.0){
            ouv = uvToXYZ(1,uv/ii);
        }
        if(uv.x < ii * 1.0){
            ouv = uvToXYZ(0,uv/ii);
        }
        var depth = textureSample(baseMap, baseMapSampler, ouv ) ;
        depth = 1.0 - depth; 

        return FragmentOutput(vec4<f32>(depth,0.0,0.0,1.0));
    }
`,Dm=null,Kh=`
    fn getHDRColor(color: vec3<f32>, exposure: f32) -> vec3 < f32 > {
        return color * pow(2.4, exposure) ;
    }

    // RGBM encode/decode
    const kRGBMRange = 8.0;

    fn EncodeRGBM( icolor : vec3f ) ->vec4f
    {
        var color = icolor ;
        color *= 1.0 / kRGBMRange;
        var m = max(max(color.x, color.y), max(color.z, 1e-5));
        m = ceil(m * 255) / 255;
        return vec4f(color / m, m);
    }

    fn DecodeRGBM( rgbm : vec4f ) -> vec3f
    {
        return rgbm.xyz * rgbm.w * kRGBMRange;
    }

    fn Luminance(  LinearColor : vec3f, LuminanceFactors: vec3f ) -> f32
    {
        return dot( LinearColor, LuminanceFactors );
    }

    fn lambda2rgb(lambda : f32) -> vec3 < f32 > {
        let ultraviolet = 400.0;
        let infrared = 700.0;

        var a = (lambda - ultraviolet) / (infrared - ultraviolet);
        let c = 10.0;
        var b = vec3<f32>(a) - vec3<f32>(0.75, 0.5, 0.25);
        return max((1.0 - c * b * b), vec3<f32>(0.0));
    }

    fn CEToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        return 1.0 - exp(-adapted_lum * color);
    }


    fn acesFilm( x:vec3f) -> vec3f {
        return clamp((x*(2.51*x+vec3f(0.03)))/(x*(2.43*x+vec3f(0.59))+vec3f(0.14)),vec3f(0.0),vec3f(1.0));
    }

    fn ACESToneMapping(color: vec3<f32>, adapted_lum: f32) -> vec3<f32>
    {
        let A = 2.51;
        let B = 0.03;
        let C = 2.43;
        let D = 0.59;
        let E = 0.14;

        var color2 = color * adapted_lum;
        color2 = (color2 * (A * color2 + B)) / (color2 * (C * color2 + D) + E);
        return color2;
    }

    fn gammaToLiner(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 2.4;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma4(color: vec4<f32>) -> vec4 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec4<f32>(gammaCorrect));
        return color2 ;
    }

    fn linerToGamma3(color: vec3<f32>) -> vec3 < f32 > {
        let gammaCorrect = 0.416666667;
        var color2 = pow(color, vec3<f32>(gammaCorrect));
        return color2 ;
    }

    // fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3 < f32 > {
    //     var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
    //     linRGB.r = pow(linRGB.r, 0.416666667);
    //     linRGB.g = pow(linRGB.g, 0.416666667);
    //     linRGB.b = pow(linRGB.b, 0.416666667);
    //     return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    // }

    fn LinearToGammaSpace(linRGB: vec3<f32>) -> vec3<f32> {
        var linRGB1 = max(linRGB, vec3<f32>(0.0));
        linRGB1 = pow(linRGB1, vec3<f32>(0.4166666567325592));
        return max(((1.0549999475479126 * linRGB1) - vec3<f32>(0.054999999701976776)), vec3<f32>(0.0));
    }

    var<private>sRGB_2_LMS_MAT: mat3x3<f32> = mat3x3<f32>(
        17.8824, 43.5161, 4.1193,
        3.4557, 27.1554, 3.8671,
        0.02996, 0.18431, 1.4670,
    );

    var<private>LMS_2_sRGB_MAT: mat3x3<f32> = mat3x3<f32>(
        0.0809, -0.1305, 0.1167,
        -0.0102, 0.0540, -0.1136,
        -0.0003, -0.0041, 0.6935,
    );

    fn sRGB_2_LMS(RGB: vec3<f32>) -> vec3<f32>
    {
        return sRGB_2_LMS_MAT * RGB;
    }

    fn LMS_2_sRGB(LMS: vec3<f32>) -> vec3<f32>
    {
        return LMS_2_sRGB_MAT * LMS;
    }

    fn LinearToSrgbBranchless(lin: vec3<f32>) -> vec3<f32>
    {
        var lin2 = max(vec3<f32>(6.10352e-5), lin);
        return min(lin2 * 12.92, pow(max(lin2, vec3<f32>(0.00313067)), vec3<f32>(0.416666667)) * vec3<f32>(1.055) - vec3<f32>(0.055));
    }

    fn sRGBToLinear(color : vec3<f32>) -> vec3<f32>
    {
        let color2 = max(vec3<f32>(6.10352e-5), color);
        let c = 0.04045;
        if (color2.r > c && color2.g > c && color2.b > c) {
            return pow(color2 * (1.0 / 1.055) + 0.0521327, vec3<f32>(2.4));
        } else {
            return color2 * (1.0 / 12.92);
        }
    }

    fn BlendNormalRNM( n1:vec3f,  n2:vec3f) -> vec3f
	{
		let t = n1.xyz + vec3f(0.0, 0.0, 1.0);
		let u = n2.xyz * vec3f(-1.0, -1.0, 1.0);
		let r = (t / t.z) * dot(t, u) - u;
		return r;
	}

//     fn ReorientedBlendNormal(){
//         vec3 t = texture(baseMap,   uv).xyz * vec3( 2.0,  2.0, 2.0) + vec3(-1.0, -1.0,  0.0);
// vec3 u = texture(detailMap, uv).xyz * vec3(-2.0, -2.0, 2.0) + vec3( 1.0,  1.0, -1.0);
// vec3 r = normalize(t * dot(t, u) - u * t.z);
// return r;
//     }

//     fn UDNBlendNormal(){
    // vec3 t = texture(baseMap,   uv).xyz * 2.0 - 1.0;
    // vec3 u = texture(detailMap, uv).xyz * 2.0 - 1.0;
    // vec3 r = normalize(t.xy + u.xy, t.z);
    // return r;
//     }


fn packRGBA8( In : vec4f ) ->u32
{
	let r = (u32(saturate(In.r) * 255.0) << 0u);
	let g = (u32(saturate(In.g) * 255.0) << 8u);
	let b = (u32(saturate(In.b) * 255.0) << 16u);
	let a = (u32(saturate(In.a) * 255.0) << 24u);
	return r | g | b | a;
}

const i256:f32 = 1.0 / 255.0 ;
fn unpackRGBA8( In : u32 ) -> vec4f 
{
	var Out:vec4f ;
	Out.r = f32((In >> 0u) & 0xFF) * i256;
	Out.g = f32((In >> 8u) & 0xFF) * i256;
	Out.b = f32((In >> 16u) & 0xFF) * i256;
	Out.a = f32((In >> 24u) & 0xFF) * i256;
	return Out;
}
`,jh=`
    fn madfrac(A:f32, B:f32)-> f32 {
        return A*B-floor(A*B) ;
    }

    fn sampleRandomDir(count:u32,SAMPLE_COUNT:u32) -> vec3<f32>{
    var ray_dir = sphericalFibonacci(f32((count)), f32(SAMPLE_COUNT) );
    return normalize(ray_dir) ;
    }

    fn sphericalFibonacci( i : f32 ,  n : f32 ) -> vec3<f32>{
        const PHI = sqrt(5.0) * 0.5 + 0.5;
        let phi = 2.0 * PI * madfrac(i, PHI - 1);
        let cosTheta = 1.0 - (2.0 * i + 1.0) * (1.0 / n);
        let sinTheta = sqrt(saturate(1.0 - cosTheta*cosTheta));

        return vec3<f32>(
            cos(phi) * sinTheta,
            sin(phi) * sinTheta,
            cosTheta);

    }
`,qh=`
    #include "MathShader"

    fn buildMatrix3x3() -> mat3x3<f32>{
        var mat3 = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,1.0,0.0,
            0.0,0.0,1.0,
        );
        return mat3 ;
    }

    fn buildMatrix4x4() -> mat4x4<f32>{
        var mat4 = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        return mat4 ;
    }

    fn buildRotateXMat3(rad:f32) -> mat3x3<f32>{
        var xrot = mat3x3<f32>(
            1.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),
            0.0,sin(rad),cos(rad)
        );
        return xrot;
    }

    fn buildRotateXMat4(rad:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xrot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(rad),-sin(rad),0.0,
            0.0,sin(rad),cos(rad),0.0,
            x,y,z,1.0,
        );
        return xrot;
    }

    fn buildYRotateXMat4(radY:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            x,y,z,1.0,
        );
        return yRot;
    }

    fn buildRotateXYZMat4(radX:f32,radY:f32,radZ:f32,x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var xRot = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,cos(radX),-sin(radX),0.0,
            0.0,sin(radX),cos(radX),0.0,
            0.0,0.0,0.0,1.0,
        );
        var yRot = mat4x4<f32>(
            cos(radY),0.0,sin(radY),0.0,
            0.0,1.0,0.0,0.0,
            -sin(radY),0.0,cos(radY),0.0,
            0.0,0.0,0.0,1.0,
        );
        var zRot = mat4x4<f32>(
            cos(radZ),-sin(radZ),0.0,0.0,
            sin(radZ), cos(radZ),0.0,0.0,
            0.0,0.0,1.0,0.0,
            0.0,0.0,0.0,1.0,
        );
        var fMat = xRot * yRot * zRot ;
        fMat[3].x = x;
        fMat[3].y = y;
        fMat[3].z = z;
        return fMat;
    }

    fn buildRotateYMat3(rad:f32) -> mat3x3<f32>{
        var yrot = mat3x3<f32>(
            cos(rad),0.0,sin(rad),
            0.0,1.0,0.0,
            -sin(rad),0.0,cos(rad)
        );
        return yrot ;
    }

    fn buildRotateZ(rad:f32) -> mat3x3<f32>{
        var zrot = mat3x3<f32>(
            cos(rad),-sin(rad),0.0,
            sin(rad), cos(rad),0.0,
            0.0,0.0,1.0
        );
        return zrot;
    }

    // fn buildRotateXMat4(rad:f32) -> mat4x4<f32>{
    //     var xrot = mat4x4<f32>(
    //         1.0,0.0,0.0,0.0,
    //         0.0,cos(rad),-sin(rad),0.0,
    //         0.0,sin(rad),cos(rad),0.0,
    //         0.0,0.0,0.0,1.0);
    //     return xrot;
    // }

    fn bulidTranslateMat4(x:f32,y:f32,z:f32) -> mat4x4<f32>{
        var trans = mat4x4<f32>(
            1.0,0.0,0.0,0.0,
            0.0,1.0,0.0,0.0,
            0.0,0.0,1.0,0.0,
            x,y,z,1.0);
        return trans;
    }

`,Jh=`
    struct LightData {
        index:f32,
        lightType:i32,
        radius:f32,
        linear:f32,
        
        position:vec3<f32>,
        lightMatrixIndex:f32,

        direction:vec3<f32>,
        quadratic:f32,

        lightColor:vec3<f32>,
        intensity:f32,

        innerCutOff :f32,
        outerCutOff:f32,
        range :f32,
        castShadow:i32,

        lightTangent:vec3<f32>,
        ies:f32,
    };

    const PointLightType = 1;
    const DirectLightType = 2;
    const SpotLightType = 3;

    struct ClusterBox {
        minPoint:vec4<f32>,
        maxPoint:vec4<f32>
    };

    struct LightIndex {
            count:f32,
            start:f32,
            empty0:f32,
            empty1:f32,
    };

    struct ClustersUniform {
        clusterTileX:f32,
        clusterTileY:f32,
        clusterTileZ:f32,
        numLights:f32,
        maxNumLightsPerCluster:f32,
        near:f32,
        far:f32,
        screenWidth:f32,
        screenHeight:f32,
        clusterPix:f32, 
    };

    @group(2) @binding(1)
    var<storage,read> lightBuffer: array<LightData>;
    @group(2) @binding(2)
    var<uniform> clustersUniform : ClustersUniform;
    @group(2) @binding(3)
    var<storage,read> lightAssignBuffer : array<f32>;
    @group(2) @binding(4)
    var<storage,read> assignTable : array<LightIndex>;
    #if DEBUG_CLUSTER
        @group(2) @binding(5)
        var<storage,read> clusterBuffer : array<ClusterBox>;
    #endif

    fn getLight( index:i32 ) -> LightData {
        let lightId = i32(lightAssignBuffer[index]);
        var lightData = lightBuffer[lightId];
        return lightData ;
    }

    fn linearTo01Depth(depth : f32) -> f32 {
        return (globalUniform.far ) * globalUniform.near / fma(depth, globalUniform.near-globalUniform.far, globalUniform.far);
    }

    fn getClusterId3() -> vec3<u32> {
        let z = linearTo01Depth(ORI_VertexVarying.fragCoord.z) ; 

        let sliceScale = f32(clustersUniform.clusterTileZ) / log2(globalUniform.far / globalUniform.near);
        let sliceBias = -(f32(clustersUniform.clusterTileZ) * log2(globalUniform.near) / log2(globalUniform.far / globalUniform.near));
        let zTile = u32(max(log2(z) * sliceScale + sliceBias, 0.0));

        var screenUV = ORI_VertexVarying.fragCoord.xy / vec2<f32>( globalUniform.windowWidth , globalUniform.windowHeight );
        let i = u32(floor(screenUV.x * clustersUniform.clusterTileX)) ;
        let j = u32(floor(screenUV.y * clustersUniform.clusterTileY) );

        return vec3<u32>(i,j,zTile);
    }

    fn getCluster() -> LightIndex {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return assignTable[id];
    }

    fn getClusterIndex() -> u32 {
        let tile = getClusterId3();
        let id = tile.x +
            tile.y * u32(clustersUniform.clusterTileX) +
            tile.z * u32(clustersUniform.clusterTileX) * u32(clustersUniform.clusterTileY);
        return id;
    }
`,Zh=`
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"

  struct FHairTransmittanceData{
    bUseBacklit:bool,
    bUseSeparableR:bool,
    bUseLegacyAbsorption:bool
  };
 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = ORI_ShadingInput.Roughness ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.Specular = vec3f(materialUniform.specularColor.rgb) ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz ) ;
      fragData.V = viewDir ;
      fragData.Ao = materialUniform.ao ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz * ORI_VertexVarying.TANGENT.w ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;
  }

  

  fn transformHairNormal(normal : vec3<f32>) -> vec3<f32>{
      var face = 1.0 ;
      if(ORI_VertexVarying.face){
          face = 1.0 ;
      }else{
          face = -1.0 ;
      }
      #if USE_TANGENT
        let T = ORI_VertexVarying.TANGENT.xyz;
        let N = ORI_VertexVarying.vWorldNormal ;
        let B = cross(T,N) * ORI_VertexVarying.TANGENT.w * face;
        let mat3 = mat3x3<f32>(T,B,N);
        let n = mat3 * normal;
        return n ;
      #else
        return normal ;
      #endif
  }


  fn Hair_g( B:f32 ,  Theta:f32 ) -> f32
  {
      return exp(-0.5 * pow2(Theta) / (B * B)) / (sqrt(2 * PI) * B);
  }

  fn Hair_F( CosTheta:f32 )-> f32
  {
      let n = 1.55;
      let F0 = pow2((1.0 - n) / (1.0 + n));
      return F0 + (1.0 - F0) * pow5(1.0 - CosTheta);
  }

  fn HairColorToAbsorption( C:vec3f ,  B:f32 ) -> vec3f
  {
      let b2 = B * B;
      let b3 = B * b2;
      let b4 = b2 * b2;
      let b5 = B * b4;
      let D = (5.969 - 0.215 * B + 2.532 * b2 - 10.73 * b3 + 5.574 * b4 + 0.245 * b5);
      return pow2v3(log(C) / D);
  }

  fn Luminance(  LinearColor : vec3f ) -> f32
  {
    return dot( LinearColor, vec3f( 0.3, 0.59, 0.11 ) );
  }

  fn KajiyaKayDiffuseAttenuation( L:vec3f,  V:vec3f,  N:vec3f,  Shadow:f32 ) -> vec3f
  {
    // Use soft Kajiya Kay diffuse attenuation
    var KajiyaDiffuse = 1.0 - abs(dot(N, L));

    var FakeNormal = normalize(V - N * dot(V, N));
    //N = normalize( DiffuseN + FakeNormal * 2 );
    let nN = FakeNormal;

    let BaseColor = fragData.Albedo.rgb / PI ;
    // Hack approximation for multiple scattering.
    var Wrap = 1.0;
    var NoL = saturate((dot(nN, L) + Wrap) / squareF(1.0 + Wrap));
    var DiffuseScatter = (1.0 / PI) * mix(NoL, KajiyaDiffuse, 0.33) * fragData.Metallic;
    var Luma = Luminance(BaseColor);
    var ScatterTint = pow(BaseColor / Luma, vec3f(1.0 - Shadow));
    return sqrt(BaseColor) * DiffuseScatter * ScatterTint;
  }

  fn HairNormal( ID : f32 ) -> vec4f {
      let tangentA = vec4f(0.0,0.0,0.3,1.0);
      let tangentB = vec4f(0.0,0.0,-0.3,1.0);

      let iTangent = mix(tangentA,tangentB,vec4f(ID));
      var tangent = vec4f(0.0);
      #if USE_FLOWER

      #else 
        let tt = vec4f(0.0,-1.0,0.0,1.0);
        tangent = tt + iTangent;
      #endif

      return normalize(tangent) ;
  }

  fn hairShading( light:LightData , sV:vec3f, N:vec3f, Shadow:f32 , HairTransmittance : FHairTransmittanceData ,  InBacklit:f32 ,  Area:f32 ,  Random:vec2f ) -> vec3f{
      var ClampedRoughness = clamp(fragData.Roughness, 1/255.0, 1.0);
      let Backlit	= min(InBacklit, materialUniform.backlit);
      let HairColor = fragData.Albedo.rgb ;
      let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
      var lightColor = getHDRColor( lightCC.rgb , light.linear )  ;
      var lightAtt = light.intensity  ;

      let V = normalize(sV) ;
      let L = normalize(-light.direction) ;
      let H = normalize(N+L) ;
      var S : vec3f= vec3f(0.0) ;

      var KajiyaKayDiffuseFactor = 1.0;

      let VoL       = dot(V,L);                                                      
      let SinThetaL = clamp(dot(N,L), -1.0, 1.0);
      let SinThetaV = clamp(dot(N,V), -1.0, 1.0);

      var CosThetaD = cos( 0.5 * abs( asinFast( SinThetaV ) - asinFast( SinThetaL ) ) );
      // var CosThetaD = cos( 0.5 * abs( asin( SinThetaV ) - asin( SinThetaL ) ) );
      
      var Lp = L - SinThetaL * N;
      var Vp = V - SinThetaV * N;
      var CosPhi = dot(Lp,Vp) * rsqrt( dot(Lp,Lp) * dot(Vp,Vp) + 1e-4 );
      var CosHalfPhi = sqrt( saturate( 0.5 + 0.5 * CosPhi ) );

      let n = 1.55;
      let n_prime = 1.19 / CosThetaD + 0.36 * CosThetaD;

      let Shift = 0.035;
      var Alpha:array<f32,3> = array<f32,3>(
        -Shift * 2.0,
        Shift,
        Shift * 4.0,
      );

      var B:array<f32,3> =array<f32,3>(
        Area + pow2(ClampedRoughness),
        (Area + pow2(ClampedRoughness) / 2.0),
        Area + pow2(ClampedRoughness) * 2.0,
      );
     
      //S SR
      let sa = sin(Alpha[0]);
      let ca = cos(Alpha[0]);
      var ShiftA = 2.0 * sa * (ca * CosHalfPhi * sqrt(1.0 - SinThetaV * SinThetaV) + sa * SinThetaV);
      var BScale = 1.0;
      if(HairTransmittance.bUseSeparableR){
          BScale = sqrt(2.0) * CosHalfPhi ;
      }
      var Mp_R = Hair_g(B[0] * BScale, SinThetaL + SinThetaV - ShiftA);
      var Np_R = 0.25 * CosHalfPhi;
      var Fp_R = Hair_F(sqrt(saturate(0.5 + 0.5 * (VoL))));
      S += vec3f(Mp_R* Np_R * Fp_R * (fragData.F0 * 2.0)) * mix(1.0, 0.0, saturate(-VoL));
      KajiyaKayDiffuseFactor -= Fp_R;

      //S ST
      var Mp_ST = Hair_g( B[1], SinThetaL + SinThetaV - Alpha[1] );
      var a_ST = 1.0 / n_prime;
      var h_ST = CosHalfPhi * ( 1.0 + a_ST * ( 0.6 - 0.8 * CosPhi ) );
      var f_ST = Hair_F( CosThetaD * sqrt( saturate( 1.0 - h_ST * h_ST ) ) );
      var Fp_ST = pow2(1.0 - f_ST);
      var Tp_ST : vec3f = vec3f( 0.0 );
      if (HairTransmittance.bUseLegacyAbsorption)
      {
        Tp_ST = pow(HairColor.rgb, vec3f(0.5 * sqrt(1.0 - pow2(h_ST * a_ST)) / CosThetaD));
      }
      else
      {
        let AbsorptionColor = HairColorToAbsorption(HairColor.rgb,0.3);
        Tp_ST = exp(-AbsorptionColor * 2.0 * abs(1.0 - pow2(h_ST * a_ST) / CosThetaD));
      }
     
      var Np_ST = exp( -3.65 * CosPhi - 3.98 );
      
      S += Mp_ST * Np_ST * Fp_ST * Tp_ST * Backlit;
      KajiyaKayDiffuseFactor -= Fp_ST;

      //S TRT
      var Mp_TRT = Hair_g( B[2], SinThetaL + SinThetaV - Alpha[2] );
      
      //float h = 0.75;
      var f_TRT = Hair_F( CosThetaD * 0.5 );
      var Fp_TRT = pow2(1.0 - f_TRT) * f_TRT;
      var Tp_TRT = pow( HairColor.rgb , vec3f(0.8 / CosThetaD) );
      var Np_TRT = exp( 17.0 * CosPhi - 16.78 );
      
      S += Mp_TRT * Np_TRT * Fp_TRT * Tp_TRT;
      KajiyaKayDiffuseFactor -= Fp_TRT;
      // S = vec3f((KajiyaKayDiffuseFactor));
     
      S += KajiyaKayDiffuseAttenuation(L,V,N,Shadow) ;//* saturate(KajiyaKayDiffuseFactor);
      // S = vec3f((KajiyaKayDiffuseFactor));
      S = -min(-S, vec3f(0.0));
      return 2.0 * PI *vec3f(S) * (lightAtt ) ;
  }

  fn BSSSRDFShading(){
    initFragData();

    var irradiance = vec3<f32>(0.0) ;
    #if USEGI
        irradiance += getIrradiance().rgb ;
    #else
        let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
    #endif
    irradiance = ORI_ShadingInput.SSS + (irradiance.rgb);
    fragData.Irradiance = irradiance.rgb ;

    //***********lighting-PBR part********* 
    var specColor = vec3<f32>(0.0) ;
    let lightIndex = getCluster();
    let start = max(lightIndex.start, 0.0);
    let count = max(lightIndex.count, 0.0);
    let end = max(start + count , 0.0);
    for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
    {
        let light = getLight(i32(i));
        switch (light.lightType) {
          case PointLightType: {
            // specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
          }
          case DirectLightType: {
              // specColor += directHairLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
              var fHairTransmittanceData : FHairTransmittanceData ;
              fHairTransmittanceData.bUseBacklit = true ;
              fHairTransmittanceData.bUseSeparableR = true ;
              fHairTransmittanceData.bUseLegacyAbsorption = false ;

              //use shadow visible backlit
              specColor = hairShading(light,fragData.V, ORI_ShadingInput.HairNormal , 1.0 ,fHairTransmittanceData,1.0,materialUniform.area,vec2f(0.0));
          }
          case SpotLightType: {
            // specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
          }
          default: {
          }
        }
    }


    let sunLight = lightBuffer[0] ;
    //***********lighting-PBR part********* 
    var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0.rgb , fragData.Roughness);
    var kS = F;
    // var kD = vec3(1.0) - kS;
    // kD = kD * (1.0 - fragData.Metallic);
    let envIBL =  materialUniform.envIntensity * IBLEnv(fragData.V ,fragData.N ,fragData.Roughness ) ;
    fragData.EnvColor = envIBL ;
    // fragData.Specular = envIBL ;
    //***********indirect-specular part********* 
    
    var iblSpecularResult = fragData.Metallic * fragData.EnvColor * materialUniform.specularColor.rgb ;
    //***********indirect-specular part********* 
    
    //***********indirect-ambient part********* 
    var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
    var iblDiffuseResult = irradiance * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
    //irradiance
    //***********indirect-ambient part********* 
    var indirectResult = (iblSpecularResult + iblDiffuseResult * max(sunLight.quadratic,0.05) ) * fragData.Ao ;
    fragData.LightChannel = specColor ;

    // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
    #if USEGBUFFER
        var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
        normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
        ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
        ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
    #endif
    
    #if USE_WORLDPOS
        ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
    #endif
  
    let finalColor =  LinearToGammaSpace(vec3f(specColor + indirectResult) ) ;
    ORI_FragmentOutput.color = vec4<f32>( finalColor ,fragData.Albedo.a) ;
    // ORI_FragmentOutput.color = vec4<f32>( vec3f(specColor) ,fragData.Albedo.a) ;
}

  `,$h=`
  #include "Clearcoat_frag"
  #include "BRDF_frag"
  #include "MathShader"
  #include "FastMathShader"
  #include "Common_frag"
  #include "GlobalUniform"

  #include "PhysicMaterialUniform_frag"
  #include "NormalMap_frag"
  #include "LightingFunction_frag"
  #include "Irradiance_frag"
  #include "ColorUtil_frag"
  #include "BxdfDebug_frag"


 
  //ORI_ShadingInput
  fn initFragData() {
      fragData.Albedo = ORI_ShadingInput.BaseColor ;
      fragData.Ao = clamp( pow(ORI_ShadingInput.AmbientOcclusion,materialUniform.ao) , 0.0 , 1.0 ) ; 
      fragData.Roughness = clamp((ORI_ShadingInput.Roughness),0.003,1.0) ; 
      fragData.Metallic = ORI_ShadingInput.Metallic ; 
      fragData.Emissive = ORI_ShadingInput.EmissiveColor.rgb ; 
      fragData.N = ORI_ShadingInput.Normal;
      let viewDir = normalize(globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz) ;
      fragData.V = viewDir ;
      #if USE_TANGENT
        fragData.T = ORI_VertexVarying.TANGENT.xyz ;
      #endif
 
      let R = 2.0 * dot( fragData.V , fragData.N ) * fragData.N - fragData.V ;
      fragData.R = R ;//reflect( fragData.V , fragData.N ) ;

      fragData.NoV = saturate(dot(fragData.N, fragData.V)) ;

      fragData.F0 = mix(vec3<f32>(materialUniform.specularColor.rgb), fragData.Albedo.rgb, fragData.Metallic);
      
      fragData.F = computeFresnelSchlick(fragData.NoV, fragData.F0);
      fragData.KD = vec3<f32>(fragData.F) ;
      fragData.KS = vec3<f32>(0.0) ;

      fragData.Indirect = 0.0 ;
      fragData.Reflectance = 1.0 ;

      fragData.ClearcoatRoughness = materialUniform.clearcoatRoughnessFactor ;
      #if USE_CLEARCOAT_ROUGHNESS
        fragData.ClearcoatRoughness = getClearcoatRoughness() * materialUniform.clearcoatRoughnessFactor;
      #endif
  }

  fn BsDFShading(){
      initFragData();

      var irradiance = vec3<f32>(0.0) ;
      #if USEGI
          irradiance += getIrradiance().rgb ;
      #else
          let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
          irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, fragData.N.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);
      #endif
      irradiance = ORI_ShadingInput.SSS + LinearToGammaSpace(irradiance.rgb);
      fragData.Irradiance = irradiance.rgb ;

   

      //***********lighting-PBR part********* 
      var specColor = vec3<f32>(0.0) ;
      let lightIndex = getCluster();
      let start = max(lightIndex.start, 0.0);
      let count = max(lightIndex.count, 0.0);
      let end = max(start + count , 0.0);
      for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
      {
          let light = getLight(i32(i));
          switch (light.lightType) {
            case PointLightType: {
              specColor += pointLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic,light) ;
            }
            case DirectLightType: {
              specColor += directDulLighting( fragData.Albedo.rgb ,fragData.N,fragData.V,fragData.Roughness ,fragData.Metallic, light , globalUniform.shadowBias) ;
            }
            case SpotLightType: {
              specColor += spotLighting( fragData.Albedo.rgb,ORI_VertexVarying.vWorldPos.xyz,fragData.N,fragData.V,fragData.Roughness,fragData.Metallic , light ) ;
            }
            default: {
            }
          }
      }


      fragData.LightChannel = specColor ;

      let sunLight = lightBuffer[0] ;
      //***********lighting-PBR part********* 
      var F = FresnelSchlickRoughness(fragData.NoV, fragData.F0, fragData.Roughness);
      var kS = F;
      var kD = vec3(1.0) - kS;
      kD = kD * (1.0 - fragData.Metallic);
      let envIBL =  materialUniform.envIntensity * approximateSpecularIBL( F , fragData.Roughness , fragData.R , fragData.NoV ) ;
      fragData.EnvColor = envIBL ;
      //***********indirect-specular part********* 
      
      var surfaceReduction = 1.0/(fragData.Roughness*fragData.Roughness+1.0);   
      var oneMinusReflectivity = oneMinusReflectivity(fragData.Metallic , materialUniform.materialF0.r );
      var grazingTerm = clamp((1.0 - fragData.Roughness ) + (1.0 - oneMinusReflectivity),0.0,1.0);
      var t = pow5(fragData.NoV);
      var fresnelLerp = FresnelLerp(fragData.NoV,fragData.F0.rgb,vec3<f32>(grazingTerm)) ;   
      var iblSpecularResult = surfaceReduction * fragData.EnvColor * fresnelLerp + envIBL;
      iblSpecularResult *= max(sunLight.quadratic,0.05) ;
      //***********indirect-specular part********* 
      
      //***********indirect-ambient part********* 
      var kdLast = (1.0 - fragData.F0.r) * (1.0 - fragData.Metallic);    
      //  Dim the edges, there should be more specular reflection at the edges
      var iblDiffuseResult = irradiance * 2.0 * kdLast * fragData.Albedo.rgb * (vec3(1.0) - kS) ;
      //irradiance
      //***********indirect-ambient part********* 
      var indirectResult = (iblSpecularResult + iblDiffuseResult) * fragData.Ao * max(sunLight.quadratic,0.05);
      // debugOut = vec4f(iblDiffuseResult,1.0);

      ORI_FragmentOutput.color = vec4<f32>(0.0);

      // Using stripped down, 'pure log', formula. Parameterized by grey points and dynamic range covered.
      #if USEGBUFFER
          var normal_rgba8unorm = (ORI_VertexVarying.vWorldNormal + 1.0) * 0.5;
          normal_rgba8unorm = clamp(normal_rgba8unorm, vec3<f32>(0.0), vec3<f32>(1.0));
          ORI_FragmentOutput.worldNormal = vec4<f32>(normal_rgba8unorm,1.0);
          ORI_FragmentOutput.material = vec4<f32>(1.0,fragData.Roughness,fragData.Metallic,1.0);
      #endif
      
      #if USE_WORLDPOS
          ORI_FragmentOutput.worldPos = vec4<f32>(ORI_VertexVarying.vWorldPos.xyzw);
      #endif
      
      var color = specColor + indirectResult ;
      color += fragData.Emissive.xyz ;

      var clearCoatColor = vec3<f32>(0.0);
      #if USE_CLEARCOAT
        let clearCoatBaseColor = vec3<f32>(1.0) * materialUniform.baseColor.rgb ;
        let clearNormal = fragData.N ;
        let clearcoatRoughness = fragData.ClearcoatRoughness ;
        let att = sunLight.intensity ;
        let clearCoatLayer = ClearCoat_BRDF( color , materialUniform.clearcoatColor.rgb , materialUniform.ior , clearNormal , -sunLight.direction ,-fragData.V , materialUniform.clearcoatWeight , clearcoatRoughness , att );
        color = vec3<f32>(clearCoatLayer.rgb/fragData.Albedo.a) ; 
      #endif
      
      let retColor = (LinearToGammaSpace(color.rgb));
      ORI_FragmentOutput.color = vec4<f32>( retColor ,fragData.Albedo.a) ;
  }

  `,eu=`
    #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let color = textureSample(baseMap,baseMapSampler,uv) ;
        if(color.w < materialUniform.alphaCutoff){
            discard ;
        }
        
        ORI_ShadingInput.BaseColor = color * materialUniform.baseColor ;
        UnLit();
    }
`,tu=`
    #include "Common_vert"
    #include "Common_frag"
    #include "ClusterLight"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 
        let baseColor = textureSample(baseMap,baseMapSampler,uv) ;
        if(baseColor.w < materialUniform.alphaCutoff){
            discard ;
        }

        var lightColor = vec4<f32>(0.0);
        let lightIndex = getCluster();
        let start = max(lightIndex.start, 0.0);
        let count = max(lightIndex.count, 0.0);
        let end = max(start + count , 0.0);
        for(var i:i32 = i32(start) ; i < i32(end); i += 1 )
        {
          let light = getLight(i32(i));
  
          switch (light.lightType) {
            case PointLightType: {
            }
            case DirectLightType: {
                var normal = ORI_VertexVarying.vWorldNormal ;
                let intensity = (light.intensity/10.0);
                let att = max(dot(normal,-light.direction),0.0) * intensity ;
                lightColor += baseColor * att * 0.5 + baseColor * 0.5 ; 
                // lightColor = baseColor * 0.5; 
            }
            case SpotLightType: {
            }
            default: {
            }
          }
        }
        
        ORI_ShadingInput.BaseColor = lightColor * materialUniform.baseColor;
        if(ORI_ShadingInput.BaseColor.w > 1.0){
            ORI_ShadingInput.BaseColor.w = 1.0;
        }
        UnLit();

        // let n = globalUniform.near ;
        // let f = globalUniform.far ;
        // let z = ORI_VertexVarying.fragCoord.z ;
        // ORI_FragmentOutput.out_depth = z * (n/(f-n)) ;
    }
`,ru=`
    #include "WorldMatrixUniform"
    #include "GlobalUniform"

    struct VertexOutput {
        @location(auto) fragUV: vec2<f32>,
        @builtin(position) member: vec4<f32>
    };

    @vertex
    fn main(@builtin(instance_index) index : u32, @location(auto) position: vec3<f32>, @location(auto) TEXCOORD_1: vec2<f32>) -> VertexOutput {
        let id = u32(index);
        let worldMatrix = models.matrix[id];

        let screenPos = vec2(((TEXCOORD_1 * 2.0) - vec2<f32>(1.0))) * 0.5 ; 
        return VertexOutput(TEXCOORD_1, vec4<f32>(screenPos, 0.0, 1.0));
    }
`,iu=`
#version 450

layout(location = 0) in vec2 fragUV;

layout(location = 0) out vec4 o_Target;

layout(set = 0, binding = 0) uniform ConstUniform {
    mat4 projMat;
    mat4 viewMat;
    mat4 shadowMatrix;
    mat4 cameraWorldMatrix;
    mat4 pvMatrixInv;
    float frame;
    float time;
    float delta;
    float shadowBias;
    float skyExposure;
    float renderPassState;
    float quadScale;

};

layout(set = 2, binding = 0) uniform sampler baseMapSampler;
layout(set = 2, binding = 1) uniform texture2D baseMap;
layout(set = 3, binding = 0) uniform MaterialDataUniform {
    vec4 color;
};

void main() {
        vec2 uv = fragUV.xy;
    uv.y = 1.0 - uv.y;
        vec4 colorTexture = texture(sampler2D(baseMap, baseMapSampler), uv * quadScale) * color;
    o_Target = vec4(colorTexture.rgb, colorTexture.a);

    if (o_Target.r <= 0.5 && o_Target.g <= 0.5 && o_Target.b <= 0.5) {
        discard;
    }
    // float gamma     = 2.2;
    // float exposure  = 1.0;
    // float pureWhite = 1.0;

    // float luminance = dot(colorTexture.rgb, vec3(0.2126, 0.7152, 0.0722));
    // float mappedLuminance = (luminance * (1.0 + luminance/(pureWhite*pureWhite))) / (1.0 + luminance);

    // // Scale color by ratio of average luminances.
    // vec3 mappedColor = (mappedLuminance / luminance) * colorTexture.rgb;

    // // Gamma correction.
    // o_Target = vec4(pow(o_Target.rgb, vec3(1.0/gamma)), 1.0);
};
`,au=`
#include "GlobalUniform"
#include "ColorUtil_frag"

struct uniformData {
    eyesPos: vec3<f32>,
    exposure: f32,
    roughness: f32,
};

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

@group(1) @binding(4)
var baseMapSampler: sampler;
@group(1) @binding(5)
var baseMap: texture_cube<f32>;

@group(2) @binding(0)
var<uniform> global: uniformData;

@fragment
fn main(@location(auto) fragUV: vec2<f32>,@location(auto) vClipPos: vec4<f32>, @location(auto) vWorldPos: vec4<f32>, @location(auto) vWorldNormal: vec3<f32> , @builtin(position) fragCoord : vec4<f32> ) -> FragmentOutput {
    let maxLevel: u32 = textureNumLevels(baseMap);
    let textureColor:vec3<f32> = textureSampleLevel(baseMap, baseMapSampler, normalize(vWorldPos.xyz), global.roughness * f32(maxLevel) ).xyz;
    let o_Color = 0.618 * vec4<f32>(LinearToGammaSpace(textureColor) * globalUniform.skyExposure , 1.0);
    let o_Normal = vec4(vWorldNormal,1.0) ;
    let o_Position = vec4<f32>(vWorldPos.xyz,100000.0) ;
    return FragmentOutput(o_Position,o_Normal,o_Color);
}
`,_n=`
#include "Common_vert"
#include "FragmentVarying"
#include "GlobalUniform"

struct FragmentOutput {
    @location(auto) o_Position: vec4<f32>,
    @location(auto) o_Normal: vec4<f32>,
    @location(auto) o_Color: vec4<f32>
};

struct MaterialUniform {
    baseColor: vec4<f32>,
    emissiveColor: vec4<f32>,
    emissiveIntensity: f32,
    normalScale: f32,
    alphaCutoff: f32
};

@group(2) @binding(0)
var<uniform> materialUniform: MaterialUniform;

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var normalMapSampler: sampler;
@group(1) @binding(auto)
var normalMap: texture_2d<f32>;

@group(1) @binding(auto)
var emissiveMapSampler: sampler;
@group(1) @binding(auto)
var emissiveMap: texture_2d<f32>;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

var<private> ORI_FragmentOutput: FragmentOutput;
var<private> ORI_VertexVarying: FragmentVarying;

@fragment
fn FragMain(vertex_varying:FragmentVarying) -> FragmentOutput {
    ORI_VertexVarying = vertex_varying;
    var texColor = textureSample(baseMap, baseMapSampler, ORI_VertexVarying.fragUV0.xy );

    var emissive = textureSample(emissiveMap, emissiveMapSampler, ORI_VertexVarying.fragUV0.xy ).rgb ;
    let intensity = materialUniform.emissiveIntensity * materialUniform.emissiveColor.a ;
    emissive = emissive.rgb * materialUniform.emissiveColor.rgb ;
    emissive = convertToHDRRGB(emissive,intensity);

    if (materialUniform.alphaCutoff-texColor.w > 0.0) {
        discard ;
    }

    var o_Position = vec4<f32>(ORI_VertexVarying.vWorldPos.xyz,emissive.r) ;
    var o_Normal = vec4<f32>((ORI_VertexVarying.vWorldNormal.xyz * 0.5 + 0.5 ),emissive.g) ;
    var o_Color = vec4<f32>((texColor * materialUniform.baseColor).rgb , emissive.b )  ;
    return FragmentOutput(o_Position,o_Normal,vec4<f32>(o_Color));
}

fn convertToHDRRGB( color : vec3<f32> , ins:f32 ) -> vec3<f32> {
    var hdrColor = vec3<f32>(0.0,0.0,0.0);
    hdrColor.r = color.r * pow(2.4, ins);
    hdrColor.g = color.g * pow(2.4, ins);
    hdrColor.b = color.b * pow(2.4, ins);
    return hdrColor;
}
`,su=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Ft.getMorphTargetShaderBinding(2,1)}
#endif

#if USE_SKELETON
    ${ca.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
    @builtin(instance_index) index : u32,
    @location(auto) position: vec3<f32>,
    @location(auto) normal: vec3<f32>,
    @location(auto) uv: vec2<f32>,
    @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_METAHUMAN
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif
    #else
        #if USE_TANGENT
            @location(auto) TANGENT: vec4<f32>,
        #endif

        #if USE_SKELETON
            #if USE_TANGENT
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #else
                @location(auto) joints0: vec4<f32>,
                @location(auto) weights0: vec4<f32>,
                #if USE_JOINT_VEC8
                    @location(auto) joints1: vec4<f32>,
                    @location(auto) weights1: vec4<f32>,
                #endif
            #endif
        #endif

        #if USE_MORPHTARGETS
            #if USE_TANGENT
                @location(auto) vIndex: f32,
            #else
                @location(auto) vIndex: f32,
            #endif
        #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;
    var vertexNormal = vertex.normal.xyz;

    #if USE_MORPHTARGETS
     ${Ft.getMorphTargetCalcVertex()}    
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;

    return VertexOutput(vertex.uv, vPos );  
}
`,ou=`
#include "WorldMatrixUniform"
#include "GlobalUniform"

struct VertexOutput {
    @location(auto) fragUV: vec2<f32>,
    @location(auto) worldPos: vec3<f32>,
    @builtin(position) member: vec4<f32>
};

#if USE_MORPHTARGETS
    ${Ft.getMorphTargetShaderBinding(2,1)}
##endif
 
#if USE_SKELETON
    ${ca.groupBindingAndFunctions(2,1)} 
#endif

var<private> worldMatrix: mat4x4<f32>;

struct VertexAttributes{
  @builtin(instance_index) index : u32,
  @location(auto) position: vec3<f32>,
  @location(auto) normal: vec3<f32>,
  @location(auto) uv: vec2<f32>,
  @location(auto) TEXCOORD_1: vec2<f32>,

  
  #if USE_METAHUMAN
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #else
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        @location(auto) joints1: vec4<f32>,
        @location(auto) weights1: vec4<f32>,
        @location(auto) vIndex: f32,
    #endif
    #else
    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
    #endif

    #if USE_SKELETON
        #if USE_TANGENT
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #else
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #endif
    #endif

    #if USE_MORPHTARGETS
        #if USE_TANGENT
            @location(auto) vIndex: f32,
        #else
            @location(auto) vIndex: f32,
        #endif
    #endif

    #endif
}

@vertex
fn main(vertex:VertexAttributes) -> VertexOutput {
    worldMatrix = models.matrix[vertex.index];
    let shadowMatrix: mat4x4<f32> = globalUniform.projMat * globalUniform.viewMat ;
    var vertexPosition = vertex.position.xyz;

    #if USE_METAHUMAN
        ${Ft.getMorphTargetCalcVertex()}
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    #if USE_MORPHTARGETS
        ${Ft.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
          worldMatrix *= getSkeletonWorldMatrix_8(vertex.joints0, vertex.weights0, vertex.joints1, vertex.weights1);
        #else
          worldMatrix *= getSkeletonWorldMatrix_4(vertex.joints0, vertex.weights0);
        #endif
    #endif

    var worldPos = worldMatrix * vec4<f32>(vertexPosition, 1.0) ;
    var vPos = shadowMatrix * worldPos;
    return VertexOutput(vertex.uv, worldPos.xyz , vPos ); 
}
`,nu=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) worldPos:vec3<f32> ) -> FragmentOutput {
        var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      #if USE_ALPHACUT
        let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
        if(Albedo.w > 0.5){
          fragOut = FragmentOutput(vec4<f32>(0.0),distance);
        }
      #else
        fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      #endif
      
        return fragOut ;
    }
`,lu=`
    #if USE_ALPHACUT
      @group(1) @binding(0)
      var baseMapSampler: sampler;
      @group(1) @binding(1)
      var baseMap: texture_2d<f32>;
    #endif

    struct FragmentOutput {
      @location(auto) o_Target: vec4<f32>,
      @builtin(frag_depth) out_depth: f32
    };

    struct MaterialUniform {
      lightWorldPos: vec3<f32>,
      cameraFar: f32,
    };

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    @fragment
    fn main(@location(auto) fragUV: vec2<f32> , @location(auto) clipPos:vec3<f32> ) -> FragmentOutput {
        // var distance = length(worldPos.xyz - materialUniform.lightWorldPos ) ;
        // distance = distance / materialUniform.cameraFar ;
        var fragOut:FragmentOutput; 

      // #if USE_ALPHACUT
      //   let Albedo = textureSample(baseMap,baseMapSampler,fragUV);
      //   if(Albedo.w > 0.5){
      //     fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      //   }
      // #else
      //   fragOut = FragmentOutput(vec4<f32>(0.0),distance);
      // #endif
      
        return fragOut ;
    }
`,hu=`
    #include "GlobalUniform"
    #include "MathShader"
    struct VertexOutput {
        @location(auto) vID: f32 ,
        @location(auto) vPos: vec3<f32> ,
        @location(auto) vClipPos: vec4<f32> ,
        @builtin(position) member: vec4<f32>
    };

    struct Uniforms {
        matrix : array<mat4x4<f32>>
    };

    @group(0) @binding(1)
    var<storage, read> models : Uniforms;

    var<private> worldMatrix: mat4x4<f32>;

    #if USE_MORPHTARGETS
        ${Ft.getMorphTargetShaderBinding(1,0)}
    #endif

    #if USE_SKELETON
        ${ca.groupBindingAndFunctions(1,0)}
    #endif

    @vertex
    fn main(
        @builtin(instance_index) index : u32,
        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,

    #if USE_TANGENT
        @location(auto) TANGENT: vec4<f32>,
        #if USE_SKELETON
            @location(auto) joints0: vec4<f32>,
            @location(auto) weights0: vec4<f32>,
            #if USE_JOINT_VEC8
                @location(auto) joints1: vec4<f32>,
                @location(auto) weights1: vec4<f32>,
            #endif
        #elseif USE_MORPHTARGETS
            @location(auto) vIndex: f32,
        #endif
    #elseif USE_SKELETON
        @location(auto) joints0: vec4<f32>,
        @location(auto) weights0: vec4<f32>,
        #if USE_JOINT_VEC8
            @location(auto) joints1: vec4<f32>,
            @location(auto) weights1: vec4<f32>,
        #endif
    #elseif USE_MORPHTARGETS
        @location(auto) vIndex: f32,
    #endif
    ) -> VertexOutput {
    worldMatrix = models.matrix[index];

    var vertexPosition = position;
    var vertexNormal = normal;
    #if USE_MORPHTARGETS
        ${Ft.getMorphTargetCalcVertex()}
    #endif

    #if USE_SKELETON
        #if USE_JOINT_VEC8
            worldMatrix *= getSkeletonWorldMatrix_8(joints0, weights0, joints1, weights1);
        #else
            worldMatrix *= getSkeletonWorldMatrix_4(joints0, weights0);
        #endif
    #endif

        
        let wPos = worldMatrix * vec4<f32>(vertexPosition.xyz, 1.0);
        var fixProjMat = globalUniform.projMat ;
        var rzMatrix : mat4x4<f32> ;
        rzMatrix[0] = vec4<f32>(1.0,0.0,0.0,0.0) ; 
        rzMatrix[1] = vec4<f32>(0.0,1.0,0.0,0.0) ; 
        rzMatrix[2] = vec4<f32>(0.0,0.0,1.0,0.0) ; 
        rzMatrix[3] = vec4<f32>(0.0,0.0,0.0,1.0) ; 
        var clipPos:vec4<f32> = fixProjMat * globalUniform.viewMat * (wPos) ;

        // let d = log2Depth(clipPos.z * (globalUniform.far - globalUniform.near),globalUniform.near,globalUniform.far) ;
        return VertexOutput(f32(index) , wPos.xyz,clipPos, clipPos);
    }

    fn depthToLinear01(depth:f32) -> f32 {
        let a = 1.0 / (globalUniform.near - globalUniform.far);
        return (globalUniform.near*globalUniform.far*a) / (depth + globalUniform.far * a) ;
    }
`,uu=`
    #include "GlobalUniform"
    #include "MathShader"
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>,
        @builtin(frag_depth) out_depth: f32
    };
   

    @fragment
    fn main(@location(auto) vID: f32, @location(auto) vPos:vec3<f32> ,  @location(auto) vClipPos: vec4<f32> ,  @builtin(position) fragCoord : vec4<f32>) -> FragmentOutput {
        var op = vec4<f32>( vPos, vID);
        let d = log2Depth(fragCoord.z+0.00001,globalUniform.near,globalUniform.far);
        return FragmentOutput(op,d);
    }
`,cu=`

    const inv256:f32 = 1.0/256.0;
    const inv1024:f32 = 1.0/1024.0;

    const bit7_inv128:f32 = 1.0 / 128.0;
    const bit7_128:f32 = 128.0;
    
    const r10g10b10 = vec2i(0x3FFFFF,0xFF);
    fn floatToVec3f( v:f32 ) -> vec3f {
        var VPInt:i32 = bitcast<i32>(v);
        var VPInt1024:i32 = VPInt%1024;
        var VPInt10241024:i32 = ((VPInt-VPInt1024)/1024)%1024;
        return vec3f(f32(VPInt1024),f32(VPInt10241024),f32(((VPInt-VPInt1024-VPInt10241024)/1048576)))*vec3f(inv1024);
    }

    fn vec3fToFloat( v:vec3f) -> f32{
        let intv = min(vec3<i32>(floor(v*1024.)),vec3<i32>(1023));
        return bitcast<f32>(i32(intv.x+intv.y*1024+intv.z*1048576));
    }

    fn vec4fToFloat_7bits( v:vec4f) -> f32{
        //0~256
        let intv = min(vec4<i32>(floor(v*bit7_128)),vec4<i32>(127));
        return bitcast<f32>(i32(intv.x+intv.y*128+intv.z*16384+intv.w*2097152));
    }

    fn floatToVec4f_7bits( v:f32 ) -> vec4f {
        var VPInt:i32 = bitcast<i32>(v);
        var VPInt128:i32 = VPInt%128;
        var VPInt128128:i32 = ((VPInt-VPInt128)/128)%128;
        var VPInt128128128:i32 = ((VPInt-VPInt128-VPInt128128)/16384)%128;
        var VPInt128128128128:i32 = ((VPInt-VPInt128-VPInt128128-VPInt128128128)/2097152)%128;
        return vec4f(f32(VPInt128),f32(VPInt128128),f32(VPInt128128128),f32(VPInt128128128128))*vec4f(bit7_inv128);
    }






    const i_r11g11b11 = vec3i(0x7FF,0x7FF,0x7FF);
    const f_r11g11b11 = vec3f(f32(0x7FF),f32(0x7FF),f32(0x7FF));
    fn r11g11b11_to_float( v:vec3f) -> f32{
        let iR: i32 = i32(v.r * f_r11g11b11.r);
        let iG: i32 = i32(v.g * f_r11g11b11.g);
        let iB: i32 = i32(v.b * f_r11g11b11.b);
        return bitcast<f32>((iR << 22u) | (iG << 11u) | iB );
    }

    fn float_to_r11g11b11( v:f32 ) -> vec3f {
        let iV: i32 = bitcast<i32>(v);
        var r: f32 = f32((iV >> 22u) & i_r11g11b11.r) / f_r11g11b11.r;
        var g: f32 = f32((iV >> 11u) & i_r11g11b11.g) / f_r11g11b11.g;
        var b: f32 = f32(iV & i_r11g11b11.b) / f_r11g11b11.b ;
        return vec3f(r,g,b);
    }

    const i_r22g8 = vec2i(0x3FFFFF,0xFF);
    const f_r22g8 = vec2f(f32(0x3FFFFF),f32(0xFF));
    fn r22g8_to_float( v:vec2f) -> f32{
        let iR: i32 = i32(v.r * f_r22g8.r);
        let iG: i32 = i32(v.g * f_r22g8.g);
        return bitcast<f32>((iR << 8u) | iG);
    }

    fn float_to_r22g8( v:f32 ) -> vec2f {
        let iV: i32 = bitcast<i32>(v);
        var r: f32 = f32((iV >> 8u) & i_r22g8.r) / f_r22g8.r;
        var g: f32 = f32(iV & i_r22g8.g) / f_r22g8.g ;
        return vec2f(r,g);
    }

    const r11g11b9 = vec3i(0x7FF,0x7FF,0x1FF);
    fn r11g11b9_to_float( v:vec3f) -> f32{
        let iR: i32 = i32(v.r * f32(r11g11b9.r));
        let iG: i32 = i32(v.g * f32(r11g11b9.g));
        let iB: i32 = i32(v.b * f32(r11g11b9.b));
        return bitcast<f32>((iR << 20u) | (iG << 9u) | iB );
    }

    fn float_to_r11g11b9( v:f32 ) -> vec3f {
        let iV: i32 = bitcast<i32>(v);
        var r: f32 = f32((iV >> 20u) & r11g11b9.r) / f32(r11g11b9.r);
        var g: f32 = f32((iV >> 9u) & r11g11b9.g) / f32(r11g11b9.g);
        var b: f32 = f32(iV & r11g11b9.b) / f32(r11g11b9.b) ;
        return vec3f(r,g,b);
    }




    fn floatToRGBA(v:f32) -> vec4f{
        var iv = bitcast<u32>(v);
        var color = vec4f(0.0);
        color.x = f32((iv&0x00FF0000u)>>16u)/255.0;
        color.y = f32((iv&0x000FF00u)>>8u)/255.0;
        color.z = f32(iv&0x000000FFu)/255.0;
        return color;
    }

    const bitShift:vec4f = vec4f(1.0, 1.0/256.0, 1.0/(256.0*256.0), 1.0/(256.0*256.0*256.0));
    fn RGBAToFloat(v:vec4f) -> f32 {
        var f = dot(v, bitShift);
        return f;
    }

`,fu=`
    #include "MathShader"
    #include "FastMathShader"
    #include "BitUtil"
    #include "ColorUtil_frag"

    @group(0) @binding(1) var gBufferTexture : texture_2d<f32>;

    struct GBuffer{
        x : f32 ,
        y : f32 ,
        z : f32 ,
        w : f32 ,
    }

    struct ViewSpaceGBuffer{
        depth:f32,
        color:vec3f ,
        abldeoColor:vec3f ,
        viewPosition:vec3f,
        viewNormal:vec3f,
        roughness:f32,
        metallic:f32,
    }

    struct WorldSpaceGBuffer{
        depth:f32,
        color:vec3f ,
        abldeoColor:vec3f ,
        worldPosition:vec3f,
        worldNormal:vec3f,
        roughness:f32,
        metallic:f32,
    }

    fn getViewSpaceGBuffer(fragCoord:vec2i , uv:vec2f ) -> ViewSpaceGBuffer {
        var sampleUV = uv ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let gBufferTexture = textureLoad(gBufferTexture, fragCoord , 0) ;

        var gBuffer : ViewSpaceGBuffer ;
        //x channel view space depth 
        gBuffer.depth = gBufferTexture.x ;
        let viewPos = getViewPosition(gBufferTexture.x,sampleUV);
        gBuffer.viewPosition = viewPos;
        
        //y channel last final color texture
        gBuffer.color = floatToVec3f(gBufferTexture.y) ;

        //z channel view space normal 
        let zChannel = floatToVec3f(gBufferTexture.z) ;
        let octUV = zChannel.xy * 2.0 - 1.0  ;
        gBuffer.viewNormal = octDecode(octUV.xy) ;

        //w channel view space normal 
        let wChannel = floatToVec3f(gBufferTexture.w) ;
        gBuffer.abldeoColor = wChannel.xyz ;

        gBuffer.roughness = zChannel.z ;
        gBuffer.metallic = 0.0 ;//wChannel.w ;

        return gBuffer ;
    }

    fn getWorldSpaceGBuffer(fragCoord:vec2i , uv:vec2f ) -> WorldSpaceGBuffer {
        var sampleUV = uv ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let gBufferTexture = textureLoad(gBufferTexture, fragCoord , 0) ;

        var gBuffer : WorldSpaceGBuffer ;
        //x channel view space depth 
        gBuffer.depth = gBufferTexture.x ;
        let worldPos = getWorldPosition(gBufferTexture.x,sampleUV);
        gBuffer.worldPosition = worldPos;

        //y channel last final color texture
        gBuffer.color = floatToVec3f(gBufferTexture.y) ;

        //z channel world space normal and roughness 
        let zChannel = floatToVec3f(gBufferTexture.z) ;
        let octUV = zChannel.xy * 2.0 - 1.0  ;
        gBuffer.worldNormal = getWorldNormal(octDecode(octUV.xy)) ;

        //w channel abldeoColor and metallic
        let wChannel = floatToVec3f(gBufferTexture.w) ;
        gBuffer.abldeoColor = wChannel.xyz ;

        gBuffer.roughness = zChannel.z ;
        gBuffer.metallic = 0.0 ;//wChannel.w ;

        return gBuffer ;
    }

    fn getGBuffer(fragCoord:vec2i) -> GBuffer {
        let gBufferTexture = textureLoad(gBufferTexture, fragCoord , 0) ;
        var gBuffer:GBuffer ;
        gBuffer.x = gBufferTexture.x ;
        gBuffer.y = gBufferTexture.y ;
        gBuffer.z = gBufferTexture.z ;
        gBuffer.w = gBufferTexture.w ;
        return gBuffer ;
    }

    fn getDepthFromGBuffer(gBuffer:GBuffer) -> f32 {
        return gBuffer.x ;
    }

    fn getViewPositionFromGBuffer(gBuffer:GBuffer,screenUV:vec2f) -> vec3f {
        var sampleUV = screenUV ;
        sampleUV.x = 1.0 - sampleUV.x ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let viewPos = getViewPosition(gBuffer.x,sampleUV);
        return viewPos;
    }

    fn getViewNormalFromGBuffer(gBuffer:GBuffer) -> vec3f {
        let worldNormal = getWorldNormalFromGBuffer(gBuffer) ;
        return getViewNormal(worldNormal);
    }

    fn getWorldPositionFromGBuffer(gBuffer:GBuffer,uv:vec2f) -> vec3f {
        var sampleUV = uv ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let worldPos = getWorldPosition(gBuffer.x,sampleUV);
        return worldPos;
    }

    fn getSkyPositionFromGBuffer(uv:vec2f) -> vec3f {
        var sampleUV = uv ;
        sampleUV.y = 1.0 - sampleUV.y ;
        let worldPos = getWorldPosition(0.9999999, sampleUV);
        return worldPos;
    }

    fn getRGBMColorFromGBuffer(gBuffer:GBuffer) -> vec3f {
        let rgb = unpack4x8unorm(u32(gBuffer.z)).rgb ;
        let m = unpack4x8unorm(u32(gBuffer.w)).z ;
        return DecodeRGBM(vec4f(rgb,m)) ;
    }

   
    fn getWorldNormalFromGBuffer(gBuffer:GBuffer) -> vec3f {
        // let viewNormal = getViewNormalFromGBuffer(gBuffer) ; 
        // let worldNormal = getWorldNormal(viewNormal) ;
        // return worldNormal;
        let zChannel = float_to_r11g11b9(gBuffer.y) ;
        let octUV = zChannel.xy * 2.0 - 1.0  ;
        let viewNormal = octDecode(octUV.xy);
        return viewNormal;
    }



    fn getAbldeoFromGBuffer(gBuffer:GBuffer) -> vec4f {
        let rgba = floatToVec4f_7bits(gBuffer.z).rgba ;
        return rgba ;
    }

    fn getAlphaFromGBuffer(gBuffer:GBuffer) -> f32 {
        let rgba = floatToVec4f_7bits(gBuffer.z).rgba ;
        return rgba.a;
    }

    fn getMetaillicFromGBuffer(gBuffer:GBuffer) -> f32 {
        let channel = float_to_r22g8(gBuffer.w) ;
        return channel.y;
    }

    fn getRoughnessFromGBuffer(gBuffer:GBuffer) -> f32 {
        let channel = float_to_r11g11b9(gBuffer.y) ;
        return channel.z;
    }

    fn getIDFromGBuffer_f32_01(gBuffer:GBuffer) -> f32 {
        let channel = float_to_r22g8(gBuffer.w) ;
        return channel.x;
    }

    fn getIDFromGBuffer_i32(gBuffer:GBuffer) -> i32 {
        let id_f32_01 = getIDFromGBuffer_f32_01(gBuffer) ;
        let id = i32(round(id_f32_01 * f_r22g8.r));
        return id;
    }

    
`,du=`
    #include "Common_vert"
    #include "Common_frag"
    #include "GlobalUniform"
    #include "BitUtil"
    #include "MathShader"
    #include "ReflectionCG"
    #include "ColorUtil_frag"
    
    struct MaterialUniform {
        transformUV1:vec4<f32>,
        transformUV2:vec4<f32>,
        baseColor: vec4<f32>,
        alphaCutoff: f32,
        reflectionIndex : f32,
    };

    // @group(1) @binding(0)
    // var baseMapSampler: sampler;
    // @group(1) @binding(1)
    // var baseMap: texture_2d<f32>;
    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        useSphereReflection();
        var finalColor : vec3f ;
        let scale = vec2f(1.0/8.0,1.0/globalUniform.reflectionProbeMaxCount) ;
        var uv = (octEncode(-ORI_VertexVarying.vWorldNormal) + 1.0) * 0.5 ;
        var uv1 = uv * scale + vec2f(0.0,(materialUniform.reflectionIndex * scale.y )) ;
        let gBuffer = textureSampleLevel(reflectionMap,reflectionMapSampler,uv1,0.0);
        ORI_ShadingInput.BaseColor = vec4f(gBuffer.rgb,1.0) ;
        UnLit();
    }

    fn UnLit(){
        var viewColor = ORI_ShadingInput.BaseColor ;
            let finalMatrix = globalUniform.projMat * globalUniform.viewMat ;
            let nMat = mat3x3<f32>(finalMatrix[0].xyz,finalMatrix[1].xyz,finalMatrix[2].xyz) ;
            let ORI_NORMALMATRIX = transpose(inverse( nMat ));

            var vNormal = normalize(ORI_NORMALMATRIX * (ORI_VertexVarying.vWorldNormal ));
            var worldNormal = vec3<f32>( (vNormal.xyz + 1.0) * 0.5);

            let gBuffer = packNHMDGBuffer(
                ORI_VertexVarying.fragCoord.z,
                vec3f(0.0),
                viewColor.rgb,
                vec3f(0.0),
                vNormal,
                viewColor.a
            );

            #if USE_CASTREFLECTION
                ORI_FragmentOutput.gBuffer = gBuffer ;
            #else
                ORI_FragmentOutput.color = viewColor ;
                ORI_FragmentOutput.gBuffer = gBuffer ;
            #endif
    }
`,gu=`
    #include 'MathShader'
    #include 'BitUtil'
    #include 'GlobalUniform'

    struct ReflectionInfo{
        gid:f32,
        worldPosition:vec3f,
        radius:f32,
        worldPosition2:vec3f,
    }

    @group(1) @binding(auto)
    var reflectionMap: texture_2d<f32>;
    @group(1) @binding(auto)
    var reflectionMapSampler: sampler;

    @group(2) @binding(8) 
    var<storage,read> reflectionBuffer : array<ReflectionInfo>;

    var<private> reflectionSize : vec2f ; 
    var<private> PROBE_SOURCESIZE : vec2f ; 
    var<private> PROBEMAP_SOURCESIZE : vec2f ; 
    var<private> aspect : vec2f ; 
    var<private> spaceV : f32 ; 

    fn useSphereReflection(){
        reflectionSize = vec2f(textureDimensions(reflectionMap).xy);
        PROBE_SOURCESIZE = vec2f(globalUniform.reflectionProbeSize);
        PROBEMAP_SOURCESIZE = vec2f(globalUniform.reflectionMapWidth,globalUniform.reflectionMapHeight) ;
        aspect = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
        spaceV = 1.0 / globalUniform.reflectionProbeMaxCount;
    }

    fn getSampleProbeUV(dir:vec3<f32>,gid:f32) -> vec2<f32> {
        let faceId = dir_to_faceId(dir);
        var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
        targetUV.x = 1.0 - targetUV.x;
        // targetUV.y = 1.0 - targetUV.y;
        let threshould = 0.5 / PROBE_SOURCESIZE;
        targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));
     
        targetUV.x = f32(faceId) + targetUV.x;
        targetUV = targetUV * aspect ;
        targetUV.y = targetUV.y + (spaceV*gid);
        return targetUV ;
     }

    //  fn getReflectionsMap(n:vec3<f32>,gid:f32) -> vec3f {
    //     var uv = getSampleProbeUV(-n,gid);
    //     let color = textureSample(reflectionMap,reflectionMapSampler,uv) ;
    //     return floatToVec3f(color.y) ;
    //  }

    const magic = vec4f(0.9852,0.99214,0.00754,0.0);
     fn getReflectionsBuffer(n:vec3<f32>,gid:f32,mip:f32) -> vec4f {
        let scaleA = vec2f(1.0/8.0,1.0/globalUniform.reflectionProbeMaxCount) ;
        let mipSource = clamp((mip * 8.0),0.0,8.0) ;
        let mip1 = floor(mipSource) ;
        let mip2 = mip1 + 1.0 ;
        let mipPect = mipSource - mip1 ;
        var uv = (octEncode(-n) + 1.0) * 0.5 * magic.xy + magic.zw ;
        var uv1 = (uv * scaleA + vec2f((mip1 * (scaleA.x)) ,0.0 ));
        var uv2 = (uv * scaleA + vec2f((mip2 * (scaleA.x)) ,0.0 ));
        let b1 = textureSampleLevel(reflectionMap,reflectionMapSampler,uv1,0.0);
        let b2 = textureSampleLevel(reflectionMap,reflectionMapSampler,uv2,0.0);
        let b1Color = b1.rgb ;
        let b2Color = b2.rgb ;

        // let rgb1 = unpack4x8unorm(u32(b1.z)).rgb ;
        // let rgb2 = unpack4x8unorm(u32(b2.z)).rgb ;

        // let m1 = unpack4x8unorm(u32(b1.w)).z ;
        // let m2 = unpack4x8unorm(u32(b2.w)).z ;

        // let b1Color = DecodeRGBM(vec4f(rgb1,m1));
        // let b2Color = DecodeRGBM(vec4f(rgb2,m2));

        // let b1D = b1.x; 
        // let b2D = b2.x; 

        let color = mix(b1Color,b2Color,vec3f(mipPect));  ;
        // let depth = mix(b1D,b2D,(mipPect)); 
        // return vec4f(color,depth) ;
        return vec4f(color,0.0) ;
     }

     fn getReflectionsEnv(reflectDir:vec3<f32>,worldPos:vec3f,mip:f32) -> vec3f{
        let maxCount = u32(globalUniform.reflectionProbeMaxCount) ;
        var nearColor = vec3f(0.0);
        if(globalUniform.reflectionCount > 0.0){
            var nearDistance = 99999.0 ;
            var nearReflectionIndex = 0u ;
            for(var i = 0u ; i < maxCount; i+=1u){
                var reflectionInfo = reflectionBuffer[i];
                let dis = length(reflectionInfo.worldPosition - worldPos) ;
                if(dis < nearDistance){
                    nearDistance = dis;
                    nearReflectionIndex = i;
                }
            }
            nearColor = getReflectionsBuffer(reflectDir,f32(nearReflectionIndex),mip).xyz;
        }else{
            nearColor = textureSampleLevel(envMap, envMapSampler, reflectDir , mip * 12.0 ).rgb ;
        }
        return nearColor ;
     }

    //  fn getReflectionsEnv(n:vec3<f32>,worldPos:vec3f,mip:f32) -> vec3f{
    //     let count = 1.0 ;//globalUniform.reflectionProbeMaxCount ;
    //     var nearColor = vec3f(0.0);
    //     var nearDistance = 99999.0 ;
    //     for(var i = 0.0 ; i < count; i+=1.0){
    //         var reflectionInfo = reflectionBuffer[i32(i)];
    //         let dis = length(reflectionInfo.worldPosition - worldPos) ;
    //         if(dis > reflectionInfo.radius){
    //             var buffer = getReflectionsBuffer(n,i,mip);
    //             var d = buffer.w;
    //             if(d <= -globalUniform.far){
    //                 d = 99999.0 - 1.0 ;
    //             }
    //             if(nearDistance > d){
    //                 nearColor = buffer.xyz;
    //                 nearDistance = d;
    //             }
    //         }else{
    //             nearColor = vec3f(1.0,0.0,0.0);
    //         }
    //     }
    //     return nearColor ;
    //  }


`,pu=`

fn Y0(v : vec3f ) -> f32 {
     return ((1.0 / 2.0) * sqrt(1.0 / PI)); 
}

fn Y1(v: vec3f ) -> f32 {
    return ( sqrt(3.0 / (4.0 * PI)) * v.z ) ;
}

fn Y2(v: vec3f ) -> f32 { 
    return (sqrt(3.0 / (4.0 * PI)) * v.y) ;
}

fn Y3(v: vec3f ) -> f32 {  
    return (sqrt(3.0 / (4.0 * PI)) * v.x) ;
}

fn Y4(v: vec3f ) -> f32 { 
    return (1.0 / 2.0 * sqrt(15.0 / PI) * v.x * v.z) ;
}

fn Y5(v: vec3f ) -> f32 { 
    return (1.0 / 2.0 * sqrt(15.0 / PI) * v.z * v.y) ;
}

fn Y6(v: vec3f ) -> f32 { 
    return (1.0 / 4.0 * sqrt(5.0 / PI) * (-v.x * v.x - v.z * v.z + 2.0 * v.y * v.y)) ;
}

fn Y7(v: vec3f ) -> f32 { 
    return (1.0 / 2.0 * -sqrt(15.0 / PI) * v.y * v.x) ;
}

fn Y8(v: vec3f ) -> f32 { 
    return (1.0 / 4.0 * sqrt(15.0 / PI) * (v.x * v.x - v.z * v.z)) ;
}

fn Y9(v: vec3f ) -> f32 { 
    return (1.0 / 4.0 * sqrt(35.0 / (2.0 * PI)) * (3.0 * v.x * v.x - v.z * v.z) * v.z) ;
}

fn Y10(v: vec3f ) -> f32 { 
    return ( 1.0 / 2.0 * sqrt(105.0 / PI) * v.x * v.z * v.y );
}

fn Y11(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(21.0 / (2.0 * PI)) * v.z * (4.0 * v.y * v.y - v.x * v.x - v.z * v.z) );
}

fn Y12(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(7.0 / PI) * v.y * (2 * v.y * v.y - 3.0 * v.x * v.x - 3.0 * v.z * v.z) );
}

fn Y13(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(21.0 / (2.0 * PI)) * v.x * (4.0 * v.y * v.y - v.x * v.x - v.z * v.z) );
}

fn Y14(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(105.0 / PI) * (v.x * v.x - v.z * v.z) * v.y );
}

fn Y15(v: vec3f ) -> f32 { 
    return ( 1.0 / 4.0 * sqrt(35.0 / (2.0 * PI)) * (v.x * v.x - 3.0 * v.z * v.z) * v.x );
}

fn SH9(dir: vec3<f32>, coefficients: array<vec4f, 9>) -> vec4<f32> {
    let N: vec3<f32> = vec3<f32>(dir.z, dir.y, dir.x);
    let v: vec3<f32> = normalize(N);

    let color = coefficients[0] * Y0(v)  
        + coefficients[1] * Y1(v) 
        + coefficients[2] * Y2(v) 
        + coefficients[3] * Y3(v) 
        + coefficients[4] * Y4(v) 
        + coefficients[5] * Y5(v) 
        + coefficients[6] * Y6(v) 
        + coefficients[7] * Y7(v)  
        + coefficients[8] * Y8(v) 
    ;
    
    return vec4(color.rgb,1.0) ;
}
`;class H{static init(){H.register("MathShader",Ah),H.register("FastMathShader",Dh),H.register("BitUtil",cu),H.register("GBufferStand",fu),H.register("SHCommon_frag",pu),H.register("MatrixShader",qh),H.register("GlobalUniform",vn),H.register("WorldMatrixUniform",xn),H.register("NormalMap_frag",Mh),H.register("LightingFunction_frag",mh),H.register("PhysicMaterialUniform_frag",vh),H.register("UnLitMaterialUniform_frag",xh),H.register("VideoUniform_frag",yh),H.register("InstanceUniform",Bh),H.register("Inline_vert",Ih),H.register("VertexAttributes_vert",_h),H.register("Common_vert",wh),H.register("Common_frag",bh),H.register("FragmentVarying",Ph),H.register("FragmentOutput",Cn),H.register("ClusterLight",Jh),H.register("ShadingInput",Rh),H.register("IESProfiles_frag",Uh),H.register("ShadowMapping_frag",Lh),H.register("Irradiance_frag",Oh),H.register("IrradianceVolumeData_frag",Sh),H.register("BrdfLut_frag",Th),H.register("EnvMap_frag",Eh),H.register("ColorUtil_frag",Kh),H.register("BRDF_frag",Nh),H.register("Hair_frag",Zh),H.register("BxDF_frag",Fh),H.register("BsDF_frag",$h),H.register("UnLit_frag",Ch),H.register("UnLit",eu),H.register("ReflectionCG",gu),H.register("ReflectionShader_shader",du),H.register("Clearcoat_frag",kh),H.register("LitShader",zh),H.register("PBRLItShader",Gh),H.register("ClusterDebug_frag",ph),H.register("BxdfDebug_frag",Qh),H.register("GenerayRandomDir",jh),H.register("Quad_vert_wgsl",Yh),H.register("Quad_frag_wgsl",Hh),H.register("Quad_depth2d_frag_wgsl",Xh),H.register("Quad_depthCube_frag_wgsl",Wh),H.register("sky_vs_frag_wgsl",ss.sky_vs_frag_wgsl),H.register("sky_fs_frag_wgsl",ss.sky_fs_frag_wgsl),H.register("LambertShader",tu),H.register("QuadGlsl_vs",ru),H.register("QuadGlsl_fs",iu),H.register("SkyGBuffer_fs",au),H.register("gbuffer_vs",_n),H.register("gbuffer_fs",_n),H.register("castPointShadowMap_vert",ou),H.register("shadowCastMap_frag",nu),H.register("shadowCastMap_vert",su),H.register("directionShadowCastMap_frag",lu),H.register("ZPass_shader_vs",hu),H.register("ZPass_shader_fs",uu)}static register(t,e){H[t.toLowerCase()]||(H[t.toLowerCase()]=e)}static getShader(t){return H[t.toLowerCase()],H[t.toLowerCase()]}}class xr{static parse(t,e){return t=this.filterComment(t),t=this.parsePreprocess(new yn,t,e),t=this.parseAutoBindingForAllGroup(t),t=this.parseAutoLocationBlock(t),t}static parseComputeShader(t,e){return t=this.filterComment(t),t=this.parsePreprocess(new yn,t,e),t=this.parseAutoBindingForAllGroup(t),t}static parsePreprocess(t,e,r){let i=e.indexOf("#");if(i==-1)return e;let a=e.substring(0,i),o=e.indexOf(`
`,e.lastIndexOf("#")),l=e.substring(i,o),h=e.substring(o);return a+this.parsePreprocessCommand(t,l,r)+h}static parseAutoBindingForAllGroup(t){let e=0,r="",i=new Map;for(;e<t.length;){let a=t.indexOf("@group(",e);if(a==-1){r+=t.substring(e);break}let o=t.indexOf(")",a),l=Number.parseInt(t.substring(a+7,o));a=t.indexOf("@binding(",o),o=t.indexOf(")",a);let h=t.substring(a+9,o);if(r+=t.substring(e,a),h.includes("auto"))if(i.has(l)){let u=i.get(l)+1;r+=`@binding(${u})`,i.set(l,u)}else r+="@binding(0)",i.set(l,0);else{let u=Number.parseInt(h);(!i.has(l)||i.get(l)<u)&&i.set(l,u),r+=`@binding(${h})`}e=o+1}return r}static parseAutoBindingForGroupX(t,e){let r=0,i="",a=new Map;for(;r<t.length;){let o=t.indexOf("@group(",r);if(o==-1){i+=t.substring(r);break}let l=t.indexOf(")",o),h=Number.parseInt(t.substring(o+7,l));if(o=t.indexOf("@binding(",l),l=t.indexOf(")",o),i+=t.substring(r,o),h==e)if(a.has(h)){let u=a.get(h)+1;i+=`@binding(${u})`,a.set(h,u)}else i+="@binding(0)",a.set(h,0);else i+=t.substring(o,l+1);r=l+1}return i}static parseAutoLocation(t){let e=0,r="",i=0;for(;e<t.length;){let a=t.indexOf("@location(",e);if(a==-1){r+=t.substring(e);break}let o=t.indexOf(")",a),l=t.substring(a+10,o);r+=t.substring(e,a),l==="auto"?(r+=`@location(${i})`,i++):r+=t.substring(a,o+1),e=o+1}return r}static parseAutoLocationBlock(t){let e=0,r="";for(;e<t.length;){let i=t.indexOf("@location(",e);if(i==-1){r+=t.substring(e);break}let a=t.indexOf("}",i),o=t.indexOf("->",i);o!=-1&&o<a&&(a=o);let l=t.substring(i,a+1);l=this.parseAutoLocation(l),r+=t.substring(e,i),r+=l,e=a+1}return r}static parsePreprocessCommand(t,e,r){let i="",a=e.split(`
`),o=[!1],l=[!1];for(let h=0;h<a.length;h++){let u=a[h],c=o[o.length-1];if(u.trim().indexOf("#")!=0){c||(i+=u+`
`);continue}let f=u.trim();if(f.indexOf("#if")!=-1){if(c&&o.length>1){o.push(c);continue}let d=f.substring(3).trim();c=!this.parseCondition(d,r),o.push(c),l.push(!c);continue}else if(f.indexOf("#elseif")!=-1||f.indexOf("#else")!=-1&&f.indexOf(" if")!=-1){if(l[l.length-1]){o.pop(),c=!0,o.push(c);continue}if(o.pop(),c=o[o.length-1],c&&o.length>1){o.push(c);continue}let d=f.substring(f.indexOf("if")+2).trim();d==""&&console.error(`preprocess command error, conditions missing: ${f}`),c=!this.parseCondition(d,r),o.push(c),l.push(!c);continue}else if(f.indexOf("#else")!=-1){o.pop(),c&&o.length>1&&o[o.length-1]?o.push(c):o.push(!c);continue}else if(f.indexOf("#endif")!=-1){o.pop(),l.pop();continue}else if(f.indexOf("#include")!=-1){let d="",p=f.charAt(f.length-1);if(p==">"?d=this.extract(f,"<",">"):d=this.extract(f,p,p),!t.includeMap.has(d)){t.includeMap.set(d,!0);let A=H.getShader(d);if(!A)throw`${f} error: '${d}' not found`;A=this.filterComment(A),A=this.parsePreprocess(t,A,r),i+=A+`\r
`}continue}else if(f.indexOf("#define ")!=-1){let d=f.substring(f.indexOf("#define ")+8).trim(),p=d.indexOf(" "),A=d,x="";p!=-1&&(A=d.substring(0,p).trim(),x=d.substring(p+1).trim()),r[A]=x;continue}else throw"nonsupport: "+f}return i}static parseCondition(t,e){let r=e[t];return r==null?!1:r==!0||r!=0}static filterComment(t){let e="",r=!0,i=!0;for(let a=0;a<t.length;){let o=r?t.indexOf("//",a):-1,l=i?t.indexOf("/*",a):-1;if(o==-1&&l==-1){e+=t.substring(a);break}r=o!=-1,i=l!=-1,o!=-1&&l!=-1&&(o<l?l=-1:o=-1),o!=-1?(l=t.indexOf(`
`,o),e+=t.substring(a,o),a=l!=-1?l:t.length):l!=-1&&(o=t.indexOf("*/",l),e+=t.substring(a,l),a=o+2)}return e}static extract(t,e,r){let i=t.indexOf(e)+e.length,a=t.indexOf(r,i);return t.substring(i,a).trim()}}class yn{constructor(){s(this,"includeMap",new Map)}}const Ji=class Ji{constructor(){s(this,"attributes",[]);s(this,"vs_variables",[]);s(this,"fs_variables",[]);s(this,"cs_variables",[]);s(this,"groups",[]);s(this,"variables",{});s(this,"useSplit",!1)}static parser(t,e){e.shaderReflection||(e.shaderReflection=new Ji),t.indexOf("@vertex")!=-1?(e.shaderReflection.attributes=this.parserVertexOld(t),e.shaderReflection.vs_variables=this.parserVariables(t)):t.indexOf("@fragment")!=-1?e.shaderReflection.fs_variables=this.parserVariables(t):t.indexOf("@compute")!=-1&&(e.shaderReflection.cs_variables=this.parserVariables(t))}static parser2(t,e){e.shaderReflection||(e.shaderReflection=new Ji);let r=e.shaderReflection;t.indexOf("@vertex")!=-1?(r.attributes=this.parserVertex(e.vsEntryPoint,t),r.vs_variables=this.parserVariables(t)):t.indexOf("@fragment")!=-1?r.fs_variables=this.parserVariables(t):t.indexOf("@compute")!=-1&&(r.cs_variables=this.parserVariables(t)),t.indexOf("splitTexture")!=-1&&(r.useSplit=!0)}static combineShaderReflectionVarInfo(t,e){for(const r of e){t.groups[r.group]||(t.groups[r.group]=[]);let i=r;if(t.groups[r.group][r.binding]){let a=t.groups[r.group][r.binding],o=r;if(a.dataFields)for(let l=0;l<a.dataFields.length;l++)a.dataFields[l];if(o.dataFields)for(let l=0;l<o.dataFields.length;l++)o.dataFields[l]}t.groups[r.group][r.binding]=i,t.variables[r.varName]=i}}static final(t){let e=t.shaderReflection;this._shaderReflectionMap.set(t.shaderVariant,e),this.combineShaderReflectionVarInfo(e,e.vs_variables),this.combineShaderReflectionVarInfo(e,e.fs_variables)}static getShaderReflection2(t,e){let r=xr.parse(t,e.defineValue);Ji.parser2(r,e)}static poolGetReflection(t){return this._shaderReflectionMap.get(t)}static genShaderVar(t){let e=`${t.vs}${t.fs}${t.compute}`;e+="|";for(const r in t.uniforms)e+=r+":";e+="|";for(const r in t.constValues)e+=r+":",e+=t.constValues[r];e+="|";for(const r in t.defines)e+=r+":",e+=t.defines[r];e+="|";for(const r in t.shaderState)e+=r+":",e+=t.shaderState[r]+";";return e}static genShaderVariant(t){let e="";for(const r in t.uniforms)e+=r+":";e+="|";for(const r in t.constValues)e+=r+":",e+=t.constValues[r];e+="|";for(const r in t.defineValue)e+=r+":",e+=t.defineValue[r];return e}static genRenderShaderVariant(t){let e=`RenderShader(${t.vsName},${t.fsName})`;e+="|",e+=this.genShaderVariant(t),e+="|";for(const r in t.shaderState)e+=r+":",e+=t.shaderState[r]+";";return e}static genComputeShaderVariant(t){let e=`ComputeShader(${t.instanceID})`;return e+="|",e+=this.genShaderVariant(t),e}combine(t){let e=t.shaderReflection,r=t.defines,i={};for(let o=0;o<this.attributes.length;o++){let l=this.attributes[o];r[l.name]&&(i[l.name]=l)}let a=e.attributes.length;for(let o=0;o<a;o++){const l=e.attributes[o];if(!i[l.name])this.attributes.push(l);else{let h=i[l.name];h.location==l.location&&h.name!=l.name&&console.log("location must same!")}}}static parserVariables(t){let e=0,r=[];for(;e<t.length;){let i=t.indexOf("@group(",e);if(i<0)break;let a=t.indexOf(";",i);e=a;let o=t.substring(i,a),l=this.extract(o,"@group(",")"),h=this.extract(o,"@binding(",")"),u="",c="var";o.indexOf("var<")!=-1?(u=this.extract(o,">",":"),c=this.extract(o,"var<",">").replace(",","-").replaceAll(" ","")):u=this.extract(o,"var",":");let f=o.substring(o.lastIndexOf(":")+1).trim(),d={group:0,binding:0,varType:"",varName:"",dataType:"",dataIsBuiltinType:!0,dataFields:null};d.group=Number.parseInt(l),d.binding=Number.parseInt(h),d.varType=c,d.varName=u,d.dataType=f,d.dataIsBuiltinType=this.isBuiltinTypes(d.dataType),d.dataIsBuiltinType||(d.dataFields=this.parserStructFields(t,d.dataType)),r.push(d)}return r}static extract(t,e,r){let i=t.indexOf(e)+e.length,a=t.indexOf(r,i);return t.substring(i,a).trim()}static isBuiltinTypes(t){switch(t){case"i32":return!0;case"u32":return!0;case"f32":return!0;default:let e=t.indexOf("<");if(e!=-1)switch(t.substring(0,e)){case"vec2":return!0;case"vec3":return!0;case"vec4":return!0;case"mat3":return!0;case"mat4":return!0;case"array":return this.isBuiltinTypes(t.substring(e+1,t.lastIndexOf(">")))}break}return!1}static parserStructFields(t,e){let r=[],i=0;for(;i<t.length;){let a=t.indexOf("struct ",i);if(a<0)break;let o=t.indexOf("{",a);if(i=o,t.substring(a+6,o).trim()===e){a=t.indexOf("{",a),o=t.indexOf("}",a);let l=t.substring(a+1,o).split(",");for(let h of l){let u=h.indexOf(":");if(u!=-1){let c={name:h.substring(0,u).trim(),type:h.substring(u+1).trim()};r.push(c)}}break}}return r}static parserVertexOld(t){let e=[],r=t.split("fn main(")[1].split("->")[0],i=r.split("@");if(i&&i.length>1)for(let o=1;o<i.length;o++){let l=i[o].replace(/\s*$/g,"");l=l.replaceAll(",",""),l=l.replaceAll(`
`,""),l=l.replaceAll("  "," "),this.parserAttribute(l,e)}else{var a=r.split(":")[1];a=a.replaceAll("  ",""),a=a.replaceAll(" ",""),a=a.replaceAll(")",""),a=t.split(`struct ${a}`)[1];let o=a.indexOf("{"),l=a.indexOf("}");a=a.slice(o,l),i=a.split("@");for(let h=1;h<i.length;h++){let u=i[h].replace(/\s*$/g,"");u=u.replaceAll(`
`,""),u=u.split(",")[0],u=u.replaceAll("  "," "),this.parserAttribute(u,e)}}return e}static parserVertex(t,e){let r=[],i=e.split(`fn ${t}(`)[1].split("->")[0],a=i.split("@");if(a&&a.length>1)for(let l=1;l<a.length;l++){let h=a[l].replace(/\s*$/g,"");h=h.replaceAll(",",""),h=h.replaceAll(`
`,""),h=h.replaceAll("  "," "),this.parserAttribute(h,r)}else{var o=i.split(":")[1];o=o.replaceAll("  ",""),o=o.replaceAll(" ",""),o=o.replaceAll(")",""),o=e.split(`struct ${o}`)[1];let l=o.indexOf("{"),h=o.indexOf("}");o=o.slice(l,h),a=o.split("@");for(let u=1;u<a.length;u++){let c=a[u].replace(/\s*$/g,"");c=c.replaceAll(`
`,""),c=c.split(",")[0],c=c.replaceAll("  "," "),this.parserAttribute(c,r)}}return r}static parserAttribute(t,e){let r={name:"",group:0,location:0,type:"",valueType:"",value:0,size:0,format:"float32"};if(t.indexOf("builtin")!=-1){r.type="builtin";var i=t.match(/\((.+?)\)/g)[0];i=t.match(/\((.+?)\)/g)[0],i=i.replace("(",""),i=i.replaceAll(")",""),r.location=parseInt(i);let a=t.split(":");r.name=a[0].split(" ")[1],r.name=r.name.replaceAll("  "," "),r.name=r.name.replaceAll(" ",""),r.valueType=a[1],r.valueType=r.valueType.replaceAll("  "," "),r.valueType=r.valueType.replaceAll(" ",""),r.valueType=r.valueType.replaceAll("\r",""),r.valueType=r.valueType.replaceAll(")",""),r.valueType=r.valueType.replaceAll(")",""),r.size=gi[r.valueType],e.push(r)}else if(t.indexOf("location")!=-1){r.type="location";var i=t.match(/\((.+?)\)/g)[0];i=t.match(/\((.+?)\)/g)[0],i=i.replace("(",""),i=i.replaceAll(")",""),r.location=parseInt(i);let o=t.split(":");r.name=o[0].split(" ")[1],r.name=r.name.replaceAll("  "," "),r.name=r.name.replaceAll(" ",""),r.valueType=o[1],r.valueType=r.valueType.replaceAll("  "," "),r.valueType=r.valueType.replaceAll(" ",""),r.valueType=r.valueType.replaceAll("\r",""),r.valueType=r.valueType.replaceAll(")",""),r.valueType=r.valueType.replaceAll(")",""),r.size=gi[r.valueType],e.push(r)}r.format=gh[gi[r.valueType]]}};s(Ji,"_shaderReflectionMap",new Map);let zt=Ji;class ce extends An{constructor(e){super();s(this,"entryPoint","CsMain");s(this,"workerSizeX",1);s(this,"workerSizeY",0);s(this,"workerSizeZ",0);s(this,"_computePipeline");s(this,"_csShaderModule");s(this,"_destCS");s(this,"_sourceCS");s(this,"_storageTextureDic");s(this,"_sampleTextureDic");s(this,"_groupsShaderReflectionVarInfos");s(this,"_groupCache",{});this._sourceCS=e,zt.getShaderReflection2(e,this),this._storageTextureDic=new Map,this._sampleTextureDic=new Map}setStorageTexture(e,r){this._storageTextureDic.has(e)||this._storageTextureDic.set(e,r)}setSamplerTexture(e,r){this._sampleTextureDic.set(e,r)}compute(e){this._computePipeline||this.genComputePipeline(),e.setPipeline(this._computePipeline);for(let r=0;r<this.bindGroups.length;++r)e.setBindGroup(r,this.bindGroups[r]);this.workerSizeX&&this.workerSizeY&&this.workerSizeZ?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY,this.workerSizeZ):this.workerSizeX&&this.workerSizeY?e.dispatchWorkgroups(this.workerSizeX,this.workerSizeY):e.dispatchWorkgroups(this.workerSizeX)}createBufferBindGroup(e,r,i,a){let o=this._bufferDic.get(r);if(o){let l={binding:i,resource:{buffer:o.buffer,offset:0,size:o.memory.shareDataBuffer.byteLength}};a.push(l)}else console.error(`ComputeShader(${this.instanceID})`,`buffer ${r} is missing!`)}noticeBufferChange(e){let r=this._groupCache[e];r&&this.genGroups(r.groupIndex,r.infos,!0)}genGroups(e,r,i=!1){if(!this.bindGroups[e]||i){const a=r[e];let o=[];for(let h=0;h<a.length;++h){const u=a[h];if(u)switch(u.varType){case"uniform":case"storage-read":case"storage-read_write":this.createBufferBindGroup(e,u.varName,u.binding,o),this._groupCache[u.varName]={groupIndex:e,infos:r};break;case"var":if(u.dataType=="sampler"){let c=u.varName.replace("Sampler",""),f=this._sampleTextureDic.get(c);if(f){let d={binding:u.binding,resource:f.gpuSampler};o.push(d)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${u.varName} is missing! `)}else if(u.dataType=="sampler_comparison"){let c=u.varName.replace("Sampler",""),f=this._sampleTextureDic.get(c);if(f){let d={binding:u.binding,resource:f.gpuSampler_comparison};o.push(d)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${u.varName} is missing! `)}else if(u.dataType.indexOf("texture_storage")!=-1){let c=this._storageTextureDic.get(u.varName);if(c){let f={binding:u.binding,resource:c.getGPUView()};o.push(f),Ae.getInstance().attached(c,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${u.varName} is missing! `)}else if(u.dataType.indexOf("texture")!=-1){let c=this._sampleTextureDic.get(u.varName);if(c){let f={binding:u.binding,resource:c.getGPUView()};o.push(f),Ae.getInstance().attached(c,this)}else console.error(`ComputeShader(${this.instanceID})`,`texture ${u.varName} is missing! `)}break;default:console.error("unprocessed type:",u.varType);break}}let l=E.device.createBindGroup({layout:this._computePipeline.getBindGroupLayout(e),entries:o});this.bindGroups[e]=l}}genComputePipeline(){this.preCompileShader(this._sourceCS),this.genReflection(),this._computePipeline=E.device.createComputePipeline({layout:"auto",compute:{module:this.compileShader(),entryPoint:this.entryPoint}}),this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroups=[];for(let r=0;r<e.groups.length;++r){let i=e.groups[r];this._groupsShaderReflectionVarInfos[r]=i,this.genGroups(r,this._groupsShaderReflectionVarInfos)}E.addEventListener(Wr.RESIZE,r=>{for(let i=0;i<e.groups.length;++i){let a=e.groups[i];this._groupsShaderReflectionVarInfos[i]=a,this.genGroups(i,this._groupsShaderReflectionVarInfos,!0)}},this)}preCompileShader(e){for(const r in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,r)){const i=this.constValues[r];e=e.replaceAll(`&${r}`,i.toString())}this._destCS=xr.parseComputeShader(e,this.defineValue)}compileShader(){let e=E.device.createShaderModule({label:`ComputeShader(${this.instanceID})`,code:this._destCS});return e.getCompilationInfo().then(r=>{r.messages.length>0&&console.warn("[shader error]",r,this._destCS)}),this._csShaderModule=e,e}genReflection(){this.shaderVariant+=zt.genComputeShaderVariant(this);let e=zt.poolGetReflection(this.shaderVariant);e?this.shaderReflection=e:(zt.getShaderReflection2(this._destCS,this),zt.combineShaderReflectionVarInfo(this.shaderReflection,this.shaderReflection.cs_variables))}}var J=(n=>(n[n.COLOR=1]="COLOR",n[n.REFLECTION=2]="REFLECTION",n[n.POSITION=4]="POSITION",n[n.GRAPHIC=8]="GRAPHIC",n[n.GI=16]="GI",n[n.Cluster=32]="Cluster",n[n.SHADOW=64]="SHADOW",n[n.POINT_SHADOW=128]="POINT_SHADOW",n[n.POST=256]="POST",n[n.DEPTH=512]="DEPTH",n[n.UI=1024]="UI",n))(J||{});class Fe{static startView(t){let e=this.viewMap.get(t);if(!e){e={};for(const r in J)parseInt(r)>=0||(e[r]={vertexCount:0,indicesCount:0,instanceCount:0,triCount:0,drawCount:0,pipelineCount:0});this.viewMap.set(t,e)}for(const r in J)parseInt(r)>=0||(e[r].vertexCount=0,e[r].indicesCount=0,e[r].triCount=0,e[r].instanceCount=0,e[r].drawCount=0,e[r].pipelineCount=0)}static viewCount(t){return this.startView(t),this.viewMap.get(t)}static viewCount_vertex(t,e,r){this.viewMap.get(t)[e].vertexCount+=r}static viewCount_indices(t,e,r){this.viewMap.get(t)[e].indicesCount+=r}static viewCount_tri(t,e,r){this.viewMap.get(t)[e].triCount+=r}static viewCount_instance(t,e,r){this.viewMap.get(t)[e].instanceCount+=r}static viewCount_draw(t,e){this.viewMap.get(t)[e].drawCount++}static viewCount_pipeline(t,e){this.viewMap.get(t)[e].pipelineCount++}static start(t){let e=this.profilerLabelMap.get(t);e||(e={lable:t,start:0,end:0,total:0,count:0,child:new Map},this.profilerLabelMap.set(t,e)),e.start=performance.now(),e.end=performance.now(),e.count=0,e.child.clear()}static end(t){let e=this.profilerLabelMap.get(t);e&&(e.end=performance.now(),e.total=e.end-e.start)}static countStart(t,e=""){let r=this.profilerLabelMap.get(t);if(r&&(r.count++,e!="")){let i=r.child.get(e);i||(i={lable:e,start:0,end:0,total:0,count:0}),i.start=performance.now(),i.end=performance.now(),i.count=0,r.child.set(e,i)}}static countEnd(t,e){let r=this.profilerLabelMap.get(t);if(r&&e!=""){let i=r.child.get(e);i||(i={lable:e,start:0,end:0,total:0,count:0}),i.end=performance.now(),i.total=i.end-i.start,i.count++}}static print(t){let e=this.profilerLabelMap.get(t);e&&console.log("performance",t,e.total+" ms")}}s(Fe,"profilerLabelMap",new Map),s(Fe,"viewMap",new Map),s(Fe,"testObj",{testValue1:0,testValue2:0,testValue3:0,testValue4:0});var mu=(()=>{var n="file:///E:/gs/CZ900/node_modules/@orillusion/core/dist/orillusion.es.js";return function(){return V(this,arguments,function*(t={}){var e=t,r,i;e.ready=new Promise((R,U)=>{r=R,i=U});var a=Object.assign({},e),o=[],l="./this.program",h=(R,U)=>{throw U},u=typeof window=="object",c=typeof importScripts=="function",f=typeof Ur=="object"&&typeof Ur.versions=="object"&&typeof Ur.versions.node=="string",d="";function p(R){return e.locateFile?e.locateFile(R,d):d+R}var A,x;if(f){const{createRequire:R}=yield Promise.resolve().then(()=>nm);var C=R("file:///E:/gs/CZ900/node_modules/@orillusion/core/dist/orillusion.es.js"),v=C("fs"),y=C("path");c?d=y.dirname(d)+"/":d=C("url").fileURLToPath(new URL(De(34315),De.b)),A=(U,W)=>(U=Ha(U)?new URL(U):y.normalize(U),v.readFileSync(U,W?void 0:"utf8")),x=U=>{var W=A(U,!0);return W.buffer||(W=new Uint8Array(W)),W},!e.thisProgram&&Ur.argv.length>1&&(l=Ur.argv[1].replace(/\\/g,"/")),o=Ur.argv.slice(2),h=(U,W)=>{throw Ur.exitCode=U,W}}else(u||c)&&(c?d=self.location.href:typeof document<"u"&&document.currentScript&&(d=document.currentScript.src),n&&(d=n),d.startsWith("blob:")?d="":d=d.substr(0,d.replace(/[?#].*/,"").lastIndexOf("/")+1),A=R=>{var U=new XMLHttpRequest;return U.open("GET",R,!1),U.send(null),U.responseText},c&&(x=R=>{var U=new XMLHttpRequest;return U.open("GET",R,!1),U.responseType="arraybuffer",U.send(null),new Uint8Array(U.response)}));var b=e.print||console.log.bind(console),B=e.printErr||console.error.bind(console);Object.assign(e,a),a=null,e.arguments&&(o=e.arguments),e.thisProgram&&(l=e.thisProgram),e.quit&&(h=e.quit);var I;e.wasmBinary&&(I=e.wasmBinary);function w(R){if(typeof f<"u"&&f){var U=rs.from(R,"base64");return new Uint8Array(U.buffer,U.byteOffset,U.length)}for(var W=atob(R),de=new Uint8Array(W.length),Pe=0;Pe<W.length;++Pe)de[Pe]=W.charCodeAt(Pe);return de}function D(R){if(sa(R))return w(R.slice(aa.length))}var L,M=!1,G,N,q,ie;function ue(){var R=L.buffer;e.HEAP8=N=new Int8Array(R),e.HEAP16=new Int16Array(R),e.HEAPU8=q=new Uint8Array(R),e.HEAPU16=new Uint16Array(R),e.HEAP32=new Int32Array(R),e.HEAPU32=ie=new Uint32Array(R),e.HEAPF32=new Float32Array(R),e.HEAPF64=new Float64Array(R)}var Ee=[],Ie=[],Ne=[],Qe=[];function xe(){if(e.preRun)for(typeof e.preRun=="function"&&(e.preRun=[e.preRun]);e.preRun.length;)vt(e.preRun.shift());hi(Ee)}function Ve(){hi(Ie)}function we(){hi(Ne)}function Ye(){if(e.postRun)for(typeof e.postRun=="function"&&(e.postRun=[e.postRun]);e.postRun.length;)Nt(e.postRun.shift());hi(Qe)}function vt(R){Ee.unshift(R)}function xt(R){Ie.unshift(R)}function Nt(R){Qe.unshift(R)}var Ke=0,nt=null;function mr(R){var U;Ke++,(U=e.monitorRunDependencies)==null||U.call(e,Ke)}function Ya(R){var W;if(Ke--,(W=e.monitorRunDependencies)==null||W.call(e,Ke),Ke==0&&nt){var U=nt;nt=null,U()}}function ia(R){var W;(W=e.onAbort)==null||W.call(e,R),R="Aborted("+R+")",B(R),M=!0,G=1,R+=". Build with -sASSERTIONS for more info.";var U=new WebAssembly.RuntimeError(R);throw i(U),U}var aa="data:application/octet-stream;base64,",sa=R=>R.startsWith(aa),Ha=R=>R.startsWith("file://"),Pr;Pr="data:application/octet-stream;base64,AGFzbQEAAAABpAEaYAF/AX9gAn9/AGADf39/AX9gA39/fwBgAX8AYAAAYAV/f39/fwBgBH9/f38AYAJ/fwF/YAZ/f39/f38AYAABf2AEf39/fQBgBH9/f38Bf2ABfAF9YAJ8fwF8YAF9AX1gAXwBfGACfn8Bf2ADfHx/AXxgAnx8AXxgBn98f39/fwF/YAJ9fwF/YAJ8fwF/YAV/f39/fwF/YAN/fn8BfmADf399AAIfBQFhAWEADAFhAWIAAwFhAWMABQFhAWQAAAFhAWUAAwNYVwMGAg0NAgAEABEEEhMFBQ4CBA8QAgAPEAUEAAcDCAAAAAgUAwAMDgAEBBUWFwEIAQgBAAAAAAEBBAAAAAAACgAJCQYGBwcKAgoKGAACBAsBAwsBAwgZAwQFAXABLCwFBwEBggKAgAIGCAF/AUHwuAQLBzkOAWYCAAFnAB0BaABbAWkAUgFqAE4BawBNAWwASwFtAEMBbgA9AW8AWgFwAFkBcQEAAXIAPgFzAEQJMQEAQQELKyMfWDY6OTg3V1ZVMjo5ODdUU1BRTycjDy0tTEVHSg9GSEkPQQ9AD0IePx4KivsBVxcAIAAtAABBIHFFBEAgASACIAAQGRoLC2sBAX8jAEGAAmsiBSQAAkAgAiADTA0AIARBgMAEcQ0AIAUgASACIANrIgNBgAIgA0GAAkkiARsQBxogAUUEQANAIAAgBUGAAhAFIANBgAJrIgNB/wFLDQALCyAAIAUgAxAFCyAFQYACaiQAC/ICAgJ/AX4CQCACRQ0AIAAgAToAACAAIAJqIgNBAWsgAToAACACQQNJDQAgACABOgACIAAgAToAASADQQNrIAE6AAAgA0ECayABOgAAIAJBB0kNACAAIAE6AAMgA0EEayABOgAAIAJBCUkNACAAQQAgAGtBA3EiBGoiAyABQf8BcUGBgoQIbCIBNgIAIAMgAiAEa0F8cSIEaiICQQRrIAE2AgAgBEEJSQ0AIAMgATYCCCADIAE2AgQgAkEIayABNgIAIAJBDGsgATYCACAEQRlJDQAgAyABNgIYIAMgATYCFCADIAE2AhAgAyABNgIMIAJBEGsgATYCACACQRRrIAE2AgAgAkEYayABNgIAIAJBHGsgATYCACAEIANBBHFBGHIiBGsiAkEgSQ0AIAGtQoGAgIAQfiEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkEgayICQR9LDQALCyAAC0sBAnwgACAAoiIBIACiIgIgASABoqIgAUSnRjuMh83GPqJEdOfK4vkAKr+goiACIAFEsvtuiRARgT+iRHesy1RVVcW/oKIgAKCgtgtPAQF8IAAgAKIiACAAIACiIgGiIABEaVDu4EKT+T6iRCceD+iHwFa/oKIgAURCOgXhU1WlP6IgAESBXgz9///fv6JEAAAAAAAA8D+goKC2C3QBAX8gAkUEQCAAKAIEIAEoAgRGDwsgACABRgRAQQEPCyABKAIEIgItAAAhAQJAIAAoAgQiAy0AACIARQ0AIAAgAUcNAANAIAItAAEhASADLQABIgBFDQEgAkEBaiECIANBAWohAyAAIAFGDQALCyAAIAFGCzUBAX9BASAAIABBAU0bIQACQANAIAAQJSIBDQFB6DgoAgAiAQRAIAERBQAMAQsLEAIACyABC9kLAQd/AkAgAEUNACAAQQhrIgMgAEEEaygCACIBQXhxIgBqIQUCQCABQQFxDQAgAUECcUUNASADIAMoAgAiAWsiA0GINSgCAEkNASAAIAFqIQACQAJAQYw1KAIAIANHBEAgAygCDCECIAFB/wFNBEAgAUEDdiEBIAMoAggiBCACRgRAQfg0Qfg0KAIAQX4gAXdxNgIADAULIAQgAjYCDCACIAQ2AggMBAsgAygCGCEGIAIgA0cEQCADKAIIIgEgAjYCDCACIAE2AggMAwsgAygCFCIBBH8gA0EUagUgAygCECIBRQ0CIANBEGoLIQQDQCAEIQcgASICQRRqIQQgAigCFCIBDQAgAkEQaiEEIAIoAhAiAQ0ACyAHQQA2AgAMAgsgBSgCBCIBQQNxQQNHDQJBgDUgADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAUgADYCAA8LQQAhAgsgBkUNAAJAIAMoAhwiAUECdEGoN2oiBCgCACADRgRAIAQgAjYCACACDQFB/DRB/DQoAgBBfiABd3E2AgAMAgsgBkEQQRQgBigCECADRhtqIAI2AgAgAkUNAQsgAiAGNgIYIAMoAhAiAQRAIAIgATYCECABIAI2AhgLIAMoAhQiAUUNACACIAE2AhQgASACNgIYCyADIAVPDQAgBSgCBCIBQQFxRQ0AAkACQAJAAkAgAUECcUUEQEGQNSgCACAFRgRAQZA1IAM2AgBBhDVBhDUoAgAgAGoiADYCACADIABBAXI2AgQgA0GMNSgCAEcNBkGANUEANgIAQYw1QQA2AgAPC0GMNSgCACAFRgRAQYw1IAM2AgBBgDVBgDUoAgAgAGoiADYCACADIABBAXI2AgQgACADaiAANgIADwsgAUF4cSAAaiEAIAUoAgwhAiABQf8BTQRAIAFBA3YhASAFKAIIIgQgAkYEQEH4NEH4NCgCAEF+IAF3cTYCAAwFCyAEIAI2AgwgAiAENgIIDAQLIAUoAhghBiACIAVHBEBBiDUoAgAaIAUoAggiASACNgIMIAIgATYCCAwDCyAFKAIUIgEEfyAFQRRqBSAFKAIQIgFFDQIgBUEQagshBANAIAQhByABIgJBFGohBCACKAIUIgENACACQRBqIQQgAigCECIBDQALIAdBADYCAAwCCyAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAwDC0EAIQILIAZFDQACQCAFKAIcIgFBAnRBqDdqIgQoAgAgBUYEQCAEIAI2AgAgAg0BQfw0Qfw0KAIAQX4gAXdxNgIADAILIAZBEEEUIAYoAhAgBUYbaiACNgIAIAJFDQELIAIgBjYCGCAFKAIQIgEEQCACIAE2AhAgASACNgIYCyAFKAIUIgFFDQAgAiABNgIUIAEgAjYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQYw1KAIARw0AQYA1IAA2AgAPCyAAQf8BTQRAIABBeHFBoDVqIQECf0H4NCgCACIEQQEgAEEDdnQiAHFFBEBB+DQgACAEcjYCACABDAELIAEoAggLIQAgASADNgIIIAAgAzYCDCADIAE2AgwgAyAANgIIDwtBHyECIABB////B00EQCAAQSYgAEEIdmciAWt2QQFxIAFBAXRrQT5qIQILIAMgAjYCHCADQgA3AhAgAkECdEGoN2ohBwJ/AkACf0H8NCgCACIBQQEgAnQiBHFFBEBB/DQgASAEcjYCAEEYIQIgByEEQQgMAQsgAEEZIAJBAXZrQQAgAkEfRxt0IQIgBygCACEEA0AgBCIBKAIEQXhxIABGDQIgAkEddiEEIAJBAXQhAiABIARBBHFqQRBqIgcoAgAiBA0AC0EYIQIgASEEQQgLIQAgAyIBDAELIAEoAggiBCADNgIMQQghAiABQQhqIQdBGCEAQQALIQUgByADNgIAIAIgA2ogBDYCACADIAE2AgwgACADaiAFNgIAQZg1QZg1KAIAQQFrIgBBfyAAGzYCAAsLTwECf0GYKygCACIBIABBB2pBeHEiAmohAAJAIAJBACAAIAFNG0UEQCAAPwBBEHRNDQEgABADDQELQbgzQTA2AgBBfw8LQZgrIAA2AgAgAQuDAQIFfwF+AkAgAEKAgICAEFQEQCAAIQcMAQsDQCABQQFrIgEgACAAQgqAIgdCCn59p0EwcjoAACAAQv////+fAVYhBSAHIQAgBQ0ACwsgB6ciAgRAA0AgAUEBayIBIAIgAkEKbiIDQQpsa0EwcjoAACACQQlLIQYgAyECIAYNAAsLIAELBgAgABAMC5kBAQN8IAAgAKIiAyADIAOioiADRHzVz1o62eU9okTrnCuK5uVavqCiIAMgA0R9/rFX4x3HPqJE1WHBGaABKr+gokSm+BARERGBP6CgIQUgAyAAoiEEIAJFBEAgBCADIAWiRElVVVVVVcW/oKIgAKAPCyAAIAMgAUQAAAAAAADgP6IgBSAEoqGiIAGhIARESVVVVVVVxT+ioKELkgEBA3xEAAAAAAAA8D8gACAAoiICRAAAAAAAAOA/oiIDoSIERAAAAAAAAPA/IAShIAOhIAIgAiACIAJEkBXLGaAB+j6iRHdRwRZswVa/oKJETFVVVVVVpT+goiACIAKiIgMgA6IgAiACRNQ4iL7p+qi9okTEsbS9nu4hPqCiRK1SnIBPfpK+oKKgoiAAIAGioaCgCyoBAX9BBBAkIgBBpCg2AgAgAEH8JzYCACAAQZAoNgIAIABBgClBARABAAtfAQN/QQgQJCIAQaQoNgIAIABBlCk2AgBBiQkQLCIBQQ1qEAsiAkEANgIIIAIgATYCBCACIAE2AgAgACACQQxqQYkJIAFBAWoQFTYCBCAAQcQpNgIAIABB5ClBAhABAAuoAQACQCABQYAITgRAIABEAAAAAAAA4H+iIQAgAUH/D0kEQCABQf8HayEBDAILIABEAAAAAAAA4H+iIQBB/RcgASABQf0XTxtB/g9rIQEMAQsgAUGBeEoNACAARAAAAAAAAGADoiEAIAFBuHBLBEAgAUHJB2ohAQwBCyAARAAAAAAAAGADoiEAQfBoIAEgAUHwaE0bQZIPaiEBCyAAIAFB/wdqrUI0hr+iC4AEAQN/IAJBgARPBEAgACABIAIQBCAADwsgACACaiEDAkAgACABc0EDcUUEQAJAIABBA3FFBEAgACECDAELIAJFBEAgACECDAELIAAhAgNAIAIgAS0AADoAACABQQFqIQEgAkEBaiICQQNxRQ0BIAIgA0kNAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgACADQQRrIgRLBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsGACAAEAwL/QICAXwDfyMAQRBrIgQkAAJAIAC8IgNB/////wdxIgJB2p+k+gNNBEAgAkGAgIDMA0kNASAAuxAIIQAMAQsgAkHRp+2DBE0EQCAAuyEBIAJB45fbgARNBEAgA0EASARAIAFEGC1EVPsh+T+gEAmMIQAMAwsgAUQYLURU+yH5v6AQCSEADAILRBgtRFT7IQnARBgtRFT7IQlAIANBAE4bIAGgmhAIIQAMAQsgAkHV44iHBE0EQCACQd/bv4UETQRAIAC7IQEgA0EASARAIAFE0iEzf3zZEkCgEAkhAAwDCyABRNIhM3982RLAoBAJjCEADAILRBgtRFT7IRlARBgtRFT7IRnAIANBAEgbIAC7oBAIIQAMAQsgAkGAgID8B08EQCAAIACTIQAMAQsgACAEQQhqEC8hAiAEKwMIIQECQAJAAkACQCACQQNxDgMAAQIDCyABEAghAAwDCyABEAkhAAwCCyABmhAIIQAMAQsgARAJjCEACyAEQRBqJAAgAAvBAQICfwF8IwBBEGsiASQAAkAgAL1CIIinQf////8HcSICQfvDpP8DTQRAIAJBgIDA8gNJDQEgAEQAAAAAAAAAAEEAEBAhAAwBCyACQYCAwP8HTwRAIAAgAKEhAAwBCyAAIAEQMCECIAErAwghACABKwMAIQMCQAJAAkACQCACQQNxDgMAAQIDCyADIABBARAQIQAMAwsgAyAAEBEhAAwCCyADIABBARAQmiEADAELIAMgABARmiEACyABQRBqJAAgAAvCAQEDfwJAIAEgAigCECIDBH8gAwUgAhAaDQEgAigCEAsgAigCFCIEa0sEQCACIAAgASACKAIkEQIADwsCQAJAIAIoAlBBAEgNACABRQ0AIAEhAwNAIAAgA2oiBUEBay0AAEEKRwRAIANBAWsiAw0BDAILCyACIAAgAyACKAIkEQIAIgQgA0kNAiABIANrIQEgAigCFCEEDAELIAAhBUEAIQMLIAQgBSABEBUaIAIgAigCFCABajYCFCABIANqIQQLIAQLWQEBfyAAIAAoAkgiAUEBayABcjYCSCAAKAIAIgFBCHEEQCAAIAFBIHI2AgBBfw8LIABCADcCBCAAIAAoAiwiATYCHCAAIAE2AhQgACABIAAoAjBqNgIQQQAL6QIDA38BfAF9IwBBEGsiAyQAAn0gALwiAkH/////B3EiAUHan6T6A00EQEMAAIA/IAFBgICAzANJDQEaIAC7EAkMAQsgAUHRp+2DBE0EQCABQeSX24AETwRARBgtRFT7IQlARBgtRFT7IQnAIAJBAEgbIAC7oBAJjAwCCyAAuyEEIAJBAEgEQCAERBgtRFT7Ifk/oBAIDAILRBgtRFT7Ifk/IAShEAgMAQsgAUHV44iHBE0EQCABQeDbv4UETwRARBgtRFT7IRlARBgtRFT7IRnAIAJBAEgbIAC7oBAJDAILIAJBAEgEQETSITN/fNkSwCAAu6EQCAwCCyAAu0TSITN/fNkSwKAQCAwBCyAAIACTIAFBgICA/AdPDQAaIAAgA0EIahAvIQEgAysDCCEEAkACQAJAAkAgAUEDcQ4DAAECAwsgBBAJDAMLIASaEAgMAgsgBBAJjAwBCyAEEAgLIQUgA0EQaiQAIAULvQECAnwCfyMAQRBrIgMkAAJ8IAC9QiCIp0H/////B3EiBEH7w6T/A00EQEQAAAAAAADwPyAEQZ7BmvIDSQ0BGiAARAAAAAAAAAAAEBEMAQsgACAAoSAEQYCAwP8HTw0AGiAAIAMQMCEEIAMrAwghACADKwMAIQECQAJAAkACQCAEQQNxDgMAAQIDCyABIAAQEQwDCyABIABBARAQmgwCCyABIAAQEZoMAQsgASAAQQEQEAshAiADQRBqJAAgAgsTAEHUNEHcMzYCAEGMNEEqNgIACwsAIAAQHxogABAMCzEBAn8gAEGUKTYCACAAKAIEQQxrIgEgASgCCEEBayICNgIIIAJBAEgEQCABEBYLIAALmgEAIABBAToANQJAIAAoAgQgAkcNACAAQQE6ADQCQCAAKAIQIgJFBEAgAEEBNgIkIAAgAzYCGCAAIAE2AhAgA0EBRw0CIAAoAjBBAUYNAQwCCyABIAJGBEAgACgCGCICQQJGBEAgACADNgIYIAMhAgsgACgCMEEBRw0CIAJBAUYNAQwCCyAAIAAoAiRBAWo2AiQLIABBAToANgsLXQEBfyAAKAIQIgNFBEAgAEEBNgIkIAAgAjYCGCAAIAE2AhAPCwJAIAEgA0YEQCAAKAIYQQJHDQEgACACNgIYDwsgAEEBOgA2IABBAjYCGCAAIAAoAiRBAWo2AiQLC4ADAQR/IwBB8ABrIgIkACAAKAIAIgNBBGsoAgAhBCADQQhrKAIAIQUgAkIANwJQIAJCADcCWCACQgA3AmAgAkIANwBnIAJCADcCSCACQQA2AkQgAkHUJTYCQCACIAA2AjwgAiABNgI4IAAgBWohAwJAIAQgAUEAEAoEQEEAIAMgBRshAAwBCyAAIANOBEAgAkIANwAvIAJCADcCGCACQgA3AiAgAkIANwIoIAJCADcCECACQQA2AgwgAiABNgIIIAIgADYCBCACIAQ2AgAgAkEBNgIwIAQgAiADIANBAUEAIAQoAgAoAhQRCQAgAigCGA0BC0EAIQAgBCACQThqIANBAUEAIAQoAgAoAhgRBgACQAJAIAIoAlwOAgABAgsgAigCTEEAIAIoAlhBAUYbQQAgAigCVEEBRhtBACACKAJgQQFGGyEADAELIAIoAlBBAUcEQCACKAJgDQEgAigCVEEBRw0BIAIoAlhBAUcNAQsgAigCSCEACyACQfAAaiQAIAALBAAgAAsOACAAQdAAahAlQdAAagvgJwEMfyMAQRBrIgokAAJAAkACQAJAAkACQAJAAkACQAJAIABB9AFNBEBB+DQoAgAiBEEQIABBC2pB+ANxIABBC0kbIgZBA3YiAHYiAUEDcQRAAkAgAUF/c0EBcSAAaiICQQN0IgFBoDVqIgAgAUGoNWooAgAiASgCCCIFRgRAQfg0IARBfiACd3E2AgAMAQsgBSAANgIMIAAgBTYCCAsgAUEIaiEAIAEgAkEDdCICQQNyNgIEIAEgAmoiASABKAIEQQFyNgIEDAsLIAZBgDUoAgAiCE0NASABBEACQEECIAB0IgJBACACa3IgASAAdHFoIgFBA3QiAEGgNWoiAiAAQag1aigCACIAKAIIIgVGBEBB+DQgBEF+IAF3cSIENgIADAELIAUgAjYCDCACIAU2AggLIAAgBkEDcjYCBCAAIAZqIgcgAUEDdCIBIAZrIgVBAXI2AgQgACABaiAFNgIAIAgEQCAIQXhxQaA1aiEBQYw1KAIAIQICfyAEQQEgCEEDdnQiA3FFBEBB+DQgAyAEcjYCACABDAELIAEoAggLIQMgASACNgIIIAMgAjYCDCACIAE2AgwgAiADNgIICyAAQQhqIQBBjDUgBzYCAEGANSAFNgIADAsLQfw0KAIAIgtFDQEgC2hBAnRBqDdqKAIAIgIoAgRBeHEgBmshAyACIQEDQAJAIAEoAhAiAEUEQCABKAIUIgBFDQELIAAoAgRBeHEgBmsiASADIAEgA0kiARshAyAAIAIgARshAiAAIQEMAQsLIAIoAhghCSACIAIoAgwiAEcEQEGINSgCABogAigCCCIBIAA2AgwgACABNgIIDAoLIAIoAhQiAQR/IAJBFGoFIAIoAhAiAUUNAyACQRBqCyEFA0AgBSEHIAEiAEEUaiEFIAAoAhQiAQ0AIABBEGohBSAAKAIQIgENAAsgB0EANgIADAkLQX8hBiAAQb9/Sw0AIABBC2oiAEF4cSEGQfw0KAIAIgdFDQBBACAGayEDAkACQAJAAn9BACAGQYACSQ0AGkEfIAZB////B0sNABogBkEmIABBCHZnIgBrdkEBcSAAQQF0a0E+agsiCEECdEGoN2ooAgAiAUUEQEEAIQAMAQtBACEAIAZBGSAIQQF2a0EAIAhBH0cbdCECA0ACQCABKAIEQXhxIAZrIgQgA08NACABIQUgBCIDDQBBACEDIAEhAAwDCyAAIAEoAhQiBCAEIAEgAkEddkEEcWooAhAiAUYbIAAgBBshACACQQF0IQIgAQ0ACwsgACAFckUEQEEAIQVBAiAIdCIAQQAgAGtyIAdxIgBFDQMgAGhBAnRBqDdqKAIAIQALIABFDQELA0AgACgCBEF4cSAGayICIANJIQEgAiADIAEbIQMgACAFIAEbIQUgACgCECIBBH8gAQUgACgCFAsiAA0ACwsgBUUNACADQYA1KAIAIAZrTw0AIAUoAhghCCAFIAUoAgwiAEcEQEGINSgCABogBSgCCCIBIAA2AgwgACABNgIIDAgLIAUoAhQiAQR/IAVBFGoFIAUoAhAiAUUNAyAFQRBqCyECA0AgAiEEIAEiAEEUaiECIAAoAhQiAQ0AIABBEGohAiAAKAIQIgENAAsgBEEANgIADAcLIAZBgDUoAgAiBU0EQEGMNSgCACEAAkAgBSAGayIBQRBPBEAgACAGaiICIAFBAXI2AgQgACAFaiABNgIAIAAgBkEDcjYCBAwBCyAAIAVBA3I2AgQgACAFaiIBIAEoAgRBAXI2AgRBACECQQAhAQtBgDUgATYCAEGMNSACNgIAIABBCGohAAwJCyAGQYQ1KAIAIgJJBEBBhDUgAiAGayIBNgIAQZA1QZA1KAIAIgAgBmoiAjYCACACIAFBAXI2AgQgACAGQQNyNgIEIABBCGohAAwJC0EAIQAgBkEvaiIDAn9B0DgoAgAEQEHYOCgCAAwBC0HcOEJ/NwIAQdQ4QoCggICAgAQ3AgBB0DggCkEMakFwcUHYqtWqBXM2AgBB5DhBADYCAEG0OEEANgIAQYAgCyIBaiIEQQAgAWsiB3EiASAGTQ0IQbA4KAIAIgUEQEGoOCgCACIIIAFqIgkgCE0NCSAFIAlJDQkLAkBBtDgtAABBBHFFBEACQAJAAkACQEGQNSgCACIFBEBBuDghAANAIAUgACgCACIITwRAIAggACgCBGogBUsNAwsgACgCCCIADQALC0EAEA0iAkF/Rg0DIAEhBEHUOCgCACIAQQFrIgUgAnEEQCABIAJrIAIgBWpBACAAa3FqIQQLIAQgBk0NA0GwOCgCACIABEBBqDgoAgAiBSAEaiIHIAVNDQQgACAHSQ0ECyAEEA0iACACRw0BDAULIAQgAmsgB3EiBBANIgIgACgCACAAKAIEakYNASACIQALIABBf0YNASAGQTBqIARNBEAgACECDAQLQdg4KAIAIgIgAyAEa2pBACACa3EiAhANQX9GDQEgAiAEaiEEIAAhAgwDCyACQX9HDQILQbQ4QbQ4KAIAQQRyNgIACyABEA0hAkEAEA0hACACQX9GDQUgAEF/Rg0FIAAgAk0NBSAAIAJrIgQgBkEoak0NBQtBqDhBqDgoAgAgBGoiADYCAEGsOCgCACAASQRAQaw4IAA2AgALAkBBkDUoAgAiAwRAQbg4IQADQCACIAAoAgAiASAAKAIEIgVqRg0CIAAoAggiAA0ACwwEC0GINSgCACIAQQAgACACTRtFBEBBiDUgAjYCAAtBACEAQbw4IAQ2AgBBuDggAjYCAEGYNUF/NgIAQZw1QdA4KAIANgIAQcQ4QQA2AgADQCAAQQN0IgFBqDVqIAFBoDVqIgU2AgAgAUGsNWogBTYCACAAQQFqIgBBIEcNAAtBhDUgBEEoayIAQXggAmtBB3EiAWsiBTYCAEGQNSABIAJqIgE2AgAgASAFQQFyNgIEIAAgAmpBKDYCBEGUNUHgOCgCADYCAAwECyACIANNDQIgASADSw0CIAAoAgxBCHENAiAAIAQgBWo2AgRBkDUgA0F4IANrQQdxIgBqIgE2AgBBhDVBhDUoAgAgBGoiAiAAayIANgIAIAEgAEEBcjYCBCACIANqQSg2AgRBlDVB4DgoAgA2AgAMAwtBACEADAYLQQAhAAwEC0GINSgCACACSwRAQYg1IAI2AgALIAIgBGohAUG4OCEAAkADQCABIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQMLQbg4IQADQAJAIAMgACgCACIBTwRAIAEgACgCBGoiBSADSw0BCyAAKAIIIQAMAQsLQYQ1IARBKGsiAEF4IAJrQQdxIgFrIgc2AgBBkDUgASACaiIBNgIAIAEgB0EBcjYCBCAAIAJqQSg2AgRBlDVB4DgoAgA2AgAgAyAFQScgBWtBB3FqQS9rIgAgACADQRBqSRsiAUEbNgIEIAFBwDgpAgA3AhAgAUG4OCkCADcCCEHAOCABQQhqNgIAQbw4IAQ2AgBBuDggAjYCAEHEOEEANgIAIAFBGGohAANAIABBBzYCBCAAQQhqIQwgAEEEaiEAIAwgBUkNAAsgASADRg0AIAEgASgCBEF+cTYCBCADIAEgA2siAkEBcjYCBCABIAI2AgACfyACQf8BTQRAIAJBeHFBoDVqIQACf0H4NCgCACIBQQEgAkEDdnQiAnFFBEBB+DQgASACcjYCACAADAELIAAoAggLIQEgACADNgIIIAEgAzYCDEEMIQJBCAwBC0EfIQAgAkH///8HTQRAIAJBJiACQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgAyAANgIcIANCADcCECAAQQJ0Qag3aiEBAkACQEH8NCgCACIFQQEgAHQiBHFFBEBB/DQgBCAFcjYCACABIAM2AgAMAQsgAkEZIABBAXZrQQAgAEEfRxt0IQAgASgCACEFA0AgBSIBKAIEQXhxIAJGDQIgAEEddiEFIABBAXQhACABIAVBBHFqIgQoAhAiBQ0ACyAEIAM2AhALIAMgATYCGEEIIQIgAyIBIQBBDAwBCyABKAIIIgAgAzYCDCABIAM2AgggAyAANgIIQQAhAEEYIQJBDAsgA2ogATYCACACIANqIAA2AgALQYQ1KAIAIgAgBk0NAEGENSAAIAZrIgE2AgBBkDVBkDUoAgAiACAGaiICNgIAIAIgAUEBcjYCBCAAIAZBA3I2AgQgAEEIaiEADAQLQbgzQTA2AgBBACEADAMLIAAgAjYCACAAIAAoAgQgBGo2AgQgAkF4IAJrQQdxaiIIIAZBA3I2AgQgAUF4IAFrQQdxaiIEIAYgCGoiA2shBwJAQZA1KAIAIARGBEBBkDUgAzYCAEGENUGENSgCACAHaiIANgIAIAMgAEEBcjYCBAwBC0GMNSgCACAERgRAQYw1IAM2AgBBgDVBgDUoAgAgB2oiADYCACADIABBAXI2AgQgACADaiAANgIADAELIAQoAgQiAEEDcUEBRgRAIABBeHEhCSAEKAIMIQICQCAAQf8BTQRAIAQoAggiASACRgRAQfg0Qfg0KAIAQX4gAEEDdndxNgIADAILIAEgAjYCDCACIAE2AggMAQsgBCgCGCEGAkAgAiAERwRAQYg1KAIAGiAEKAIIIgAgAjYCDCACIAA2AggMAQsCQCAEKAIUIgAEfyAEQRRqBSAEKAIQIgBFDQEgBEEQagshAQNAIAEhBSAAIgJBFGohASAAKAIUIgANACACQRBqIQEgAigCECIADQALIAVBADYCAAwBC0EAIQILIAZFDQACQCAEKAIcIgBBAnRBqDdqIgEoAgAgBEYEQCABIAI2AgAgAg0BQfw0Qfw0KAIAQX4gAHdxNgIADAILIAZBEEEUIAYoAhAgBEYbaiACNgIAIAJFDQELIAIgBjYCGCAEKAIQIgAEQCACIAA2AhAgACACNgIYCyAEKAIUIgBFDQAgAiAANgIUIAAgAjYCGAsgByAJaiEHIAQgCWoiBCgCBCEACyAEIABBfnE2AgQgAyAHQQFyNgIEIAMgB2ogBzYCACAHQf8BTQRAIAdBeHFBoDVqIQACf0H4NCgCACIBQQEgB0EDdnQiAnFFBEBB+DQgASACcjYCACAADAELIAAoAggLIQEgACADNgIIIAEgAzYCDCADIAA2AgwgAyABNgIIDAELQR8hAiAHQf///wdNBEAgB0EmIAdBCHZnIgBrdkEBcSAAQQF0a0E+aiECCyADIAI2AhwgA0IANwIQIAJBAnRBqDdqIQACQAJAQfw0KAIAIgFBASACdCIFcUUEQEH8NCABIAVyNgIAIAAgAzYCAAwBCyAHQRkgAkEBdmtBACACQR9HG3QhAiAAKAIAIQEDQCABIgAoAgRBeHEgB0YNAiACQR12IQEgAkEBdCECIAAgAUEEcWoiBSgCECIBDQALIAUgAzYCEAsgAyAANgIYIAMgAzYCDCADIAM2AggMAQsgACgCCCIBIAM2AgwgACADNgIIIANBADYCGCADIAA2AgwgAyABNgIICyAIQQhqIQAMAgsCQCAIRQ0AAkAgBSgCHCIBQQJ0Qag3aiICKAIAIAVGBEAgAiAANgIAIAANAUH8NCAHQX4gAXdxIgc2AgAMAgsgCEEQQRQgCCgCECAFRhtqIAA2AgAgAEUNAQsgACAINgIYIAUoAhAiAQRAIAAgATYCECABIAA2AhgLIAUoAhQiAUUNACAAIAE2AhQgASAANgIYCwJAIANBD00EQCAFIAMgBmoiAEEDcjYCBCAAIAVqIgAgACgCBEEBcjYCBAwBCyAFIAZBA3I2AgQgBSAGaiIEIANBAXI2AgQgAyAEaiADNgIAIANB/wFNBEAgA0F4cUGgNWohAAJ/Qfg0KAIAIgFBASADQQN2dCICcUUEQEH4NCABIAJyNgIAIAAMAQsgACgCCAshASAAIAQ2AgggASAENgIMIAQgADYCDCAEIAE2AggMAQtBHyEAIANB////B00EQCADQSYgA0EIdmciAGt2QQFxIABBAXRrQT5qIQALIAQgADYCHCAEQgA3AhAgAEECdEGoN2ohAQJAAkAgB0EBIAB0IgJxRQRAQfw0IAIgB3I2AgAgASAENgIAIAQgATYCGAwBCyADQRkgAEEBdmtBACAAQR9HG3QhACABKAIAIQEDQCABIgIoAgRBeHEgA0YNAiAAQR12IQEgAEEBdCEAIAIgAUEEcWoiBygCECIBDQALIAcgBDYCECAEIAI2AhgLIAQgBDYCDCAEIAQ2AggMAQsgAigCCCIAIAQ2AgwgAiAENgIIIARBADYCGCAEIAI2AgwgBCAANgIICyAFQQhqIQAMAQsCQCAJRQ0AAkAgAigCHCIBQQJ0Qag3aiIFKAIAIAJGBEAgBSAANgIAIAANAUH8NCALQX4gAXdxNgIADAILIAlBEEEUIAkoAhAgAkYbaiAANgIAIABFDQELIAAgCTYCGCACKAIQIgEEQCAAIAE2AhAgASAANgIYCyACKAIUIgFFDQAgACABNgIUIAEgADYCGAsCQCADQQ9NBEAgAiADIAZqIgBBA3I2AgQgACACaiIAIAAoAgRBAXI2AgQMAQsgAiAGQQNyNgIEIAIgBmoiBSADQQFyNgIEIAMgBWogAzYCACAIBEAgCEF4cUGgNWohAEGMNSgCACEBAn9BASAIQQN2dCIHIARxRQRAQfg0IAQgB3I2AgAgAAwBCyAAKAIICyEEIAAgATYCCCAEIAE2AgwgASAANgIMIAEgBDYCCAtBjDUgBTYCAEGANSADNgIACyACQQhqIQALIApBEGokACAAC5cCACAARQRAQQAPCwJ/AkAgAAR/IAFB/wBNDQECQEHUNCgCACgCAEUEQCABQYB/cUGAvwNGDQMMAQsgAUH/D00EQCAAIAFBP3FBgAFyOgABIAAgAUEGdkHAAXI6AABBAgwECyABQYBAcUGAwANHIAFBgLADT3FFBEAgACABQT9xQYABcjoAAiAAIAFBDHZB4AFyOgAAIAAgAUEGdkE/cUGAAXI6AAFBAwwECyABQYCABGtB//8/TQRAIAAgAUE/cUGAAXI6AAMgACABQRJ2QfABcjoAACAAIAFBBnZBP3FBgAFyOgACIAAgAUEMdkE/cUGAAXI6AAFBBAwECwtBuDNBGTYCAEF/BUEBCwwBCyAAIAE6AABBAQsLoRgDE38BfAJ+IwBBsARrIgwkACAMQQA2AiwCQCABvSIaQgBTBEBBASEPQfYIIRMgAZoiAb0hGgwBCyAEQYAQcQRAQQEhD0H5CCETDAELQfwIQfcIIARBAXEiDxshEyAPRSEVCwJAIBpCgICAgICAgPj/AINCgICAgICAgPj/AFEEQCAAQSAgAiAPQQNqIgMgBEH//3txEAYgACATIA8QBSAAQZ8JQdwJIAVBIHEiBRtBuAlB4AkgBRsgASABYhtBAxAFIABBICACIAMgBEGAwABzEAYgAyACIAIgA0gbIQkMAQsgDEEQaiESAkACfwJAIAEgDEEsahArIgEgAaAiAUQAAAAAAAAAAGIEQCAMIAwoAiwiBkEBazYCLCAFQSByIg5B4QBHDQEMAwsgBUEgciIOQeEARg0CIAwoAiwhCkEGIAMgA0EASBsMAQsgDCAGQR1rIgo2AiwgAUQAAAAAAACwQaIhAUEGIAMgA0EASBsLIQsgDEEwakGgAkEAIApBAE4baiINIQcDQCAHAn8gAUQAAAAAAADwQWMgAUQAAAAAAAAAAGZxBEAgAasMAQtBAAsiAzYCACAHQQRqIQcgASADuKFEAAAAAGXNzUGiIgFEAAAAAAAAAABiDQALAkAgCkEATARAIAohAyAHIQYgDSEIDAELIA0hCCAKIQMDQEEdIAMgA0EdTxshAwJAIAdBBGsiBiAISQ0AIAOtIRtCACEaA0AgBiAaQv////8PgyAGNQIAIBuGfCIaIBpCgJTr3AOAIhpCgJTr3AN+fT4CACAGQQRrIgYgCE8NAAsgGqciBkUNACAIQQRrIgggBjYCAAsDQCAIIAciBkkEQCAGQQRrIgcoAgBFDQELCyAMIAwoAiwgA2siAzYCLCAGIQcgA0EASg0ACwsgA0EASARAIAtBGWpBCW5BAWohECAOQeYARiERA0BBCUEAIANrIgMgA0EJTxshCQJAIAYgCE0EQCAIKAIARUECdCEHDAELQYCU69wDIAl2IRRBfyAJdEF/cyEWQQAhAyAIIQcDQCAHIAMgBygCACIXIAl2ajYCACAWIBdxIBRsIQMgB0EEaiIHIAZJDQALIAgoAgBFQQJ0IQcgA0UNACAGIAM2AgAgBkEEaiEGCyAMIAwoAiwgCWoiAzYCLCANIAcgCGoiCCARGyIHIBBBAnRqIAYgBiAHa0ECdSAQShshBiADQQBIDQALC0EAIQMCQCAGIAhNDQAgDSAIa0ECdUEJbCEDQQohByAIKAIAIglBCkkNAANAIANBAWohAyAJIAdBCmwiB08NAAsLIAsgA0EAIA5B5gBHG2sgDkHnAEYgC0EAR3FrIgcgBiANa0ECdUEJbEEJa0gEQCAMQTBqQQRBpAIgCkEASBtqIAdBgMgAaiIJQQltIhFBAnRqIhBBgCBrIQpBCiEHIAkgEUEJbGsiCUEHTARAA0AgB0EKbCEHIAlBAWoiCUEIRw0ACwsCQCAKKAIAIhEgESAHbiIUIAdsayIJRSAQQfwfayIWIAZGcQ0AAkAgFEEBcUUEQEQAAAAAAABAQyEBIAdBgJTr3ANHDQEgCCAKTw0BIBBBhCBrLQAAQQFxRQ0BC0QBAAAAAABAQyEBC0QAAAAAAADgP0QAAAAAAADwP0QAAAAAAAD4PyAGIBZGG0QAAAAAAAD4PyAJIAdBAXYiFEYbIAkgFEkbIRkCQCAVDQAgEy0AAEEtRw0AIBmaIRkgAZohAQsgCiARIAlrIgk2AgAgASAZoCABYQ0AIAogByAJaiIDNgIAIANBgJTr3ANPBEADQCAKQQA2AgAgCCAKQQRrIgpLBEAgCEEEayIIQQA2AgALIAogCigCAEEBaiIDNgIAIANB/5Pr3ANLDQALCyANIAhrQQJ1QQlsIQNBCiEHIAgoAgAiCUEKSQ0AA0AgA0EBaiEDIAkgB0EKbCIHTw0ACwsgCkEEaiIHIAYgBiAHSxshBgsDQCAGIgcgCE0iCUUEQCAGQQRrIgYoAgBFDQELCwJAIA5B5wBHBEAgBEEIcSEKDAELIANBf3NBfyALQQEgCxsiBiADSiADQXtKcSIKGyAGaiELQX9BfiAKGyAFaiEFIARBCHEiCg0AQXchBgJAIAkNACAHQQRrKAIAIg5FDQBBCiEJQQAhBiAOQQpwDQADQCAGIgpBAWohBiAOIAlBCmwiCXBFDQALIApBf3MhBgsgByANa0ECdUEJbCEJIAVBX3FBxgBGBEBBACEKIAsgBiAJakEJayIGQQAgBkEAShsiBiAGIAtKGyELDAELQQAhCiALIAMgCWogBmpBCWsiBkEAIAZBAEobIgYgBiALShshCwtBfyEJIAtB/f///wdB/v///wcgCiALciIRG0oNASALIBFBAEdqQQFqIQ4CQCAFQV9xIhVBxgBGBEAgAyAOQf////8Hc0oNAyADQQAgA0EAShshBgwBCyASIAMgA0EfdSIGcyAGa60gEhAOIgZrQQFMBEADQCAGQQFrIgZBMDoAACASIAZrQQJIDQALCyAGQQJrIhAgBToAACAGQQFrQS1BKyADQQBIGzoAACASIBBrIgYgDkH/////B3NKDQILIAYgDmoiAyAPQf////8Hc0oNASAAQSAgAiADIA9qIgUgBBAGIAAgEyAPEAUgAEEwIAIgBSAEQYCABHMQBgJAAkACQCAVQcYARgRAIAxBEGoiBkEIciEDIAZBCXIhCiANIAggCCANSxsiCSEIA0AgCDUCACAKEA4hBgJAIAggCUcEQCAGIAxBEGpNDQEDQCAGQQFrIgZBMDoAACAGIAxBEGpLDQALDAELIAYgCkcNACAMQTA6ABggAyEGCyAAIAYgCiAGaxAFIAhBBGoiCCANTQ0ACyARBEAgAEHkCUEBEAULIAcgCE0NASALQQBMDQEDQCAINQIAIAoQDiIGIAxBEGpLBEADQCAGQQFrIgZBMDoAACAGIAxBEGpLDQALCyAAIAZBCSALIAtBCU4bEAUgC0EJayEGIAhBBGoiCCAHTw0DIAtBCUohGCAGIQsgGA0ACwwCCwJAIAtBAEgNACAHIAhBBGogByAISxshCSAMQRBqIgZBCHIhAyAGQQlyIQ0gCCEHA0AgDSAHNQIAIA0QDiIGRgRAIAxBMDoAGCADIQYLAkAgByAIRwRAIAYgDEEQak0NAQNAIAZBAWsiBkEwOgAAIAYgDEEQaksNAAsMAQsgACAGQQEQBSAGQQFqIQYgCiALckUNACAAQeQJQQEQBQsgACAGIA0gBmsiBiALIAYgC0gbEAUgCyAGayELIAdBBGoiByAJTw0BIAtBAE4NAAsLIABBMCALQRJqQRJBABAGIAAgECASIBBrEAUMAgsgCyEGCyAAQTAgBkEJakEJQQAQBgsgAEEgIAIgBSAEQYDAAHMQBiAFIAIgAiAFSBshCQwBCyATIAVBGnRBH3VBCXFqIQgCQCADQQtLDQBBDCADayEGRAAAAAAAADBAIRkDQCAZRAAAAAAAADBAoiEZIAZBAWsiBg0ACyAILQAAQS1GBEAgGSABmiAZoaCaIQEMAQsgASAZoCAZoSEBCyASIAwoAiwiBiAGQR91IgZzIAZrrSASEA4iBkYEQCAMQTA6AA8gDEEPaiEGCyAPQQJyIQsgBUEgcSENIAwoAiwhByAGQQJrIgogBUEPajoAACAGQQFrQS1BKyAHQQBIGzoAACAEQQhxIQYgDEEQaiEHA0AgByIFAn8gAZlEAAAAAAAA4EFjBEAgAaoMAQtBgICAgHgLIgdBoCVqLQAAIA1yOgAAIAEgB7ehRAAAAAAAADBAoiEBAkAgBUEBaiIHIAxBEGprQQFHDQACQCAGDQAgA0EASg0AIAFEAAAAAAAAAABhDQELIAVBLjoAASAFQQJqIQcLIAFEAAAAAAAAAABiDQALQX8hCUH9////ByALIBIgCmsiBmoiDWsgA0gNACAAQSAgAiANIANBAmogByAMQRBqIgdrIgUgBUECayADSBsgBSADGyIJaiIDIAQQBiAAIAggCxAFIABBMCACIAMgBEGAgARzEAYgACAHIAUQBSAAQTAgCSAFa0EAQQAQBiAAIAogBhAFIABBICACIAMgBEGAwABzEAYgAyACIAIgA0gbIQkLIAxBsARqJAAgCQu0AgACQAJAAkACQAJAAkACQAJAAkACQAJAIAFBCWsOEgAICQoICQECAwQKCQoKCAkFBgcLIAIgAigCACIBQQRqNgIAIAAgASgCADYCAA8LIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LIAIgAigCAEEHakF4cSIBQQhqNgIAIAAgASsDADkDAA8LAAsPCyACIAIoAgAiAUEEajYCACAAIAE0AgA3AwAPCyACIAIoAgAiAUEEajYCACAAIAE1AgA3AwAPCyACIAIoAgBBB2pBeHEiAUEIajYCACAAIAEpAwA3AwALcwEGfyAAKAIAIgMsAABBMGsiAUEJSwRAQQAPCwNAQX8hBCACQcyZs+YATQRAQX8gASACQQpsIgVqIAEgBUH/////B3NLGyEECyAAIANBAWoiBTYCACADLAABIQYgBCECIAUhAyAGQTBrIgFBCkkNAAsgAguTFAIWfwF+Qe0JIQUjAEHQAGsiBiQAIAZB7Qk2AkwgBkE3aiEUIAZBOGohDwJAAkACQAJAA0BBACEEA0AgBSELIAQgDEH/////B3NKDQIgBCAMaiEMAkACQAJAIAUiBC0AACIJBEADQAJAAkAgCUH/AXEiBUUEQCAEIQUMAQsgBUElRw0BIAQhCQNAIAktAAFBJUcEQCAJIQUMAgsgBEEBaiEEIAktAAIhFyAJQQJqIgUhCSAXQSVGDQALCyAEIAtrIgQgDEH/////B3MiFUoNCCAABEAgACALIAQQBQsgBA0GIAYgBTYCTCAFQQFqIQRBfyEOAkAgBSwAAUEwayIHQQlLDQAgBS0AAkEkRw0AIAVBA2ohBEEBIRAgByEOCyAGIAQ2AkxBACEKAkAgBCwAACIJQSBrIgVBH0sEQCAEIQcMAQsgBCEHQQEgBXQiBUGJ0QRxRQ0AA0AgBiAEQQFqIgc2AkwgBSAKciEKIAQsAAEiCUEgayIFQSBPDQEgByEEQQEgBXQiBUGJ0QRxDQALCwJAIAlBKkYEQAJ/AkAgBywAAUEwayIEQQlLDQAgBy0AAkEkRw0AAn8gAEUEQCADIARBAnRqQQo2AgBBAAwBCyACIARBA3RqKAIACyENIAdBA2ohBUEBDAELIBANBiAHQQFqIQUgAEUEQCAGIAU2AkxBACEQQQAhDQwDCyABIAEoAgAiBEEEajYCACAEKAIAIQ1BAAshECAGIAU2AkwgDUEATg0BQQAgDWshDSAKQYDAAHIhCgwBCyAGQcwAahApIg1BAEgNCSAGKAJMIQULQQAhBEF/IQgCf0EAIAUtAABBLkcNABogBS0AAUEqRgRAAn8CQCAFLAACQTBrIgdBCUsNACAFLQADQSRHDQAgBUEEaiEFAn8gAEUEQCADIAdBAnRqQQo2AgBBAAwBCyACIAdBA3RqKAIACwwBCyAQDQYgBUECaiEFQQAgAEUNABogASABKAIAIgdBBGo2AgAgBygCAAshCCAGIAU2AkwgCEEATgwBCyAGIAVBAWo2AkwgBkHMAGoQKSEIIAYoAkwhBUEBCyERA0AgBCESQRwhByAFIhYsAAAiBEH7AGtBRkkNCiAFQQFqIQUgBCASQTpsakGPIWotAAAiBEEBa0EISQ0ACyAGIAU2AkwCQCAEQRtHBEAgBEUNCyAOQQBOBEAgAEUEQCADIA5BAnRqIAQ2AgAMCwsgBiACIA5BA3RqKQMANwNADAILIABFDQcgBkFAayAEIAEQKAwBCyAOQQBODQpBACEEIABFDQcLIAAtAABBIHENCiAKQf//e3EiCSAKIApBgMAAcRshCkEAIQ5B7AghEyAPIQcCQAJAAkACfwJAAkACQAJAAn8CQAJAAkACQAJAAkACQCAWLAAAIgRBU3EgBCAEQQ9xQQNGGyAEIBIbIgRB2ABrDiEEFBQUFBQUFBQOFA8GDg4OFAYUFBQUAgUDFBQJFAEUFAQACwJAIARBwQBrDgcOFAsUDg4OAAsgBEHTAEYNCQwTCyAGKQNAIRpB7AgMBQtBACEEAkACQAJAAkACQAJAAkAgEkH/AXEOCAABAgMEGgUGGgsgBigCQCAMNgIADBkLIAYoAkAgDDYCAAwYCyAGKAJAIAysNwMADBcLIAYoAkAgDDsBAAwWCyAGKAJAIAw6AAAMFQsgBigCQCAMNgIADBQLIAYoAkAgDKw3AwAMEwtBCCAIIAhBCE0bIQggCkEIciEKQfgAIQQLIA8hCyAGKQNAIhpCAFIEQCAEQSBxIQUDQCALQQFrIgsgGqdBD3FBoCVqLQAAIAVyOgAAIBpCD1YhGCAaQgSIIRogGA0ACwsgBikDQFANAyAKQQhxRQ0DIARBBHZB7AhqIRNBAiEODAMLIA8hBCAGKQNAIhpCAFIEQANAIARBAWsiBCAap0EHcUEwcjoAACAaQgdWIRkgGkIDiCEaIBkNAAsLIAQhCyAKQQhxRQ0CIAggDyAEayIEQQFqIAQgCEgbIQgMAgsgBikDQCIaQgBTBEAgBkIAIBp9Iho3A0BBASEOQewIDAELIApBgBBxBEBBASEOQe0IDAELQe4IQewIIApBAXEiDhsLIRMgGiAPEA4hCwsgESAIQQBIcQ0PIApB//97cSAKIBEbIQoCQCAGKQNAIhpCAFINACAIDQAgDyELQQAhCAwMCyAIIBpQIA8gC2tqIgQgBCAISBshCAwLCwJ/Qf////8HIAggCEH/////B08bIgoiBUEARyEHAkACQAJAIAYoAkAiBEHmCSAEGyILIgRBA3FFDQAgBUUNAANAIAQtAABFDQIgBUEBayIFQQBHIQcgBEEBaiIEQQNxRQ0BIAUNAAsLIAdFDQECQCAELQAARQ0AIAVBBEkNAANAIAQoAgAiB0F/cyAHQYGChAhrcUGAgYKEeHENAiAEQQRqIQQgBUEEayIFQQNLDQALCyAFRQ0BCwNAIAQgBC0AAEUNAhogBEEBaiEEIAVBAWsiBQ0ACwtBAAsiBCALayAKIAQbIgQgC2ohByAIQQBOBEAgCSEKIAQhCAwLCyAJIQogBCEIIActAAANDgwKCyAIBEAgBigCQAwCC0EAIQQgAEEgIA1BACAKEAYMAgsgBkEANgIMIAYgBikDQD4CCCAGIAZBCGoiBDYCQEF/IQggBAshCUEAIQQDQAJAIAkoAgAiC0UNACAGQQRqIAsQJiILQQBIDQ8gCyAIIARrSw0AIAlBBGohCSAEIAtqIgQgCEkNAQsLQT0hByAEQQBIDQwgAEEgIA0gBCAKEAYgBEUEQEEAIQQMAQtBACEHIAYoAkAhCQNAIAkoAgAiC0UNASAGQQRqIgggCxAmIgsgB2oiByAESw0BIAAgCCALEAUgCUEEaiEJIAQgB0sNAAsLIABBICANIAQgCkGAwABzEAYgDSAEIAQgDUgbIQQMCAsgESAIQQBIcQ0JQT0hByAAIAYrA0AgDSAIIAogBBAnIgRBAE4NBwwKCyAGIAYpA0A8ADdBASEIIBQhCyAJIQoMBAsgBC0AASEJIARBAWohBAwACwALIAANCCAQRQ0CQQEhBANAIAMgBEECdGooAgAiAARAIAIgBEEDdGogACABEChBASEMIARBAWoiBEEKRw0BDAoLC0EBIQwgBEEKTw0IA0AgAyAEQQJ0aigCAA0BIARBAWoiBEEKRw0ACwwIC0EcIQcMBQsgCCAHIAtrIgkgCCAJShsiCCAOQf////8Hc0oNA0E9IQcgDSAIIA5qIgUgBSANSBsiBCAVSg0EIABBICAEIAUgChAGIAAgEyAOEAUgAEEwIAQgBSAKQYCABHMQBiAAQTAgCCAJQQAQBiAAIAsgCRAFIABBICAEIAUgCkGAwABzEAYgBigCTCEFDAELCwtBACEMDAMLQT0hBwtBuDMgBzYCAAtBfyEMCyAGQdAAaiQAIAwLfgIBfwF+IAC9IgNCNIinQf8PcSICQf8PRwR8IAJFBEAgASAARAAAAAAAAAAAYQR/QQAFIABEAAAAAAAA8EOiIAEQKyEAIAEoAgBBQGoLNgIAIAAPCyABIAJB/gdrNgIAIANC/////////4eAf4NCgICAgICAgPA/hL8FIAALC3oBA38CQAJAIAAiAUEDcUUNACABLQAARQRAQQAPCwNAIAFBAWoiAUEDcUUNASABLQAADQALDAELA0AgASICQQRqIQEgAigCACIDQX9zIANBgYKECGtxQYCBgoR4cUUNAAsDQCACIgFBAWohAiABLQAADQALCyABIABrCwIAC8gCAQZ/IwBBEGsiAyQAIAMgADYCDCMAQdABayIBJAAgASAANgLMASABQaABaiIAQQBBKBAHGiABIAEoAswBNgLIAQJAQQAgAUHIAWogAUHQAGogABAqQQBIDQBB1CooAgBBAEghBkGIKkGIKigCACIEQV9xNgIAAn8CQAJAQbgqKAIARQRAQbgqQdAANgIAQaQqQQA2AgBBmCpCADcDAEG0KigCACECQbQqIAE2AgAMAQtBmCooAgANAQtBf0GIKhAaDQEaC0GIKiABQcgBaiABQdAAaiABQaABahAqCyEFIAIEf0GIKkEAQQBBrCooAgARAgAaQbgqQQA2AgBBtCogAjYCAEGkKkEANgIAQZwqKAIAGkGYKkIANwMAQQAFIAULGkGIKkGIKigCACAEQSBxcjYCACAGDQALIAFB0AFqJAAgA0EQaiQAC5QDAgR/A3wjAEEQayIDJAACQCAAvCIEQf////8HcSICQdqfpO4ETQRAIAEgALsiByAHRIPIyW0wX+Q/okQAAAAAAAA4Q6BEAAAAAAAAOMOgIgZEAAAAUPsh+b+ioCAGRGNiGmG0EFG+oqAiCDkDACAIRAAAAGD7Iem/YyEFAn8gBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIQIgBQRAIAEgByAGRAAAAAAAAPC/oCIGRAAAAFD7Ifm/oqAgBkRjYhphtBBRvqKgOQMAIAJBAWshAgwCCyAIRAAAAGD7Iek/ZEUNASABIAcgBkQAAAAAAADwP6AiBkQAAABQ+yH5v6KgIAZEY2IaYbQQUb6ioDkDACACQQFqIQIMAQsgAkGAgID8B08EQCABIAAgAJO7OQMAQQAhAgwBCyADIAIgAkEXdkGWAWsiAkEXdGu+uzkDCCADQQhqIAMgAkEBQQAQMSECIAMrAwAhBiAEQQBIBEAgASAGmjkDAEEAIAJrIQIMAQsgASAGOQMACyADQRBqJAAgAgu8CgMHfwR8AX4jAEEwayIEJAACQAJAAkAgAL0iDUIgiKciAkH/////B3EiA0H61L2ABE0EQCACQf//P3FB+8MkRg0BIANB/LKLgARNBEAgDUIAWQRAIAEgAEQAAEBU+yH5v6AiCUQxY2IaYbTQvaAiADkDACABIAkgAKFEMWNiGmG00L2gOQMIQQEhAgwFCyABIABEAABAVPsh+T+gIglEMWNiGmG00D2gIgA5AwAgASAJIAChRDFjYhphtNA9oDkDCEF/IQIMBAsgDUIAWQRAIAEgAEQAAEBU+yEJwKAiCUQxY2IaYbTgvaAiADkDACABIAkgAKFEMWNiGmG04L2gOQMIQQIhAgwECyABIABEAABAVPshCUCgIglEMWNiGmG04D2gIgA5AwAgASAJIAChRDFjYhphtOA9oDkDCEF+IQIMAwsgA0G7jPGABE0EQCADQbz714AETQRAIANB/LLLgARGDQIgDUIAWQRAIAEgAEQAADB/fNkSwKAiCUTKlJOnkQ7pvaAiADkDACABIAkgAKFEypSTp5EO6b2gOQMIQQMhAgwFCyABIABEAAAwf3zZEkCgIglEypSTp5EO6T2gIgA5AwAgASAJIAChRMqUk6eRDuk9oDkDCEF9IQIMBAsgA0H7w+SABEYNASANQgBZBEAgASAARAAAQFT7IRnAoCIJRDFjYhphtPC9oCIAOQMAIAEgCSAAoUQxY2IaYbTwvaA5AwhBBCECDAQLIAEgAEQAAEBU+yEZQKAiCUQxY2IaYbTwPaAiADkDACABIAkgAKFEMWNiGmG08D2gOQMIQXwhAgwDCyADQfrD5IkESw0BCyAAIABEg8jJbTBf5D+iRAAAAAAAADhDoEQAAAAAAAA4w6AiCkQAAEBU+yH5v6KgIgsgCkQxY2IaYbTQPaIiDKEiCUQYLURU+yHpv2MhBQJ/IAqZRAAAAAAAAOBBYwRAIAqqDAELQYCAgIB4CyECAkAgBQRAIAJBAWshAiAKRAAAAAAAAPC/oCIKRDFjYhphtNA9oiEMIAAgCkQAAEBU+yH5v6KgIQsMAQsgCUQYLURU+yHpP2RFDQAgAkEBaiECIApEAAAAAAAA8D+gIgpEMWNiGmG00D2iIQwgACAKRAAAQFT7Ifm/oqAhCwsgASALIAyhIgA5AwACQCADQRR2IgUgAL1CNIinQf8PcWtBEUgNACABIAsgCkQAAGAaYbTQPaIiAKEiCSAKRHNwAy6KGaM7oiALIAmhIAChoSIMoSIAOQMAIAUgAL1CNIinQf8PcWtBMkgEQCAJIQsMAQsgASAJIApEAAAALooZozuiIgChIgsgCkTBSSAlmoN7OaIgCSALoSAAoaEiDKEiADkDAAsgASALIAChIAyhOQMIDAELIANBgIDA/wdPBEAgASAAIAChIgA5AwAgASAAOQMIQQAhAgwBCyAEQRBqIgJBCHIhByANQv////////8Hg0KAgICAgICAsMEAhL8hAEEBIQYDQCACAn8gAJlEAAAAAAAA4EFjBEAgAKoMAQtBgICAgHgLtyIJOQMAIAAgCaFEAAAAAAAAcEGiIQAgBiEIQQAhBiAHIQIgCA0ACyAEIAA5AyBBAiECA0AgAiIFQQFrIQIgBEEQaiIGIAVBA3RqKwMARAAAAAAAAAAAYQ0ACyAGIAQgA0EUdkGWCGsgBUEBakEBEDEhAiAEKwMAIQAgDUIAUwRAIAEgAJo5AwAgASAEKwMImjkDCEEAIAJrIQIMAQsgASAAOQMAIAEgBCsDCDkDCAsgBEEwaiQAIAILwBECA3wXfyMAQbAEayIJJAAgAiACQQNrQRhtIghBACAIQQBKGyISQWhsaiEMIARBAnRBsAtqKAIAIg0gA0EBayILakEATgRAIAMgDWohCCASIAtrIQIDQCAJQcACaiAKQQN0aiACQQBIBHxEAAAAAAAAAAAFIAJBAnRBwAtqKAIAtws5AwAgAkEBaiECIApBAWoiCiAIRw0ACwsgDEEYayEPQQAhCCANQQAgDUEAShshCiADQQBMIQ4DQAJAIA4EQEQAAAAAAAAAACEFDAELIAggC2ohEUEAIQJEAAAAAAAAAAAhBQNAIAAgAkEDdGorAwAgCUHAAmogESACa0EDdGorAwCiIAWgIQUgAkEBaiICIANHDQALCyAJIAhBA3RqIAU5AwAgCCAKRiEYIAhBAWohCCAYRQ0AC0EvIAxrIRRBMCAMayERIAxBGWshFSANIQgCQANAIAkgCEEDdGorAwAhBUEAIQIgCCEKIAhBAEwiEEUEQANAIAlB4ANqIAJBAnRqAn8CfyAFRAAAAAAAAHA+oiIGmUQAAAAAAADgQWMEQCAGqgwBC0GAgICAeAu3IgZEAAAAAAAAcMGiIAWgIgWZRAAAAAAAAOBBYwRAIAWqDAELQYCAgIB4CzYCACAJIApBAWsiCkEDdGorAwAgBqAhBSACQQFqIgIgCEcNAAsLAn8gBSAPEBQiBSAFRAAAAAAAAMA/opxEAAAAAAAAIMCioCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAshDiAFIA63oSEFAkACQAJAAn8gD0EATCIWRQRAIAhBAnQgCWoiAiACKALcAyICIAIgEXUiAiARdGsiCjYC3AMgAiAOaiEOIAogFHUMAQsgDw0BIAhBAnQgCWooAtwDQRd1CyILQQBMDQIMAQtBAiELIAVEAAAAAAAA4D9mDQBBACELDAELQQAhAkEAIQogEEUEQANAIAlB4ANqIAJBAnRqIhcoAgAhEEH///8HIRMCfwJAIAoNAEGAgIAIIRMgEA0AQQAMAQsgFyATIBBrNgIAQQELIQogAkEBaiICIAhHDQALCwJAIBYNAEH///8DIQICQAJAIBUOAgEAAgtB////ASECCyAIQQJ0IAlqIhAgECgC3AMgAnE2AtwDCyAOQQFqIQ4gC0ECRw0ARAAAAAAAAPA/IAWhIQVBAiELIApFDQAgBUQAAAAAAADwPyAPEBShIQULIAVEAAAAAAAAAABhBEBBACEKIAghAgJAIAggDUwNAANAIAlB4ANqIAJBAWsiAkECdGooAgAgCnIhCiACIA1KDQALIApFDQAgDyEMA0AgDEEYayEMIAlB4ANqIAhBAWsiCEECdGooAgBFDQALDAMLQQEhAgNAIAIiCkEBaiECIAlB4ANqIA0gCmtBAnRqKAIARQ0ACyAIIApqIQoDQCAJQcACaiADIAhqIgtBA3RqIAhBAWoiCCASakECdEHAC2ooAgC3OQMAQQAhAkQAAAAAAAAAACEFIANBAEoEQANAIAAgAkEDdGorAwAgCUHAAmogCyACa0EDdGorAwCiIAWgIQUgAkEBaiICIANHDQALCyAJIAhBA3RqIAU5AwAgCCAKSA0ACyAKIQgMAQsLAkAgBUEYIAxrEBQiBUQAAAAAAABwQWYEQCAJQeADaiAIQQJ0agJ/An8gBUQAAAAAAABwPqIiBplEAAAAAAAA4EFjBEAgBqoMAQtBgICAgHgLIgK3RAAAAAAAAHDBoiAFoCIFmUQAAAAAAADgQWMEQCAFqgwBC0GAgICAeAs2AgAgCEEBaiEIDAELAn8gBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIQIgDyEMCyAJQeADaiAIQQJ0aiACNgIAC0QAAAAAAADwPyAMEBQhBQJAIAhBAEgNACAIIQMDQCAJIAMiAEEDdGogBSAJQeADaiAAQQJ0aigCALeiOQMAIABBAWshAyAFRAAAAAAAAHA+oiEFIAANAAsgCEEASA0AIAghCgNARAAAAAAAAAAAIQVBACECIA0gCCAKayIAIAAgDUobIgNBAE4EQANAIAJBA3RBkCFqKwMAIAkgAiAKakEDdGorAwCiIAWgIQUgAiADRyEZIAJBAWohAiAZDQALCyAJQaABaiAAQQN0aiAFOQMAIApBAEohGiAKQQFrIQogGg0ACwsCQAJAAkACQAJAIAQOBAECAgAEC0QAAAAAAAAAACEGAkAgCEEATA0AIAlBoAFqIAhBA3RqKwMAIQUgCCECA0AgCUGgAWoiAyACQQN0aiAFIAJBAWsiAEEDdCADaiIEKwMAIgcgByAFoCIFoaA5AwAgBCAFOQMAIAJBAUshGyAAIQIgGw0ACyAIQQFGDQAgCEEDdCADaisDACEFIAghAgNAIAlBoAFqIgMgAkEDdGogBSADIAJBAWsiAEEDdGoiAysDACIGIAYgBaAiBaGgOQMAIAMgBTkDACACQQJLIRwgACECIBwNAAtEAAAAAAAAAAAhBiAIQQFGDQADQCAGIAlBoAFqIAhBA3RqKwMAoCEGIAhBAkohHSAIQQFrIQggHQ0ACwsgCSsDoAEhBSALDQIgASAFOQMAIAkrA6gBIQUgASAGOQMQIAEgBTkDCAwDC0QAAAAAAAAAACEFIAhBAE4EQANAIAgiAEEBayEIIAUgCUGgAWogAEEDdGorAwCgIQUgAA0ACwsgASAFmiAFIAsbOQMADAILRAAAAAAAAAAAIQUgCEEATgRAIAghAwNAIAMiAEEBayEDIAUgCUGgAWogAEEDdGorAwCgIQUgAA0ACwsgASAFmiAFIAsbOQMAIAkrA6ABIAWhIQVBASECIAhBAEoEQANAIAUgCUGgAWogAkEDdGorAwCgIQUgAiAIRyEeIAJBAWohAiAeDQALCyABIAWaIAUgCxs5AwgMAQsgASAFmjkDACAJKwOoASEFIAEgBpo5AxAgASAFmjkDCAsgCUGwBGokACAOQQdxC44PAQh/AkAgASAAKAIMIgQgACgCCCIDa0EGdSICRg0AAkAgASACSwRAIAEgAmsiBiAAKAIQIgUgBCIDa0EGdU0EQAJAIAZFDQAgAyECIAZBA3EiBQRAQQAhBANAIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIkIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIUIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwIEIAJBgICA/AM2AjwgAkGAgID8AzYCACACQgA3AjQgAkGAgID8AzYCKCACQYCAgPwDNgIUIAJBQGshAiAEQQFqIgQgBUcNAAsLIAZBBnQgA2ohAyAGQQFrQf///x9xQQNJDQADQCAC/QwAAAAAAAAAAAAAAAAAAAAA/QsCJCAC/QwAAAAAAAAAAAAAAAAAAAAA/QsCFCAC/QwAAAAAAAAAAAAAAAAAAAAA/QsCTCAC/QwAAAAAAAAAAAAAAAAAAAAA/QsCXCAC/QwAAAAAAAAAAAAAAAAAAAAA/QsCBCACQgA3AkQgAkGAgID8AzYCACACQoCAgPyDgIDAPzcCPCACQYCAgPwDNgJ8IAL9DAAAAAAAAAAAAAAAAAAAAAD9CwKEASACQgA3AjQgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAmwgAv0MAAAAAAAAAAAAAAAAAAAAAP0LApQBIAJCADcCtAEgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAqQBIAJBgICA/AM2AiggAkGAgID8AzYCFCACQYCAgPwDNgJUIAJBgICA/AM2AmggAkGAgID8AzYCvAEgAkGAgID8AzYCqAEgAkGAgID8AzYClAEgAkGAgID8AzYCgAEgAkIANwL0ASAC/QwAAAAAAAAAAAAAAAAAAAAA/QsC5AEgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAtQBIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwLEASACQYCAgPwDNgL8ASACQYCAgPwDNgLoASACQYCAgPwDNgLUASACQYCAgPwDNgLAASACQYACaiICIANHDQALCyAAIAM2AgwMAgsCQCADIAAoAggiAmtBBnUiCCAGaiIHQYCAgCBJBEBBACEDQf///x8gBSACayIFQQV1IgIgByACIAdLGyAFQcD///8HTxsiBwRAIAdBgICAIE8NAiAHQQZ0EAshAwsgAyAIQQZ0aiIEIQIgBkEDcSIFBEADQCAC/QwAAAAAAAAAAAAAAAAAAAAA/QsCJCAC/QwAAAAAAAAAAAAAAAAAAAAA/QsCFCAC/QwAAAAAAAAAAAAAAAAAAAAA/QsCBCACQYCAgPwDNgI8IAJBgICA/AM2AgAgAkIANwI0IAJBgICA/AM2AiggAkGAgID8AzYCFCACQUBrIQIgCUEBaiIJIAVHDQALCyAGQQZ0IARqIQggBkEBa0H///8fcUEDTwRAA0AgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAiQgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAhQgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAkwgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAlwgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgQgAkIANwJEIAJBgICA/AM2AgAgAkKAgID8g4CAwD83AjwgAkGAgID8AzYCfCAC/QwAAAAAAAAAAAAAAAAAAAAA/QsChAEgAkIANwI0IAL9DAAAAAAAAAAAAAAAAAAAAAD9CwJsIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwKUASACQgA3ArQBIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwKkASACQYCAgPwDNgIoIAJBgICA/AM2AhQgAkGAgID8AzYCVCACQYCAgPwDNgJoIAJBgICA/AM2ArwBIAJBgICA/AM2AqgBIAJBgICA/AM2ApQBIAJBgICA/AM2AoABIAJCADcC9AEgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAuQBIAL9DAAAAAAAAAAAAAAAAAAAAAD9CwLUASAC/QwAAAAAAAAAAAAAAAAAAAAA/QsCxAEgAkGAgID8AzYC/AEgAkGAgID8AzYC6AEgAkGAgID8AzYC1AEgAkGAgID8AzYCwAEgAkGAAmoiAiAIRw0ACwsgACgCDCICIAAoAggiBUcEQANAIARBQGoiBCACQUBqIgL9AAIA/QsCACAEIAL9AAIw/QsCMCAEIAL9AAIg/QsCICAEIAL9AAIQ/QsCECACIAVHDQALIAAoAgghAgsgACADIAdBBnRqNgIQIAAgCDYCDCAAIAQ2AgggAgRAIAIQFgsMAwsQEwALEBIACyABIAJPDQAgACADIAFBBnRqNgIMCwJAIAAoAhggACgCFCIDa0EkbSICIAFJBEAgAEEUaiABIAJrEDQMAQsgASACTw0AIAAgAyABQSRsajYCGAsCQCAAKAIkIAAoAiAiA2tBBHUiAiABSQRAIABBIGogASACaxA7DAELIAEgAk8NACAAIAMgAUEEdGo2AiQLIAAoAjAgACgCLCIDa0EkbSICIAFJBEAgAEEsaiABIAJrEDQPCyABIAJPDQAgACADIAFBJGxqNgIwCwvmCQMEfw59EHsjAEFAaiIDJAAgACgCCCABQQZ0aiECIAAoAiAgAUEEdGoiBSgCAARAIAFBJGwiBCAAKAIUaiIBKgIMIQcCQCAFKAIEQQFHBEAgASoCCCELIAEqAgQhDiABKgIAIRAgASoCFCEKIAEqAhAhCAwBCyAAKAIsIARqIgQqAgghCyAEKgIEIQ4gASAAKgIEIgYgBCoCAJQgASoCAJIiEDgCACABIAYgDpQgASoCBJIiDjgCBCABIAYgC5QgASoCCJIiCzgCCCAEKgIUIQogBCoCECEIIAEgBiAEKgIMlCAHkiIHOAIMIAEgBiAIlCABKgIQkiIIOAIQIAEgBiAKlCABKgIUkiIKOAIUIAQqAiAhDSAEKgIcIQkgASAGIAQqAhiUIAEqAhiSOAIYIAEgBiAJlCABKgIckjgCHCABIAYgDZQgASoCIJI4AiALIAJBADYCLCACQQA2AhwgAkEANgIMIAdDNfqOPJRDAAAAP5QiBxAXIQ0gCEM1+o48lEMAAAA/lCIMEBchCCAKQzX6jjyUQwAAAD+UIgoQFyEGIAcQGyEJIAwQGyEMIAIgCyAJIAiUIg8gChAbIgeUIAYgDSAMlCIRlJIiCiAGIAkgDJQiCZQgByANIAiUIgyUkyINIA2SIgiUIhIgCSAHlCAMIAaUkiIJIBEgB5QgBiAPlJMiBiAGkiIMlCIPk5Q4AiQgAiALIAYgCJQiESAJIAogCpIiB5QiE5KUOAIgIAIgDiASIA+SlDgCGCACIA4gBiAHlCIPIAkgCJQiCZOUOAIQIAIgECARIBOTlDgCCCACIBAgDyAJkpQ4AgQgAiALQwAAgD8gBiAMlCIGIAogB5QiC5KTlDgCKCACIA5DAACAPyAGIA0gCJQiBpKTlDgCFCACIBBDAACAPyALIAaSk5Q4AgAgAiABKgIYOAIwIAIgASoCHDgCNCABKgIgIQYgAkGAgID8AzYCPCACIAY4AjggBSgCCCIBQX9HBEAgACABEDMhACAD/QwAAAAAAAAAAAAAAAAAAAAA/QsCJCAD/QwAAAAAAAAAAAAAAAAAAAAA/QsCFCADQgA3AjQgA0GAgID8AzYCKCADQYCAgPwDNgIUIAP9DAAAAAAAAAAAAAAAAAAAAAD9CwIEIANBgICA/AM2AjwgA0GAgID8AzYCACAC/QkCDCEYIAL9CQIIIRkgAv0JAgAhGiAC/QkCBCEbIAL9CQIcIRwgAv0JAhghHSAC/QkCECEeIAL9CQIUIR8gAv0JAiwhICAC/QkCKCEhIAL9CQIgISIgAv0JAiQhIyADIAD9AAIwIhQgAv0JAjz95gEgAP0AAiAiFSAC/QkCOP3mASAA/QACACIWIAL9CQIw/eYBIAD9AAIQIhcgAv0JAjT95gH95AH95AH95AH9CwIwIAMgFCAg/eYBIBUgIf3mASAWICL95gEgFyAj/eYB/eQB/eQB/eQB/QsCICADIBQgHP3mASAVIB395gEgFiAe/eYBIBcgH/3mAf3kAf3kAf3kAf0LAhAgAyAUIBj95gEgFSAZ/eYBIBYgGv3mASAbIBf95gH95AH95AH95AH9CwIAIAIgA/0AAjD9CwIwIAIgA/0AAiD9CwIgIAIgA/0AAhD9CwIQIAIgA/0AAgD9CwIACyAFQQA2AgALIANBQGskACACC7MDAQd/IAEgACgCCCIEIAAoAgQiAmtBJG1NBEAgACABBH8gAkEAIAFBJGxBJGsiACAAQSRwa0EkaiIAEAcgAGoFIAILNgIEDwsCQCACIAAoAgAiBmtBJG0iByABaiIDQcjj8ThJBEBBx+PxOCAEIAZrQSRtIgRBAXQiCCADIAMgCEkbIARB4/G4HE8bIgQEQCAEQcjj8ThPDQIgBEEkbBALIQULIAdBJGwgBWoiA0EAIAFBJGxBJGsiASABQSRwa0EkaiIHEAciASAHaiEHIAUgBEEkbGohBAJAIAIgBkYEQCABIQUMAQsDQCADQSRrIgUgAkEkayIBKgIAOAIAIANBIGsgAkEgayoCADgCACADQRxrIAJBHGsqAgA4AgAgA0EYayACQRhrKgIAOAIAIANBFGsgAkEUayoCADgCACADQRBrIAJBEGsqAgA4AgAgA0EMayACQQxrKgIAOAIAIANBCGsgAkEIayoCADgCACADQQRrIAJBBGsqAgA4AgAgBSEDIAEiAiAGRw0ACwsgACAENgIIIAAgBzYCBCAAIAU2AgAgBgRAIAYQDAsPCxATAAsQEgAL/AsDBH8gfAN7IwBBgAFrIgMkACAAKAIIIAFBB3RqIQIgACgCICABQQR0aiIFKAIABEAgAUHIAGwiASAAKAIUaiIEKwMYIQgCfCAFKAIEQQFHBEAgBCsDECELIAQrAwAhDCAEKwMoIQogBCsDICEGIAQrAwgMAQsgACgCLCABaiIBKwMQIQYgBCAB/QADACAAKgIEuyIH/RQiJv3yASAE/QADAP3wASIn/QsDACAEIAYgB6IgBCsDEKAiCzkDECAEIAErAxggB6IgCKAiCDkDGCAEIAH9AAMgICb98gEgBP0AAyD98AEiKP0LAyAgASsDQCEGIAQgAf0AAzAgJv3yASAE/QADMP3wAf0LAzAgBCAGIAeiIAQrA0CgOQNAICf9IQAhDCAo/SEBIQogKP0hACEGICf9IQELIRAgAkIANwNYIAJCADcDOCACQgA3AxggCEQAAACgRt+RP6JEAAAAAAAA4D+iIggQGCENIAZEAAAAoEbfkT+iRAAAAAAAAOA/oiIHEBghDiAKRAAAAKBG35E/okQAAAAAAADgP6IiBhAYIQ8gCBAcIQggBxAcIQcgAiALIAggDqIiEyAGEBwiCaIgDyANIAeiIgqioCIRIA8gCCAHoiIIoiAJIA0gDqIiBqKhIhQgFKAiEqIiByAIIAmiIAYgD6KgIg0gCiAJoiAPIBOioSIJIAmgIhOiIgahojkDSCACIAsgCSASoiIKIA0gESARoCIOoiIIoKI5A0AgAiAQIAcgBqCiOQMwIAIgECAJIA6iIgcgDSASoiIGoaI5AyAgAiAMIAogCKGiOQMQIAIgDCAHIAagojkDCCACIAtEAAAAAAAA8D8gCSAToiIGIBEgDqIiB6ChojkDUCACIBBEAAAAAAAA8D8gBiAUIBKiIgagoaI5AyggAiAMRAAAAAAAAPA/IAcgBqChojkDACACIAQrAzA5A2AgAiAEKwM4OQNoIAQrA0AhBiACQoCAgICAgID4PzcDeCACIAY5A3AgBSgCCCIBQX9HBEAgACABEDUhACADQQhqQQBB8AAQBxogA0KAgICAgICA+D83A3ggA0KAgICAgICA+D83A1AgA0KAgICAgICA+D83AyggA0KAgICAgICA+D83AwAgAisDGCEVIAIrAxAhFiACKwMAIRcgAisDCCEYIAIrAzghGSACKwMwIRogAisDICEbIAIrAyghHCACKwNYIR0gAisDUCEeIAIrA0AhHyACKwNIISAgACsDYCEhIAArA0AhIiAAKwMAISMgACsDICEkIAArA2ghJSAAKwNIIQsgACsDCCEMIAArAyghDyAAKwNwIRAgACsDUCEJIAArAxAhESAAKwMwIRIgAyAAKwN4IhQgAisDeCINoiAAKwNYIg4gAisDcCIToiAAKwMYIgogAisDYCIIoiAAKwM4IgcgAisDaCIGoqCgoDkDeCADIBAgDaIgCSAToiARIAiiIBIgBqKgoKA5A3AgAyAlIA2iIAsgE6IgDCAIoiAPIAaioKCgOQNoIAMgISANoiAiIBOiICMgCKIgJCAGoqCgoDkDYCADIBQgHaIgDiAeoiAKIB+iIAcgIKKgoKA5A1ggAyAQIB2iIAkgHqIgESAfoiASICCioKCgOQNQIAMgJSAdoiALIB6iIAwgH6IgDyAgoqCgoDkDSCADICEgHaIgIiAeoiAjIB+iICQgIKKgoKA5A0AgAyAUIBmiIA4gGqIgCiAboiAHIByioKCgOQM4IAMgECAZoiAJIBqiIBEgG6IgEiAcoqCgoDkDMCADICUgGaIgCyAaoiAMIBuiIA8gHKKgoKA5AyggAyAhIBmiICIgGqIgIyAboiAkIByioKCgOQMgIAMgFCAVoiAOIBaiIAogF6IgGCAHoqCgoDkDGCADIBAgFaIgCSAWoiARIBeiIBggEqKgoKA5AxAgAyAlIBWiIAsgFqIgDCAXoiAYIA+ioKCgOQMIIAMgISAVoiAiIBaiICMgF6IgJCAYoqCgoDkDACACIANBgAEQFRoLIAVBADYCAAsgA0GAAWokACACC4gLAQd/AkAgASAAKAIMIgQgACgCCCIDa0EHdSICRg0AAkAgASACSwRAIAEgAmsiBiAAKAIQIgUgBCIDa0EHdU0EQAJAIAZFDQAgAyECIAZBA3EiBQRAQQAhBANAIAJBCGpBAEHwABAHGiACQoCAgICAgID4PzcDeCACQoCAgICAgID4PzcDUCACQoCAgICAgID4PzcDKCACQoCAgICAgID4PzcDACACQYABaiECIARBAWoiBCAFRw0ACwsgBkEHdCADaiEDIAZBAWtB////D3FBA0kNAANAIAJBCGpBAEHwABAHGiACQoCAgICAgID4PzcDeCACQoCAgICAgID4PzcDUCACQoCAgICAgID4PzcDKCACQoCAgICAgID4PzcDACACQYgBakEAQfAAEAcaIAJCgICAgICAgPg/NwP4ASACQoCAgICAgID4PzcD0AEgAkKAgICAgICA+D83A6gBIAJCgICAgICAgPg/NwOAASACQYgCakEAQfAAEAcaIAJCgICAgICAgPg/NwP4AiACQoCAgICAgID4PzcD0AIgAkKAgICAgICA+D83A6gCIAJCgICAgICAgPg/NwOAAiACQYgDakEAQfAAEAcaIAJCgICAgICAgPg/NwP4AyACQoCAgICAgID4PzcD0AMgAkKAgICAgICA+D83A6gDIAJCgICAgICAgPg/NwOAAyACQYAEaiICIANHDQALCyAAIAM2AgwMAgsCQCADIAAoAggiAmtBB3UiBCAGaiIHQYCAgBBJBEBBACEDQf///w8gBSACayIFQQZ1IgIgByACIAdLGyAFQYD///8HTxsiBwRAIAdBgICAEE8NAiAHQQd0EAshCAsgCCAEQQd0aiIEIQIgBkEDcSIFBEADQCACQQhqQQBB8AAQBxogAkKAgICAgICA+D83A3ggAkKAgICAgICA+D83A1AgAkKAgICAgICA+D83AyggAkKAgICAgICA+D83AwAgAkGAAWohAiADQQFqIgMgBUcNAAsLIAZBB3QgBGohBSAGQQFrQf///w9xQQNPBEADQCACQQhqQQBB8AAQBxogAkKAgICAgICA+D83A3ggAkKAgICAgICA+D83A1AgAkKAgICAgICA+D83AyggAkKAgICAgICA+D83AwAgAkGIAWpBAEHwABAHGiACQoCAgICAgID4PzcD+AEgAkKAgICAgICA+D83A9ABIAJCgICAgICAgPg/NwOoASACQoCAgICAgID4PzcDgAEgAkGIAmpBAEHwABAHGiACQoCAgICAgID4PzcD+AIgAkKAgICAgICA+D83A9ACIAJCgICAgICAgPg/NwOoAiACQoCAgICAgID4PzcDgAIgAkGIA2pBAEHwABAHGiACQoCAgICAgID4PzcD+AMgAkKAgICAgICA+D83A9ADIAJCgICAgICAgPg/NwOoAyACQoCAgICAgID4PzcDgAMgAkGABGoiAiAFRw0ACwsgACgCDCICIAAoAggiA0cEQANAIARBgAFrIgQgAkGAAWsiAkGAARAVGiACIANHDQALIAAoAgghAgsgACAIIAdBB3RqNgIQIAAgBTYCDCAAIAQ2AgggAgRAIAIQFgsMAwsQEwALEBIACyABIAJPDQAgACADIAFBB3RqNgIMCwJAIAAoAhggACgCFCIDa0HIAG0iAiABSQRAIABBFGogASACaxA8DAELIAEgAk8NACAAIAMgAUHIAGxqNgIYCwJAIAAoAiQgACgCICIDa0EEdSICIAFJBEAgAEEgaiABIAJrEDsMAQsgASACTw0AIAAgAyABQQR0ajYCJAsgACgCMCAAKAIsIgNrQcgAbSICIAFJBEAgAEEsaiABIAJrEDwPCyABIAJPDQAgACADIAFByABsajYCMAsLBwAgACgCLAsHACAAKAIgCwcAIAAoAhQLBwAgACgCCAvUBQEHfyABIAAoAggiByAAKAIEIgNrQQR1TQRAAkAgAUUNACADIQIgAUEHcSIFBEADQCACQv////8PNwIIIAJCADcCACACQRBqIQIgBEEBaiIEIAVHDQALCyABQQR0IANqIQMgAUEBa0H/////AHFBB0kNAANAIAJC/////w83AnggAkIANwJwIAJC/////w83AmggAkIANwJgIAJC/////w83AlggAkIANwJQIAJC/////w83AkggAkIANwJAIAJC/////w83AjggAkIANwIwIAJC/////w83AiggAkIANwIgIAJC/////w83AhggAkIANwIQIAJC/////w83AgggAkIANwIAIAJBgAFqIgIgA0cNAAsLIAAgAzYCBA8LAkAgAyAAKAIAIgJrQQR1IgQgAWoiBkGAgICAAUkEQEH/////ACAHIAJrIgdBA3UiAiAGIAIgBksbIAdB8P///wdPGyIGBEAgBkGAgICAAU8NAiAGQQR0EAshCAsgCCAEQQR0aiIEIQIgAUEHcSIHBEADQCACQv////8PNwIIIAJCADcCACACQRBqIQIgBUEBaiIFIAdHDQALCyABQQR0IARqIQUgAUEBa0H/////AHFBB08EQANAIAJC/////w83AnggAkIANwJwIAJC/////w83AmggAkIANwJgIAJC/////w83AlggAkIANwJQIAJC/////w83AkggAkIANwJAIAJC/////w83AjggAkIANwIwIAJC/////w83AiggAkIANwIgIAJC/////w83AhggAkIANwIQIAJC/////w83AgggAkIANwIAIAJBgAFqIgIgBUcNAAsLIAAoAgAiASADRwRAA0AgBEEQayIEIANBEGsiA/0AAgD9CwIAIAEgA0cNAAsgACgCACEDCyAAIAggBkEEdGo2AgggACAFNgIEIAAgBDYCACADBEAgAxAMCw8LEBMACxASAAuLAwEHfyABIAAoAggiAiAAKAIEIgNrQcgAbU0EQCAAIAEEfyADQQAgAUHIAGxByABrIgAgAEHIAHBrQcgAaiIAEAcgAGoFIAMLNgIEDwsCQCADIAAoAgAiBmtByABtIgggAWoiBEHk8bgcSQRAQePxuBwgAiAGa0HIAG0iB0EBdCICIAQgAiAESxsgB0HxuJwOTxsiBARAIARB5PG4HE8NAiAEQcgAbBALIQULIAUgCEHIAGxqIgJBACABQcgAbEHIAGsiASABQcgAcGtByABqIgcQByIBIAdqIQggBSAEQcgAbGohBwJAIAMgBkYEQCABIQUMAQsDQCACQcgAayIFIANByABrIgH9AAMA/QsDACACQThrIANBOGv9AAMA/QsDACACQShrIANBKGv9AAMA/QsDACACQRhrIANBGGv9AAMA/QsDACACQQhrIANBCGsrAwA5AwAgBSECIAEiAyAGRw0ACwsgACAHNgIIIAAgCDYCBCAAIAU2AgAgBgRAIAYQDAsPCxATAAsQEgALGQEBf0GgKygCACIBIAAgASgCACgCGBEBAAsQACMAIABrQXBxIgAkACAACwcAIAAoAgQLBQBBowkLBQBBzQkLBQBBkAkLFwEBf0GgKygCACIAIAAoAgAoAhQRAAALFQAgAEUEQEEADwsgAEHkJhAiQQBHCxoAIAAgASgCCCAFEAoEQCABIAIgAyAEECALCzcAIAAgASgCCCAFEAoEQCABIAIgAyAEECAPCyAAKAIIIgAgASACIAMgBCAFIAAoAgAoAhQRCQALpwEAIAAgASgCCCAEEAoEQAJAIAEoAgQgAkcNACABKAIcQQFGDQAgASADNgIcCw8LAkAgACABKAIAIAQQCkUNAAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNASABQQE2AiAPCyABIAI2AhQgASADNgIgIAEgASgCKEEBajYCKAJAIAEoAiRBAUcNACABKAIYQQJHDQAgAUEBOgA2CyABQQQ2AiwLC4gCACAAIAEoAgggBBAKBEACQCABKAIEIAJHDQAgASgCHEEBRg0AIAEgAzYCHAsPCwJAIAAgASgCACAEEAoEQAJAIAIgASgCEEcEQCABKAIUIAJHDQELIANBAUcNAiABQQE2AiAPCyABIAM2AiACQCABKAIsQQRGDQAgAUEAOwE0IAAoAggiACABIAIgAkEBIAQgACgCACgCFBEJACABLQA1BEAgAUEDNgIsIAEtADRFDQEMAwsgAUEENgIsCyABIAI2AhQgASABKAIoQQFqNgIoIAEoAiRBAUcNASABKAIYQQJHDQEgAUEBOgA2DwsgACgCCCIAIAEgAiADIAQgACgCACgCGBEGAAsLMQAgACABKAIIQQAQCgRAIAEgAiADECEPCyAAKAIIIgAgASACIAMgACgCACgCHBEHAAsYACAAIAEoAghBABAKBEAgASACIAMQIQsLFwEBf0GgKygCACIAIAAoAgAoAhARAAALnAEBAn8jAEFAaiIDJAACf0EBIAAgAUEAEAoNABpBACABRQ0AGkEAIAFBhCYQIiIBRQ0AGiADQQxqQQBBNBAHGiADQQE2AjggA0F/NgIUIAMgADYCECADIAE2AgggASADQQhqIAIoAgBBASABKAIAKAIcEQcAIAMoAiAiAEEBRgRAIAIgAygCGDYCAAsgAEEBRgshBCADQUBrJAAgBAsXAQF/QaArKAIAIgAgACgCACgCDBEAAAsXAQF/QaArKAIAIgAgACgCACgCCBEAAAsEAEIACwQAQQAL9AIBCH8jAEEgayIDJAAgAyAAKAIcIgQ2AhAgACgCFCEFIAMgAjYCHCADIAE2AhggAyAFIARrIgE2AhQgASACaiEFQQIhBwJ/AkACQAJAIAAoAjwgA0EQaiIBQQIgA0EMahAAIgQEf0G4MyAENgIAQX8FQQALBEAgASEEDAELA0AgBSADKAIMIgZGDQIgBkEASARAIAEhBAwECyABIAYgASgCBCIISyIJQQN0aiIEIAYgCEEAIAkbayIIIAQoAgBqNgIAIAFBDEEEIAkbaiIBIAEoAgAgCGs2AgAgBSAGayEFIAAoAjwgBCIBIAcgCWsiByADQQxqEAAiBgR/QbgzIAY2AgBBfwVBAAtFDQALCyAFQX9HDQELIAAgACgCLCIBNgIcIAAgATYCFCAAIAEgACgCMGo2AhAgAgwBCyAAQQA2AhwgAEIANwMQIAAgACgCAEEgcjYCAEEAIAdBAkYNABogAiAEKAIEawshCiADQSBqJAAgCgsZAQF/QaArKAIAIgEgACABKAIAKAIEEQEACycAIAAgAzgCBCABIAJIBEADQCAAIAEQMxogAUEBaiIBIAJHDQALCwuWAgIBfw99IwBBgAFrIgIkACAAKAIIIAFBBnRqIgAqAgAhAyAAKgIEIQQgACoCCCEFIAAqAgwhBiAAKgIQIQcgACoCFCEIIAAqAhghCSAAKgIcIQogACoCICELIAAqAiQhDCAAKgIoIQ0gACoCLCEOIAAqAjAhDyAAKgI0IRAgACoCOCERIAIgACoCPLs5A3ggAiARuzkDcCACIBC7OQNoIAIgD7s5A2AgAiAOuzkDWCACIA27OQNQIAIgDLs5A0ggAkFAayALuzkDACACIAq7OQM4IAIgCbs5AzAgAiAIuzkDKCACIAe7OQMgIAIgBrs5AxggAiAFuzkDECACIAS7OQMIIAIgA7s5AwAgAhAuIAJBgAFqJAALJQAgASAAKAIMIAAoAghrQQZ1RwRAIAAgASAAKAIAKAIEEQEACwsnACAAIAM4AgQgASACSARAA0AgACABEDUaIAFBAWoiASACRw0ACwsLpgECAX8HeyMAQYABayICJAAgACgCCCABQQd0aiIA/QADACEDIAD9AAMQIQQgAP0AAyAhBSAA/QADMCEGIAD9AANAIQcgAP0AA1AhCCAA/QADYCEJIAIgAP0AA3D9CwRwIAIgCf0LBGAgAiAI/QsEUCACQUBrIAf9CwQAIAIgBv0LBDAgAiAF/QsEICACIAT9CwQQIAIgA/0LBAAgAhAuIAJBgAFqJAALJQAgASAAKAIMIAAoAghrQQd1RwRAIAAgASAAKAIAKAIEEQEACwv/AQBB1CooAgAaAkACf0G8CRAsIgACf0HUKigCAEEASARAQbwJIABBiCoQGQwBC0G8CSAAQYgqEBkLIgEgAEYNABogAQsgAEcNAAJAQdgqKAIAQQpGDQBBnCooAgAiAEGYKigCAEYNAEGcKiAAQQFqNgIAIABBCjoAAAwBCyMAQRBrIgAkACAAQQo6AA8CQAJAQZgqKAIAIgEEfyABBUGIKhAaDQJBmCooAgALQZwqKAIAIgFGDQBB2CooAgBBCkYNAEGcKiABQQFqNgIAIAFBCjoAAAwBC0GIKiAAQQ9qQQFBrCooAgARAgBBAUcNACAALQAPGgsgAEEQaiQAC0EACx0BAX9BoCsoAgAiAyAAIAEgAiADKAIAKAIcEQsAC4cCAQF/QaArKAIAIgJFBEBBOBALIgNBBGohAiABBEAgA0GICDYCACACQQA2AjAgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAiAgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAhAgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAARAIAMgABA2C0GgKyADNgIADwsgA0HgCjYCACACQQA2AjAgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAiAgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAhAgAv0MAAAAAAAAAAAAAAAAAAAAAP0LAgAgAARAIAMgABAyC0GgKyADNgIADwsgAiAAQQAgAigCACgCABEDAAsLoCEVAEGECAuiA2AEAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAADE5TWF0cml4QmF0Y2hDb21wdXRlcklkRQAyMElNYXRyaXhCYXRjaENvbXB1dGVyAHgTAABBBAAAoBMAACgEAABYBAAALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweAB2ZWN0b3IAc3RkOjpleGNlcHRpb24AbmFuAGJhZF9hcnJheV9uZXdfbGVuZ3RoAGluZgB3YXNtIGhhdmUgbG9hZGVkAHN0ZDo6YmFkX2FsbG9jAE5BTgBJTkYALgAobnVsbCkAWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQpbJS4yZiwgJS4yZiwgJS4yZiwgJS4yZl0NClslLjJmLCAlLjJmLCAlLjJmLCAlLjJmXQ0KWyUuMmYsICUuMmYsICUuMmYsICUuMmZdDQoAAAAAAAAAnAUAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAMTlNYXRyaXhCYXRjaENvbXB1dGVySWZFAAAAAKATAACABQAAWAQAQbALC9cVAwAAAAQAAAAEAAAABgAAAIP5ogBETm4A/CkVANFXJwDdNPUAYtvAADyZlQBBkEMAY1H+ALveqwC3YcUAOm4kANJNQgBJBuAACeouAByS0QDrHf4AKbEcAOg+pwD1NYIARLsuAJzphAC0JnAAQX5fANaROQBTgzkAnPQ5AItfhAAo+b0A+B87AN7/lwAPmAUAES/vAApaiwBtH20Az342AAnLJwBGT7cAnmY/AC3qXwC6J3UA5evHAD178QD3OQcAklKKAPtr6gAfsV8ACF2NADADVgB7/EYA8KtrACC8zwA29JoA46kdAF5hkQAIG+YAhZllAKAUXwCNQGgAgNj/ACdzTQAGBjEAylYVAMmocwB74mAAa4zAABnERwDNZ8MACejcAFmDKgCLdsQAphyWAESv3QAZV9EApT4FAAUH/wAzfj8AwjLoAJhP3gC7fTIAJj3DAB5r7wCf+F4ANR86AH/yygDxhx0AfJAhAGokfADVbvoAMC13ABU7QwC1FMYAwxmdAK3EwgAsTUEADABdAIZ9RgDjcS0Am8aaADNiAAC00nwAtKeXADdV1QDXPvYAoxAYAE12/ABknSoAcNerAGN8+AB6sFcAFxXnAMBJVgA71tkAp4Q4ACQjywDWincAWlQjAAAfuQDxChsAGc7fAJ8x/wBmHmoAmVdhAKz7RwB+f9gAImW3ADLoiQDmv2AA78TNAGw2CQBdP9QAFt7XAFg73gDem5IA0iIoACiG6ADiWE0AxsoyAAjjFgDgfcsAF8BQAPMdpwAY4FsALhM0AIMSYgCDSAEA9Y5bAK2wfwAe6fIASEpDABBn0wCq3dgArl9CAGphzgAKKKQA05m0AAam8gBcd38Ao8KDAGE8iACKc3gAr4xaAG/XvQAtpmMA9L/LAI2B7wAmwWcAVcpFAMrZNgAoqNIAwmGNABLJdwAEJhQAEkabAMRZxADIxUQATbKRAAAX8wDUQ60AKUnlAP3VEAAAvvwAHpTMAHDO7gATPvUA7PGAALPnwwDH+CgAkwWUAMFxPgAuCbMAC0XzAIgSnACrIHsALrWfAEeSwgB7Mi8ADFVtAHKnkABr5x8AMcuWAHkWSgBBeeIA9N+JAOiUlwDi5oQAmTGXAIjtawBfXzYAu/0OAEiatABnpGwAcXJCAI1dMgCfFbgAvOUJAI0xJQD3dDkAMAUcAA0MAQBLCGgALO5YAEeqkAB05wIAvdYkAPd9pgBuSHIAnxbvAI6UpgC0kfYA0VNRAM8K8gAgmDMA9Ut+ALJjaADdPl8AQF0DAIWJfwBVUikAN2TAAG3YEAAySDIAW0x1AE5x1ABFVG4ACwnBACr1aQAUZtUAJwedAF0EUAC0O9sA6nbFAIf5FwBJa30AHSe6AJZpKQDGzKwArRRUAJDiagCI2YkALHJQAASkvgB3B5QA8zBwAAD8JwDqcagAZsJJAGTgPQCX3YMAoz+XAEOU/QANhowAMUHeAJI5nQDdcIwAF7fnAAjfOwAVNysAXICgAFqAkwAQEZIAD+jYAGyArwDb/0sAOJAPAFkYdgBipRUAYcu7AMeJuQAQQL0A0vIEAEl1JwDrtvYA2yK7AAoUqgCJJi8AZIN2AAk7MwAOlBoAUTqqAB2jwgCv7a4AXCYSAG3CTQAtepwAwFaXAAM/gwAJ8PYAK0CMAG0xmQA5tAcADCAVANjDWwD1ksQAxq1LAE7KpQCnN80A5qk2AKuSlADdQmgAGWPeAHaM7wBoi1IA/Ns3AK6hqwDfFTEAAK6hAAz72gBkTWYA7QW3ACllMABXVr8AR/86AGr5uQB1vvMAKJPfAKuAMABmjPYABMsVAPoiBgDZ5B0APbOkAFcbjwA2zQkATkLpABO+pAAzI7UA8KoaAE9lqADSwaUACz8PAFt4zQAj+XYAe4sEAIkXcgDGplMAb27iAO/rAACbSlgAxNq3AKpmugB2z88A0QIdALHxLQCMmcEAw613AIZI2gD3XaAAxoD0AKzwLwDd7JoAP1y8ANDebQCQxx8AKtu2AKMlOgAAr5oArVOTALZXBAApLbQAS4B+ANoHpwB2qg4Ae1mhABYSKgDcty0A+uX9AInb/gCJvv0A5HZsAAap/AA+gHAAhW4VAP2H/wAoPgcAYWczACoYhgBNveoAs+evAI9tbgCVZzkAMb9bAITXSAAw3xYAxy1DACVhNQDJcM4AMMu4AL9s/QCkAKIABWzkAFrdoAAhb0cAYhLSALlchABwYUkAa1bgAJlSAQBQVTcAHtW3ADPxxAATbl8AXTDkAIUuqQAdssMAoTI2AAi3pADqsdQAFvchAI9p5AAn/3cADAOAAI1ALQBPzaAAIKWZALOi0wAvXQoAtPlCABHaywB9vtAAm9vBAKsXvQDKooEACGpcAC5VFwAnAFUAfxTwAOEHhgAUC2QAlkGNAIe+3gDa/SoAayW2AHuJNAAF8/4Aub+eAGhqTwBKKqgAT8RaAC34vADXWpgA9MeVAA1NjQAgOqYApFdfABQ/sQCAOJUAzCABAHHdhgDJ3rYAv2D1AE1lEQABB2sAjLCsALLA0ABRVUgAHvsOAJVywwCjBjsAwEA1AAbcewDgRcwATin6ANbKyADo80EAfGTeAJtk2ADZvjEApJfDAHdY1ABp48UA8NoTALo6PABGGEYAVXVfANK99QBuksYArC5dAA5E7QAcPkIAYcSHACn96QDn1vMAInzKAG+RNQAI4MUA/9eNAG5q4gCw/cYAkwjBAHxddABrrbIAzW6dAD5yewDGEWoA98+pAClz3wC1yboAtwBRAOKyDQB0uiQA5X1gAHTYigANFSwAgRgMAH5mlAABKRYAn3p2AP39vgBWRe8A2X42AOzZEwCLurkAxJf8ADGoJwDxbsMAlMU2ANioVgC0qLUAz8wOABKJLQBvVzQALFaJAJnO4wDWILkAa16qAD4qnAARX8wA/QtKAOH0+wCOO20A4oYsAOnUhAD8tKkA7+7RAC41yQAvOWEAOCFEABvZyACB/AoA+0pqAC8c2ABTtIQATpmMAFQizAAqVdwAwMbWAAsZlgAacLgAaZVkACZaYAA/Uu4AfxEPAPS1EQD8y/UANLwtADS87gDoXcwA3V5gAGeOmwCSM+8AyRe4AGFYmwDhV7wAUYPGANg+EADdcUgALRzdAK8YoQAhLEYAWfPXANl6mACeVMAAT4b6AFYG/ADlea4AiSI2ADitIgBnk9wAVeiqAIImOADK55sAUQ2kAJkzsQCp1w4AaQVIAGWy8AB/iKcAiEyXAPnRNgAhkrMAe4JKAJjPIQBAn9wA3EdVAOF0OgBn60IA/p3fAF7UXwB7Z6QAuqx6AFX2ogAriCMAQbpVAFluCAAhKoYAOUeDAInj5gDlntQASftAAP9W6QAcD8oAxVmKAJT6KwDTwcUAD8XPANtargBHxYYAhUNiACGGOwAseZQAEGGHACpMewCALBoAQ78SAIgmkAB4PIkAqMTkAOXbewDEOsIAJvTqAPdnigANkr8AZaMrAD2TsQC9fAsApFHcACfdYwBp4d0AmpQZAKgplQBozigACe20AESfIABOmMoAcIJjAH58IwAPuTIAp/WOABRW5wAh8QgAtZ0qAG9+TQClGVEAtfmrAILf1gCW3WEAFjYCAMQ6nwCDoqEAcu1tADmNegCCuKkAazJcAEYnWwAANO0A0gB3APz0VQABWU0A4HGAAEGTIQt+QPsh+T8AAAAALUR0PgAAAICYRvg8AAAAYFHMeDsAAACAgxvwOQAAAEAgJXo4AAAAgCKC4zYAAAAAHfNpNRkACgAZGRkAAAAABQAAAAAAAAkAAAAACwAAAAAAAAAAGQARChkZGQMKBwABAAkLGAAACQYLAAALAAYZAAAAGRkZAEGhIgshDgAAAAAAAAAAGQAKDRkZGQANAAACAAkOAAAACQAOAAAOAEHbIgsBDABB5yILFRMAAAAAEwAAAAAJDAAAAAAADAAADABBlSMLARAAQaEjCxUPAAAABA8AAAAACRAAAAAAABAAABAAQc8jCwESAEHbIwseEQAAAAARAAAAAAkSAAAAAAASAAASAAAaAAAAGhoaAEGSJAsOGgAAABoaGgAAAAAAAAkAQcMkCwEUAEHPJAsVFwAAAAAXAAAAAAkUAAAAAAAUAAAUAEH9JAsBFgBBiSUL/QQVAAAAABUAAAAACRYAAAAAABYAABYAADAxMjM0NTY3ODlBQkNERUZOMTBfX2N4eGFiaXYxMTZfX3NoaW1fdHlwZV9pbmZvRQAAAACgEwAAsBIAAAAVAABOMTBfX2N4eGFiaXYxMTdfX2NsYXNzX3R5cGVfaW5mb0UAAACgEwAA4BIAANQSAABOMTBfX2N4eGFiaXYxMTdfX3BiYXNlX3R5cGVfaW5mb0UAAACgEwAAEBMAANQSAABOMTBfX2N4eGFiaXYxMTlfX3BvaW50ZXJfdHlwZV9pbmZvRQCgEwAAQBMAADQTAAAAAAAABBMAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAAAAAAOgTAAAXAAAAHwAAABkAAAAaAAAAGwAAACAAAAAhAAAAIgAAAE4xMF9fY3h4YWJpdjEyMF9fc2lfY2xhc3NfdHlwZV9pbmZvRQAAAACgEwAAwBMAAAQTAAAAAAAAWBQAAAEAAAAjAAAAJAAAAAAAAACAFAAAAQAAACUAAAAmAAAAAAAAAEAUAAABAAAAJwAAACgAAABTdDlleGNlcHRpb24AAAAAeBMAADAUAABTdDliYWRfYWxsb2MAAAAAoBMAAEgUAABAFAAAU3QyMGJhZF9hcnJheV9uZXdfbGVuZ3RoAAAAAKATAABkFAAAWBQAAAAAAACwFAAAAgAAACkAAAAqAAAAU3QxMWxvZ2ljX2Vycm9yAKATAACgFAAAQBQAAAAAAADkFAAAAgAAACsAAAAqAAAAU3QxMmxlbmd0aF9lcnJvcgAAAACgEwAA0BQAALAUAABTdDl0eXBlX2luZm8AAAAAeBMAAPAUAEGIKgsBBQBBlCoLARMAQawqCw4UAAAAFQAAALgVAAAABABBxCoLAQEAQdQqCwX/////CgBBmCsLA3AcAQ==",sa(Pr)||(Pr=p(Pr));function Xa(R){if(R==Pr&&I)return new Uint8Array(I);var U=D(R);if(U)return U;if(x)return x(R);throw"both async and sync fetching of the wasm failed"}function Wa(R){return Promise.resolve().then(()=>Xa(R))}function Ka(R,U,W){return Wa(R).then(de=>WebAssembly.instantiate(de,U)).then(W,de=>{B(`failed to asynchronously prepare wasm: ${de}`),ia(de)})}function ja(R,U,W,de){return Ka(U,W,de)}function qa(){var R={a:mm};function U(de,Pe){return Dt=de.exports,L=Dt.f,ue(),xt(Dt.g),Ya(),Dt}mr();function W(de){U(de.instance)}if(e.instantiateWasm)try{return e.instantiateWasm(R,U)}catch(de){B(`Module.instantiateWasm callback failed with error: ${de}`),i(de)}return ja(I,Pr,R,W).catch(i),{}}function oa(R){this.name="ExitStatus",this.message=`Program terminated with exit(${R})`,this.status=R}var hi=R=>{for(;R.length>0;)R.shift()(e)},Ja=e.noExitRuntime||!0;class Za{constructor(U){this.excPtr=U,this.ptr=U-24}set_type(U){ie[this.ptr+4>>2]=U}get_type(){return ie[this.ptr+4>>2]}set_destructor(U){ie[this.ptr+8>>2]=U}get_destructor(){return ie[this.ptr+8>>2]}set_caught(U){U=U?1:0,N[this.ptr+12]=U}get_caught(){return N[this.ptr+12]!=0}set_rethrown(U){U=U?1:0,N[this.ptr+13]=U}get_rethrown(){return N[this.ptr+13]!=0}init(U,W){this.set_adjusted_ptr(0),this.set_type(U),this.set_destructor(W)}set_adjusted_ptr(U){ie[this.ptr+16>>2]=U}get_adjusted_ptr(){return ie[this.ptr+16>>2]}get_exception_ptr(){var U=th(this.get_type());if(U)return ie[this.excPtr>>2];var W=this.get_adjusted_ptr();return W!==0?W:this.excPtr}}var na=0,$a=(R,U,W)=>{var de=new Za(R);throw de.init(U,W),na=R,na},es=()=>{ia("")},ts=(R,U,W)=>q.copyWithin(R,U,U+W),Bi=()=>2147483648,Di=R=>{var U=L.buffer,W=(R-U.byteLength+65535)/65536;try{return L.grow(W),ue(),1}catch(de){}},Mi=R=>{var U=q.length;R>>>=0;var W=Bi();if(R>W)return!1;for(var de=(Ar,la)=>Ar+(la-Ar%la)%la,Pe=1;Pe<=4;Pe*=2){var je=U*(1+.2/Pe);je=Math.min(je,R+100663296);var Re=Math.min(W,de(Math.max(R,je),65536)),Be=Di(Re);if(Be)return!0}return!1},Pi=[null,[],[]],ui=typeof TextDecoder<"u"?new TextDecoder("utf8"):void 0,Ri=(R,U,W)=>{for(var de=U+W,Pe=U;R[Pe]&&!(Pe>=de);)++Pe;if(Pe-U>16&&R.buffer&&ui)return ui.decode(R.subarray(U,Pe));for(var je="";U<Pe;){var Re=R[U++];if(!(Re&128)){je+=String.fromCharCode(Re);continue}var Be=R[U++]&63;if((Re&224)==192){je+=String.fromCharCode((Re&31)<<6|Be);continue}var Ar=R[U++]&63;if((Re&240)==224?Re=(Re&15)<<12|Be<<6|Ar:Re=(Re&7)<<18|Be<<12|Ar<<6|R[U++]&63,Re<65536)je+=String.fromCharCode(Re);else{var la=Re-65536;je+=String.fromCharCode(55296|la>>10,56320|la&1023)}}return je},Ui=(R,U)=>{var W=Pi[R];U===0||U===10?((R===1?b:B)(Ri(W,0)),W.length=0):W.push(U)},Li=(R,U,W,de)=>{for(var Pe=0,je=0;je<W;je++){var Re=ie[U>>2],Be=ie[U+4>>2];U+=8;for(var Ar=0;Ar<Be;Ar++)Ui(R,q[Re+Ar]);Pe+=Be}return ie[de>>2]=Pe,0},Oi=0,lm=()=>Ja||Oi>0,hm=R=>{var U;G=R,lm()||((U=e.onExit)==null||U.call(e,R),M=!0),h(R,new oa(R))},um=(R,U)=>{G=R,hm(R)},cm=R=>{if(R instanceof oa||R=="unwind")return G;h(1,R)},fm=R=>{for(var U=0,W=0;W<R.length;++W){var de=R.charCodeAt(W);de<=127?U++:de<=2047?U+=2:de>=55296&&de<=57343?(U+=4,++W):U+=3}return U},dm=(R,U,W,de)=>{if(!(de>0))return 0;for(var Pe=W,je=W+de-1,Re=0;Re<R.length;++Re){var Be=R.charCodeAt(Re);if(Be>=55296&&Be<=57343){var Ar=R.charCodeAt(++Re);Be=65536+((Be&1023)<<10)|Ar&1023}if(Be<=127){if(W>=je)break;U[W++]=Be}else if(Be<=2047){if(W+1>=je)break;U[W++]=192|Be>>6,U[W++]=128|Be&63}else if(Be<=65535){if(W+2>=je)break;U[W++]=224|Be>>12,U[W++]=128|Be>>6&63,U[W++]=128|Be&63}else{if(W+3>=je)break;U[W++]=240|Be>>18,U[W++]=128|Be>>12&63,U[W++]=128|Be>>6&63,U[W++]=128|Be&63}}return U[W]=0,W-Pe},gm=(R,U,W)=>dm(R,q,U,W),pm=R=>{var U=fm(R)+1,W=hn(U);return gm(R,W,U),W},mm={b:$a,c:es,e:ts,d:Mi,a:Li},Dt=qa();e._initialize=(R,U,W)=>(e._initialize=Dt.h)(R,U,W),e._allocMatrix=R=>(e._allocMatrix=Dt.i)(R),e._getMatrixBufferPtr=()=>(e._getMatrixBufferPtr=Dt.j)(),e._getSRTPtr=()=>(e._getSRTPtr=Dt.k)(),e._getInfoPtr=()=>(e._getInfoPtr=Dt.l)(),e._getContinuedSRTPtr=()=>(e._getContinuedSRTPtr=Dt.m)(),e._printMatrix=R=>(e._printMatrix=Dt.n)(R),e._updateAllMatrixContinueTransform=(R,U,W)=>(e._updateAllMatrixContinueTransform=Dt.o)(R,U,W);var eh=e._main=(R,U)=>(eh=e._main=Dt.p)(R,U),hn=R=>(hn=Dt.r)(R),th=R=>(th=Dt.s)(R),Ws;nt=function R(){Ws||rh(),Ws||(nt=R)};function Am(R=[]){var U=eh;R.unshift(l);var W=R.length,de=hn((W+1)*4),Pe=de;R.forEach(Re=>{ie[Pe>>2]=pm(Re),Pe+=4}),ie[Pe>>2]=0;try{var je=U(W,de);return um(je,!0),je}catch(Re){return cm(Re)}}function rh(R=o){if(Ke>0||(xe(),Ke>0))return;function U(){Ws||(Ws=!0,e.calledRun=!0,!M&&(Ve(),we(),r(e),e.onRuntimeInitialized&&e.onRuntimeInitialized(),ih&&Am(R),Ye()))}e.setStatus?(e.setStatus("Running..."),setTimeout(function(){setTimeout(function(){e.setStatus("")},1),U()},1)):U()}if(e.preInit)for(typeof e.preInit=="function"&&(e.preInit=[e.preInit]);e.preInit.length>0;)e.preInit.pop()();var ih=!0;return e.noInitialRun&&(ih=!1),rh(),t.ready})}})();function Kr(n,t,e){return m.setting.doublePrecision?new Float64Array(n,t,e):new Float32Array(n,t,e)}const et=class et{static init(t,e=!1){return V(this,null,function*(){this.wasm=yield mu(),this.useDoublePrecision=e,this.wasm._initialize(t,e,0),this.allocMatrix(t)})}static allocMatrix(t){t>Q.maxCount&&console.error(`The maximum allocation size is exceeded! current:${t}, limit:${Q.maxCount}`),this.wasm._allocMatrix(t),this.matrixBufferPtr=this.wasm._getMatrixBufferPtr(),this.matrixSRTBufferPtr=this.wasm._getSRTPtr(),this.matrixStateBufferPtr=this.wasm._getInfoPtr(),this.matrixContinuedSRTBufferPtr=this.wasm._getContinuedSRTPtr(),this.useDoublePrecision?(this.matrixBuffer=Kr(this.wasm.HEAPF64.buffer,this.matrixBufferPtr,16*t),this.matrixSRTBuffer=Kr(this.wasm.HEAPF64.buffer,this.matrixSRTBufferPtr,3*3*t),this.matrixContinuedSRTBuffer=Kr(this.wasm.HEAPF64.buffer,this.matrixContinuedSRTBufferPtr,3*3*t),Q.blockBytes=Q.block*8):(this.matrixBuffer=Kr(this.wasm.HEAPF32.buffer,this.matrixBufferPtr,16*t),this.matrixSRTBuffer=Kr(this.wasm.HEAPF32.buffer,this.matrixSRTBufferPtr,3*3*t),this.matrixContinuedSRTBuffer=Kr(this.wasm.HEAPF32.buffer,this.matrixContinuedSRTBufferPtr,3*3*t),Q.blockBytes=Q.block*4),this.matrixStateBuffer=new Int32Array(this.wasm.HEAP32.buffer,this.matrixStateBufferPtr,et.stateStruct*t),Q.allocMatrix(t)}static updateAllContinueTransform(t,e,r){this.wasm._updateAllMatrixContinueTransform(t,e,r)}static setParent(t,e,r){this.matrixStateBuffer[t*et.stateStruct+2]=e>=0?e:-1,this.matrixStateBuffer[t*et.stateStruct+3]=r}static setTranslate(t,e,r,i){this.matrixSRTBuffer[t*9+6]=e,this.matrixSRTBuffer[t*9+7]=r,this.matrixSRTBuffer[t*9+8]=i}static setRotation(t,e,r,i){this.matrixSRTBuffer[t*9+3]=e%360,this.matrixSRTBuffer[t*9+4]=r%360,this.matrixSRTBuffer[t*9+5]=i%360}static setScale(t,e,r,i){this.matrixSRTBuffer[t*9+0]=e,this.matrixSRTBuffer[t*9+1]=r,this.matrixSRTBuffer[t*9+2]=i}static setContinueTranslate(t,e,r,i){(e!=0||r!=0||i!=0)&&(this.matrixContinuedSRTBuffer[t*9+6]=e,this.matrixContinuedSRTBuffer[t*9+7]=r,this.matrixContinuedSRTBuffer[t*9+8]=i,this.matrixStateBuffer[t*et.stateStruct+1]=1)}static setContinueRotation(t,e,r,i){(e!=0||r!=0||i!=0)&&(this.matrixContinuedSRTBuffer[t*9+3]=e,this.matrixContinuedSRTBuffer[t*9+4]=r,this.matrixContinuedSRTBuffer[t*9+5]=i,this.matrixStateBuffer[t*et.stateStruct+1]=1)}static setContinueScale(t,e,r,i){(e!=0||r!=0||i!=0)&&(this.matrixContinuedSRTBuffer[t*9+0]=e,this.matrixContinuedSRTBuffer[t*9+1]=r,this.matrixContinuedSRTBuffer[t*9+2]=i,this.matrixStateBuffer[t*et.stateStruct+1]=1)}};s(et,"matrixBuffer"),s(et,"matrixSRTBuffer"),s(et,"matrixContinuedSRTBuffer"),s(et,"matrixStateBuffer"),s(et,"matrixBufferPtr"),s(et,"matrixSRTBufferPtr"),s(et,"matrixContinuedSRTBufferPtr"),s(et,"matrixStateBufferPtr"),s(et,"wasm"),s(et,"stateStruct",4),s(et,"useDoublePrecision",!1);let Se=et;class Gt{}s(Gt,"AXIS_ANGLE","axisAngle"),s(Gt,"EULER_ANGLES","eulerAngles"),s(Gt,"QUATERNION","quaternion");const We=class We{constructor(t=0,e=0,r=0,i=1){s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"w",1);this.x=t,this.y=e,this.z=r,this.w=i}static identity(){return We._zero}static quaternionToMatrix(t,e){let r=t.x*2,i=t.y*2,a=t.z*2,o=t.x*r,l=t.y*i,h=t.z*a,u=t.x*i,c=t.x*a,f=t.y*a,d=t.w*r,p=t.w*i,A=t.w*a;e.rawData[0]=1-(l+h),e.rawData[1]=u+A,e.rawData[2]=c-p,e.rawData[3]=0,e.rawData[4]=u-A,e.rawData[5]=1-(o+h),e.rawData[6]=f+d,e.rawData[7]=0,e.rawData[8]=c+p,e.rawData[9]=f-d,e.rawData[10]=1-(o+l),e.rawData[11]=0,e.rawData[12]=0,e.rawData[13]=0,e.rawData[14]=0,e.rawData[15]=1}get magnitude(){return Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z)}set(t=0,e=0,r=0,i=1){return this.x=t,this.y=e,this.z=r,this.w=i,this}divide(t){return t instanceof We?new We(this.x/t.x,this.y/t.y,this.z/t.z):(this.x=this.x/t,this.y=this.y/t,this.z=this.z/t,this)}setFromArray(t){return this.x=t[0],this.y=t[1],this.z=t[2],this.w=t[3],this}multiply(t,e){var r=t.w,i=t.x,a=t.y,o=t.z,l=e.w,h=e.x,u=e.y,c=e.z;this.w=r*l-i*h-a*u-o*c,this.x=r*h+i*l+a*c-o*u,this.y=r*u-i*c+a*l+o*h,this.z=r*c+i*u-a*h+o*l}multiplyVector(t,e=null){e||(e=new We);var r=t.x,i=t.y,a=t.z;return e.w=-this.x*r-this.y*i-this.z*a,e.x=this.w*r+this.y*a-this.z*i,e.y=this.w*i-this.x*a+this.z*r,e.z=this.w*a+this.x*i-this.y*r,e}fromAxisAngle(t,e){e*=Math.PI/180;var r=e*.5,i=Math.sin(r);this.w=Math.cos(r),this.x=t.x*i,this.y=t.y*i,this.z=t.z*i,this.normalize()}toAxisAngle(t){var e=this.x*this.x+this.y*this.y+this.z*this.z,r=0;return e>0?(r=2*Math.acos(this.w),e=1/Math.sqrt(e),t.x=this.x*e,t.y=this.y*e,t.z=this.z*e):(r=0,t.x=1,t.y=0,t.z=0),r}slerp(t,e,r){var i=t.w,a=t.x,o=t.y,l=t.z,h=e.w,u=e.x,c=e.y,f=e.z,d=i*h+a*u+o*c+l*f;if(d<0&&(d=-d,h=-h,u=-u,c=-c,f=-f),d<.95){var p=Math.acos(d),A=1/Math.sin(p),x=Math.sin(p*(1-r))*A,C=Math.sin(p*r)*A;this.w=i*x+h*C,this.x=a*x+u*C,this.y=o*x+c*C,this.z=l*x+f*C}else{this.w=i+r*(h-i),this.x=a+r*(u-a),this.y=o+r*(c-o),this.z=l+r*(f-l);var v=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z);this.w*=v,this.x*=v,this.y*=v,this.z*=v}}lerp(t,e,r){var i=t.w,a=t.x,o=t.y,l=t.z,h=e.w,u=e.x,c=e.y,f=e.z,d;i*h+a*u+o*c+l*f<0&&(h=-h,u=-u,c=-c,f=-f),this.w=i+r*(h-i),this.x=a+r*(u-a),this.y=o+r*(c-o),this.z=l+r*(f-l),d=1/Math.sqrt(this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z),this.w*=d,this.x*=d,this.y*=d,this.z*=d}fromEulerAngles(t,e,r){t*=ft,e*=ft,r*=ft;var i=t*.5,a=e*.5,o=r*.5,l=Math.cos(i),h=Math.sin(i),u=Math.cos(a),c=Math.sin(a),f=Math.cos(o),d=Math.sin(o);return this.w=l*u*f+h*c*d,this.x=h*u*f-l*c*d,this.y=l*c*f+h*u*d,this.z=l*u*d-h*c*f,this}setFromRotationMatrix(t){const e=t.rawData,r=e[0],i=e[4],a=e[8],o=e[1],l=e[5],h=e[9],u=e[2],c=e[6],f=e[10],d=r+l+f;if(d>0){const p=.5/Math.sqrt(d+1);this.w=.25/p,this.x=(c-h)*p,this.y=(a-u)*p,this.z=(o-i)*p}else if(r>l&&r>f){const p=2*Math.sqrt(1+r-l-f);this.w=(c-h)/p,this.x=.25*p,this.y=(i+o)/p,this.z=(a+u)/p}else if(l>f){const p=2*Math.sqrt(1+l-r-f);this.w=(a-u)/p,this.x=(i+o)/p,this.y=.25*p,this.z=(h+c)/p}else{const p=2*Math.sqrt(1+f-r-l);this.w=(o-i)/p,this.x=(a+u)/p,this.y=(h+c)/p,this.z=.25*p}return this}getEulerAngles(t){var e,r,i,a,o,l,h,u;return t||(t=new g),a=this.x,o=this.y,l=this.z,h=this.w,u=2*(h*o-a*l),u<=-.99999?(e=2*Math.atan2(a,h),r=-Math.PI/2,i=0):u>=.99999?(e=2*Math.atan2(a,h),r=Math.PI/2,i=0):(e=Math.atan2(2*(h*a+o*l),1-2*(a*a+o*o)),r=Math.asin(u),i=Math.atan2(2*(h*l+a*o),1-2*(o*o+l*l))),t.set(e,r,i).scaleBy(fa)}normalize(t=1){var e=t/Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w);this.x*=e,this.y*=e,this.z*=e,this.w*=e}toString(){return"{x:"+this.x+" y:"+this.y+" z:"+this.z+" w:"+this.w+"}"}fromMatrix(t){var e=t.decompose(Gt.QUATERNION)[1];this.x=e.x,this.y=e.y,this.z=e.z,this.w=e.w}inverse(t=null){t||(t=new We);var e=this.w*this.w+this.x*this.x+this.y*this.y+this.z*this.z;if(e>0){var r=1/e;t.w=this.w*r,t.x=-this.x*r,t.y=-this.y*r,t.z=-this.z*r}return t}clone(){return new We(this.x,this.y,this.z,this.w)}transformVector(t,e=null){var r,i,a,o,l=t.x,h=t.y,u=t.z;return e||(e=new g),o=-this.x*l-this.y*h-this.z*u,r=this.w*l+this.y*u-this.z*h,i=this.w*h-this.x*u+this.z*l,a=this.w*u+this.x*h-this.y*l,e.x=-o*this.x+r*this.w-i*this.z+a*this.y,e.y=-o*this.y+r*this.z+i*this.w-a*this.x,e.z=-o*this.z-r*this.y+i*this.x+a*this.w,e}copyFrom(t){var e=this;return e.x=t.x,e.y=t.y,e.z=t.z,e.w=t.w,this}mul(t,e,r){let i=r||new We;return i.x=t.w*e.x+t.x*e.w+t.y*e.z-t.z*e.y,i.y=t.w*e.y+t.y*e.w+t.z*e.x-t.x*e.z,i.z=t.w*e.z+t.z*e.w+t.x*e.y-t.y*e.x,i.w=t.w*e.w-t.x*e.x-t.y*e.y-t.z*e.z,i}clampf(t,e,r){if(e>r){var i=e;e=r,r=i}return t<e?e:t<r?t:r}static serialize(t){return new We(t.x,t.y,t.z,t.w)}};s(We,"HELP_0",new We(0,0,0,1)),s(We,"HELP_1",new We(0,0,0,1)),s(We,"HELP_2",new We(0,0,0,1)),s(We,"_zero",new We(0,0,0,1)),s(We,"CALCULATION_QUATERNION",new We);let Z=We;function Mm(n,t,e){let r=n.x*2,i=n.y*2,a=n.z*2,o=n.x*r,l=n.y*i,h=n.z*a,u=n.x*i,c=n.x*a,f=n.y*a,d=n.w*r,p=n.w*i,A=n.w*a,x=e||new g;return x.x=(1-(l+h))*t.x+(u-A)*t.y+(c+p)*t.z,x.y=(u+A)*t.x+(1-(o+h))*t.y+(f-d)*t.z,x.z=(c-p)*t.x+(f+d)*t.y+(1-(o+l))*t.z,x}class os{constructor(t=0){s(this,"_x",0);s(this,"_y",0);s(this,"_z",0);s(this,"_w",0);this.seed=t}get seed(){return this._x}set seed(t){this._x=t,this._y=this._x*1812433253+1,this._z=this._y*1812433253+1,this._w=this._z*1812433253+1}static getFloatFromInt(t){return Math.floor((t&8388607)*(1/8388607))}static getByteFromInt(t){return t>>15}clone(){let t=new os;return t._x=this._x,t._y=this._y,t._z=this._z,t._w=this._w,t}get(){let t=this._x^this._x<<11;return this._x=this._y,this._y=this._z,this._z=this._w,this._w=this._w^this._w>>19^(t^t>>8)}getFloat(){return xu(this.get())}getSignedFloat(){return this.getFloat()*2-1}}let fa=180/Math.PI,ft=Math.PI/180,Pm=2147483647,Rm=null;function se(n,t,e){return Math.max(t,Math.min(e,n))}class yt{static gaussFunction(t,e,r,i){let a=Math.pow(t-r,2),o=2*Math.pow(i,2),l=-1*(a/o),h=Math.pow(Math.E,l);return Math.round(h*e)}static computeGaussian(t,e){return 1/Math.sqrt(2*Math.PI*e)*Math.exp(-(t*t)/(2*e*e))}static gaussCoef(t){t<.5&&(t=.5);let e=Math.exp(.726*.726)/t,r=Math.exp(-e),i=Math.exp(-2*e),a=(1-r)*(1-r)/(1+2*e*r-i),o=a,l=a*(e-1)*r,h=a*(e+1)*r,u=-a*i,c=2*r,f=-i,d=(o+l)/(1-c-f),p=(h+u)/(1-c-f);return new Float32Array([o,l,h,u,c,f,d,p])}static clampf(t,e,r){if(e>r){let i=e;e=r,r=i}return t<e?e:t<r?t:r}static normalizeAngle(t){for(;t>180;)t-=360;for(;t<-180;)t+=360;return t}static fract(t){return t-Math.floor(t)}static getRandDirXZ(t){let e=t*Math.random(),r=360*Math.random()*ft,i=Math.cos(r)*e,a=Math.sin(r)*e;return{x:i,z:a}}static getRandDirXYZ(t){let e=t*Math.random(),r=360*Math.random()*ft,i=Math.cos(r)*e,a=Math.tan(r)*e,o=Math.sin(r)*e;return new g(i,a,o)}static getCycleXYZ(t){let e=t*Math.random(),r=360*Math.random()*ft,i=Math.cos(r)*e,a=t*Math.random()-t*.5,o=Math.sin(r)*e;return new g(i,a,o)}static angle(t,e){let r=he.HELP_0,i=he.HELP_1;return r.set(t.x,t.z),i.set(e.x,e.z),Math.acos((r.x*i.x+r.y*i.y)/(r.abs()*i.abs()))}static angle_360(t,e){let r=g.HELP_0;return t.crossProduct(e,r),r.z>0?yt.angle(t,e):360-yt.angle(t,e)}getRotationY(t){return yt.normalizeAngle(Math.atan2(t.z,t.x)*fa)}static fromToRotation(t,e,r=null){r||(r=new Z);let i=Q.help_matrix_2;return Q.fromToRotation(t,e,i),r.fromMatrix(i),r}static getEularDir_yUp(t){let e=Z.HELP_0;return e.fromEulerAngles(0,t,0),e.transformVector(g.Z_AXIS,g.HELP_5),g.HELP_5}static transformVector(t,e,r=null){r||(r=new g);let i=t.rawData,a=i[0],o=i[1],l=i[2],h=i[3],u=i[4],c=i[5],f=i[6],d=i[7],p=i[8],A=i[9],x=i[10],C=i[11],v=i[12],y=i[13],b=i[14],B=i[15],I=e.x,w=e.y,D=e.z;return r.x=a*I+u*w+p*D+v,r.y=o*I+c*w+A*D+y,r.z=l*I+f*w+x*D+b,r.w=h*I+d*w+C*D+B,r}}let Ni=function(n,t,e){return n*(1-e)+t*e};function Um(n,t,e){let r=new g,i=n.x,a=n.y,o=n.z,l=n.w,h=t.x,u=t.y,c=t.z,f=t.w;return r.x=(h-i)*e+i,r.y=(u-a)*e+a,r.z=(c-o)*e+o,r.w=(f-l)*e+l,r}function Lm(n,t,e){let r=new K;return r.r=(1-e)*n.r+e*t.r,r.g=(1-e)*n.g+e*t.g,r.b=(1-e)*n.b+e*t.b,r.a=(1-e)*n.a+e*t.a,r}function Om(n,t,e){return n+((t-n)*e>>8)&255}let Sn=function(n,t,e){let r=e-t;return Math.floor(n/r)%2==0?n%r+t:e-n%r+t},In=function(n,t,e){let r=e-t;return n%r+t},Nm=function(n,t){let e=0;for(let r in n)r==t&&e++;return e};class Fm{constructor(){s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"w",0);s(this,"randSeedList");this.randSeedList=[]}reset(){this.x=Math.random()*1,this.y=Math.random()*1,this.z=Math.random()*1,this.w=Math.random()*1,this.randSeedList.length=0;for(let t=0;t<20;t++)this.randSeedList.push(Math.random()*1)}}function St(n,t){return n instanceof g&&t instanceof g||n instanceof Z&&t instanceof Z?n.x*t.x+n.y*t.y+n.z*t.z:n.x*t.x+n.y*t.y}function bn(n,t){return new g(n.x*t.x,n.y*t.y,n.z*t.z)}function Au(n){return Math.sqrt(n)}function wn(n){return Au(St(n,n))}function vu(n,t){if(wn(n)>g.EPSILON)return n.divide(wn(n));if(n instanceof he)return new he;if(n instanceof g)return new g;if(n instanceof Z)return new Z}function xu(n){return(n&8388607)*(1/8388607)}function da(n){return n.getFloat()}function dt(n,t,e){let r=n.getFloat();return r=t*r+(1-r)*e,r}function km(n,t,e){let r;if(t<e){r=e-t;let i=n.get()%r;return i+=t,i}else if(t>e){r=t-e;let i=n.get()%r;return i=t-i,i}else return t}function Js(n){let t=dt(n,-1,1),e=dt(n,0,2*Math.PI),r=Math.sqrt(1-t*t),i=r*Math.cos(e),a=r*Math.sin(e);return new g(i,a,t)}function Cu(n){let t=dt(n,0,2*Math.PI),e=Math.cos(t),r=Math.sin(t);return new he(e,r)}function zm(n){let t=new Z;return t.x=dt(n,-1,1),t.y=dt(n,-1,1),t.z=dt(n,-1,1),t.w=dt(n,-1,1),t=vu(t),St(t,Z.identity())<0?-t:t}function Gm(n){const t=2*Math.PI;let e=dt(n,0,1),r=dt(n,0,t),i=dt(n,0,t),a=Math.sqrt(1-e),o=Math.sqrt(e),l=new Z(a*Math.sin(r),a*Math.cos(r),o*Math.sin(i),o*Math.cos(i));return St(l,Z.identity())<0?-l:l}function Qm(n,t){return new g(dt(n,-t.x,t.x),dt(n,-t.y,t.y),dt(n,-t.z,t.z))}function _u(n){let t=Js(n);return t.scaleBy(Math.pow(da(n),1/3)),t}function Vm(n,t){return bn(_u(n),t)}function Ym(n,t,e){let r=Js(n),i=Math.pow(dt(n,0,1),1/3);return r.scaleBy(t+(e-t)*i),r}function Hm(n){let t=Cu(n);return t.multiply(Math.pow(dt(n,0,1),1/2),t),t}function Xm(n,t,e){let r=bn(Js(n),t),i=Math.pow(dt(n,e,1),1/3);return r.scaleBy(i),r}function Wm(n){let t=n.getFloat(),e=n.getFloat();t+e>1&&(t=1-t,e=1-e);let r=1-t-e;return new g(t,e,r)}function Km(n){return n/360*2*Math.PI}function jm(n){return 180*n/Math.PI}function qm(n){return Math.sin(n)}function Jm(n){return Math.cos(n)}let yu=4919;function Zm(){return++yu}function $m(n,t,e){let r=n[t],i=n[e];n[t]=i,n[e]=r}function Su(n){return Math.floor(n)}function Tn(n){return Su(n+.5)}function eA(n){return n=Math.max(n,0),n=Math.min(n,1),Tn(n*65535)}function tA(n){return n=Math.max(n,0),n=Math.min(n,1),Tn(n*255)}function Iu(n){return Math.abs(n)==0?n:1/Math.sqrt(n)}function rA(n){let t=En(n);return n.scaleBy(Iu(t))}function iA(n,t){return n.crossProduct(t)}function En(n){return St(n,n)}function aA(n){let t=new os(n);return da(t)}function sA(n,t){let e=new os(t);n.x=da(e),n.y=da(e),n.z=da(e)}function oA(n,t,e){return n<t?e:n>e?t:n}function Bn(n,t){return n-Math.floor(n/t)*t}const bu=1e-6,k=class k{constructor(t=!1){s(this,"index",0);s(this,"offset",0);s(this,"rawData");s(this,"_position");if(k.useCount>=k.allocCount){let e=k.allocCount+k.allocOnceCount;Se.allocMatrix(e)}this.index=k.useCount,this.offset=k.wasmMatrixPtr+this.index*k.blockBytes,k.dynamicGlobalMatrixRef[this.index]=this,k.useCount++,this.rawData=Kr(k.dynamicMatrixBytes.buffer,this.offset,16),this._position=new g,this.identity()}static allocMatrix(t){this.allocCount=t,k.dynamicMatrixBytes=Se.matrixBuffer,k.buffer=k.dynamicMatrixBytes.buffer,k.wasmMatrixPtr=Se.matrixBufferPtr,this.dynamicGlobalMatrixRef||(this.dynamicGlobalMatrixRef=[]),this.dynamicGlobalMatrixRef.forEach(e=>{e.offset=k.wasmMatrixPtr+e.index*k.blockBytes,e.rawData=Kr(k.dynamicMatrixBytes.buffer,e.offset,16)}),k.help_matrix_0||(k.help_matrix_0=new k),k.help_matrix_1||(k.help_matrix_1=new k),k.help_matrix_2||(k.help_matrix_2=new k),k.helpMatrix||(k.helpMatrix=new k),k.helpMatrix2||(k.helpMatrix2=new k),k._getEulerMatrix||(k._getEulerMatrix=new k),k._getEulerMatrix.identity()}static fromToRotation(t,e,r){return r||(r=new k),r.transformDir(t,e),r}static getAxisRotation(t,e,r,i){let a=new k,o=i*(Math.PI/180),l=Math.cos(o),h=Math.sin(o),u=1-l,c,f;return a.rawData[0]=l+t*t*u,a.rawData[5]=l+e*e*u,a.rawData[10]=l+r*r*u,c=t*e*u,f=r*h,a.rawData[1]=c+f,a.rawData[4]=c-f,c=t*r*u,f=e*h,a.rawData[8]=c+f,a.rawData[2]=c-f,c=e*r*u,f=t*h,a.rawData[9]=c-f,a.rawData[6]=c+f,a}static sanitizeEuler(t){k.makePositive(t)}static makePositive(t){let e=-1e-4,r=Math.PI*2-1e-4;t.x<e?t.x+=2*Math.PI:t.x>r&&(t.x-=2*Math.PI),t.y<e?t.y+=2*Math.PI:t.y>r&&(t.y-=2*Math.PI),t.z<e?t.z+=2*Math.PI:t.z>r&&(t.z-=2*Math.PI)}static matrixToEuler(t,e){return t.get(1,2)<.999?t.get(1,2)>-.999?(e.x=Math.asin(-t.get(1,2)),e.y=Math.atan2(t.get(0,2),t.get(2,2)),e.z=Math.atan2(t.get(1,0),t.get(1,1)),k.sanitizeEuler(e),!0):(e.x=Math.PI*.5,e.y=Math.atan2(t.get(0,1),t.get(0,0)),e.z=0,k.sanitizeEuler(e),!1):(e.x=-Math.PI*.5,e.y=Math.atan2(-t.get(0,1),t.get(0,0)),e.z=0,k.sanitizeEuler(e),!1)}static matrixMultiply(t,e,r){k.wasm.Matrix_Multiply(t.index,e.index,r.index)}static matrixAppend(t,e,r){k.wasm.Matrix_Append(t.index,e.index,r.index)}static matrixRotateY(t,e){k.wasm.Matrix_Append(t,e.index)}static matrixRotate(t,e,r){k.wasm.Matrix_Rotate(t,e,r.index)}lookAt(t,e,r=g.Y_AXIS){let i=this.rawData,a=e.subtract(t,g.HELP_0);a.length===0&&(a.z=1),a.normalize();let o=r.crossProduct(a,g.HELP_1);o.length===0&&(Math.abs(r.z)===1?a.x+=1e-4:a.z-=1e-4,a.normalize(),o=r.crossProduct(a,g.HELP_1)),o.normalize();let l=a.crossProduct(o,g.HELP_2);i[0]=o.x,i[1]=l.x,i[2]=a.x,i[3]=0,i[4]=o.y,i[5]=l.y,i[6]=a.y,i[7]=0,i[8]=o.z,i[9]=l.z,i[10]=a.z,i[11]=0,i[12]=-o.dotProduct(t),i[13]=-l.dotProduct(t),i[14]=-a.dotProduct(t),i[15]=1}multiply(t){let e=this.rawData,r=t.rawData,i=k.floatArray;i[0]=e[0]*r[0]+e[1]*r[4]+e[2]*r[8]+e[3]*r[12],i[1]=e[0]*r[1]+e[1]*r[5]+e[2]*r[9]+e[3]*r[13],i[2]=e[0]*r[2]+e[1]*r[6]+e[2]*r[10]+e[3]*r[14],i[3]=e[0]*r[3]+e[1]*r[7]+e[2]*r[11]+e[3]*r[15],i[4]=e[4]*r[0]+e[5]*r[4]+e[6]*r[8]+e[7]*r[12],i[5]=e[4]*r[1]+e[5]*r[5]+e[6]*r[9]+e[7]*r[13],i[6]=e[4]*r[2]+e[5]*r[6]+e[6]*r[10]+e[7]*r[14],i[7]=e[4]*r[3]+e[5]*r[7]+e[6]*r[11]+e[7]*r[15],i[8]=e[8]*r[0]+e[9]*r[4]+e[10]*r[8]+e[11]*r[12],i[9]=e[8]*r[1]+e[9]*r[5]+e[10]*r[9]+e[11]*r[13],i[10]=e[8]*r[2]+e[9]*r[6]+e[10]*r[10]+e[11]*r[14],i[11]=e[8]*r[3]+e[9]*r[7]+e[10]*r[11]+e[11]*r[15],i[12]=e[12]*r[0]+e[13]*r[4]+e[14]*r[8]+e[15]*r[12],i[13]=e[12]*r[1]+e[13]*r[5]+e[14]*r[9]+e[15]*r[13],i[14]=e[12]*r[2]+e[13]*r[6]+e[14]*r[10]+e[15]*r[14],i[15]=e[12]*r[3]+e[13]*r[7]+e[14]*r[11]+e[15]*r[15],e[0]=i[0],e[1]=i[1],e[2]=i[2],e[3]=i[3],e[4]=i[4],e[5]=i[5],e[6]=i[6],e[7]=i[7],e[8]=i[8],e[9]=i[9],e[10]=i[10],e[11]=i[11],e[12]=i[12],e[13]=i[13],e[14]=i[14],e[15]=i[15]}multiplyMatrices(t,e){const r=t.rawData,i=e.rawData,a=this.rawData,o=r[0],l=r[4],h=r[8],u=r[12],c=r[1],f=r[5],d=r[9],p=r[13],A=r[2],x=r[6],C=r[10],v=r[14],y=r[3],b=r[7],B=r[11],I=r[15],w=i[0],D=i[4],L=i[8],M=i[12],G=i[1],N=i[5],q=i[9],ie=i[13],ue=i[2],Ee=i[6],Ie=i[10],Ne=i[14],Qe=i[3],xe=i[7],Ve=i[11],we=i[15];return a[0]=o*w+l*G+h*ue+u*Qe,a[4]=o*D+l*N+h*Ee+u*xe,a[8]=o*L+l*q+h*Ie+u*Ve,a[12]=o*M+l*ie+h*Ne+u*we,a[1]=c*w+f*G+d*ue+p*Qe,a[5]=c*D+f*N+d*Ee+p*xe,a[9]=c*L+f*q+d*Ie+p*Ve,a[13]=c*M+f*ie+d*Ne+p*we,a[2]=A*w+x*G+C*ue+v*Qe,a[6]=A*D+x*N+C*Ee+v*xe,a[10]=A*L+x*q+C*Ie+v*Ve,a[14]=A*M+x*ie+C*Ne+v*we,a[3]=y*w+b*G+B*ue+I*Qe,a[7]=y*D+b*N+B*Ee+I*xe,a[11]=y*L+b*q+B*Ie+I*Ve,a[15]=y*M+b*ie+B*Ne+I*we,this}multiplyPoint3(t,e){e||(e=new g);let r=this.rawData;return e.x=r[0]*t.x+r[4]*t.y+r[8]*t.z+r[12],e.y=r[1]*t.x+r[5]*t.y+r[9]*t.z+r[13],e.z=r[2]*t.x+r[6]*t.y+r[10]*t.z+r[14],e}multiplyVector4(t,e){e||(e=new g);let r=this.rawData,i=t.x,a=t.y,o=t.z,l=r[3]*i+r[7]*a+r[11]*o+r[15];return l=l||1,e.x=(r[0]*i+r[4]*a+r[8]*o+r[12])/l,e.y=(r[1]*i+r[5]*a+r[9]*o+r[13])/l,e.z=(r[2]*i+r[6]*a+r[10]*o+r[14])/l,e.w=1,e}transformVector4(t,e){let r=this.rawData;e||(e=new g);let i=t.x,a=t.y,o=t.z,l=t.w;return e.x=i*r[0]+a*r[4]+o*r[8]+l*r[12],e.y=i*r[1]+a*r[5]+o*r[9]+l*r[13],e.z=i*r[2]+a*r[6]+o*r[10]+l*r[14],e.w=i*r[3]+a*r[7]+o*r[11]+l*r[15],e}perspectiveMultiplyPoint3(t,e){let r=g.HELP_2,i,a=this.rawData;if(r.x=a[0]*t.x+a[4]*t.y+a[8]*t.z+a[12],r.y=a[1]*t.x+a[5]*t.y+a[9]*t.z+a[13],r.z=a[2]*t.x+a[6]*t.y+a[10]*t.z+a[14],i=a[3]*t.x+a[7]*t.y+a[11]*t.z+a[15],Math.abs(i)>1e-7){let o=1/i;return e.x=r.x*o,e.y=r.y*o,e.z=r.z*o,!0}else return e.x=0,e.y=0,e.z=0,!1}perspective(t,e,r,i){let a=this.rawData,o=t*ft/2,l=Math.cos(o)/Math.sin(o);a[0]=-l/e,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=l,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=i/(i-r),a[11]=1,a[12]=0,a[13]=0,a[14]=-r*i/(i-r),a[15]=0}perspective3(t,e,r,i){var a=Math.tan(t*Math.PI/360)*r,o=a*e;this.frustum(-o,o,-a,a,r,i)}frustum(t,e,r,i,a,o){var l=this.rawData;l[0]=-2*a/(e-t),l[1]=0,l[2]=0,l[3]=0,l[4]=0,l[5]=2*a/(i-r),l[6]=0,l[7]=0,l[8]=(e+t)/(e-t),l[9]=(i+r)/(i-r),l[10]=o/(o-a),l[11]=1,l[12]=0,l[13]=0,l[14]=-o*a/(o-a),l[15]=0}ortho(t,e,r,i){let a=this.rawData;return a[0]=2/t,a[1]=0,a[2]=0,a[3]=0,a[4]=0,a[5]=2/e,a[6]=0,a[7]=0,a[8]=0,a[9]=0,a[10]=1/(i-r),a[11]=0,a[12]=0,a[13]=0,a[14]=r/(r-i),a[15]=1,this}orthoZO(t,e,r,i,a,o){let l=this.rawData,h=1/(t-e),u=1/(r-i),c=1/(a-o);return l[0]=-2*h,l[1]=0,l[2]=0,l[3]=0,l[4]=0,l[5]=-2*u,l[6]=0,l[7]=0,l[8]=0,l[9]=0,l[10]=c,l[11]=0,l[12]=(t+e)*h,l[13]=(i+r)*u,l[14]=a*c,l[15]=1,this}orthoOffCenter(t,e,r,i,a,o){let l=this.rawData;l[0]=-2/(e-t),l[1]=0,l[2]=0,l[3]=0,l[4]=0,l[5]=2/(i-r),l[6]=0,l[7]=0,l[8]=0,l[9]=0,l[10]=1/(o-a),l[11]=0,l[12]=(t+e)/(t-e),l[13]=(i+r)/(r-i),l[14]=a/(a-o),l[15]=1}transformDir(t,e){let r=this.rawData,i=1e-6,a=g.ZERO;e.crossProduct(t,a);let o=e.dotProduct(t);if(o>1-i)this.identity();else if(o<-1+i){let l=g.HELP_1,h=g.HELP_2,u=0,c,f,d,p,A,x,C,v,y,b,B,I,w,D,L,M,G,N;h.x=0,h.y=t.z,h.z=-t.y,h.dotProduct(h)<i&&(h.x=-t.z,h.y=0,h.z=t.x),u=1/Math.sqrt(h.dotProduct(h)),h.x*=u,h.y*=u,h.z*=u,h.crossProduct(t,l),c=-t.x*t.x,f=-t.y*t.y,d=-t.z*t.z,p=-t.x*t.y,A=-t.x*t.z,x=-t.y*t.z,C=l.x*l.x,v=l.y*l.y,y=l.z*l.z,b=l.x*l.y,B=l.x*l.z,I=l.y*l.z,w=-h.x*h.x,D=-h.y*h.y,L=-h.z*h.z,M=-h.x*h.y,G=-h.x*h.z,N=-h.y*h.z,r[0]=c+C+w,r[1]=p+b+M,r[2]=A+B+G,r[4]=r[1],r[5]=f+v+D,r[6]=x+I+N,r[8]=r[2],r[9]=r[6],r[10]=d+y+L,r[3]=0,r[7]=0,r[11]=0,r[15]=1}else{let l,h,u,c,f,d=a.dotProduct(a),p=(1-o)/d;l=p*a.x,h=p*a.z,u=l*a.y,c=l*a.z,f=h*a.y,r[0]=o+l*a.x,r[1]=u-a.z,r[2]=c+a.y,r[4]=u+a.z,r[5]=o+p*a.y*a.y,r[6]=f-a.x,r[8]=c-a.y,r[9]=f+a.x,r[10]=o+h*a.z,r[3]=0,r[7]=0,r[11]=0,r[15]=1}return this}append(t){let e=this.rawData,r=e[0],i=e[4],a=e[8],o=e[12],l=e[1],h=e[5],u=e[9],c=e[13],f=e[2],d=e[6],p=e[10],A=e[14],x=e[3],C=e[7],v=e[11],y=e[15];e[0]=r*t.rawData[0]+l*t.rawData[4]+f*t.rawData[8]+x*t.rawData[12],e[1]=r*t.rawData[1]+l*t.rawData[5]+f*t.rawData[9]+x*t.rawData[13],e[2]=r*t.rawData[2]+l*t.rawData[6]+f*t.rawData[10]+x*t.rawData[14],e[3]=r*t.rawData[3]+l*t.rawData[7]+f*t.rawData[11]+x*t.rawData[15],e[4]=i*t.rawData[0]+h*t.rawData[4]+d*t.rawData[8]+C*t.rawData[12],e[5]=i*t.rawData[1]+h*t.rawData[5]+d*t.rawData[9]+C*t.rawData[13],e[6]=i*t.rawData[2]+h*t.rawData[6]+d*t.rawData[10]+C*t.rawData[14],e[7]=i*t.rawData[3]+h*t.rawData[7]+d*t.rawData[11]+C*t.rawData[15],e[8]=a*t.rawData[0]+u*t.rawData[4]+p*t.rawData[8]+v*t.rawData[12],e[9]=a*t.rawData[1]+u*t.rawData[5]+p*t.rawData[9]+v*t.rawData[13],e[10]=a*t.rawData[2]+u*t.rawData[6]+p*t.rawData[10]+v*t.rawData[14],e[11]=a*t.rawData[3]+u*t.rawData[7]+p*t.rawData[11]+v*t.rawData[15],e[12]=o*t.rawData[0]+c*t.rawData[4]+A*t.rawData[8]+y*t.rawData[12],e[13]=o*t.rawData[1]+c*t.rawData[5]+A*t.rawData[9]+y*t.rawData[13],e[14]=o*t.rawData[2]+c*t.rawData[6]+A*t.rawData[10]+y*t.rawData[14],e[15]=o*t.rawData[3]+c*t.rawData[7]+A*t.rawData[11]+y*t.rawData[15]}add(t){let e=this.rawData,r=e[0],i=e[4],a=e[8],o=e[12],l=e[1],h=e[5],u=e[9],c=e[13],f=e[2],d=e[6],p=e[10],A=e[14],x=e[3],C=e[7],v=e[11],y=e[15],b=t.rawData[0],B=t.rawData[4],I=t.rawData[8],w=t.rawData[12],D=t.rawData[1],L=t.rawData[5],M=t.rawData[9],G=t.rawData[13],N=t.rawData[2],q=t.rawData[6],ie=t.rawData[10],ue=t.rawData[14],Ee=t.rawData[3],Ie=t.rawData[7],Ne=t.rawData[11],Qe=t.rawData[15];return e[0]=r+b,e[1]=l+D,e[2]=f+N,e[3]=x+Ee,e[4]=i+B,e[5]=h+L,e[6]=d+q,e[7]=C+Ie,e[8]=a+I,e[9]=u+M,e[10]=p+ie,e[11]=v+Ne,e[12]=o+w,e[13]=c+G,e[14]=A+ue,e[15]=y+Qe,this}sub(t){let e=this.rawData,r=e[0],i=e[4],a=e[8],o=e[12],l=e[1],h=e[5],u=e[9],c=e[13],f=e[2],d=e[6],p=e[10],A=e[14],x=e[3],C=e[7],v=e[11],y=e[15],b=t.rawData[0],B=t.rawData[4],I=t.rawData[8],w=t.rawData[12],D=t.rawData[1],L=t.rawData[5],M=t.rawData[9],G=t.rawData[13],N=t.rawData[2],q=t.rawData[6],ie=t.rawData[10],ue=t.rawData[14],Ee=t.rawData[3],Ie=t.rawData[7],Ne=t.rawData[11],Qe=t.rawData[15];return e[0]=r-b,e[1]=l-D,e[2]=f-N,e[3]=x-Ee,e[4]=i-B,e[5]=h-L,e[6]=d-q,e[7]=C-Ie,e[8]=a-I,e[9]=u-M,e[10]=p-ie,e[11]=v-Ne,e[12]=o-w,e[13]=c-G,e[14]=A-ue,e[15]=y-Qe,this}mult(t){let e=this.rawData;return e[0]*=t,e[1]*=t,e[2]*=t,e[3]*=t,e[4]*=t,e[5]*=t,e[6]*=t,e[7]*=t,e[8]*=t,e[9]*=t,e[10]*=t,e[11]*=t,e[12]*=t,e[13]*=t,e[14]*=t,e[15]*=t,this}appendRotation(t,e){let r=k.getAxisRotation(e.x,e.y,e.z,t);this.append(r)}createByRotation(t,e){let r=k.helpMatrix,i,a,o=t*ft;return i=Math.sin(o),a=Math.cos(o),e.x==1&&(r.rawData[0]=1,r.rawData[1]=0,r.rawData[2]=0,r.rawData[3]=0,r.rawData[4]=0,r.rawData[5]=a,r.rawData[6]=i,r.rawData[7]=0,r.rawData[8]=0,r.rawData[9]=-i,r.rawData[10]=a,r.rawData[11]=0,r.rawData[12]=0,r.rawData[13]=0,r.rawData[14]=0,r.rawData[15]=1),e.y==1&&(r.rawData[0]=a,r.rawData[1]=0,r.rawData[2]=-i,r.rawData[3]=0,r.rawData[4]=0,r.rawData[5]=1,r.rawData[6]=0,r.rawData[7]=0,r.rawData[8]=i,r.rawData[9]=0,r.rawData[10]=a,r.rawData[11]=0,r.rawData[12]=0,r.rawData[13]=0,r.rawData[14]=0,r.rawData[15]=1),e.z==1&&(r.rawData[0]=a,r.rawData[1]=i,r.rawData[2]=0,r.rawData[3]=0,r.rawData[4]=-i,r.rawData[5]=a,r.rawData[6]=0,r.rawData[7]=0,r.rawData[8]=0,r.rawData[9]=0,r.rawData[10]=1,r.rawData[11]=0,r.rawData[12]=0,r.rawData[13]=0,r.rawData[14]=0,r.rawData[15]=1),this.append(r),this}appendScale(t,e,r){k.helpMatrix.createByScale(t,e,r),this.append(k.helpMatrix)}createByScale(t,e,r){let i=this.rawData;i[0]=t,i[1]=0,i[2]=0,i[3]=0,i[4]=0,i[5]=e,i[6]=0,i[7]=0,i[8]=0,i[9]=0,i[10]=r,i[11]=0,i[12]=0,i[13]=0,i[14]=0,i[15]=1}appendTranslation(t,e,r){let i=this.rawData;i[12]+=t,i[13]+=e,i[14]+=r}clone(){let t=new k;return t.copyFrom(this),t}copyRowFrom(t,e){let r=this.rawData;switch(t){case 0:r[0]=e.x,r[1]=e.y,r[2]=e.z,r[3]=e.w;break;case 1:r[4]=e.x,r[5]=e.y,r[6]=e.z,r[7]=e.w;break;case 2:r[8]=e.x,r[9]=e.y,r[10]=e.z,r[11]=e.w;break;case 3:r[12]=e.x,r[13]=e.y,r[14]=e.z,r[15]=e.w;break}}copyRowTo(t,e){let r=this.rawData;switch(t){case 0:e.x=r[0],e.y=r[1],e.z=r[2],e.w=r[3];break;case 1:e.x=r[4],e.y=r[5],e.z=r[6],e.w=r[7];break;case 2:e.x=r[8],e.y=r[9],e.z=r[10],e.w=r[11];break;case 3:e.x=r[12],e.y=r[13],e.z=r[14],e.w=r[15];break}}copyFrom(t){let e=this.rawData;return e[0]=t.rawData[0],e[1]=t.rawData[1],e[2]=t.rawData[2],e[3]=t.rawData[3],e[4]=t.rawData[4],e[5]=t.rawData[5],e[6]=t.rawData[6],e[7]=t.rawData[7],e[8]=t.rawData[8],e[9]=t.rawData[9],e[10]=t.rawData[10],e[11]=t.rawData[11],e[12]=t.rawData[12],e[13]=t.rawData[13],e[14]=t.rawData[14],e[15]=t.rawData[15],this}copyRawDataTo(t,e=0,r=!1){let i=this.rawData;t[0+e]=i[0],t[1+e]=i[1],t[2+e]=i[2],t[3+e]=i[3],t[4+e]=i[4],t[5+e]=i[5],t[6+e]=i[6],t[7+e]=i[7],t[8+e]=i[8],t[9+e]=i[9],t[10+e]=i[10],t[11+e]=i[11],t[12+e]=i[12],t[13+e]=i[13],t[14+e]=i[14],t[15+e]=i[15]}copyColFrom(t,e){let r=this.rawData;switch(t){case 0:r[0]=e.x,r[4]=e.y,r[8]=e.z,r[12]=e.w;break;case 1:r[1]=e.x,r[5]=e.y,r[9]=e.z,r[13]=e.w;break;case 2:r[2]=e.x,r[6]=e.y,r[10]=e.z,r[14]=e.w;break;case 3:r[3]=e.x,r[7]=e.y,r[11]=e.z,r[15]=e.w;break}}copyColTo(t,e){let r=this.rawData;switch(t){case 0:e.x=r[0],e.y=r[4],e.z=r[8],e.w=r[12];break;case 1:e.x=r[1],e.y=r[5],e.z=r[9],e.w=r[13];break;case 2:e.x=r[2],e.y=r[6],e.z=r[10],e.w=r[14];break;case 3:e.x=r[3],e.y=r[7],e.z=r[11],e.w=r[15];break}}copyToMatrix3D(t){t.rawData=this.rawData.slice(0)}makeRotationFromQuaternion(t){return this.compose(k._zero,t,k._one),this}decompose(t="eulerAngles",e){let r=Z.CALCULATION_QUATERNION,i=e||k._prs;this.copyRawDataTo(k.decomposeRawData);let a=k.decomposeRawData,o=i[0];o.x=a[12],o.y=a[13],o.z=a[14],a[12]=0,a[13]=0,a[14]=0;let l=i[2];l.x=Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]),l.y=Math.sqrt(a[4]*a[4]+a[5]*a[5]+a[6]*a[6]),l.z=Math.sqrt(a[8]*a[8]+a[9]*a[9]+a[10]*a[10]),a[0]*(a[5]*a[10]-a[6]*a[9])-a[1]*(a[4]*a[10]-a[6]*a[8])+a[2]*(a[4]*a[9]-a[5]*a[8])<0&&(l.z=-l.z),a[0]/=l.x,a[1]/=l.x,a[2]/=l.x,a[4]/=l.y,a[5]/=l.y,a[6]/=l.y,a[8]/=l.z,a[9]/=l.z,a[10]/=l.z;let h=i[1],u;switch(t){case Gt.AXIS_ANGLE:h.w=Math.acos((a[0]+a[5]+a[10]-1)/2);let c=Math.sqrt((a[6]-a[9])*(a[6]-a[9])+(a[8]-a[2])*(a[8]-a[2])+(a[1]-a[4])*(a[1]-a[4]));h.x=(a[6]-a[9])/c,h.y=(a[8]-a[2])/c,h.z=(a[1]-a[4])/c;break;case Gt.QUATERNION:u=a[0]+a[5]+a[10],u>0?(h.w=Math.sqrt(1+u)/2,h.x=(a[6]-a[9])/(4*h.w),h.y=(a[8]-a[2])/(4*h.w),h.z=(a[1]-a[4])/(4*h.w)):a[0]>a[5]&&a[0]>a[10]?(h.x=Math.sqrt(1+a[0]-a[5]-a[10])/2,h.w=(a[6]-a[9])/(4*h.x),h.y=(a[1]+a[4])/(4*h.x),h.z=(a[8]+a[2])/(4*h.x)):a[5]>a[10]?(h.y=Math.sqrt(1+a[5]-a[0]-a[10])/2,h.x=(a[1]+a[4])/(4*h.y),h.w=(a[8]-a[2])/(4*h.y),h.z=(a[6]+a[9])/(4*h.y)):(h.z=Math.sqrt(1+a[10]-a[0]-a[5])/2,h.x=(a[8]+a[2])/(4*h.z),h.y=(a[6]+a[9])/(4*h.z),h.w=(a[1]-a[4])/(4*h.z));break;case Gt.EULER_ANGLES:u=a[0]+a[5]+a[10],u>0?(r.w=Math.sqrt(1+u)/2,r.x=(a[6]-a[9])/(4*r.w),r.y=(a[8]-a[2])/(4*r.w),r.z=(a[1]-a[4])/(4*r.w)):a[0]>a[5]&&a[0]>a[10]?(r.x=Math.sqrt(1+a[0]-a[5]-a[10])/2,r.w=(a[6]-a[9])/(4*r.x),r.y=(a[1]+a[4])/(4*r.x),r.z=(a[8]+a[2])/(4*r.x)):a[5]>a[10]?(h.y=Math.sqrt(1+a[5]-a[0]-a[10])/2,r.x=(a[1]+a[4])/(4*r.y),r.w=(a[8]-a[2])/(4*r.y),r.z=(a[6]+a[9])/(4*r.y)):(r.z=Math.sqrt(1+a[10]-a[0]-a[5])/2,r.x=(a[8]+a[2])/(4*r.z),r.y=(a[6]+a[9])/(4*r.z),r.w=(a[1]-a[4])/(4*r.z)),r.getEulerAngles(h);break}return i[0]=o,i[1]=h,i[2]=l,i}static getEuler(t,e,r=!0,i){return t||(t=new g),k._getEulerMatrix.makeRotationFromQuaternion(e).makeEuler(t,r,i),t}compose(t,e,r){const i=this.rawData,a=e.x,o=e.y,l=e.z,h=e.w,u=a+a,c=o+o,f=l+l,d=a*u,p=a*c,A=a*f,x=o*c,C=o*f,v=l*f,y=h*u,b=h*c,B=h*f,I=r.x,w=r.y,D=r.z;return i[0]=(1-(x+v))*I,i[1]=(p+B)*I,i[2]=(A-b)*I,i[3]=0,i[4]=(p-B)*w,i[5]=(1-(d+v))*w,i[6]=(C+y)*w,i[7]=0,i[8]=(A+b)*D,i[9]=(C-y)*D,i[10]=(1-(d+x))*D,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1,this}deltaTransformVector(t,e){e||(e=new g);let r=this.rawData,i=t.x,a=t.y,o=t.z;return e.x=i*r[0]+a*r[4]+o*r[8],e.y=i*r[1]+a*r[5]+o*r[9],e.z=i*r[2]+a*r[6]+o*r[10],e.w=i*r[3]+a*r[7]+o*r[11],e}identity(){let t=this.rawData;return t[0]=1,t[1]=0,t[2]=0,t[3]=0,t[4]=0,t[5]=1,t[6]=0,t[7]=0,t[8]=0,t[9]=0,t[10]=1,t[11]=0,t[12]=0,t[13]=0,t[14]=0,t[15]=1,this}fill(t){let e=this.rawData;e[1]=t,e[2]=t,e[3]=t,e[4]=t,e[6]=t,e[7]=t,e[8]=t,e[9]=t,e[11]=t,e[12]=t,e[13]=t,e[14]=t,e[0]=t,e[5]=t,e[10]=t,e[15]=t}invers33(){let t=this.rawData,e=t[5]*t[10]-t[9]*t[6],r=t[8]*t[6]-t[4]*t[10],i=t[4]*t[9]-t[8]*t[5],a=t[9]*t[2]-t[1]*t[10],o=t[0]*t[10]-t[8]*t[2],l=t[8]*t[1]-t[0]*t[9],h=t[1]*t[6]-t[5]*t[2],u=t[4]*t[2]-t[0]*t[6],c=t[0]*t[5]-t[4]*t[1],f=t[0]*e+t[4]*a+t[8]*h;if(Math.abs(f)>1e-11){let d=1/f;t[0]=d*e,t[4]=d*r,t[8]=d*i,t[1]=d*a,t[5]=d*o,t[9]=d*l,t[2]=d*h,t[6]=d*u,t[10]=d*c}}invert(){let t=this.determinant,e=Math.abs(t)>1e-11,r=this.rawData;if(e){t=1/t;let i=r[0],a=r[4],o=r[8],l=r[12],h=r[1],u=r[5],c=r[9],f=r[13],d=r[2],p=r[6],A=r[10],x=r[14],C=r[3],v=r[7],y=r[11],b=r[15];r[0]=t*(u*(A*b-x*y)-c*(p*b-x*v)+f*(p*y-A*v)),r[1]=-t*(h*(A*b-x*y)-c*(d*b-x*C)+f*(d*y-A*C)),r[2]=t*(h*(p*b-x*v)-u*(d*b-x*C)+f*(d*v-p*C)),r[3]=-t*(h*(p*y-A*v)-u*(d*y-A*C)+c*(d*v-p*C)),r[4]=-t*(a*(A*b-x*y)-o*(p*b-x*v)+l*(p*y-A*v)),r[5]=t*(i*(A*b-x*y)-o*(d*b-x*C)+l*(d*y-A*C)),r[6]=-t*(i*(p*b-x*v)-a*(d*b-x*C)+l*(d*v-p*C)),r[7]=t*(i*(p*y-A*v)-a*(d*y-A*C)+o*(d*v-p*C)),r[8]=t*(a*(c*b-f*y)-o*(u*b-f*v)+l*(u*y-c*v)),r[9]=-t*(i*(c*b-f*y)-o*(h*b-f*C)+l*(h*y-c*C)),r[10]=t*(i*(u*b-f*v)-a*(h*b-f*C)+l*(h*v-u*C)),r[11]=-t*(i*(u*y-c*v)-a*(h*y-c*C)+o*(h*v-u*C)),r[12]=-t*(a*(c*x-f*A)-o*(u*x-f*p)+l*(u*A-c*p)),r[13]=t*(i*(c*x-f*A)-o*(h*x-f*d)+l*(h*A-c*d)),r[14]=-t*(i*(u*x-f*p)-a*(h*x-f*d)+l*(h*p-u*d)),r[15]=t*(i*(u*A-c*p)-a*(h*A-c*d)+o*(h*p-u*d))}return e}transformPoint(t,e){let r=this.rawData;e||(e=new g);let i=t.x,a=t.y,o=t.z;return e.x=i*r[0]+a*r[4]+o*r[8]+r[12],e.y=i*r[1]+a*r[5]+o*r[9]+r[13],e.z=i*r[2]+a*r[6]+o*r[10]+r[14],e}transformVector(t,e){let r=this.rawData;e||(e=new g);let i=t.x,a=t.y,o=t.z;return e.x=i*r[0]+a*r[4]+o*r[8],e.y=i*r[1]+a*r[5]+o*r[9],e.z=i*r[2]+a*r[6]+o*r[10],e}transpose(){let t=this.rawData;for(let e=0;e<k.helpMatrix.rawData.length;e++)k.helpMatrix.rawData[e]=t[e];t[1]=k.helpMatrix.rawData[4],t[2]=k.helpMatrix.rawData[8],t[3]=k.helpMatrix.rawData[12],t[4]=k.helpMatrix.rawData[1],t[6]=k.helpMatrix.rawData[9],t[7]=k.helpMatrix.rawData[13],t[8]=k.helpMatrix.rawData[2],t[9]=k.helpMatrix.rawData[6],t[11]=k.helpMatrix.rawData[14],t[12]=k.helpMatrix.rawData[3],t[13]=k.helpMatrix.rawData[7],t[14]=k.helpMatrix.rawData[11]}get determinant(){let t=this.rawData;return(t[0]*t[5]-t[4]*t[1])*(t[10]*t[15]-t[14]*t[11])-(t[0]*t[9]-t[8]*t[1])*(t[6]*t[15]-t[14]*t[7])+(t[0]*t[13]-t[12]*t[1])*(t[6]*t[11]-t[10]*t[7])+(t[4]*t[9]-t[8]*t[5])*(t[2]*t[15]-t[14]*t[3])-(t[4]*t[13]-t[12]*t[5])*(t[2]*t[11]-t[10]*t[3])+(t[8]*t[13]-t[12]*t[9])*(t[2]*t[7]-t[6]*t[3])}getPosition(t){t||(t=new g);let e=this.rawData;return t.x=e[12],t.y=e[13],t.z=e[14],t}get position(){return this._position.set(this.rawData[12],this.rawData[13],this.rawData[14]),this._position}set position(t){let e=this.rawData;e[12]=t.x,e[13]=t.y,e[14]=t.z}get scale(){let t=this.rawData;return new g(t[0],t[5],t[10])}set scale(t){let e=this.rawData;e[0]=t.x,e[5]=t.y,e[10]=t.z}toString(){let t=this.rawData;return"matrix3d("+Math.round(t[0]*1e3)/1e3+","+Math.round(t[1]*1e3)/1e3+","+Math.round(t[2]*1e3)/1e3+","+Math.round(t[3]*1e3)/1e3+","+Math.round(t[4]*1e3)/1e3+","+Math.round(t[5]*1e3)/1e3+","+Math.round(t[6]*1e3)/1e3+","+Math.round(t[7]*1e3)/1e3+","+Math.round(t[8]*1e3)/1e3+","+Math.round(t[9]*1e3)/1e3+","+Math.round(t[10]*1e3)/1e3+","+Math.round(t[11]*1e3)/1e3+","+Math.round(t[12]*1e3)/1e3+","+Math.round(t[13]*1e3)/1e3+","+Math.round(t[14]*1e3)/1e3+","+Math.round(t[15]*1e3)/1e3+")"}lerp(t,e,r){this.copyFrom(e).sub(t).mult(r).add(t)}get(t,e){return this.rawData[t+e*4]}set(t,e,r){this.rawData[t+e*4]=r}getMaxScaleOnAxis(){let t=this.rawData,e=t[0]*t[0]+t[1]*t[1]+t[2]*t[2],r=t[4]*t[4]+t[5]*t[5]+t[6]*t[6],i=t[8]*t[8]+t[9]*t[9]+t[10]*t[10];return Math.sqrt(Math.max(e,r,i))}translate(t){let e=this.get(0,0)*t.x+this.get(0,1)*t.y+this.get(0,2)*t.z+this.get(0,3),r=this.get(1,0)*t.x+this.get(1,1)*t.y+this.get(1,2)*t.z+this.get(1,3),i=this.get(2,0)*t.x+this.get(2,1)*t.y+this.get(2,2)*t.z+this.get(2,3),a=this.get(3,0)*t.x+this.get(3,1)*t.y+this.get(3,2)*t.z+this.get(3,3);return this.set(0,3,e),this.set(1,3,r),this.set(2,3,i),this.set(3,3,a),this}setTRInverse(t,e){e=e.inverse(),Z.quaternionToMatrix(e,this),this.translate(new g(-t.x,-t.y,-t.z))}setScale(t){return this.set(0,0,t.x),this.set(0,1,0),this.set(0,2,0),this.set(0,3,0),this.set(1,0,0),this.set(1,1,t.y),this.set(1,2,0),this.set(1,3,0),this.set(2,0,0),this.set(2,1,0),this.set(2,2,t.z),this.set(2,3,0),this.set(3,0,0),this.set(3,1,0),this.set(3,2,0),this.set(3,3,1),this}makeBasis(t,e,r){return this.setElements(t.x,e.x,r.x,0,t.y,e.y,r.y,0,t.z,e.z,r.z,0,0,0,0,1),this}makeRotationAxis(t,e){const r=Math.cos(e),i=Math.sin(e),a=1-r,o=t.x,l=t.y,h=t.z,u=a*o,c=a*l;return this.setElements(u*o+r,u*l-i*h,u*h+i*l,0,u*l+i*h,c*l+r,c*h-i*o,0,u*h-i*l,c*h+i*o,a*h*h+r,0,0,0,0,1),this}static transpose(t,e){e||(e=new k);let r=t.rawData,i=e.rawData;return i[0]=r[0],i[1]=r[4],i[2]=r[8],i[3]=r[12],i[4]=r[1],i[5]=r[5],i[6]=r[9],i[7]=r[13],i[8]=r[2],i[9]=r[6],i[10]=r[10],i[11]=r[14],i[12]=r[3],i[13]=r[7],i[14]=r[11],i[15]=r[15],e}static inverse(t,e){e||(e=new k);let r=t.rawData,i=e.rawData;i[0]=r[5]*r[10]*r[15]-r[5]*r[14]*r[11]-r[6]*r[9]*r[15]+r[6]*r[13]*r[11]+r[7]*r[9]*r[14]-r[7]*r[13]*r[10],i[1]=-r[1]*r[10]*r[15]+r[1]*r[14]*r[11]+r[2]*r[9]*r[15]-r[2]*r[13]*r[11]-r[3]*r[9]*r[14]+r[3]*r[13]*r[10],i[2]=r[1]*r[6]*r[15]-r[1]*r[14]*r[7]-r[2]*r[5]*r[15]+r[2]*r[13]*r[7]+r[3]*r[5]*r[14]-r[3]*r[13]*r[6],i[3]=-r[1]*r[6]*r[11]+r[1]*r[10]*r[7]+r[2]*r[5]*r[11]-r[2]*r[9]*r[7]-r[3]*r[5]*r[10]+r[3]*r[9]*r[6],i[4]=-r[4]*r[10]*r[15]+r[4]*r[14]*r[11]+r[6]*r[8]*r[15]-r[6]*r[12]*r[11]-r[7]*r[8]*r[14]+r[7]*r[12]*r[10],i[5]=r[0]*r[10]*r[15]-r[0]*r[14]*r[11]-r[2]*r[8]*r[15]+r[2]*r[12]*r[11]+r[3]*r[8]*r[14]-r[3]*r[12]*r[10],i[6]=-r[0]*r[6]*r[15]+r[0]*r[14]*r[7]+r[2]*r[4]*r[15]-r[2]*r[12]*r[7]-r[3]*r[4]*r[14]+r[3]*r[12]*r[6],i[7]=r[0]*r[6]*r[11]-r[0]*r[10]*r[7]-r[2]*r[4]*r[11]+r[2]*r[8]*r[7]+r[3]*r[4]*r[10]-r[3]*r[8]*r[6],i[8]=r[4]*r[9]*r[15]-r[4]*r[13]*r[11]-r[5]*r[8]*r[15]+r[5]*r[12]*r[11]+r[7]*r[8]*r[13]-r[7]*r[12]*r[9],i[9]=-r[0]*r[9]*r[15]+r[0]*r[13]*r[11]+r[1]*r[8]*r[15]-r[1]*r[12]*r[11]-r[3]*r[8]*r[13]+r[3]*r[12]*r[9],i[10]=r[0]*r[5]*r[15]-r[0]*r[13]*r[7]-r[1]*r[4]*r[15]+r[1]*r[12]*r[7]+r[3]*r[4]*r[13]-r[3]*r[12]*r[5],i[11]=-r[0]*r[5]*r[11]+r[0]*r[9]*r[7]+r[1]*r[4]*r[11]-r[1]*r[8]*r[7]-r[3]*r[4]*r[9]+r[3]*r[8]*r[5],i[12]=-r[4]*r[9]*r[14]+r[4]*r[13]*r[10]+r[5]*r[8]*r[14]-r[5]*r[12]*r[10]-r[6]*r[8]*r[13]+r[6]*r[12]*r[9],i[13]=r[0]*r[9]*r[14]-r[0]*r[13]*r[10]-r[1]*r[8]*r[14]+r[1]*r[12]*r[10]+r[2]*r[8]*r[13]-r[2]*r[12]*r[9],i[14]=-r[0]*r[5]*r[14]+r[0]*r[13]*r[6]+r[1]*r[4]*r[14]-r[1]*r[12]*r[6]-r[2]*r[4]*r[13]+r[2]*r[12]*r[5],i[15]=r[0]*r[5]*r[10]-r[0]*r[9]*r[6]-r[1]*r[4]*r[10]+r[1]*r[8]*r[6]+r[2]*r[4]*r[9]-r[2]*r[8]*r[5];let a=r[0]*i[0]+r[1]*i[4]+r[2]*i[8]+r[3]*i[12];for(let o=0;o<16;o++)i[o]/=a;return e}makeEuler(t,e,r="XYZ"){const i=this.rawData,a=i[0],o=i[4],l=i[8],h=i[1],u=i[5],c=i[9],f=i[2],d=i[6],p=i[10];switch(r){case"XYZ":t.y=Math.asin(se(l,-1,1)),Math.abs(l)<.9999999?(t.x=Math.atan2(-c,p),t.z=Math.atan2(-o,a)):(t.x=Math.atan2(d,u),t.z=0);break;case"YXZ":t.x=Math.asin(-se(c,-1,1)),Math.abs(c)<.9999999?(t.y=Math.atan2(l,p),t.z=Math.atan2(h,u)):(t.y=Math.atan2(-f,a),t.z=0);break;case"ZXY":t.x=Math.asin(se(d,-1,1)),Math.abs(d)<.9999999?(t.y=Math.atan2(-f,p),t.z=Math.atan2(-o,u)):(t.y=0,t.z=Math.atan2(h,a));break;case"ZYX":t.y=Math.asin(-se(f,-1,1)),Math.abs(f)<.9999999?(t.x=Math.atan2(d,p),t.z=Math.atan2(h,a)):(t.x=0,t.z=Math.atan2(-o,u));break;case"YZX":t.z=Math.asin(se(h,-1,1)),Math.abs(h)<.9999999?(t.x=Math.atan2(-c,u),t.y=Math.atan2(-f,a)):(t.x=0,t.y=Math.atan2(l,p));break;case"XZY":t.z=Math.asin(-se(o,-1,1)),Math.abs(o)<.9999999?(t.x=Math.atan2(d,u),t.y=Math.atan2(l,a)):(t.x=Math.atan2(-c,p),t.y=0);break}return e&&t.multiplyScalar(fa),t}setElements(t,e,r,i,a,o,l,h,u,c,f,d,p,A,x,C){const v=this.rawData;return v[0]=t,v[4]=e,v[8]=r,v[12]=i,v[1]=a,v[5]=o,v[9]=l,v[13]=h,v[2]=u,v[6]=c,v[10]=f,v[14]=d,v[3]=p,v[7]=A,v[11]=x,v[15]=C,this}makeMatrix44ByQuaternion(t,e,r){this.identity(),Z.quaternionToMatrix(r,this),this.appendTranslation(t.x,t.y,t.z),this.appendScale(e.x,e.y,e.z)}};s(k,"blockBytes",16*4),s(k,"block",16),s(k,"allocCount",1e3),s(k,"allocOnceCount",1e3),s(k,"maxCount",50*1e4),s(k,"useCount",0),s(k,"buffer"),s(k,"wasmMatrixPtr",0),s(k,"dynamicMatrixBytes"),s(k,"dynamicGlobalMatrixRef"),s(k,"wasm"),s(k,"help_matrix_0"),s(k,"help_matrix_1"),s(k,"help_matrix_2"),s(k,"helpMatrix"),s(k,"helpMatrix2"),s(k,"_getEulerMatrix"),s(k,"_zero",new g(0,0,0)),s(k,"_one",new g(1,1,1)),s(k,"_prs",[new g,new g,new g]),s(k,"floatArray",new Float64Array(16).fill(0)),s(k,"decomposeRawData",new Float64Array(16).fill(0));let Q=k;function wu(n,t,e){for(let r=0;r<4;r++)e.rawData[r]=n.rawData[r]*t.rawData[0]+n.rawData[r+4]*t.rawData[1]+n.rawData[r+8]*t.rawData[2]+n.rawData[r+12]*t.rawData[3],e.rawData[r+4]=n.rawData[r]*t.rawData[4]+n.rawData[r+4]*t.rawData[5]+n.rawData[r+8]*t.rawData[6]+n.rawData[r+12]*t.rawData[7],e.rawData[r+8]=n.rawData[r]*t.rawData[8]+n.rawData[r+4]*t.rawData[9]+n.rawData[r+8]*t.rawData[10]+n.rawData[r+12]*t.rawData[11],e.rawData[r+12]=n.rawData[r]*t.rawData[12]+n.rawData[r+4]*t.rawData[13]+n.rawData[r+8]*t.rawData[14]+n.rawData[r+12]*t.rawData[15]}function Zs(n,t,e,r){let i=r.rawData,a=n.x*ft,o=n.y*ft,l=n.z*ft,h=0,u=a*.5,c=o*.5,f=l*.5,d=Math.cos(u),p=Math.sin(u),A=Math.cos(c),x=Math.sin(c),C=Math.cos(f),v=Math.sin(f);h=d*A*C+p*x*v,a=p*A*C-d*x*v,o=d*x*C+p*A*v,l=d*A*v-p*x*C;let y=a+a,b=o+o,B=l+l,I=a*y,w=a*b,D=a*B,L=o*b,M=o*B,G=l*B,N=h*y,q=h*b,ie=h*B,ue=e.x,Ee=e.y,Ie=e.z;i[0]=(1-(L+G))*ue,i[1]=(w+ie)*ue,i[2]=(D-q)*ue,i[3]=0,i[4]=(w-ie)*Ee,i[5]=(1-(I+G))*Ee,i[6]=(M+N)*Ee,i[7]=0,i[8]=(D+q)*Ie,i[9]=(M-N)*Ie,i[10]=(1-(I+L))*Ie,i[11]=0,i[12]=t.x,i[13]=t.y,i[14]=t.z,i[15]=1}function Tu(n,t,e){let r=n.rawData,i=e.rawData,a=r[0],o=r[4],l=r[8],h=r[12],u=r[1],c=r[5],f=r[9],d=r[13],p=r[2],A=r[6],x=r[10],C=r[14],v=r[3],y=r[7],b=r[11],B=r[15];i[0]=a*t.rawData[0]+u*t.rawData[4]+p*t.rawData[8]+v*t.rawData[12],i[1]=a*t.rawData[1]+u*t.rawData[5]+p*t.rawData[9]+v*t.rawData[13],i[2]=a*t.rawData[2]+u*t.rawData[6]+p*t.rawData[10]+v*t.rawData[14],i[3]=a*t.rawData[3]+u*t.rawData[7]+p*t.rawData[11]+v*t.rawData[15],i[4]=o*t.rawData[0]+c*t.rawData[4]+A*t.rawData[8]+y*t.rawData[12],i[5]=o*t.rawData[1]+c*t.rawData[5]+A*t.rawData[9]+y*t.rawData[13],i[6]=o*t.rawData[2]+c*t.rawData[6]+A*t.rawData[10]+y*t.rawData[14],i[7]=o*t.rawData[3]+c*t.rawData[7]+A*t.rawData[11]+y*t.rawData[15],i[8]=l*t.rawData[0]+f*t.rawData[4]+x*t.rawData[8]+b*t.rawData[12],i[9]=l*t.rawData[1]+f*t.rawData[5]+x*t.rawData[9]+b*t.rawData[13],i[10]=l*t.rawData[2]+f*t.rawData[6]+x*t.rawData[10]+b*t.rawData[14],i[11]=l*t.rawData[3]+f*t.rawData[7]+x*t.rawData[11]+b*t.rawData[15],i[12]=h*t.rawData[0]+d*t.rawData[4]+C*t.rawData[8]+B*t.rawData[12],i[13]=h*t.rawData[1]+d*t.rawData[5]+C*t.rawData[9]+B*t.rawData[13],i[14]=h*t.rawData[2]+d*t.rawData[6]+C*t.rawData[10]+B*t.rawData[14],i[15]=h*t.rawData[3]+d*t.rawData[7]+C*t.rawData[11]+B*t.rawData[15]}function nA(n,t){let e=t.x,r=t.y,i=t.z,a=t.w,o=n.rawData,l=2*e*r,h=2*e*i,u=2*e*a,c=2*r*i,f=2*r*a,d=2*i*a,p=e*e,A=r*r,x=i*i,C=a*a;return o[0]=p-A-x+C,o[4]=l-d,o[8]=h+f,o[12]=0,o[1]=l+d,o[5]=-p+A-x+C,o[9]=c-u,o[13]=0,o[2]=h-f,o[6]=c+u,o[10]=-p-A+x+C,o[14]=0,o[3]=0,o[7]=0,o[11]=0,o[15]=1,n}function lA(n,t){let e=t.rawData,r=Math.sin(n),i=Math.cos(n);return e[0]=i,e[1]=0,e[2]=-r,e[3]=0,e[8]=r,e[9]=0,e[10]=i,e[11]=0,e}function hA(n,t,e){let r=t.x,i=t.y,a=t.z,o=Math.hypot(r,i,a),l,h,u,c,f,d,p,A,x,C,v,y;if(o<bu)return null;o=1/o,r*=o,i*=o,a*=o,l=Math.sin(n),h=Math.cos(n),u=1-h,c=r*r*u+h,f=i*r*u+a*l,d=a*r*u-i*l,p=r*i*u-a*l,A=i*i*u+h,x=a*i*u+r*l,C=r*a*u+i*l,v=i*a*u-r*l,y=a*a*u+h;let b=e.rawData;return b[0]=c,b[1]=f,b[2]=d,b[3]=0,b[4]=p,b[5]=A,b[6]=x,b[7]=0,b[8]=C,b[9]=v,b[10]=y,b[11]=0,b[12]=0,b[13]=0,b[14]=0,b[15]=1,b}function Dn(n,t,e){let r=n.rawData,i=r[0],a=r[1],o=r[2],l=r[3],h=r[4],u=r[5],c=r[6],f=r[7],d=r[8],p=r[9],A=r[10],x=r[11],C=r[12],v=r[13],y=r[14],b=r[15],B=t.rawData,I=e.rawData,w=B[0],D=B[1],L=B[2],M=B[3];return I[0]=w*i+D*h+L*d+M*C,I[1]=w*a+D*u+L*p+M*v,I[2]=w*o+D*c+L*A+M*y,I[3]=w*l+D*f+L*x+M*b,w=B[4],D=B[5],L=B[6],M=B[7],I[4]=w*i+D*h+L*d+M*C,I[5]=w*a+D*u+L*p+M*v,I[6]=w*o+D*c+L*A+M*y,I[7]=w*l+D*f+L*x+M*b,w=B[8],D=B[9],L=B[10],M=B[11],I[8]=w*i+D*h+L*d+M*C,I[9]=w*a+D*u+L*p+M*v,I[10]=w*o+D*c+L*A+M*y,I[11]=w*l+D*f+L*x+M*b,w=B[12],D=B[13],L=B[14],M=B[15],I[12]=w*i+D*h+L*d+M*C,I[13]=w*a+D*u+L*p+M*v,I[14]=w*o+D*c+L*A+M*y,I[15]=w*l+D*f+L*x+M*b,I}var tt=(n=>(n[n.None=0]="None",n[n.PointLight=1]="PointLight",n[n.DirectionLight=2]="DirectionLight",n[n.SpotLight=3]="SpotLight",n[n.SkyLight=4]="SkyLight",n))(tt||{});class ns extends is{constructor(){super(...arguments);s(this,"index",-1);s(this,"lightType",-1);s(this,"radius",.001);s(this,"linear",8);s(this,"lightPosition",new g);s(this,"lightMatrixIndex",-1);s(this,"direction",new g);s(this,"quadratic",.032);s(this,"lightColor",new K(1,1,1,1));s(this,"intensity",1);s(this,"innerAngle",0);s(this,"outerAngle",1);s(this,"range",100);s(this,"castShadowIndex",-1);s(this,"lightTangent",g.FORWARD);s(this,"iesIndex",-1)}}s(ns,"lightSize",24);const fr=class fr{static init(){this._init||(this._init=!0,this.componentsUpdateList=new Map,this.componentsLateUpdateList=new Map,this.componentsBeforeUpdateList=new Map,this.componentsComputeList=new Map,this.componentsEnablePickerList=new Map,this.graphicComponent=new Map,this.waitStartComponent=new Map)}static bindUpdate(t,e,r){this.init();let i=this.componentsUpdateList.get(t);i||(i=new Map,this.componentsUpdateList.set(t,i)),i.set(e,r)}static unBindUpdate(t,e){this.init();let r=this.componentsUpdateList.get(t);r&&r.delete(e)}static bindLateUpdate(t,e,r){this.init();let i=this.componentsLateUpdateList.get(t);i||(i=new Map,this.componentsLateUpdateList.set(t,i)),i.set(e,r)}static unBindLateUpdate(t,e){this.init();let r=this.componentsLateUpdateList.get(t);r&&r.delete(e)}static bindBeforeUpdate(t,e,r){this.init();let i=this.componentsBeforeUpdateList.get(t);i||(i=new Map,this.componentsBeforeUpdateList.set(t,i)),i.set(e,r)}static unBindBeforeUpdate(t,e){this.init();let r=this.componentsBeforeUpdateList.get(t);r&&r.delete(e)}static bindCompute(t,e,r){this.init();let i=this.componentsComputeList.get(t);i||(i=new Map,this.componentsComputeList.set(t,i)),i.set(e,r)}static unBindCompute(t,e){this.init();let r=this.componentsComputeList.get(t);r&&r.delete(e)}static bindGraphic(t,e,r){this.init();let i=this.graphicComponent.get(t);i||(i=new Map,this.graphicComponent.set(t,i)),i.set(e,r)}static unBindGraphic(t,e){this.init();let r=this.graphicComponent.get(t);r&&r.delete(e)}static appendWaitStart(t){this.init();let e=this.waitStartComponent.get(t.object3D);e?e.indexOf(t)==-1&&e.push(t):this.waitStartComponent.set(t.object3D,[t])}static removeWaitStart(t,e){this.init();let r=fr.waitStartComponent.get(t);if(r){let i=r.indexOf(e);i!=-1&&r.splice(i)}}static bindEnablePick(t,e,r){this.init();let i=this.componentsEnablePickerList.get(t);i||(i=new Map,this.componentsEnablePickerList.set(t,i)),i.set(e,r)}static unBindEnablePick(t,e){this.init();let r=this.componentsEnablePickerList.get(t);r&&r.delete(e)}};s(fr,"componentsUpdateList"),s(fr,"componentsLateUpdateList"),s(fr,"componentsBeforeUpdateList"),s(fr,"componentsComputeList"),s(fr,"componentsEnablePickerList"),s(fr,"graphicComponent"),s(fr,"waitStartComponent"),s(fr,"_init",!1);let Te=fr;class Qt{constructor(){s(this,"object3D",null);s(this,"_eventDispatcher");s(this,"_enable",!0);s(this,"__isStart",!1);s(this,"isDestroyed",!1)}get eventDispatcher(){return this._eventDispatcher||(this._eventDispatcher=new ir),this._eventDispatcher}set eventDispatcher(t){console.error("The eventDispatcher should not be set externally!")}get isStart(){return this.__isStart}get transform(){return this.object3D.transform}set enable(t){var e,r;this._enable!=t&&(this._enable=t,this._enable?(e=this.onEnable)==null||e.call(this,this.transform.view3D):(r=this.onDisable)==null||r.call(this,this.transform.view3D))}get enable(){return this._enable}__init(t){this.init(t)}__start(){var t,e;this.transform&&this.transform.scene3D&&this._enable&&((t=this.onEnable)==null||t.call(this,this.transform.view3D)),this.transform&&this.transform.scene3D&&this.__isStart==!1&&((e=this.start)==null||e.call(this),this.__isStart=!0),this.onUpdate&&this._onUpdate(this.onUpdate.bind(this)),this.onLateUpdate&&this._onLateUpdate(this.onLateUpdate.bind(this)),this.onBeforeUpdate&&this._onBeforeUpdate(this.onBeforeUpdate.bind(this)),this.onCompute&&this._onCompute(this.onCompute.bind(this)),this.onGraphic&&this._onGraphic(this.onGraphic.bind(this))}__stop(){var t;this.transform&&this.transform.scene3D&&((t=this.onDisable)==null||t.call(this,this.transform.view3D)),this._onUpdate(null),this._onLateUpdate(null),this._onBeforeUpdate(null),this._onCompute(null),this._onGraphic(null)}init(t){}start(){}stop(){}cloneTo(t){}copyComponent(t){return this}_onUpdate(t){t!=null?Te.bindUpdate(this.transform.view3D,this,t):Te.unBindUpdate(this.transform.view3D,this)}_onLateUpdate(t){t!=null?Te.bindLateUpdate(this.transform.view3D,this,t):Te.unBindLateUpdate(this.transform.view3D,this)}_onBeforeUpdate(t){t!=null?Te.bindBeforeUpdate(this.transform.view3D,this,t):Te.unBindBeforeUpdate(this.transform.view3D,this)}_onCompute(t){t!=null?Te.bindCompute(this.transform.view3D,this,t):Te.unBindCompute(this.transform.view3D,this)}_onGraphic(t){t!=null?Te.bindGraphic(this.transform.view3D,this,t):Te.unBindGraphic(this.transform.view3D,this)}beforeDestroy(t){Te.removeWaitStart(this.object3D,this)}destroy(t){this.isDestroyed||(this.isDestroyed=!0,this.enable=!1,this.stop(),this._onBeforeUpdate(null),this._onUpdate(null),this._onLateUpdate(null),this.onEnable=null,this.onDisable=null,this.onUpdate=null,this.onLateUpdate=null,this.onBeforeUpdate=null,this.onCompute=null,this.onGraphic=null)}}class $s{constructor(){s(this,"value",0);s(this,"inv_base",0)}static get(t,e){let r=0,i=1/e;for(;t>0;)r+=t%e*i,t/=e,i/=e;return r}getBase(t,e){let r=this.inv_base=1/e;for(;t>0;)this.value+=r*(t%e),t/=e,r*=this.inv_base}next(){let t=1-this.value-1e-7;if(this.inv_base<t)this.value+=this.inv_base;else{let e=this.inv_base,r;do r=e,e*=this.inv_base;while(e>=t);this.value+=r+e-1}}get(){return this.value}}const zr=class zr{constructor(t,e){s(this,"origin",new g);s(this,"length",Number.MAX_VALUE);s(this,"_vector",new g);s(this,"_dir",new g);s(this,"_v0",new g);s(this,"_v1",new g);s(this,"_v2",new g);s(this,"_E1",new g);s(this,"_E2",new g);s(this,"_P",new g);s(this,"_T",new g);s(this,"_Q",new g);this.origin.copyFrom(t||new g),this._dir.copyFrom(e||new g),this._dir.normalize()}get direction(){return this._dir}set direction(t){this._dir.copyFrom(t),this._dir.normalize()}clone(){return new zr(this.origin,this.direction)}intersectBox(t,e){let r=this.direction,i=this.origin,a,o,l,h,u,c;const f=1/r.x,d=1/r.y,p=1/r.z,A=t.min,x=t.max;return a=((f>=0?A.x:x.x)-i.x)*f,o=((f>=0?x.x:A.x)-i.x)*f,l=((d>=0?A.y:x.y)-i.y)*d,h=((d>=0?x.y:A.y)-i.y)*d,a>h||l>o||(l>a&&(a=l),h<o&&(o=h),u=((p>=0?A.z:x.z)-i.z)*p,c=((p>=0?x.z:A.z)-i.z)*p,a>c||u>o)||(u>a&&(a=u),c<o&&(o=c),o<0)?null:(e||(e=new g),this.pointAt(a>=0?a:o,e))}pointAt(t,e){return e||(e=new g),e.copy(this.direction),e.multiplyScalar(t),e.add(this.origin,e),e}copy(t){return this.origin.copy(t.origin),this.direction.copy(t.direction),this._dir.copy(t._dir),this.length=t.length,this}setApproxDirection(t){this._dir=t.normalize()}setOrigin(t){this.origin.copyFrom(t)}getOrigin(){return this.origin}getPoint(t){return this._dir.scaleBy(t),this.origin.add(this._dir)}sqrDistToPoint(t){let e=this._dir,r=t.subtract(this.origin),i=St(r,e),a=St(e,e),o=i/a,l=this.getPoint(o);return En(t.subtract(l))}applyMatrix(t){this.origin=t.transformPoint(this.origin),this._dir=t.transformVector(this._dir)}pointInTriangle(t,e,r,i){let a=this._v0,o=this._v1,l=this._v2;i.subtract(e,a),r.subtract(e,o),t.subtract(e,l);let h=g.dot(a,a),u=g.dot(a,o),c=g.dot(a,l),f=g.dot(o,o),d=g.dot(o,l),p=1/(h*f-u*u),A=(f*c-u*d)*p,x=(h*d-u*c)*p;return A>=0&&x>=0&&A+x<1}intersectTriangle(t,e,r){let i=r.v1,a=r.v2,o=r.v3;a.subtract(i,this._E1),o.subtract(i,this._E2),e.crossProduct(this._E2,this._P);let l=this._E1.dotProduct(this._P);if(l>0?t.subtract(i,this._T):(i.subtract(t,this._T),l=-l),l<1e-4||(r.u=this._T.dotProduct(this._P),r.u<0||r.u>l)||(this._T.crossProduct(this._E1,this._Q),r.v=e.dotProduct(this._Q),r.v<0||r.u+r.v>l))return null;let h=new g;r.t0=r.t=this._E2.dotProduct(this._Q);let u=1/l;return r.t*=u,r.u*=u,r.v*=u,h.x=t.x+r.t*e.x,h.y=t.y+r.t*e.y,h.z=t.z+r.t*e.z,h}intersectSphere(t,e,r,i){let a=t.subtract(r),o=g.dot(e,e),l=2*g.dot(a,e),h=g.dot(a,a)-i*i,u=l*l-4*o*h,c=g.HELP_3;if(u<0)return null;{let f=(-l-Math.sqrt(u))/(o*2);return f<0?null:(c.x=t.x+f*e.x,c.y=t.y+f*e.y,c.z=t.z+f*e.z,c)}}intersectionSegment(t,e,r){const i=this.origin,a=g.HELP_0,o=g.HELP_1,l=g.HELP_2,h=g.HELP_3;e.subtract(t,a),this._dir.scaleToRef(zr._rayl,l),i.add(l,o),t.subtract(i,h);var u=g.dot(a,a),c=g.dot(a,l),f=g.dot(l,l),d=g.dot(a,h),p=g.dot(l,h),A=u*f-c*c,x,C,v=A,y,b,B=A;A<zr._smallnum?(C=0,v=1,b=p,B=f):(C=c*p-f*d,b=u*p-c*d,C<0?(C=0,b=p,B=f):C>v&&(C=v,b=p+c,B=f)),b<0?(b=0,-d<0?C=0:-d>u?C=v:(C=-d,v=u)):b>B&&(b=B,-d+c<0?C=0:-d+c>u?C=v:(C=-d+c,v=u)),x=Math.abs(C)<zr._smallnum?0:C/v,y=Math.abs(b)<zr._smallnum?0:b/B;const I=g.HELP_4;l.scaleToRef(y,I);const w=g.HELP_5;a.scaleToRef(x,w),w.add(h,w);const D=g.HELP_6;w.subtract(I,D);var L=y>0&&y<=this._dir.length&&D.lengthSquared<r*r;if(L){let M=new g;return M.copyFrom(e.subtract(t)),M.scaleBy(x),M.add(t,M),{out:M,length:w.length}}return{out:null,length:-1}}get_vec(t,e){let r=g.HELP_1;return r.x=t.x-e.x,r.y=t.y-e.y,r.z=t.z-e.z,r}};s(zr,"_rayl",1e9),s(zr,"_smallnum",1e-8);let mi=zr;class ls{constructor(t=0,e=0,r=0,i=0){s(this,"x");s(this,"y");s(this,"w");s(this,"h");this.x=t,this.y=e,this.w=r,this.h=i}get width(){return this.w}set width(t){this.w=t}get height(){return this.h}set height(t){this.h=t}static pointInRect(t,e,r,i,a,o){return!(t<r||t>a||e<i||e>o)}clone(){return new ls(this.x,this.y,this.w,this.h)}copyFrom(t){this.x=t.x,this.y=t.y,this.w=t.w,this.h=t.h}copyTo(t){t.copyFrom(this)}inner(t,e){return!(t<this.x||t>this.x+this.width||e<this.y||e>this.y+this.height)}equal(t){return!(this.x!=t.x||this.y!=t.y||this.width!=t.width||this.height!=t.height)}equalArea(t,e,r,i){return!(this.x!=t||this.y!=e||this.width!=r||this.height!=i)}equalInnerArea(t){var e=this.x,r=this.y,i=this.x+this.width,a=this.y+this.height,o=t.x,l=t.y,h=t.x+t.width,u=t.y+t.height;return Math.max(e,o)<=Math.min(i,h)&&Math.max(r,l)<=Math.min(a,u)}innerArea(t,e){e=e||new ls;var r=this.x,i=this.y,a=this.x+this.width,o=this.y+this.height,l=t.x,h=t.y,u=t.x+t.width,c=t.y+t.height,f=Math.max(i,h),d=Math.min(o,c),p=Math.max(r,l),A=Math.min(u,a);return f>=0&&d>=0&&d-f>=0&&A-p>0?(e.x=p,e.y=f,e.width=A-p,e.height=d-f):(e.x=0,e.y=0,e.width=0,e.height=0),e}setTo(t,e,r,i){this.x=t,this.y=e,this.width=r,this.height=i}}const ai=class ai{constructor(t,e){s(this,"center");s(this,"extents");s(this,"max");s(this,"min");s(this,"size");t||(t=g.ZERO.clone()),e||(e=g.ZERO.clone()),this.setFromCenterAndSize(t,e)}makeEmpty(){return this.setFromMinMax(ai.maxVector3,ai.minVector3),this}setFromMinMax(t,e){return this.init(),e.subtract(t,this.size),t.add(e,this.center).multiplyScalar(.5),this.extents.copyFrom(this.size).multiplyScalar(.5),this.min.copyFrom(t),this.max.copyFrom(e),this}init(){return this.min||(this.min=new g),this.max||(this.max=new g),this.size||(this.size=new g),this.center||(this.center=new g),this.extents||(this.extents=new g),this}setFromCenterAndSize(t,e){return this.size=e,this.center=t,this.init(),this.extents.copy(e).multiplyScalar(.5),this.center.subtract(this.extents,this.min),this.center.add(this.extents,this.max),this}inFrustum(t,e){return e.containsBox(t.bound)}merge(t){t.min.x<this.min.x&&(this.min.x=t.min.x),t.min.y<this.min.y&&(this.min.y=t.min.y),t.min.z<this.min.z&&(this.min.z=t.min.z),t.max.x>this.max.x&&(this.max.x=t.max.x),t.max.y>this.max.y&&(this.max.y=t.max.y),t.max.z>this.max.z&&(this.max.z=t.max.z),this.size.x=t.max.x-t.min.x,this.size.y=t.max.y-t.min.y,this.size.z=t.max.z-t.min.z,this.extents.x=this.size.x*.5,this.extents.y=this.size.y*.5,this.extents.z=this.size.z*.5,this.center.x=this.extents.x+t.min.x,this.center.y=this.extents.y+t.min.y,this.center.z=this.extents.z+t.min.z}intersects(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.min.y<=t.max.y&&this.max.y>=t.min.y&&this.min.z<=t.max.z&&this.max.z>=t.min.z}intersectsSphere(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.min.y<=t.max.y&&this.max.y>=t.min.y&&this.min.z<=t.max.z&&this.max.z>=t.min.z}intersectsBox(t){return this.min.x<=t.max.x&&this.max.x>=t.min.x&&this.min.y<=t.max.y&&this.max.y>=t.min.y&&this.min.z<=t.max.z&&this.max.z>=t.min.z}equals(t){return this.center.equals(t.center)&&this.extents.equals(t.extents)}expandByPoint(t){t.x<this.min.x&&(this.min.x=t.x),t.x>this.max.x&&(this.max.x=t.x),t.y<this.min.y&&(this.min.y=t.y),t.y>this.max.y&&(this.max.y=t.y),t.z<this.min.z&&(this.min.z=t.z),t.z>this.max.z&&(this.max.z=t.z)}static fromPoints(t){for(var e=new ai(new g,new g),r=0;r<t.length;r++)e.expandByPoint(t[r]);return e}calculateTransform(t){}clone(){var t=new ai(this.center.clone(),this.size.clone());return t}intersectsRay(t,e){throw new Error("Method not implemented.")}containsPoint(t){return this.min.x<=t.x&&this.max.x>=t.x&&this.min.y<=t.y&&this.max.y>=t.y&&this.min.z<=t.z&&this.max.z>=t.z}containsBox(t){let e=this.min,r=this.max;return e.x<=t.min.x&&e.y<=t.min.y&&e.z<=t.min.z&&r.x>=t.max.x&&r.y>=t.max.y&&r.z>=t.max.z}updateBound(){}destroy(t){this.center=null,this.extents=null,this.min=null,this.max=null,this.size=null}};s(ai,"maxVector3",new g(1,1,1).multiplyScalar(Number.MAX_VALUE*.1)),s(ai,"minVector3",new g(1,1,1).multiplyScalar(-Number.MAX_VALUE*.1));let Oe=ai;class Eu{constructor(){s(this,"planes");s(this,"corners");s(this,"boundingBox",new Oe);this.planes=[],this.corners=[];for(var t=0;t<6;t++)this.planes[t]=new g;for(var t=0;t<2*2*2;t++)this.corners[t]=new g}updateBoundBox(t){this.boundingBox.makeEmpty();let e=this.boundingBox.min,r=this.boundingBox.max,i=0;for(let a=0;a<2;++a)for(let o=0;o<2;++o)for(let l=0;l<2;++l){let h=this.corners[i];i++,h.set(2*a-1,2*o-1,l,1),t.transformVector4(h,h),h.div(h.w,h),e.x=Math.min(h.x,e.x),e.y=Math.min(h.y,e.y),e.z=Math.min(h.z,e.z),r.x=Math.max(h.x,r.x),r.y=Math.max(h.y,r.y),r.z=Math.max(h.z,r.z)}return this.boundingBox.setFromMinMax(e,r),this}setFrustumCorners(t){let e=0;for(let r=0;r<2;++r)for(let i=0;i<2;++i)for(let a=0;a<2;++a){let o=this.corners[e];o.set(2*r-1,2*i-1,a,1),t.transformVector4(o,o),o.div(o.w,o),e++}}update(t){var e=t.rawData;this.planes[0].x=e[3]-e[0],this.planes[0].y=e[7]-e[4],this.planes[0].z=e[11]-e[8],this.planes[0].w=e[15]-e[12];var r=Math.sqrt(this.planes[0].x*this.planes[0].x+this.planes[0].y*this.planes[0].y+this.planes[0].z*this.planes[0].z);this.planes[0].x/=r,this.planes[0].y/=r,this.planes[0].z/=r,this.planes[0].w/=r,this.planes[1].x=e[3]+e[0],this.planes[1].y=e[7]+e[4],this.planes[1].z=e[11]+e[8],this.planes[1].w=e[15]+e[12],r=Math.sqrt(this.planes[1].x*this.planes[1].x+this.planes[1].y*this.planes[1].y+this.planes[1].z*this.planes[1].z),this.planes[1].x/=r,this.planes[1].y/=r,this.planes[1].z/=r,this.planes[1].w/=r,this.planes[2].x=e[3]+e[1],this.planes[2].y=e[7]+e[5],this.planes[2].z=e[11]+e[9],this.planes[2].w=e[15]+e[13],r=Math.sqrt(this.planes[2].x*this.planes[2].x+this.planes[2].y*this.planes[2].y+this.planes[2].z*this.planes[2].z),this.planes[2].x/=r,this.planes[2].y/=r,this.planes[2].z/=r,this.planes[2].w/=r,this.planes[3].x=e[3]-e[1],this.planes[3].y=e[7]-e[5],this.planes[3].z=e[11]-e[9],this.planes[3].w=e[15]-e[13],r=Math.sqrt(this.planes[3].x*this.planes[3].x+this.planes[3].y*this.planes[3].y+this.planes[3].z*this.planes[3].z),this.planes[3].x/=r,this.planes[3].y/=r,this.planes[3].z/=r,this.planes[3].w/=r,this.planes[4].x=e[3]-e[2],this.planes[4].y=e[7]-e[6],this.planes[4].z=e[11]-e[10],this.planes[4].w=e[15]-e[14],r=Math.sqrt(this.planes[4].x*this.planes[4].x+this.planes[4].y*this.planes[4].y+this.planes[4].z*this.planes[4].z),this.planes[4].x/=r,this.planes[4].y/=r,this.planes[4].z/=r,this.planes[4].w/=r,this.planes[5].x=e[3]+e[2],this.planes[5].y=e[7]+e[6],this.planes[5].z=e[11]+e[10],this.planes[5].w=e[15]+e[14],r=Math.sqrt(this.planes[5].x*this.planes[5].x+this.planes[5].y*this.planes[5].y+this.planes[5].z*this.planes[5].z),this.planes[5].x/=r,this.planes[5].y/=r,this.planes[5].z/=r,this.planes[5].w/=r}containsPoint(t){for(var e=0;e<6;e++)if(this.planes[e].x*t.x+this.planes[e].y*t.y+this.planes[e].z*t.z+this.planes[e].w<=0)return!1;return!0}containsSphere(t){let e=t.bound,r=0,i,a=t.transform.worldPosition,o=e.radius,l=e.center.x+a.x,h=e.center.y+a.y,u=e.center.z+a.z;for(let c of this.planes){if(i=c.x*l+c.y*h+c.z*u+c.w,i<=-o)return 0;i>o&&r++}return r===6?2:1}containsBox(t){let e=0,r,i=Math.max(t.size.x,t.size.y,t.size.z)*2,a=t.center.x,o=t.center.y,l=t.center.z;for(let h of this.planes){if(r=h.x*a+h.y*o+h.z*l+h.w,r<=-i)return 0;r>i&&e++}return e===6?2:1}containsBox2(t){let e=0,r,i=1.74*Math.max(t.extents.x,t.extents.y,t.extents.z);for(let a of this.planes){if(r=a.x*t.center.x+a.y*t.center.y+a.z*t.center.z+a.w,r<=-i)return 0;r>i&&e++}return e===6?2:1}}var qe=(n=>(n[n.ortho=0]="ortho",n[n.perspective=1]="perspective",n[n.shadow=2]="shadow",n))(qe||{});class Bu{constructor(t){s(this,"corners");s(this,"index");this.index=t,this.corners=[];for(let e=0;e<4;e++)this.corners.push(new g)}}class Du{constructor(t,e,r){s(this,"bound");s(this,"twoSections");s(this,"name");s(this,"color");s(this,"shadowCamera");s(this,"index");this.bound=new Oe,this.shadowCamera=rt.createCamera3DObject(null,"csmShadowCamera_"+r),this.shadowCamera.isShadowCamera=!0,this.shadowCamera.orthoOffCenter(100,-100,100,-100,1,1e4),this.twoSections=[t,e],this.index=r,r==0?this.color=new K(1,0,0,1):r==1?this.color=new K(0,1,0,1):r==2?this.color=new K(0,0,1,1):r==3&&(this.color=new K(0,1,1,1)),this.name="child_"+r}updateBound(){this.bound.makeEmpty();let t=this.bound.min,e=this.bound.max;for(let r of this.twoSections)for(let i of r.corners)t.x=Math.min(i.x,t.x),t.y=Math.min(i.y,t.y),t.z=Math.min(i.z,t.z),e.x=Math.max(i.x,e.x),e.y=Math.max(i.y,e.y),e.z=Math.max(i.z,e.z);return this.bound.setFromMinMax(t,e),this}}class Mu{constructor(t){s(this,"sections");s(this,"children");s(this,"name");this.sections=[];let e=t+1;for(let r=0;r<e;r++)this.sections.push(new Bu(r));this.children=[];for(let r=0;r<t;r++)this.children.push(new Du(this.sections[r],this.sections[r+1],r))}update(t,e,r,i,a){let o=this.sections.length-1;for(let l=0;l<=o;++l){let h=this.sections[l],u=0,c=this.logSplit(r,i,l,this.sections.length);{let d=(c-r)/i;d=Ks(d,a.csmScatteringExp),c=(i-r)*d+r}c*=a.csmAreaScale;let f=(t.rawData[10]*c+t.rawData[14])/c;for(let d=0;d<2;++d)for(let p=0;p<2;++p){let A=h.corners[u];u++,A.set(2*d-1,2*p-1,f,1),e.transformVector4(A,A),A.div(A.w,A)}}for(let l of this.children)l.updateBound();return this}squareSplit(t,e,r,i){return Ks(r/(i-1),4)*(e-t)+t}uniformSplit(t,e,r,i){return r/(i-1)*(e-t)+t}logSplit(t,e,r,i){return t*Ks(e/t,r/(i-1))}}class Fi extends Qt{constructor(){super();s(this,"fov",60);s(this,"name");s(this,"aspect",1);s(this,"near",1);s(this,"far",5e3);s(this,"left",-100);s(this,"right",100);s(this,"top",100);s(this,"bottom",-100);s(this,"frustumSize",0);s(this,"frustumDepth",0);s(this,"viewPort",new ls);s(this,"frustum");s(this,"sh",new Float32Array(36));s(this,"isShadowCamera",!1);s(this,"_projectionMatrixInv",new Q);s(this,"_projectionMatrix",new Q);s(this,"_viewMatrix",new Q);s(this,"_viewMatrixInv",new Q);s(this,"_unprojection",new Q);s(this,"_pvMatrixInv",new Q);s(this,"_pvMatrix",new Q);s(this,"_halfw");s(this,"_halfh");s(this,"_ray");s(this,"_enableCSM",!1);s(this,"mainCamera");s(this,"lookTarget");s(this,"type",qe.perspective);s(this,"csm");s(this,"cubeShadowCameras",[]);s(this,"_haltonSeq");s(this,"_jitterOffsetList");s(this,"_useJitterProjection",!1);s(this,"_jitterFrameIndex",0);s(this,"_sampleIndex",0);s(this,"_jitterX",0);s(this,"_jitterY",0);s(this,"_jitterOffsetX");s(this,"_jitterOffsetY")}get projectionMatrix(){return this._projectionMatrix}get enableCSM(){return this._enableCSM}set enableCSM(e){e&&!this.csm&&(this.csm=new Mu(nr.Cascades)),this._enableCSM=e}init(){super.init(),this._ray=new mi,this.frustum=new Eu,this.lookTarget=new g(0,0,0),this.viewPort.x=0,this.viewPort.y=0,this.viewPort.w=E.presentationSize[0],this.viewPort.h=E.presentationSize[1],this.updateProjection(),E.addEventListener(Wr.RESIZE,this.updateProjection,this)}updateProjection(){this.aspect=E.aspect,this.type==qe.perspective?this.perspective(this.fov,this.aspect,this.near,this.far):this.type==qe.ortho&&(this.frustumSize&&this.frustumDepth?this.ortho(this.frustumSize,this.frustumDepth):this.frustumSize?this.ortho2(this.frustumSize,this.near,this.far):this.orthoOffCenter(this.left,this.right,this.bottom,this.top,this.near,this.far))}getShadowBias(e){let r=2*this.getShadowWorldExtents()/e,i=this.far-this.near;return r/i-m.setting.shadow.shadowBias*.01}getShadowWorldExtents(){let e=m.setting.shadow.shadowBound;return e?e*=.5:e=Math.round(.05*this.frustum.boundingBox.extents.length),e}getCSMShadowBiasScale(e){if(e==this)return 1;let r=this.far-this.near,i=this.csm.children[0].shadowCamera;return(i.far-i.near)/r}getCSMShadowWorldExtents(e){return Math.round(this.csm.children[e].bound.extents.length)}perspective(e,r,i,a){this.fov=e,this.aspect=r,this.near=Math.max(.001,i),this.far=a,this._projectionMatrix.perspective(this.fov,this.aspect,this.near,this.far),this.type=qe.perspective,this._useJitterProjection&&(this._jitterOffsetX=this._projectionMatrix.get(0,2),this._jitterOffsetY=this._projectionMatrix.get(1,2))}ortho(e,r){this.frustumSize=e,this.frustumDepth=r;let i=e*this.aspect,a=e,o=-i/2,l=i/2,h=a/2,u=-a/2,c=g.distance(this.object3D.localPosition,this.lookTarget),f=c-r,d=c+r;this.orthoOffCenter(o,l,u,h,f,d)}ortho2(e,r,i){this.frustumSize=e;let a=e*this.aspect,o=e,l=-a/2,h=a/2,u=o/2,c=-o/2;this.orthoOffCenter(l,h,c,u,r,i)}orthoOffCenter(e,r,i,a,o,l){this.near=o,this.far=l,this.left=e,this.right=r,this.top=a,this.bottom=i,this.type=qe.ortho,this._projectionMatrix.orthoOffCenter(this.left,this.right,this.bottom,this.top,this.near,this.far),this._useJitterProjection&&(this._jitterOffsetX=this._projectionMatrix.get(0,2),this._jitterOffsetY=this._projectionMatrix.get(1,2))}get viewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.invert(),this._viewMatrix}get shadowViewMatrix(){return this._viewMatrix.copyFrom(this.transform.worldMatrix),this._viewMatrix.appendScale(1,1,1),this._viewMatrix.invert(),this._viewMatrix}object3DToScreenRay(e,r=null){return r||(r=new g(0,0,0,1)),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5,yt.transformVector(this.viewMatrix,e,r),this.project(r,r),r.x=this._halfw+r.x*this._halfw,r.y=this.viewPort.height-(this._halfh-r.y*this._halfh),r}screenRayToObject3D(e,r=null){r||(r=new g),this._halfw=this.viewPort.width*.5,this._halfh=this.viewPort.height*.5;let i=e.x,a=e.y;return r.x=i/this.viewPort.width-.25,r.y=a/this.viewPort.height-.25,this.unProject(r.x,r.y,e.z,r),r}get pvMatrix(){return Dn(this._projectionMatrix,this.viewMatrix,this._pvMatrix),this._pvMatrix}get pvMatrix2(){Dn(this._projectionMatrix,this.transform.worldMatrix,this._pvMatrix);let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get pvMatrixInv(){let e=this._pvMatrixInv.copyFrom(this.pvMatrix);return e.invert(),e}get vMatrixInv(){let e=this._viewMatrixInv.copyFrom(this.viewMatrix);return e.invert(),e}get cameraToWorld(){let e=Q.helpMatrix;return e.identity(),e.copyFrom(this.projectionMatrixInv),e.multiply(this.vMatrixInv),e}get ndcToView(){let e=Q.helpMatrix;return e.identity(),e.copyFrom(this.projectionMatrixInv),e}get projectionMatrixInv(){return this._projectionMatrixInv.copyFrom(this._projectionMatrix),this._projectionMatrixInv.invert(),this._projectionMatrixInv}unProject(e,r,i,a){return a||(a=new g),a.x=e,a.y=-r,a.z=i,a.w=1,a.x*=i,a.y*=i,this._unprojection.copyFrom(this._projectionMatrix),this._unprojection.invert(),yt.transformVector(this._unprojection,a,a),a.z=i,a}project(e,r){return this._projectionMatrix.perspectiveMultiplyPoint3(e,r),r.x=r.x/r.w,r.y=-r.y/r.w,r.z=e.z,r}screenPointToRay(e,r){let i=this._ray,a=rt.UnProjection(e,r,.01,this),o=rt.UnProjection(e,r,1,this);return o=o.subtract(a).normalize(),i.origin.copyFrom(a),i.direction=o,i}screenPointToWorld(e,r,i){return rt.UnProjection(e,r,i,this)}worldToScreenPoint(e,r){return rt.Projection(e,this,r)}lookAt(e,r,i=g.Y_AXIS){this.transform.lookAt(e,r,i),r&&this.lookTarget.copyFrom(r)}onUpdate(){var r;this._useJitterProjection&&this.getJitteredProjectionMatrix(),this.frustum.update(this.pvMatrix),this.frustum.updateBoundBox(this.pvMatrixInv);let e=m.setting.shadow;this.enableCSM&&((r=this.csm)==null||r.update(this._projectionMatrix,this._pvMatrixInv,this.near,this.far,e))}get jitterFrameIndex(){return this._jitterFrameIndex}get jitterX(){return this._jitterX}get jitterY(){return this._jitterY}enableJitterProjection(e){this._jitterFrameIndex=0,this._useJitterProjection=e,this._haltonSeq||(this._haltonSeq=new $s),this._jitterOffsetList=[];for(let r=0;r<32;r++){let i=this.generateRandomOffset();this._jitterOffsetList.push(i)}this._jitterOffsetList.reverse()}generateRandomOffset(){let e=new he($s.get((this._sampleIndex&1023)+1,2)-.5,$s.get((this._sampleIndex&1023)+1,3)-.5);return++this._sampleIndex>=32&&(this._sampleIndex=0),e}getJitteredProjectionMatrix(){let e=m.setting.render.postProcessing.taa,r=e.temporalJitterScale,i=this._jitterFrameIndex%e.jitterSeedCount,a=this._jitterOffsetList[i].x*r,o=this._jitterOffsetList[i].y*r;this._jitterX=a/this.viewPort.width,this._jitterY=o/this.viewPort.height,(!this._jitterOffsetX||!this._jitterOffsetY)&&(this._jitterOffsetX=this._projectionMatrix.get(0,2),this._jitterOffsetY=this._projectionMatrix.get(1,2));let l=this._jitterOffsetX+this._jitterX,h=this._jitterOffsetY+this._jitterY;this._projectionMatrix.set(0,2,l),this._projectionMatrix.set(1,2,h),this._jitterFrameIndex++}getWorldDirection(e){e||(e=new g);const r=this.transform._worldMatrix.rawData;return e.set(-r[8],-r[9],-r[10]).normalize()}}const pt=class pt extends Qt{constructor(){super();s(this,"eventPositionChange",new lt(pt.POSITION_ONCHANGE));s(this,"eventRotationChange",new lt(pt.ROTATION_ONCHANGE));s(this,"eventScaleChange",new lt(pt.SCALE_ONCHANGE));s(this,"eventLocalChange",new lt(pt.LOCAL_ONCHANGE));s(this,"onPositionChange");s(this,"onRotationChange");s(this,"onScaleChange");s(this,"_scene3d");s(this,"_parent");s(this,"_localPos");s(this,"_localRot");s(this,"_localRotQuat");s(this,"_localScale");s(this,"_localDetailPos");s(this,"_localDetailRot");s(this,"_localDetailScale");s(this,"index");s(this,"index2");s(this,"_forward",new g);s(this,"_back",new g);s(this,"_right",new g);s(this,"_left",new g);s(this,"_up",new g);s(this,"_down",new g);s(this,"_worldMatrix");s(this,"_targetPos");s(this,"static",!1);s(this,"depthOrder",0);this._worldMatrix=new Q(!0),this.index=this._worldMatrix.index,this.index2=this._worldMatrix.index*Se.stateStruct,this._localPos=new g,this._localRot=new g,this._localRotQuat=new Z,this._localScale=new g(1,1,1),Se.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),Se.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),Se.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z)}get localChange(){return Se.matrixStateBuffer[this.index2]!=0}set localChange(e){Se.matrixStateBuffer[this.index2]=e?1:0}get targetPos(){return this._targetPos}set targetPos(e){this._targetPos=e}get parent(){return this._parent}set parent(e){var i;let r=(i=this._parent)==null?void 0:i.object3D;if(this._parent=e,this.depthOrder=e?e.depthOrder+1:0,Se.setParent(this.index,e?e.worldMatrix.index:-1,this.depthOrder),this.localChange=!0,this.object3D){let a=e?e.scene3D:null;a?(this._scene3d=a,this.object3D.components.forEach(o=>{Te.appendWaitStart(o)})):this.object3D.components.forEach(o=>{o.__stop()});for(let o of this.object3D.entityChildren)o.transform.parent=e?this:null;this.object3D.components.forEach(o=>{var l,h;(h=o.onParentChange)==null||h.call(o,r,(l=this._parent)==null?void 0:l.object3D)})}this.notifyLocalChange()}set enable(e){this.transform._scene3d&&e?super.enable=!0:super.enable=!1;for(let r of this.object3D.entityChildren)r.transform.enable=e}get enable(){return this._enable}get scene3D(){return this._scene3d}set scene3D(e){this._scene3d=e}get view3D(){return this._scene3d&&this._scene3d.view?this._scene3d.view:null}awake(){}start(){}stop(){}notifyLocalChange(){if(this.localChange=!0,this.object3D){let e=this.object3D.entityChildren,r=0,i=e.length;for(r=0;r<i;r++)e[r].transform.notifyLocalChange()}this.eventDispatcher.dispatchEvent(this.eventLocalChange)}get up(){return this.worldMatrix.transformVector(g.UP,this._up),this._up}set up(e){this._up.copyFrom(e),yt.fromToRotation(g.UP,this._up,Z.HELP_0),this.transform.localRotQuat=Z.HELP_0}get down(){return this.worldMatrix.transformVector(g.DOWN,this._down),this._down}set down(e){var r;this._down.copyFrom(e),yt.fromToRotation(g.DOWN,this._down,Z.HELP_0),this.transform.localRotQuat=Z.HELP_0,this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get forward(){return this.worldMatrix.transformVector(g.FORWARD,this._forward),this._forward}set forward(e){var r;this._forward.copyFrom(e),yt.fromToRotation(g.FORWARD,this._forward,Z.HELP_0),this.transform.localRotQuat=Z.HELP_0,this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get back(){return this.worldMatrix.transformVector(g.BACK,this._back),this._back}set back(e){this._back.copyFrom(e),yt.fromToRotation(g.BACK,this._back,Z.HELP_0),this.transform.localRotQuat=Z.HELP_0}get left(){return this.worldMatrix.transformVector(g.neg_X_AXIS,this._left),this._left}set left(e){this._left.copyFrom(e),yt.fromToRotation(g.LEFT,this._left,Z.HELP_0),this.transform.localRotQuat=Z.HELP_0}get right(){return this.worldMatrix.transformVector(g.X_AXIS,this._right),this._right}set right(e){var r;this._right.copyFrom(e),yt.fromToRotation(g.RIGHT,this._right,Z.HELP_0),this.transform.localRotQuat=Z.HELP_0,this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotQuat(){return this.localChange&&this.updateWorldMatrix(),this._localRotQuat}set localRotQuat(e){var r;(e.x!=this._localRotQuat.x||e.y!=this._localRotQuat.y||e.z!=this._localRotQuat.z||e.w!=this._localRotQuat.w)&&(this._localRotQuat.copyFrom(e),this._localRotQuat.getEulerAngles(this._localRot),Se.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}notifyChange(){var e,r,i;this.notifyLocalChange(),(e=this.onRotationChange)==null||e.call(this),(r=this.onScaleChange)==null||r.call(this),(i=this.onPositionChange)==null||i.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get worldMatrix(){return this.updateWorldMatrix(),this._worldMatrix}updateWorldMatrix(e=!1){(this.localChange||e)&&(this.parent?(Zs(this._localRot,this._localPos,this._localScale,this._worldMatrix),Tu(this._worldMatrix,this.parent.worldMatrix,this._worldMatrix)):Zs(this._localRot,this._localPos,this._localScale,this._worldMatrix),this.localChange=!1)}updateChildTransform(){let e=this;if(e.localChange&&e.updateWorldMatrix(),e.object3D.numChildren>0)for(const r of e.object3D.entityChildren)r.transform.updateChildTransform()}lookTarget(e,r=g.UP){this.lookAt(this.transform.worldPosition,e,r)}lookAt(e,r,i=g.UP){this._targetPos||(this._targetPos=new g),this._targetPos.copyFrom(r),this.localPosition=e,Q.helpMatrix.lookAt(e,r,i),Q.helpMatrix.invert();var a=Q.helpMatrix.decompose(Gt.QUATERNION);this.localRotQuat=Z.CALCULATION_QUATERNION.copyFrom(a[1])}decomposeFromMatrix(e,r="eulerAngles"){let i=e.decompose(r),a=this.transform;return a.localRotQuat.copyFrom(i[1]),a.localRotQuat=a.localRotQuat,a.localPosition.copyFrom(i[0]),a.localPosition=a.localPosition,a.localScale.copyFrom(i[2]),a.localScale=a.localScale,this}cloneTo(e){e.transform.localPosition=this.localPosition,e.transform.localRotation=this.localRotation,e.transform.localScale=this.localScale}set x(e){var r;this._localPos.x!=e&&(this._localPos.x=e,Se.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(r=this.onPositionChange)==null||r.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get x(){return this._localPos.x}set y(e){var r;this._localPos.y!=e&&(this._localPos.y=e,Se.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(r=this.onPositionChange)==null||r.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get y(){return this._localPos.y}set z(e){var r;this._localPos.z!=e&&(this._localPos.z=e,Se.setTranslate(this.index,this._localPos.x,this._localPos.y,this._localPos.z),this.notifyLocalChange(),(r=this.onPositionChange)==null||r.call(this),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange))}get z(){return this._localPos.z}set scaleX(e){var r;this._localScale.x!=e&&(this._localScale.x=e,Se.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(r=this.onScaleChange)==null||r.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleX(){return this._localScale.x}set scaleY(e){var r;this._localScale.y!=e&&(this._localScale.y=e,Se.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(r=this.onScaleChange)==null||r.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleY(){return this._localScale.y}set scaleZ(e){var r;this._localScale.z!=e&&(this._localScale.z=e,Se.setScale(this.index,this._localScale.x,this._localScale.y,this._localScale.z),this.notifyLocalChange(),(r=this.onScaleChange)==null||r.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange))}get scaleZ(){return this._localScale.z}set rotationX(e){var r;this._localRot.x!=e&&(this._localRot.x=e,Se.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationX(){return this._localRot.x}set rotationY(e){var r;this._localRot.y!=e&&(this._localRot.y=e,Se.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationY(){return this._localRot.y}set rotationZ(e){var r;this._localRot.z!=e&&(this._localRot.z=e,Se.setRotation(this.index,this._localRot.x,this._localRot.y,this._localRot.z),this.notifyLocalChange(),(r=this.onRotationChange)==null||r.call(this),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange))}get rotationZ(){return this._localRot.z}get worldPosition(){return this.localChange&&this.updateWorldMatrix(),this._worldMatrix.position}set localPosition(e){this.onPositionChange&&(this._localPos.x!=e.x||this._localPos.y!=e.y||this._localPos.z!=e.z)&&this.onPositionChange(this._localPos,e),this._localPos.copyFrom(e),Se.setTranslate(this.index,e.x,e.y,e.z),this.notifyLocalChange(),this.eventPositionChange&&this.eventDispatcher.dispatchEvent(this.eventPositionChange)}get localPosition(){return this._localPos}set localRotation(e){this.onRotationChange&&(this._localRot.x!=e.x||this._localRot.y!=e.y||this._localRot.z!=e.z)&&this.onRotationChange(this._localRot,e),Se.setRotation(this.index,e.x,e.y,e.z),this._localRot.copyFrom(e),this.notifyLocalChange(),this.eventRotationChange&&this.eventDispatcher.dispatchEvent(this.eventRotationChange)}get localRotation(){return this._localRot}set localScale(e){var r;Se.setScale(this.index,e.x,e.y,e.z),this._localScale.copyFrom(e),this.notifyLocalChange(),(r=this.onScaleChange)==null||r.call(this),this.eventScaleChange&&this.eventDispatcher.dispatchEvent(this.eventScaleChange)}get localScale(){return this._localScale}get localDetailScale(){return this._localDetailScale}set localDetailScale(e){this._localDetailScale=e,Se.setContinueScale(this.index,e.x,e.y,e.z)}get localDetailRot(){return this._localDetailRot}set localDetailRot(e){this._localDetailRot=e,Se.setContinueRotation(this.index,e.x,e.y,e.z)}get localDetailPos(){return this._localDetailPos}set localDetailPos(e){this._localDetailPos=e,Se.setContinueTranslate(this.index,e.x,e.y,e.z)}beforeDestroy(e){this.parent&&this.parent.object3D&&this.parent.object3D.removeChild(this.object3D),super.beforeDestroy(e)}destroy(){super.destroy(),this.scene3D=null,this.eventPositionChange=null,this.eventRotationChange=null,this.eventScaleChange=null,this.onPositionChange=null,this.onRotationChange=null,this.onScaleChange=null,this._scene3d=null,this._parent=null,this._localPos=null,this._localRot=null,this._localRotQuat=null,this._localScale=null,this._forward=null,this._back=null,this._right=null,this._left=null,this._up=null,this._down=null,this.localChange=null,this._targetPos=null}};s(pt,"LIMIT",1),s(pt,"COMPONENT_NAME","UUTransform"),s(pt,"COMPONENT_TYPE","Transform"),s(pt,"POSITION_ONCHANGE","POSITION_ONCHANGE"),s(pt,"ROTATION_ONCHANGE","ROTATION_ONCHANGE"),s(pt,"SCALE_ONCHANGE","SCALE_ONCHANGE"),s(pt,"PARENT_ONCHANGE","PARENT_ONCHANGE"),s(pt,"CHILDREN_ONCHANGE","CHILDREN_ONCHANGE"),s(pt,"ADD_ONCHANGE","ADD_ONCHANGE"),s(pt,"LOCAL_ONCHANGE","LOCAL_ONCHANGE");let Cr=pt;const si=class si{static genMeshBounds(t,e){let r=this.genMeshMinVector,i=this.genMeshMaxVector,a=this.genMeshVectorList8;e||(e=new Oe(g.ZERO,g.ZERO)),e.setFromMinMax(this.maxVector,this.minVector);let o=t.getComponents($);for(const l of o)if(l&&l.geometry){let h=l.object3D.transform.worldMatrix;r.copy(l.geometry.bounds.min),i.copy(l.geometry.bounds.max),a[0].set(r.x,r.y,r.z),a[1].set(r.x,r.y,i.z),a[2].set(r.x,i.y,r.z),a[3].set(r.x,i.y,i.z),a[4].set(i.x,r.y,r.z),a[5].set(i.x,r.y,i.z),a[6].set(i.x,i.y,r.z),a[7].set(i.x,i.y,i.z);for(const u of a)h.transformPoint(u,u),e.expandByPoint(u)}return i.copyFrom(e.max),r.copyFrom(e.min),e.setFromMinMax(r,i),e}static transformBound(t,e,r){let i=this.genMeshMinVector.copyFrom(e.min),a=this.genMeshMaxVector.copyFrom(e.max),o=this.genMeshVectorList8;r||(r=new Oe(g.ZERO,g.ZERO)),r.setFromMinMax(this.maxVector,this.minVector),o[0].set(i.x,i.y,i.z),o[1].set(i.x,i.y,a.z),o[2].set(i.x,a.y,i.z),o[3].set(i.x,a.y,a.z),o[4].set(a.x,i.y,i.z),o[5].set(a.x,i.y,a.z),o[6].set(a.x,a.y,i.z),o[7].set(a.x,a.y,a.z);for(const l of o)t.transformPoint(l,l),r.expandByPoint(l);return a.copyFrom(r.max),i.copyFrom(r.min),r.setFromMinMax(i,a),r}};s(si,"maxVector",new g(Number.MAX_VALUE*.1,Number.MAX_VALUE*.1,Number.MAX_VALUE*.1)),s(si,"minVector",si.maxVector.clone().multiplyScalar(-1)),s(si,"genMeshMaxVector",g.ZERO.clone()),s(si,"genMeshMinVector",g.ZERO.clone()),s(si,"genMeshVectorList8",[new g,new g,new g,new g,new g,new g,new g,new g]);let hs=si;class Pu extends ir{constructor(){super();s(this,"name","");s(this,"_instanceID","");s(this,"_numChildren");s(this,"transform");s(this,"renderNode");s(this,"entityChildren");s(this,"components");s(this,"waitDisposeComponents");s(this,"_bound");s(this,"_boundWorld");s(this,"_isBoundChange",!0);s(this,"_dispose",!1);this.entityChildren=[],this.components=new Map,this._instanceID=mn().toString(),this.waitDisposeComponents=[]}get instanceID(){return this._instanceID}get dispose(){return this._dispose}getObjectByName(e){if(e.indexOf("/")>=0){let r=e.split("/"),i=this;for(;r.length>0&&i;){let a=r.shift();if(i=i.getChildByName(a,!1),!i)return null}return i}else return this.getChildByName(e,!1)}get numChildren(){return this._numChildren}addChild(e){if(e==null)throw new Error("child is null!");if(e===this)throw new Error("child is self!");return this.entityChildren.indexOf(e)==-1?(e.removeFromParent(),e.transform.parent=this.transform,this.entityChildren.push(e),this._numChildren=this.entityChildren.length,this.noticeComponents("onAddChild",e),e):null}removeChild(e){if(e===null)return;if(e===this)throw new Error("add child is self!");let r=this.entityChildren.indexOf(e);r!=-1&&(this.entityChildren.splice(r,1),e.transform.parent=null,this._numChildren=this.entityChildren.length,this.noticeComponents("onRemoveChild",e))}removeAllChild(){for(;this.numChildren>0;)this.removeChild(this.entityChildren[0])}removeSelf(){return this.removeFromParent()}removeChildByIndex(e){e>=0&&e<this.entityChildren.length?this.removeChild(this.entityChildren[e]):console.error("remove child by index , index out of range")}hasChild(e){return this.entityChildren.indexOf(e)!=-1}removeFromParent(){let e=this.transform.parent;return e&&e.object3D&&e.object3D.removeChild(this),this}getChildByIndex(e){let r=null;return e<this.entityChildren.length&&(r=this.entityChildren[e]),r}getChildByName(e,r=!0){let i=null;for(const a of this.entityChildren){if(a.name==e)return i=a,i;if(r&&(i=a.getChildByName(e,r),i))return i}return i}update(){}instantiate(){return null}onTransformLocalChange(e){this._isBoundChange=!0}get bound(){return(this._isBoundChange||!this._bound)&&this.updateBound(),this._boundWorld}set bound(e){this._bound=e,this._boundWorld=this._bound.clone(),this._isBoundChange=!0}updateBound(){return this._bound||(this._bound=new Oe,this._boundWorld=this._bound.clone(),this._isBoundChange=!0),this._isBoundChange&&(hs.transformBound(this.transform.worldMatrix,this._bound,this._boundWorld),this._isBoundChange=!1),this._boundWorld}waitUpdate(){this._dispose?(this.transform.parent&&this.transform.parent.object3D.removeChild(this),this.components.forEach((e,r)=>{e.enable=!1,e.beforeDestroy(),e.destroy()}),this.components.clear()):Te.waitStartComponent.forEach((e,r)=>{for(;e.length>0;){const i=e.shift();i.__start(),Te.waitStartComponent.delete(i.object3D)}})}noticeComponents(e,r){var i;for(let a of this.components.values())(i=a[e])==null||i.call(a,r)}destroy(e){this._dispose||(this.components.forEach(r=>{r.beforeDestroy(e)}),this.components.forEach(r=>{r.destroy(e)}),this.components.clear(),this.entityChildren.forEach(r=>{r.destroy(e)}),this.removeAllChild(),this.transform.parent=null,this._dispose=!0,super.destroy())}}var Ru=Object.defineProperty,Uu=Object.getOwnPropertyDescriptor,Lu=(n,t,e,r)=>{for(var i=r>1?void 0:r?Uu(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Ru(t,e,i),i};let ee=class extends Pu{constructor(){super();s(this,"_isScene3D");s(this,"prefabRef");s(this,"serializeTag");this.transform=this.addComponent(Cr),this.transform.eventDispatcher.addEventListener(Cr.LOCAL_ONCHANGE,this.onTransformLocalChange,this)}get isScene3D(){return this._isScene3D}forChild(t){this.entityChildren.forEach(e=>{t(e),e.forChild(t)})}addComponent(t,e){if(!this.components.has(t)){let r=new t;return r.object3D=this,this.components.set(t,r),r.__init(e),Te.appendWaitStart(r),r}return this.components.get(t)}getOrAddComponent(t){let e=this.components.get(t);return e||(e=this.addComponent(t)),e}removeComponent(t){if(this.components.has(t)){let e=this.components.get(t);Te.removeWaitStart(this,e),this.components.delete(t),e.__stop(),e.beforeDestroy(),e.destroy()}}hasComponent(t){return this.components.has(t)}getComponent(t){return this.components.get(t)}getComponentFromParent(t){return this.parent?this.parent.object3D.getComponent(t)||this.parent.object3D.getComponentFromParent(t):null}getComponentsInChild(t){let e=[],r=this.components.get(t);r&&e.push(r);for(let i=0;i<this.entityChildren.length;i++){let a=this.entityChildren[i].getComponentsInChild(t);e.push(...a)}return e}getComponents(t,e,r){e||(e=[]);let i=this.getComponent(t);i&&(i.enable||r)&&e.push(i);for(let a=0,o=this.entityChildren.length;a<o;a++){let l=this.entityChildren[a];l&&l instanceof ee&&l.getComponents(t,e,r)}return e}getComponentsExt(t,e,r){e||(e=[]);let i=this.components.get(t);if(i&&(i.enable||r))e.push(i);else for(const a of this.entityChildren)a instanceof ee&&a.getComponentsExt(t,e,r);return e}getComponentsByProperty(t,e,r=!0,i,a){i||(i=[]);let o;for(const l of this.components.values())l&&(l.enable||a)&&l[t]===e&&(i.push(l),o=!0);if(!(o&&r))for(const l of this.entityChildren)l instanceof ee&&l.getComponentsByProperty(t,e,r,i,a);return i}clone(){return this.instantiate()}instantiate(){let t=new ee;return t.name=this.name,t.serializeTag=this.serializeTag,t.prefabRef=this.prefabRef,this.entityChildren.forEach((e,r)=>{let i=e.instantiate();t.addChild(i)}),this.components.forEach((e,r)=>{e.cloneTo(t)}),t}get localPosition(){return this.transform.localPosition}set localPosition(t){this.transform.localPosition=t}get localRotation(){return this.transform.localRotation}set localRotation(t){this.transform.localRotation=t}get localScale(){return this.transform.localScale}set localScale(t){this.transform.localScale=t}get localQuaternion(){return this.transform.localRotQuat}set localQuaternion(t){this.transform.localRotQuat=t}notifyChange(){this.transform.notifyChange()}get parent(){return this.transform.parent}get parentObject(){return this.transform.parent.object3D}set x(t){this.transform.x=t}get x(){return this.transform.x}set y(t){this.transform.y=t}get y(){return this.transform.y}set z(t){this.transform.z=t}get z(){return this.transform.z}set scaleX(t){this.transform.scaleX=t}get scaleX(){return this.transform.scaleX}set scaleY(t){this.transform.scaleY=t}get scaleY(){return this.transform.scaleY}set scaleZ(t){this.transform.scaleZ=t}get scaleZ(){return this.transform.scaleZ}set rotationX(t){this.transform.rotationX=t}get rotationX(){return this.transform.rotationX}set rotationY(t){this.transform.rotationY=t}get rotationY(){return this.transform.rotationY}set rotationZ(t){this.transform.rotationZ=t}get rotationZ(){return this.transform.rotationZ}fixedUpdate(){}lateUpdate(){}traverse(t){t(this);for(let e=0,r=this.entityChildren.length;e<r;e++){let i=this.entityChildren[e];i instanceof ee&&i.traverse(t)}}destroy(t){this.transform.eventDispatcher.removeEventListener(Cr.LOCAL_ONCHANGE,this.onTransformLocalChange,this),super.destroy(t)}};ee=Lu([Ou],ee);function Ou(n,t){return class extends ee{set active(e){this.transform.enable=e>0}get active(){return this.transform.enable?1:0}get materialColor(){var e,r;return(r=(e=this.getComponent($))==null?void 0:e.material)==null?void 0:r.shader.getDefaultColorShader().baseColor}set materialColor(e){var i;let r=(i=this.getComponent($))==null?void 0:i.material;r&&(r.shader.getDefaultColorShader().baseColor=e)}notifyMaterialColorChange(e,r){var i,a;(a=(i=this.getComponent($).materials)==null?void 0:i[e])==null||a.shader.getDefaultColorShader().uniforms[r].onChange()}}}class rt{static createCamera3DObject(t,e){return this.createCamera3D(null,t,e)}static createCamera3D(t,e,r){return t||(t=new ee),e&&e.addChild(t),r&&(t.name=r),t.getOrAddComponent(Fi)}static UnProjection(t,e,r=1,i){let a=new g(t,e,0),o=1,l=g.HELP_0,h=E.canvas.offsetLeft,u=E.canvas.offsetTop,c=E.canvas.clientWidth,f=E.canvas.clientHeight;l.x=((a.x-h)*o/c-.5)*2,l.y=-((a.y-u)*o/f-.5)*2,l.z=r;let d=new g(0,0,0),p=Q.helpMatrix2;p.copyFrom(i.projectionMatrix),p.invert();let A=Q.helpMatrix;return A.identity(),A.multiply(p),A.multiply(i.transform.worldMatrix),A.perspectiveMultiplyPoint3(l,d),d}static Projection(t,e,r){let i=r||new g(0,0,0),a=Q.helpMatrix;a.copyFrom(e.viewMatrix),a.multiply(e.projectionMatrix),a.perspectiveMultiplyPoint3(t,i);let o=E.canvas.clientWidth/2,l=E.canvas.clientHeight/2;return i.x=i.x*o+o,i.y=l-i.y*l,i}static UnProjection2(t,e,r,i,a){let o=a||new g(0,0,0),l=Q.helpMatrix;l.copyFrom(i.pvMatrixInv);let h=E.canvas.clientWidth/2,u=E.canvas.clientHeight/2;return o.x=(t-h)/h,o.y=(u-e)/u,o.z=r,l.perspectiveMultiplyPoint3(o,o),o}}const Gr=class Gr{static init(){this.directionLightList=new Map,this.pointLightList=new Map,this.shadowLights=new Map}static createBuffer(t){if(!this.shadowLights.has(t.scene)){let e=new Float32Array(16);this.shadowLights.set(t.scene,e)}}static getShadowLightList(t){if(!t.transform.view3D)return null;if(t.lightData.lightType==tt.DirectionLight){let e=this.directionLightList.get(t.transform.view3D.scene);return e||(e=[],this.directionLightList.set(t.transform.view3D.scene,e)),e}else if(t.lightData.lightType==tt.PointLight){let e=this.pointLightList.get(t.transform.view3D.scene);return e||(e=[],this.pointLightList.set(t.transform.view3D.scene,e)),e}else if(t.lightData.lightType==tt.SpotLight){let e=this.pointLightList.get(t.transform.view3D.scene);return e||(e=[],this.pointLightList.set(t.transform.view3D.scene,e)),e}}static getShadowLightWhichScene(t,e){if(e==tt.DirectionLight){let r=this.directionLightList.get(t);return r||(r=[],this.directionLightList.set(t,r)),r}else if(e==tt.PointLight){let r=this.pointLightList.get(t);return r||(r=[],this.pointLightList.set(t,r)),r}}static getDirectShadowLightWhichScene(t){let e=this.directionLightList.get(t);return e||(e=[],this.directionLightList.set(t,e)),e}static getPointShadowLightWhichScene(t){let e=this.pointLightList.get(t);return e||(e=[],this.pointLightList.set(t,e)),e}static addShadowLight(t){if(!t.transform.view3D)return null;let e=t.transform.view3D.scene;if(t.lightData.lightType==tt.DirectionLight){let r=this.directionLightList.get(e);if(r||(r=[],this.directionLightList.set(e,r)),!t.shadowCamera){t.shadowCamera=rt.createCamera3DObject(null,"shadowCamera"),t.shadowCamera.isShadowCamera=!0;let i=-1e3;t.shadowCamera.orthoOffCenter(i,-i,i,-i,1,1e4)}return r.indexOf(t)==-1&&r.push(t),r}else if(t.lightData.lightType==tt.PointLight||t.lightData.lightType==tt.SpotLight){let r=this.pointLightList.get(e);return r&&r.length>=8||(r||(r=[],this.pointLightList.set(e,r)),r.indexOf(t)==-1&&r.push(t)),r}}static removeShadowLight(t){if(t.lightData.castShadowIndex=-1,!t.transform.view3D)return null;if(t.lightData.lightType==tt.DirectionLight){let e=this.directionLightList.get(t.transform.view3D.scene);if(e){let r=e.indexOf(t);r!=-1&&e.splice(r,1)}return t.lightData.castShadowIndex=-1,e}else if(t.lightData.lightType==tt.PointLight||t.lightData.lightType==tt.SpotLight){let e=this.pointLightList.get(t.transform.view3D.scene);if(e){let r=e.indexOf(t);r!=-1&&e.splice(r,1)}return t.lightData.castShadowIndex=-1,e}}static update(t){let e=this.shadowLights.get(t.scene),r=Gr.directionLightList.get(t.scene),i=Gr.pointLightList.get(t.scene),a=0,o=0,l=0,h=0;if(e.fill(0),r){let u=0;for(let c=0;c<r.length;c++){const f=r[c];e[c]=f.lightData.index,f.lightData.castShadowIndex=u++}o=r.length}if(i){l=o;let u=0;for(let c=l;c<i.length;c++){const f=i[c];e[c]=f.lightData.index,f.lightData.castShadowIndex=u++}h=l+i.length}re.getAllCameraGroup().forEach(u=>{u.dirShadowStart=a,u.dirShadowEnd=o,u.pointShadowStart=l,u.pointShadowEnd=h,u.shadowLights=e})}};s(Gr,"maxNumDirectionShadow",8),s(Gr,"maxNumPointShadow",8),s(Gr,"directionLightList"),s(Gr,"pointLightList"),s(Gr,"shadowLights");let Kt=Gr;class eo{static getGlobalDataBindGroupLayout(){if(this._globalDataBindGroupLayout)return this._globalDataBindGroupLayout;let t=[];return t.push({binding:0,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"uniform"}}),t.push({binding:1,visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,buffer:{type:"read-only-storage"}}),this._globalDataBindGroupLayout=E.device.createBindGroupLayout({entries:t}),this._globalDataBindGroupLayout}}s(eo,"_globalDataBindGroupLayout");class Mn{constructor(t){s(this,"uuid");s(this,"usage");s(this,"globalBindGroup");s(this,"uniformGPUBuffer");s(this,"matrixBindGroup");s(this,"uniformByteLength");s(this,"matrixesByteLength");s(this,"shadowMatrixRaw",new Float32Array(8*16));s(this,"csmMatrixRaw",new Float32Array(nr.Cascades*16));s(this,"csmShadowBias",new Float32Array(4));s(this,"shadowLights",new Float32Array(16));s(this,"dirShadowStart",0);s(this,"dirShadowEnd",0);s(this,"pointShadowStart",0);s(this,"pointShadowEnd",0);this.uuid=kt(),this.usage=GPUBufferUsage.UNIFORM|GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.uniformGPUBuffer=new Ct(8192+9*4*4),this.uniformGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBindGroup=t,this.createBindGroup()}createBindGroup(){this.uniformByteLength=this.uniformGPUBuffer.memory.shareDataBuffer.byteLength,this.matrixesByteLength=Q.block*4*Q.maxCount,this.globalBindGroup=E.device.createBindGroup({label:"global_bindGroupLayout",layout:eo.getGlobalDataBindGroupLayout(),entries:[{binding:0,resource:{buffer:this.uniformGPUBuffer.buffer,offset:0,size:this.uniformByteLength}},{binding:1,resource:{buffer:this.matrixBindGroup.matrixBufferDst.buffer,offset:0,size:this.matrixesByteLength}}]})}setCamera(t){this.uniformGPUBuffer.setMatrix("_projectionMatrix",t.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",t.viewMatrix),this.uniformGPUBuffer.setMatrix("_cameraWorldMatrix",t.transform.worldMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",t.projectionMatrixInv),this.uniformGPUBuffer.setMatrix("viewToWorld",t.cameraToWorld);let e=Kt.getDirectShadowLightWhichScene(t.transform.scene3D);this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0);for(let h=0;h<8;h++)if(h<e.length){let u=e[h].shadowCamera;this.shadowMatrixRaw.set(u.pvMatrix.rawData,h*16)}else this.shadowMatrixRaw.set(t.transform.worldMatrix.rawData,h*16);this.uniformGPUBuffer.setFloat32Array("shadowMatrix",this.shadowMatrixRaw);let r=m.setting.shadow.shadowSize;if(nr.Cascades>1&&t.enableCSM&&e[0])for(let h=0;h<nr.Cascades;h++){let u=t.csm.children[h].shadowCamera;this.csmMatrixRaw.set(u.pvMatrix.rawData,h*16),this.csmShadowBias[h]=t.getCSMShadowBiasScale(u)}this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setFloat32Array("shadowLights",this.shadowLights);let i=m.setting.reflectionSetting,a=X.instance.getReflections(t.transform.scene3D).length;this.uniformGPUBuffer.setFloat("reflectionProbeSize",i.reflectionProbeSize),this.uniformGPUBuffer.setFloat("reflectionProbeMaxCount",i.reflectionProbeMaxCount),this.uniformGPUBuffer.setFloat("reflectionMapWidth",i.width),this.uniformGPUBuffer.setFloat("reflectionMapHeight",i.height),this.uniformGPUBuffer.setFloat("reflectionCount",a),this.uniformGPUBuffer.setFloat("test2",Fe.testObj.testValue2),this.uniformGPUBuffer.setFloat("test3",Fe.testObj.testValue3),this.uniformGPUBuffer.setFloat("test4",Fe.testObj.testValue4),this.uniformGPUBuffer.setVector3("CameraPos",t.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",me.frame),this.uniformGPUBuffer.setFloat32Array("SH",t.sh),this.uniformGPUBuffer.setFloat("time",me.time),this.uniformGPUBuffer.setFloat("delta",me.delta),this.uniformGPUBuffer.setFloat("shadowBias",t.getShadowBias(r)),this.uniformGPUBuffer.setFloat("skyExposure",m.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",m.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",m.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",m.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",m.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",m.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",m.setting.render.renderState_split);let o=m.inputSystem.mouseX*E.pixelRatio,l=m.inputSystem.mouseY*E.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",o),this.uniformGPUBuffer.setFloat("mouseY",l),this.uniformGPUBuffer.setFloat("windowWidth",E.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",E.windowHeight),this.uniformGPUBuffer.setFloat("near",t.near),this.uniformGPUBuffer.setFloat("far",t.far),this.uniformGPUBuffer.setFloat("pointShadowBias",m.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",r),this.uniformGPUBuffer.setFloat("shadowSoft",m.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",t.enableCSM?1:0),this.uniformGPUBuffer.setFloat("csmMargin",m.setting.shadow.csmMargin),this.uniformGPUBuffer.setInt32("nDirShadowStart",this.dirShadowStart),this.uniformGPUBuffer.setInt32("nDirShadowEnd",this.dirShadowEnd),this.uniformGPUBuffer.setInt32("nPointShadowStart",this.pointShadowStart),this.uniformGPUBuffer.setInt32("nPointShadowEnd",this.pointShadowEnd),this.uniformGPUBuffer.setVector3("cameraForward",t.transform.forward),this.uniformGPUBuffer.setVector4Array("frustumPlanes",t.frustum.planes),this.uniformGPUBuffer.apply()}setShadowCamera(t){this.uniformGPUBuffer.setMatrix("_projectionMatrix",t.projectionMatrix),this.uniformGPUBuffer.setMatrix("_viewMatrix",t.viewMatrix),this.uniformGPUBuffer.setMatrix("_pvMatrix",t.pvMatrix),this.uniformGPUBuffer.setMatrix("pvMatrixInv",t.projectionMatrixInv),this.uniformGPUBuffer.setMatrix("viewToWorld",t.cameraToWorld),this.csmShadowBias.fill(1e-4),this.shadowMatrixRaw.fill(0),this.csmMatrixRaw.fill(0),this.uniformGPUBuffer.setFloat32Array("shadowCamera",this.shadowMatrixRaw),this.uniformGPUBuffer.setFloat32Array("csmShadowBias",this.csmShadowBias),this.uniformGPUBuffer.setFloat32Array("csmMatrix",this.csmMatrixRaw),this.uniformGPUBuffer.setFloat32Array("shadowLights",this.shadowLights),this.uniformGPUBuffer.setVector3("CameraPos",t.transform.worldPosition),this.uniformGPUBuffer.setFloat("frame",me.frame),this.uniformGPUBuffer.setFloat32Array("SH",t.sh),this.uniformGPUBuffer.setFloat("time",me.time),this.uniformGPUBuffer.setFloat("delta",me.delta),this.uniformGPUBuffer.setFloat("shadowBias",m.setting.shadow.shadowBias),this.uniformGPUBuffer.setFloat("skyExposure",m.setting.sky.skyExposure),this.uniformGPUBuffer.setFloat("renderPassState",m.setting.render.renderPassState),this.uniformGPUBuffer.setFloat("quadScale",m.setting.render.quadScale),this.uniformGPUBuffer.setFloat("hdrExposure",m.setting.render.hdrExposure),this.uniformGPUBuffer.setInt32("renderState_left",m.setting.render.renderState_left),this.uniformGPUBuffer.setInt32("renderState_right",m.setting.render.renderState_right),this.uniformGPUBuffer.setFloat("renderState_split",m.setting.render.renderState_split);let e=m.inputSystem.mouseX*E.pixelRatio,r=m.inputSystem.mouseY*E.pixelRatio;this.uniformGPUBuffer.setFloat("mouseX",e),this.uniformGPUBuffer.setFloat("mouseY",r),this.uniformGPUBuffer.setFloat("windowWidth",E.windowWidth),this.uniformGPUBuffer.setFloat("windowHeight",E.windowHeight),this.uniformGPUBuffer.setFloat("near",t.near),this.uniformGPUBuffer.setFloat("far",t.far),this.uniformGPUBuffer.setFloat("pointShadowBias",m.setting.shadow.pointShadowBias),this.uniformGPUBuffer.setFloat("shadowMapSize",m.setting.shadow.shadowSize),this.uniformGPUBuffer.setFloat("shadowSoft",m.setting.shadow.shadowSoft),this.uniformGPUBuffer.setFloat("enableCSM",0),this.uniformGPUBuffer.setFloat("csmMargin",m.setting.shadow.csmMargin),this.uniformGPUBuffer.setInt32("nDirShadowStart",this.dirShadowStart),this.uniformGPUBuffer.setInt32("nDirShadowEnd",this.dirShadowEnd),this.uniformGPUBuffer.setInt32("nPointShadowStart",this.pointShadowStart),this.uniformGPUBuffer.setInt32("nPointShadowEnd",this.pointShadowEnd),this.uniformGPUBuffer.apply()}setShadowLight(){}}const dr=class dr{constructor(t,e=0,r=null,i=0){s(this,"entities");s(this,"box");s(this,"subTrees",[]);s(this,"parent");s(this,"level");s(this,"index");s(this,"uuid");s(this,"__rayCastTempVector",new g);this.parent=r,this.box=t.clone(),this.level=i,this.index=e,this.uuid=i+"_"+e,this.entities=new Map}tryInsertEntity(t){let e=t.renderer.object3D.bound;if(this.level==0||this.box.containsBox(e)){this.subTrees.length==0&&this.level<dr.maxSplitLevel&&this.splitTree();let r;if(this.subTrees.length>0){for(let i of this.subTrees)if(i.tryInsertEntity(t)){r=!0;break}}return r||t.enterNode(this),!0}return!1}splitTree(){if(this.subTrees.length==0){const t=dr._v1,e=this.box.extents.clone();let r=this.level+1,i=0;for(let a=0;a<2;a++)for(let o=0;o<2;o++)for(let l=0;l<2;l++){const h=new Oe;this.box.min.add(t.set(a,o,l).multiply(e),h.min),h.min.add(e,h.max),h.setFromMinMax(h.min,h.max);let u=new dr(h,i++,this,r);this.subTrees.push(u)}}}rayCasts(t,e){if(this.level==0||t.intersectBox(this.box,this.__rayCastTempVector)){this.entities.size>0&&e.push(...this.entities.values());for(let r of this.subTrees)r.rayCasts(t,e);return!0}return!1}frustumCasts(t,e){if(this.level==0||t.containsBox2(this.box)>0){if(this.entities.size>0)for(const r of this.entities.values())(this.level>dr.autoSplitLevel||t.containsBox2(r.renderer.object3D.bound)>0)&&e.push(r);for(let r of this.subTrees)r.frustumCasts(t,e);return!0}return!1}getRenderNode(t,e){if(this.level==0||t.containsBox2(this.box)>0){if(this.entities.size>0)for(const r of this.entities.values())(this.level>dr.autoSplitLevel||t.containsBox2(r.renderer.object3D.bound)>0)&&(r.renderer.renderOrder<3e3?e.opaqueList.push(r.renderer):r.renderer.renderOrder>=3e3&&e.transparentList.push(r.renderer));for(let r of this.subTrees)r.getRenderNode(t,e);return!0}return!1}boxCasts(t,e){if(t.intersectsBox(this.box)){this.entities.size>0&&e.push(...this.entities.values());for(let r of this.subTrees)r.boxCasts(t,e);return!0}return!1}clean(){for(let t of this.entities.values())t.leaveNode();return this.entities.clear(),this}};s(dr,"_v1",new g),s(dr,"_v2",new g),s(dr,"maxSplitLevel",6),s(dr,"autoSplitLevel",3);let to=dr;class Nu{constructor(){s(this,"_pool",[]);s(this,"_worldPosition",new g);s(this,"_viewPosition",new g);s(this,"_zSortList",[])}pop(){return this._pool.pop()||{}}recycle(){for(let t of this._zSortList)t.z=0,t.userData=null,t.obj3d=null,this._pool.push(t);this._zSortList.length=0}sort(t,e,r,i){this._zSortList=[];for(let a of e){let o=this.pop();o.userData=a,o.obj3d=r(a),o.z=this.worldToCameraDepth(o.obj3d,t),this._zSortList.push(o)}this._zSortList.sort((a,o)=>a.z-o.z>0?1:-1),i||(i=[]);for(let a of this._zSortList)i.push(a.userData);return this.recycle(),i}worldToCameraDepth(t,e){e||(e=t.transform.view3D.camera);let r=0;return e&&(this._worldPosition.copyFrom(t.transform.worldPosition),e.worldToScreenPoint(this._worldPosition,this._viewPosition),r=this._viewPosition.z),r}}let Fu=new Nu;var us=(n=>(n[n.None=2]="None",n[n.StaticBatch=4]="StaticBatch",n[n.DynamicBatch=8]="DynamicBatch",n[n.Hiden=16]="Hiden",n))(us||{});class Pn{static addMask(t,e){return t|e}static removeMask(t,e){return t&~e}static hasMask(t,e){return(t&e)!=0}}class ku{constructor(){s(this,"opaqueList",[]);s(this,"transparentList",[]);s(this,"sky")}clean(){this.opaqueList.length=0,this.transparentList.length=0}}class zu{constructor(){s(this,"renderGroup");this.renderGroup=new Map}collect_add(t){let e="",r="";e+=t.geometry.instanceID;for(let a=0;a<t.materials.length;a++){const o=t.materials[a];r+=o.shader.getDefaultColorShader().shaderVariant}let i=e+r;this.renderGroup.has(i)||this.renderGroup.set(i,{bundleMap:new Map,key:i,renderNodes:[]}),this.renderGroup.get(i).renderNodes.indexOf(t)==-1&&this.renderGroup.get(i).renderNodes.push(t)}}class Gu{constructor(){s(this,"renderShaderUpdateList",new Map);s(this,"renderNodeList",new Map)}collect_add(t){let e=t.transform.view3D;e&&t.materials&&t.materials.forEach(r=>{let i=this.renderShaderUpdateList.get(e);i||(i=new Map,this.renderShaderUpdateList.set(e,i));let a=this.renderNodeList.get(e);a||(a=new Map,this.renderNodeList.set(e,a)),a.set(t.instanceID,t);let o=r.getAllPass();for(let l=0;l<o.length;l++){const h=o[l];let u=`${t.geometry.instanceID+h.instanceID}`,c=i.get(u);c||(c=new Map,i.set(u,c)),c.set(t.instanceID,t)}})}collect_remove(t){let e=t.transform.view3D;if(e&&t.materials){let r=this.renderShaderUpdateList.get(e);r&&t.materials.forEach(i=>{let a=i.getAllPass();for(let o=0;o<a.length;o++){const l=a[o];let h=`${t.geometry.instanceID+l.instanceID}`;r.delete(h)}})}}}const zs=class zs{constructor(){s(this,"_sceneLights");s(this,"_sceneGIProbes");s(this,"_op_RenderNodes");s(this,"_tr_RenderNodes");s(this,"_octreeRenderNodes");s(this,"_reflections");s(this,"_graphics");s(this,"_op_renderGroup");s(this,"_tr_renderGroup");s(this,"_renderShaderCollect");s(this,"state",{giLightingChange:!0});s(this,"sky");s(this,"_collectInfo");s(this,"rendererOctree");this._sceneLights=new Map,this._sceneGIProbes=new Map,this._op_RenderNodes=new Map,this._tr_RenderNodes=new Map,this._reflections=new Map,this._graphics=[],this._op_renderGroup=new Map,this._tr_renderGroup=new Map,this._collectInfo=new ku,this._renderShaderCollect=new Gu,this._octreeRenderNodes=new Map}static get instance(){return this._instance||(this._instance=new zs),this._instance}getPashList(t,e){if(e.renderOrder<3e3)return this._op_RenderNodes.get(t);if(e.renderOrder>=3e3)return this._tr_RenderNodes.get(t)}sortRenderNode(t,e){for(let r=t.length-1;r>0;r--)if(t[r].renderOrder<e.renderOrder){t.push(e);return}t.push(e)}addRenderNode(t,e){if(!t)return;let r=e.renderOrder>=3e3;if(e.hasMask(ye.Sky))this.sky=e;else if(e.hasMask(ye.Reflection)){this.removeRenderNode(t,e);let i=this._reflections.get(t);i||(i=[],this._reflections.set(t,i),i.push(e)),i.includes(e)||i.push(e)}else if(e.hasMask(ye.Graphic3D))this._graphics.indexOf(e)==-1&&this._graphics.push(e);else if(Pn.hasMask(e.renderLayer,us.None)){this.removeRenderNode(t,e);let i=r?this._tr_RenderNodes:this._op_RenderNodes;i.has(t)||i.set(t,[]),i.get(t).push(e),m.setting.occlusionQuery.octree&&e.attachSceneOctree(this.getOctree(t));let a=this.getPashList(t,e);a.indexOf(e)==-1&&this.sortRenderNode(a,e)}else{this.removeRenderNode(t,e);let i=r?this._tr_renderGroup:this._op_renderGroup;i.has(t)||i.set(t,new zu),i.get(t).collect_add(e)}e.object3D.renderNode=e,this._renderShaderCollect.collect_add(e)}getOctree(t){let e,r=m.setting.occlusionQuery.octree;if(r&&(e=this._octreeRenderNodes.get(t),!e)){let i=new g(r.x,r.y,r.z),a=new g(r.width,r.height,r.depth),o=new Oe(i,a);e=new to(o),this._octreeRenderNodes.set(t,e)}return e}removeRenderNode(t,e){if(e.detachSceneOctree(),e.hasMask(ye.Sky))this.sky=null;else if(e.hasMask(ye.Reflection)){let r=this._reflections.get(t);if(r){let i=r.indexOf(e);i!=-1&&r.splice(i,1)}}else if(Pn.hasMask(e.renderLayer,us.None)){let r=this.getPashList(t,e);if(r){let i=r.indexOf(e);i!=-1&&r.splice(i,1)}}this._renderShaderCollect.collect_remove(e)}addLight(t,e){if(!this._sceneLights.has(t))this._sceneLights.set(t,[e]);else{let r=this._sceneLights.get(t);if(r.length>=m.setting.light.maxLight){console.warn("Alreay meet maxmium light number:",m.setting.light.maxLight);return}r.indexOf(e)!=-1||r.push(e)}}removeLight(t,e){if(this._sceneLights.has(t)){let r=this._sceneLights.get(t),i=r.indexOf(e);i!=-1&&r.splice(i,1)}}getLights(t){return this._sceneLights.get(t)||[]}addGIProbe(t,e){this._sceneGIProbes.has(t)?this._sceneGIProbes.get(t).push(e):this._sceneGIProbes.set(t,[e])}removeGIProbe(t,e){if(this._sceneGIProbes.has(t)){let r=this._sceneGIProbes.get(t),i=r.indexOf(e);i!=-1&&r.splice(i,1)}}getProbes(t){return this._sceneGIProbes.get(t)||[]}getReflections(t){return this._reflections.get(t)||[]}autoSortRenderNodes(t){let e=this._tr_RenderNodes.get(t);if(!e)return;let r=!1;for(const i of e)if(i.isRenderOrderChange||i.needSortOnCameraZ){r=!0;break}if(r){for(const i of e){let a=i.renderOrder;if(i.needSortOnCameraZ){let o=Fu.worldToCameraDepth(i.object3D);o=1-Math.max(0,Math.min(1,o)),a+=o}i.__renderOrder=a,i.isRenderOrderChange=!1}e.sort((i,a)=>i.__renderOrder>a.__renderOrder?1:-1)}return this}getRenderNodes(t,e){if(this.autoSortRenderNodes(t),this._collectInfo.clean(),this._collectInfo.sky=this.sky,m.setting.occlusionQuery.octree)this.rendererOctree=this.getOctree(t),this.rendererOctree.getRenderNode(e.frustum,this._collectInfo);else{let r=this._op_RenderNodes.get(t);r&&(this._collectInfo.opaqueList=r.concat());let i=this._tr_RenderNodes.get(t);i&&(this._collectInfo.transparentList=i.concat())}return this._collectInfo}getOpRenderGroup(t){return this._op_renderGroup.get(t)}getTrRenderGroup(t){return this._tr_renderGroup.get(t)}getGraphicList(){return this._graphics}getRenderShaderCollect(t){return this._renderShaderCollect.renderShaderUpdateList.get(t)}};s(zs,"_instance");let X=zs;class Qu{constructor(){s(this,"setting");s(this,"probesBufferData");s(this,"probesBuffer");s(this,"isVolumeFrameChange",!0);s(this,"randomOrientation");s(this,"startPosition",new g);s(this,"isVolumeChange",!0);s(this,"irradianceVolumeBuffer");s(this,"directionDistance",20);s(this,"randomSeedCount",3);s(this,"useRandomIndex",0);s(this,"centerDirection",new g(0,0,this.directionDistance).normalize(1));s(this,"arroundPositions",[]);s(this,"debugX",0);s(this,"debugY",0);s(this,"debugZ",0)}updateOrientation(){return this.useRandomIndex++,this.useRandomIndex>=this.arroundPositions.length&&(this.useRandomIndex=0),Q.fromToRotation(this.centerDirection,this.arroundPositions[this.useRandomIndex],this.randomOrientation),this.randomOrientation}init(t){this.setting=t,this.randomOrientation=new Q(!1),this.randomOrientation.identity(),this.irradianceVolumeBuffer=new Ct(80),this.createFramesBuffer(),this.arroundPositions.push(this.centerDirection.clone());for(let e=0;e<this.randomSeedCount;e++){let r=Math.PI*2*e/this.randomSeedCount,i=new g(Math.sin(r),Math.cos(r),this.directionDistance).normalize(1);this.arroundPositions.push(i)}}setVolumeDataChange(){this.isVolumeChange=!0}updateProbes(t){let e=this.probesBufferData;for(let r of t){let i=r.index*4;e[i+3]=r.drawCallFrame}}createFramesBuffer(){if(!this.probesBufferData){let t=this.setting.probeXCount*this.setting.probeYCount*this.setting.probeZCount;this.probesBufferData=new Float32Array(t*4),this.probesBufferData.fill(-1),this.probesBuffer=new be(t*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST)}}uploadBuffer(){this.isVolumeChange&&(this.fillIrradianceData(),this.isVolumeChange=!1,this.isVolumeFrameChange=!0),this.probesBuffer.setFloat32Array("uniformFramesBuffer",this.probesBufferData)}calcPosition(t,e,r,i){let a=this.setting,o=this.setting.probeSpace;return i=i||new g,i.x=t*o-o*(a.probeXCount-1)*.5+a.offsetX,i.y=e*o-o*(a.probeYCount-1)*.5+a.offsetY,i.z=r*o-o*(a.probeZCount-1)*.5+a.offsetZ,i}fillIrradianceData(){let t=this.setting,e=this.calcPosition(0,0,0,this.startPosition);this.irradianceVolumeBuffer.setFloat("orientationIndex",this.randomOrientation.index),this.irradianceVolumeBuffer.setFloat("hysteresis",t.hysteresis),this.irradianceVolumeBuffer.setFloat("OctRTSideSize",t.octRTSideSize),this.irradianceVolumeBuffer.setFloat("OctRTMaxSize",t.octRTMaxSize),this.irradianceVolumeBuffer.setFloat("startX",e.x),this.irradianceVolumeBuffer.setFloat("startY",e.y),this.irradianceVolumeBuffer.setFloat("startZ",e.z),this.irradianceVolumeBuffer.setFloat("ProbeSpace",t.probeSpace),this.irradianceVolumeBuffer.setFloat("probeXCount",t.probeXCount),this.irradianceVolumeBuffer.setFloat("probeYCount",t.probeYCount),this.irradianceVolumeBuffer.setFloat("probeZCount",t.probeZCount),this.irradianceVolumeBuffer.setFloat("maxDistance",t.probeSpace*1.732),this.irradianceVolumeBuffer.setFloat("depthSharpness",t.depthSharpness),this.irradianceVolumeBuffer.setFloat("ProbeSourceTextureSize",t.probeSourceTextureSize),this.irradianceVolumeBuffer.setFloat("ProbeSize",t.probeSize),this.irradianceVolumeBuffer.setFloat("bounceIntensity",t.bounceIntensity),this.irradianceVolumeBuffer.setFloat("probeRoughness",t.probeRoughness),this.irradianceVolumeBuffer.setFloat("normalBias",t.normalBias),this.irradianceVolumeBuffer.setFloat("irradianceChebyshevBias",t.irradianceChebyshevBias),this.irradianceVolumeBuffer.setFloat("rayNumber",t.rayNumber),this.irradianceVolumeBuffer.setFloat("irradianceDistanceBias",t.irradianceDistanceBias),this.irradianceVolumeBuffer.setFloat("indirectIntensity",t.indirectIntensity),this.irradianceVolumeBuffer.setFloat("ddgiGamma",t.ddgiGamma),this.irradianceVolumeBuffer.setFloat("lerpHysteresis",t.lerpHysteresis),this.irradianceVolumeBuffer.setFloat("debugX",this.debugX),this.irradianceVolumeBuffer.setFloat("debugY",this.debugY),this.irradianceVolumeBuffer.setFloat("debugZ",this.debugZ),this.irradianceVolumeBuffer.apply()}}class Vu{constructor(){s(this,"storageGPUBuffer");s(this,"irradianceVolume");s(this,"_lightList",[]);this.storageGPUBuffer=new be(ns.lightSize*m.setting.light.maxLight,GPUBufferUsage.COPY_SRC),this.irradianceVolume=new Qu,this.irradianceVolume.init(m.setting.gi);for(let t=0;t<m.setting.light.maxLight;t++){let e=this.storageGPUBuffer.memory.allocation_node(ns.lightSize*4);this._lightList.push(e)}this.storageGPUBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(t){this.storageGPUBuffer.clean();let e=X.instance.getLights(t.scene);for(let r=0;r<e.length;r++){const i=e[r].lightData;i.index=r,this.writeLightBytes(i,this._lightList[r])}this.storageGPUBuffer.apply()}writeLightBytes(t,e){e.offset=0,e.writeFloat(t.index),e.writeInt32(t.lightType),e.writeFloat(t.radius),e.writeFloat(t.linear),e.writeVector3(t.lightPosition),e.writeFloat(t.lightMatrixIndex),e.writeVector3(t.direction),e.writeFloat(t.quadratic),e.writeRGBColor(t.lightColor),e.writeFloat(t.intensity),e.writeFloat(t.innerAngle),e.writeFloat(t.outerAngle),e.writeFloat(t.range),e.writeInt32(t.castShadowIndex),e.writeVector3(t.lightTangent),e.writeFloat(t.iesIndex)}}class Yu{constructor(){s(this,"storageGPUBuffer");s(this,"reflectionMap");s(this,"sourceReflectionMap");s(this,"count");this.storageGPUBuffer=new be(6*128)}update(t){this.storageGPUBuffer.clean();let e=X.instance.getReflections(t.scene);for(let r=0;r<e.length;r++){const i=e[r];i.gid=r,this.storageGPUBuffer.setFloat("gid",i.gid),this.storageGPUBuffer.setVector3("worldPosition",i.transform.worldPosition),this.storageGPUBuffer.setFloat("radius",i.radius),this.storageGPUBuffer.setVector3("bound",i.transform.worldPosition)}this.count=e.length,this.storageGPUBuffer.apply()}}class Hu extends fi{constructor(e,r=0,i){super();s(this,"size");this.bufferType=vr.StorageGPUBuffer,this.size=e,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|r,e,i,"MatrixGPUBuffer")}writeBufferByHeap(e,r){let i;e instanceof Float64Array?i=new Float32Array(e):i=e;let a=E.device;if(i.length>0){let o=null;for(;this.mapAsyncReady.length&&(o=this.mapAsyncReady.shift(),o.usedSize!=i.byteLength);)o.destroy(),this.mapAsyncBuffersOutstanding--,o=null;o||(o=a.createBuffer({size:i.byteLength,usage:GPUBufferUsage.COPY_SRC|GPUBufferUsage.MAP_WRITE,mappedAtCreation:!0}),o.usedSize=i.byteLength,this.mapAsyncBuffersOutstanding++,this.mapAsyncBuffersOutstanding>10&&console.warn(` Warning: mapAsync requests from ${this.mapAsyncBuffersOutstanding} frames ago have not resolved yet.  MB of staging buffers allocated.`));let l=new Float32Array(i.buffer,i.byteOffset,r);new Float32Array(o.getMappedRange(0,r*4)).set(l),o.unmap();const h=a.createCommandEncoder();h.copyBufferToBuffer(o,0,this.buffer,0,r*4),a.queue.submit([h.finish()]),o.mapAsync(GPUMapMode.WRITE).then(()=>this.mapAsyncReady.push(o))}}}class Xu{constructor(){s(this,"uuid");s(this,"index");s(this,"usage");s(this,"groupBufferSize");s(this,"matrixBufferDst");this.uuid=kt(),this.groupBufferSize=0,this.usage=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,this.cacheWorldMatrix()}cacheWorldMatrix(){this.groupBufferSize=Q.maxCount*Q.blockBytes,this.matrixBufferDst=new Hu(this.groupBufferSize/4),this.matrixBufferDst.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.matrixBufferDst.buffer.label=this.groupBufferSize.toString()}writeBuffer(t){const e=Q.dynamicMatrixBytes;this.matrixBufferDst.mapAsyncWrite(e,t)}}class re{static init(){this.modelMatrixBindGroup=new Xu,this._cameraBindGroups=new Map,this._lightEntriesMap=new Map,this._reflectionEntriesMap=new Map}static getAllCameraGroup(){return this._cameraBindGroups}static getCameraGroup(t){let e=this._cameraBindGroups.get(t);return e||(e=new Mn(this.modelMatrixBindGroup),this._cameraBindGroups.set(t,e)),t.isShadowCamera?e.setShadowCamera(t):e.setCamera(t),e}static updateCameraGroup(t){let e=this._cameraBindGroups.get(t);e||(e=new Mn(this.modelMatrixBindGroup),this._cameraBindGroups.set(t,e)),t.isShadowCamera?e.setShadowCamera(t):e.setCamera(t)}static getLightEntries(t){t||console.log("getLightEntries scene is null");let e=this._lightEntriesMap.get(t);return e||(e=new Vu,this._lightEntriesMap.set(t,e)),this._lightEntriesMap.get(t)}static getReflectionEntries(t){t||console.log("getLightEntries scene is null");let e=this._reflectionEntriesMap.get(t);return e||(e=new Yu,this._reflectionEntriesMap.set(t,e)),this._reflectionEntriesMap.get(t)}}s(re,"_cameraBindGroups"),s(re,"_lightEntriesMap"),s(re,"_reflectionEntriesMap"),s(re,"modelMatrixBindGroup");const mt=class mt{static bindPipeline(t,e){if(mt.lastShader!=e)mt.lastShader=e;else return!1;mt.lastPipeline!=e.pipeline&&(mt.lastPipeline=e.pipeline,t.setPipeline(e.pipeline));for(let r=1;r<e.bindGroups.length;r++){const i=e.bindGroups[r];i&&t.setBindGroup(r,i)}return!0}static bindCamera(t,e){let r=re.getCameraGroup(e);t.setBindGroup(0,r.globalBindGroup)}static bindGeometryBuffer(t,e){if(this.lastGeometry!=e){this.lastGeometry=e,e.indicesBuffer&&t.setIndexBuffer(e.indicesBuffer.indicesGPUBuffer.buffer,e.indicesBuffer.indicesFormat);let r=e.vertexBuffer.vertexGPUBuffer,i=e.vertexBuffer.vertexBufferLayouts;for(let a=0;a<i.length;a++){const o=i[a];t.setVertexBuffer(a,r.buffer,o.offset,o.size)}}}static cleanCache(){this.lastGeometry=null,this.lastPipeline=null,this.lastShader=null}static createPipeline(t){return Fe.countStart("GPUContext","pipeline"),E.device.createRenderPipeline(t)}static beginCommandEncoder(){return Fe.countStart("GPUContext","beginCommandEncoder"),this.LastCommand&&E.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=E.device.createCommandEncoder(),this.LastCommand}static endCommandEncoder(t){this.LastCommand==t&&(E.device.queue.submit([this.LastCommand.finish()]),this.LastCommand=null,Fe.countStart("GPUContext","endCommandEncoder"))}static recordBundleEncoder(t){return E.device.createRenderBundleEncoder(t)}static beginRenderPass(t,e){if(this.cleanCache(),this.renderPassCount++,this.lastRenderPassState=e,e.depthTexture){let r=e.renderPassDescriptor.depthStencilAttachment;r.view=e.depthTexture.getGPUView()}if(e.renderTargets&&e.renderTargets.length>0){for(let r=0;r<e.renderTargets.length;++r){const i=e.renderTargets[r];let a=e.renderPassDescriptor.colorAttachments[r];e.multisample>0&&e.renderTargets.length==1?(a.view=e.multiTexture.createView(),a.resolveTarget=i.getGPUView()):a.view=i.getGPUTexture().createView()}return t.beginRenderPass(e.renderPassDescriptor)}else{let r=e.renderPassDescriptor.colorAttachments[0];return r&&(e.multisample>0?(r.view=e.multiTexture.createView(),r.resolveTarget=E.context.getCurrentTexture().createView()):r.view=E.context.getCurrentTexture().createView()),t.beginRenderPass(e.renderPassDescriptor)}}static drawIndexed(t,e,r,i,a,o){t.drawIndexed(e,r,i,a,o),this.drawCount++}static draw(t,e,r,i,a){t.draw(e,r,i,a),this.drawCount++}static endPass(t){t.insertDebugMarker("end"),t.end()}static computeCommand(t,e){let r=t.beginComputePass();for(let i=0;i<e.length;i++)e[i].compute(r);r.end()}static copyTexture(t,e,r){t.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{width:r.width,height:r.height,depthOrArrayLayers:1})}};s(mt,"lastGeometry"),s(mt,"lastPipeline"),s(mt,"lastShader"),s(mt,"drawCount",0),s(mt,"renderPassCount",0),s(mt,"geometryCount",0),s(mt,"pipelineCount",0),s(mt,"matrixCount",0),s(mt,"lastRenderPassState"),s(mt,"LastCommand");let S=mt;class Rn{constructor(){s(this,"source");s(this,"input");s(this,"output")}reset(t){this.input&&this.input.destroy(),this.output&&this.output.destroy(),this.input=this.output=null,this.source=t}apply(t){if(this.source){if(!this.input){let e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this.input=new be(this.source.length,e,this.source),this.input.apply()}if(!this.output){let e=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC;this.output=new be(t*3,e),this.output.apply()}}}}class Wu{constructor(){s(this,"enable");s(this,"morphTargetsRelative");s(this,"MaxMorphTargetCount",64);s(this,"_computeConfigArray");s(this,"_computeConfigBuffer");s(this,"_morphInfluenceArray");s(this,"_morphInfluenceBuffer");s(this,"_positionAttrDataGroup");s(this,"_normalAttrDataGroup");s(this,"_isInfluenceDirty");s(this,"_morphTargetCount");s(this,"_totalVertexCount");s(this,"_computeShader");s(this,"_computeShaders");s(this,"_computeWorkGroupXY",1);s(this,"_collectMorphTargetData");s(this,"_blendTarget");this._isInfluenceDirty=!0,this.generateGPUBuffer(),this._positionAttrDataGroup=new Rn,this._normalAttrDataGroup=new Rn}initMorphTarget(t){this._collectMorphTargetData=this.collectMorphTargetList(t),this._computeShader&&this._computeShader.destroy();let e=Ft.CsMain;this._computeShader=new ce(e),this._collectMorphTargetData.mergedNormal?this._computeShader.setDefine("USE_MORPHNORMALS",!0):this._computeShader.deleteDefine("USE_MORPHNORMALS"),this._computeShaders=[this._computeShader],this._isInfluenceDirty=!0,this._morphTargetCount=this._collectMorphTargetData.mtCount,this._totalVertexCount=this._collectMorphTargetData.vCount,this._morphInfluenceArray.fill(0),this._computeWorkGroupXY=this.calcWorkGroup(this._totalVertexCount),this._positionAttrDataGroup.reset(this._collectMorphTargetData.mergedPos),this._normalAttrDataGroup.reset(this._collectMorphTargetData.mergedNormal)}applyRenderShader(t){this.uploadMorphTargetBuffer(),this.uploadConfigGBuffer(),t.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),t.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&t.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)}computeMorphTarget(t){this.uploadConfigGBuffer(),this.uploadMorphTargetBuffer(),this._computeShader.setUniformBuffer("morphTargetConfig",this._computeConfigBuffer),this._computeShader.setStorageBuffer("morphTargetInfluence",this._morphInfluenceBuffer),this._computeShader.setStorageBuffer("morphTargetPositions",this._positionAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpPositions",this._positionAttrDataGroup.output),this._collectMorphTargetData.mergedNormal&&(this._computeShader.setStorageBuffer("morphTargetNormals",this._normalAttrDataGroup.input),this._computeShader.setStorageBuffer("morphTargetOpNormals",this._normalAttrDataGroup.output)),this._computeShader.workerSizeX=this._computeWorkGroupXY,this._computeShader.workerSizeY=this._computeWorkGroupXY,this._computeShader.workerSizeZ=1,S.computeCommand(t,this._computeShaders)}updateInfluence(t,e){this._isInfluenceDirty=!0,this._morphInfluenceArray[t]=e}get blendShape(){return this._blendTarget}collectMorphTargetList(t){let e=this.collectAttribute("a_morphPositions_",t),r=e.length,i=e[0].data.length/3;if(this._blendTarget={},t.blendShapeData)for(let h=0;h<t.blendShapeData.shapeIndexs.length;h++){let u=t.blendShapeData.shapeIndexs[h],c=t.blendShapeData.shapeNames[h].split("."),f=c[c.length-1];this._blendTarget[f]=d=>this.updateInfluence(u,d)}let a=new Float32Array(i*r*3);{let h=0;for(let u=0;u<r;u++){let c=e[u];a.set(c.data,h),h+=c.data.length}}let o=this.collectAttribute("a_morphNormals_",t),l;if(o&&o.length>0){let h=0;l=new Float32Array(i*r*3);for(let u=0;u<r;u++){let c=o[u];l.set(c.data,h),h+=c.data.length}}return{mtCount:r,vCount:i,mergedPos:a,mergedNormal:l}}collectAttribute(t,e){let r=[];for(let i=0;i<this.MaxMorphTargetCount;i++){let a=t+i,o=e.getAttribute(a);if(o)r[i]=o;else break}return r}uploadConfigGBuffer(){if(this._isInfluenceDirty){let t=0;for(let e=0;e<this._morphTargetCount;e++)t+=this._morphInfluenceArray[e];this._morphInfluenceBuffer.setFloat32Array("data",this._morphInfluenceArray),this._morphInfluenceBuffer.apply(),this._computeConfigArray[0]=this.morphTargetsRelative?1:1-t,this._computeConfigArray[1]=this._morphTargetCount,this._computeConfigArray[2]=this._totalVertexCount,this._computeConfigArray[3]=this._computeWorkGroupXY,this._computeConfigBuffer.setFloat32Array("data",this._computeConfigArray),this._computeConfigBuffer.apply(),this._isInfluenceDirty=!1}}calcWorkGroup(t){let e=Math.ceil(Math.sqrt(t)),r=Math.ceil(Math.log2(e));return e=Math.pow(2,r),e}uploadMorphTargetBuffer(){this._positionAttrDataGroup.output||this._positionAttrDataGroup.apply(this._totalVertexCount),this._normalAttrDataGroup.output||this._normalAttrDataGroup.apply(this._totalVertexCount)}generateGPUBuffer(){this._computeConfigArray=new Float32Array(4),this._computeConfigBuffer=new Ct(4),this._morphInfluenceArray=new Float32Array(this.MaxMorphTargetCount);let t=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST;this._morphInfluenceBuffer=new be(this.MaxMorphTargetCount,t)}}class Ce{}s(Ce,"GLTF_NODE_INDEX_PROPERTY"),s(Ce,"BASE_COLOR_UNIFORM","u_baseColorFactor"),s(Ce,"BASE_COLOR_TEXTURE_UNIFORM","u_baseColorSampler"),s(Ce,"METALROUGHNESS_UNIFORM","u_metallicRoughnessValues"),s(Ce,"METALROUGHNESS_TEXTURE_UNIFORM","u_metallicRoughnessSampler"),s(Ce,"NORMAL_TEXTURE_UNIFORM","u_normalSampler"),s(Ce,"NORMAL_SCALE_UNIFORM","u_normalScale"),s(Ce,"EMISSIVE_TEXTURE_UNIFORM","u_emissiveSampler"),s(Ce,"EMISSIVE_FACTOR_UNIFORM","u_emissiveFactor"),s(Ce,"OCCLUSION_TEXTURE_UNIFORM","u_occlusionSampler"),s(Ce,"OCCLUSION_FACTOR_UNIFORM","u_occlusionFactor"),s(Ce,"MAX_MORPH_TARGETS",8),s(Ce,"MORPH_POSITION_PREFIX","a_morphPositions_"),s(Ce,"MORPH_NORMAL_PREFIX","a_morphNormals_"),s(Ce,"MORPH_TANGENT_PREFIX","a_morphTangents_"),s(Ce,"MORPH_WEIGHT_UNIFORM","u_morphWeights"),s(Ce,"SCENE_ROOT_SKELETON","SCENE_ROOT"),s(Ce,"IDENTITY_INVERSE_BIND_MATRICES","IDENTITY_IBM"),s(Ce,"JOINT_MATRICES_UNIFORM","u_jointMatrix"),s(Ce,"ALPHA_CUTOFF_UNIFORM","u_alphaCutoff");var O=(n=>(n.position="position",n.normal="normal",n.uv="uv",n.TANGENT="TANGENT",n.TEXCOORD_1="TEXCOORD_1",n.TEXCOORD_2="TEXCOORD_2",n.TEXCOORD_3="TEXCOORD_3",n.TEXCOORD_4="TEXCOORD_4",n.TEXCOORD_5="TEXCOORD_5",n.TEXCOORD_6="TEXCOORD_6",n.TEXCOORD_7="TEXCOORD_7",n.color="color",n.joints0="joints0",n.joints1="joints1",n.weights0="weights0",n.weights1="weights1",n.weight="weight",n.indices="indices",n.vIndex="vIndex",n.a_morphPositions_0="a_morphPositions_0",n.all="all",n))(O||{}),oe=(n=>(n[n.NONE=0]="NONE",n[n.ABOVE=1]="ABOVE",n[n.ALPHA=2]="ALPHA",n[n.NORMAL=3]="NORMAL",n[n.ADD=4]="ADD",n[n.BELOW=5]="BELOW",n[n.ERASE=6]="ERASE",n[n.MUL=7]="MUL",n[n.SCREEN=8]="SCREEN",n[n.DIVD=9]="DIVD",n[n.SOFT_ADD=10]="SOFT_ADD",n))(oe||{}),Ku=(n=>(n[n.src_a=0]="src_a",n[n.dest_a=1]="dest_a",n))(Ku||{});class ju{static getBlend(t){let e={color:{srcFactor:"src-alpha",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}};switch(t){case 0:e.color.srcFactor="one",e.color.dstFactor="zero",e.color.operation="add";break;case 1:e.color.srcFactor="one-minus-src-alpha",e.color.dstFactor="dst-alpha",e.color.operation="add";break;case 4:e.color.srcFactor="one",e.color.dstFactor="one",e.color.operation="add",e.alpha.srcFactor="one",e.alpha.dstFactor="one",e.alpha.operation="add";break;case 2:e.color.srcFactor="src-alpha",e.color.dstFactor="one-minus-src-alpha",e.color.operation="add";break;case 5:e.color.srcFactor="one-minus-src-alpha",e.color.dstFactor="one",e.color.operation="add";break;case 6:e.color.srcFactor="zero",e.color.dstFactor="one-minus-src-alpha",e.color.operation="add";break;case 7:e.color.srcFactor="dst",e.color.dstFactor="one-minus-src-alpha",e.color.operation="add";break;case 3:e.color.srcFactor="src-alpha",e.color.dstFactor="one-minus-src-alpha",e.color.operation="add";break;case 10:e.color.srcFactor="one",e.color.dstFactor="one",e.color.operation="max",e.alpha.srcFactor="one",e.alpha.dstFactor="one",e.alpha.operation="add";break;case 8:e.color.srcFactor="one",e.color.dstFactor="one-minus-src",e.color.operation="add";break}return e}}const Qr=class Qr{static getMipmapPipeline(t){let e=E.device,r=Qr.pipelineCache[t.format];if(!r){const i=e.createShaderModule({code:Qr.mipmapShader});let a=e.createBindGroupLayout({entries:[{binding:0,visibility:t.visibility,sampler:t.samplerBindingLayout},{binding:1,visibility:t.visibility,texture:t.textureBindingLayout}]}),o=E.device.createPipelineLayout({bindGroupLayouts:[a]});r=e.createRenderPipeline({layout:o,vertex:{module:i,entryPoint:"vertexMain"},fragment:{module:i,entryPoint:"fragmentMain",targets:[{format:t.format}]},primitive:{topology:"triangle-strip",stripIndexFormat:"uint32"}}),Qr.pipelineCache[t.format]=r}return r}static webGPUGenerateMipmap(t){let e=E.device,r=t.textureDescriptor,i=Qr.getMipmapPipeline(t),a=t.getGPUTexture().createView({baseMipLevel:0,mipLevelCount:1});const o=S.beginCommandEncoder();for(let l=1;l<r.mipLevelCount;++l){const h=t.getGPUTexture().createView({baseMipLevel:l,mipLevelCount:1}),u=o.beginRenderPass({colorAttachments:[{view:h,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]});let c=e.createBindGroupLayout({entries:[{binding:0,visibility:t.visibility,sampler:t.samplerBindingLayout},{binding:1,visibility:t.visibility,texture:t.textureBindingLayout}]});const f=e.createBindGroup({layout:c,entries:[{binding:0,resource:t.gpuSampler},{binding:1,resource:a}]});u.setPipeline(i),u.setBindGroup(0,f),u.draw(4),u.end(),a=h}S.endCommandEncoder(o)}static getMipmapCount(t,e){let r=Math.max(t,e);return 1+Math.log2(r)|0}};s(Qr,"mipmapShader",`
        var<private> pos : array<vec2<f32>, 4> = array<vec2<f32>, 4>(
        vec2<f32>(-1.0, 1.0), vec2<f32>(1.0, 1.0),
        vec2<f32>(-1.0, -1.0), vec2<f32>(1.0, -1.0));

        struct VertexOutput {
        @builtin(position) position : vec4<f32>,
        @location(0) texCoord : vec2<f32>
        };

        @vertex
        fn vertexMain(@builtin(vertex_index) vertexIndex : u32) -> VertexOutput {
        var output : VertexOutput;
        output.texCoord = pos[vertexIndex] * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5);
        output.position = vec4<f32>(pos[vertexIndex], 0.0, 1.0);
        return output;
        }

        @binding(0) @group(0) var imgSampler : sampler;
        @binding(1) @group(0) var img : texture_2d<f32>;

        @fragment
        fn fragmentMain(@location(0) texCoord : vec2<f32>) -> @location(0) vec4<f32> {
        var outColor: vec4<f32> = textureSampleLevel(img, imgSampler, texCoord , 0.0 );
        return outColor;
        }
      `),s(Qr,"pipelineCache",{}),s(Qr,"pipeline");let jr=Qr;class It{constructor(t=32,e=32,r=1){s(this,"name");s(this,"url");s(this,"gpuTexture");s(this,"pid");s(this,"view");s(this,"gpuSampler");s(this,"gpuSampler_comparison");s(this,"format");s(this,"usage");s(this,"width",4);s(this,"height",4);s(this,"depthOrArrayLayers",1);s(this,"numberLayer",1);s(this,"viewDescriptor");s(this,"textureDescriptor");s(this,"visibility",GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT);s(this,"textureBindingLayout",{viewDimension:"2d",multisampled:!1});s(this,"samplerBindingLayout",{type:"filtering"});s(this,"sampler_comparisonBindingLayout",{type:"comparison"});s(this,"flipY");s(this,"isVideoTexture");s(this,"isHDRTexture");s(this,"_useMipmap",!1);s(this,"_sourceImageData");s(this,"_addressModeU");s(this,"_addressModeV");s(this,"_addressModeW");s(this,"_magFilter");s(this,"_minFilter");s(this,"_mipmapFilter");s(this,"_lodMinClamp");s(this,"_lodMaxClamp");s(this,"_compare");s(this,"_maxAnisotropy");s(this,"mipmapCount",1);s(this,"_textureChange",!1);s(this,"_stateChangeRef",new Map);this.width=t,this.height=e,this.numberLayer=r,this.minFilter=pi.linear,this.magFilter=pi.linear,this.mipmapFilter=pi.linear,this.addressModeU=Wt.repeat,this.addressModeV=Wt.repeat}init(){let t=this;return t.internalCreateBindingLayoutDesc&&t.internalCreateBindingLayoutDesc(),t.internalCreateTexture&&t.internalCreateTexture(),t.internalCreateView&&t.internalCreateView(),t.internalCreateSampler&&t.internalCreateSampler(),this}createTextureDescriptor(t,e,r,i,a=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.STORAGE_BINDING,o=1,l=0){this.width=t,this.height=e,this.format=i,this.usage=a,this.textureDescriptor={size:[t,e,o],mipLevelCount:r,format:i,usage:a,label:`${this.name+this.width+this.height+this.format}`},l>0&&(this.textureDescriptor.sampleCount=l),o>1?this.viewDescriptor={format:i,dimension:"2d-array"}:this.viewDescriptor={format:i,dimension:this.textureBindingLayout.viewDimension,mipLevelCount:r,baseMipLevel:0}}generate(t){let e=32,r=32;"width"in t&&(e=t.width,r=t.height),(e<32||r<32)&&console.log(t.name+"Size must be greater than 32!"),this.width=e,this.height=r,this.createTexture(t)}createTexture(t){this._sourceImageData=t,this.updateTextureDescription(),this.updateGPUTexture();let e=E.device;this.gpuTexture instanceof GPUTexture&&e.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),this.useMipmap&&jr.webGPUGenerateMipmap(this)}get useMipmap(){return this._useMipmap}set useMipmap(t){if(t){if(this.samplerBindingLayout.type="filtering",this._useMipmap==!1&&this._sourceImageData){this._useMipmap=!0,this.updateTextureDescription(),this.updateGPUTexture();let e=E.device;this.gpuTexture instanceof GPUTexture&&e.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height]),jr.webGPUGenerateMipmap(this)}}else if(this.samplerBindingLayout.type="non-filtering",this._useMipmap==!0&&this._sourceImageData){this._useMipmap=!1,this.updateTextureDescription(),this.updateGPUTexture();let e=E.device;this.gpuTexture instanceof GPUTexture&&e.queue.copyExternalImageToTexture({source:this._sourceImageData},{texture:this.gpuTexture},[this.width,this.height])}this._textureChange=!0,this._useMipmap=t,this.noticeChange()}get sourceImageData(){return this._sourceImageData}getMipmapCount(){let t=this.width,e=this.height,r=Math.max(t,e);return 1+Math.log2(r)|0}updateTextureDescription(){this.mipmapCount=Math.floor(this.useMipmap?this.getMipmapCount():1),this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format)}updateGPUTexture(){this.gpuTexture&&this.gpuTexture instanceof GPUTexture&&this.gpuTexture.destroy(),this.gpuTexture=null,this.view=null,this.gpuTexture=this.getGPUTexture()}getGPUTexture(){return this.gpuTexture||(this.gpuTexture=E.device.createTexture(this.textureDescriptor)),this.gpuTexture}getGPUView(t=0){return this.view||(this.gpuTexture=this.getGPUTexture(),this.gpuTexture instanceof GPUTexture&&(this.view=this.gpuTexture.createView(this.viewDescriptor),this.view.label=this.name)),this.view}bindStateChange(t,e){this._stateChangeRef.set(e,t)}unBindStateChange(t){this._stateChangeRef.delete(t)}noticeChange(){this.gpuSampler=E.device.createSampler(this),this._stateChangeRef.forEach((t,e)=>{t()})}destroy(t){t&&this.gpuTexture instanceof GPUTexture&&(this.gpuSampler=null,this.gpuSampler_comparison=null,this.textureBindingLayout=null,this.textureDescriptor=null,this.gpuTexture.destroy(),this.gpuTexture=null),this._stateChangeRef.clear()}get addressModeU(){return this._addressModeU}set addressModeU(t){this._addressModeU!=t&&(this._addressModeU=t,this.noticeChange())}get addressModeV(){return this._addressModeV}set addressModeV(t){this._addressModeV!=t&&(this._addressModeV=t,this.noticeChange())}get addressModeW(){return this._addressModeW}set addressModeW(t){this._addressModeW!=t&&(this._addressModeW=t,this.noticeChange())}get magFilter(){return this._magFilter}set magFilter(t){this._magFilter!=t&&(this._magFilter=t,this.noticeChange())}get minFilter(){return this._minFilter}set minFilter(t){this._minFilter!=t&&(this._minFilter=t,this.noticeChange())}get mipmapFilter(){return this._mipmapFilter}set mipmapFilter(t){this._mipmapFilter!=t&&(this._mipmapFilter=t,this.noticeChange())}get lodMinClamp(){return this._lodMinClamp}set lodMinClamp(t){this._lodMinClamp!=t&&(this._lodMinClamp=t,this.noticeChange())}get lodMaxClamp(){return this._lodMaxClamp}set lodMaxClamp(t){this._lodMaxClamp!=t&&(this._lodMaxClamp=t,this.noticeChange())}get compare(){return this._compare}set compare(t){this._compare!=t&&(this._compare=t,this.noticeChange())}get maxAnisotropy(){return this._maxAnisotropy}set maxAnisotropy(t){this._maxAnisotropy!=t&&(this._maxAnisotropy=t,this.noticeChange())}static delayDestroyTexture(t){this._texs.includes(t)||this._texs.push(t)}static destroyTexture(){if(this._texs.length>0)for(;this._texs.length>0;)this._texs.shift().destroy()}}s(It,"_texs",[]);class qu extends It{constructor(e,r,i){super(e,r,i);s(this,"_bitmapTextures");this.format=j.rgba8unorm,this.mipmapCount=1,this._bitmapTextures=[],this.init()}setTextures(e){this._bitmapTextures.length=0;for(let r=0;r<e.length;r++){const i=e[r];this.addTexture(i)}}addTexture(e){(e.width!=this.width||e.height!=this.height)&&console.error("bitmap texture must match bitmapTextureArray size!"),e.pid=this._bitmapTextures.length,this._bitmapTextures.push(e),this.updateTexture()}removeTexture(e){let r=this._bitmapTextures.indexOf(e);if(r!=-1){this._bitmapTextures.splice(r,1);for(let i=0;i<this._bitmapTextures.length;i++){const a=this._bitmapTextures[i];a.pid=i}}}updateTexture(){let e=S.beginCommandEncoder();for(let r=0;r<this._bitmapTextures.length;r++){let i=this._bitmapTextures[r];e.copyTextureToTexture({texture:i.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:r}},{width:this.width,height:this.height,depthOrArrayLayers:1})}S.endCommandEncoder(e)}internalCreateBindingLayoutDesc(){this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.minFilter=pi.linear,this.magFilter=pi.linear}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=E.device.createSampler(this)}}const gr=class gr{constructor(){s(this,"_iesTexture");s(this,"index",0)}generateIES(t){}set IESTexture(t){this._iesTexture=t,t.addressModeU=Wt.repeat,t.addressModeV=Wt.repeat,t.addressModeW=Wt.repeat,gr.ies_list.indexOf(this)==-1&&(this.index=gr.ies_list.length,gr.ies_list.push(this),gr.iesTexture||gr.create(t.width,t.height),gr.iesTexture.addTexture(t))}get IESTexture(){return this._iesTexture}static create(t,e){let r=48;this.iesTexture=new qu(t,e,r)}};s(gr,"use",!1),s(gr,"iesTexture"),s(gr,"ies_list",[]);let ga=gr;class cs{constructor(t=0,e="\0"){s(this,"Type",0);s(this,"Line",0);s(this,"Colume",0);s(this,"Literal","");this.Type=t,this.Literal=e}isTypeEqual(t){return this.Type==t}isLiteralEqual(t){return this.Literal==t}isBuiltinType(){return this.Type>33&&this.Type<101}isDataType(){return this.Type==1||this.isBuiltinType()}isOperation(){return this.Type>102&&this.Type<127}isAssignOperation(){return this.Type>128&&this.Type<133}get nOperationPriorityLevel(){switch(this.Type){case 26:return 1;case 27:return 1;case 125:return 2;case 110:return 3;case 114:return 3;case 105:return 4;case 106:return 4;case 103:return 5;case 104:return 5;case 115:return 6;case 116:return 6;case 119:return 7;case 120:return 7;case 122:return 7;case 123:return 7;case 121:return 8;case 124:return 8;case 111:return 9;case 113:return 10;case 112:return 11;case 107:return 12;case 109:return 13;case 108:return 14;case 24:return 15;case 126:return 16;case 129:return 16;case 130:return 16;case 131:return 16;case 132:return 16}return 99}}var _=(n=>(n[n.EOF=0]="EOF",n[n.IDENT=1]="IDENT",n[n.VOID=2]="VOID",n[n.CONST=3]="CONST",n[n.LAYOUT=4]="LAYOUT",n[n.PRECISION=5]="PRECISION",n[n.ATTRIBUTE=6]="ATTRIBUTE",n[n.UNIFORM=7]="UNIFORM",n[n.VARYING=8]="VARYING",n[n.INVARIANT=9]="INVARIANT",n[n.IN=10]="IN",n[n.OUT=11]="OUT",n[n.INOUT=12]="INOUT",n[n.IF=13]="IF",n[n.ELSE=14]="ELSE",n[n.FOR=15]="FOR",n[n.WHILE=16]="WHILE",n[n.DO=17]="DO",n[n.BREAK=18]="BREAK",n[n.RETURN=19]="RETURN",n[n.CONTINUE=20]="CONTINUE",n[n.STRUCT=21]="STRUCT",n[n.COMMA=22]="COMMA",n[n.COLON=23]="COLON",n[n.QUEMARK=24]="QUEMARK",n[n.SEMICOLON=25]="SEMICOLON",n[n.LEFTSAMLL=26]="LEFTSAMLL",n[n.RIGHTSAMLL=27]="RIGHTSAMLL",n[n.LEFTMEDI=28]="LEFTMEDI",n[n.RIGHTMEDI=29]="RIGHTMEDI",n[n.LEFTBIG=30]="LEFTBIG",n[n.RIGHTBIG=31]="RIGHTBIG",n[n.LITERAL=32]="LITERAL",n[n.BeginBuiltinType=33]="BeginBuiltinType",n[n.INT=34]="INT",n[n.INT_ARRAY=35]="INT_ARRAY",n[n.UINT=36]="UINT",n[n.UINT_ARRAY=37]="UINT_ARRAY",n[n.BOOL=38]="BOOL",n[n.BOOL_ARRAY=39]="BOOL_ARRAY",n[n.FLOAT=40]="FLOAT",n[n.FLOAT_ARRAY=41]="FLOAT_ARRAY",n[n.DOUBLE=42]="DOUBLE",n[n.DOUBLE_ARRAY=43]="DOUBLE_ARRAY",n[n.VEC2=44]="VEC2",n[n.VEC2_ARRAY=45]="VEC2_ARRAY",n[n.VEC3=46]="VEC3",n[n.VEC3_ARRAY=47]="VEC3_ARRAY",n[n.VEC4=48]="VEC4",n[n.VEC4_ARRAY=49]="VEC4_ARRAY",n[n.BVEC2=50]="BVEC2",n[n.BVEC2_ARRAY=51]="BVEC2_ARRAY",n[n.BVEC3=52]="BVEC3",n[n.BVEC3_ARRAY=53]="BVEC3_ARRAY",n[n.BVEC4=54]="BVEC4",n[n.BVEC4_ARRAY=55]="BVEC4_ARRAY",n[n.IVEC2=56]="IVEC2",n[n.IVEC2_ARRAY=57]="IVEC2_ARRAY",n[n.IVEC3=58]="IVEC3",n[n.IVEC3_ARRAY=59]="IVEC3_ARRAY",n[n.IVEC4=60]="IVEC4",n[n.IVEC4_ARRAY=61]="IVEC4_ARRAY",n[n.UVEC2=62]="UVEC2",n[n.UVEC2_ARRAY=63]="UVEC2_ARRAY",n[n.UVEC3=64]="UVEC3",n[n.UVEC3_ARRAY=65]="UVEC3_ARRAY",n[n.UVEC4=66]="UVEC4",n[n.UVEC4_ARRAY=67]="UVEC4_ARRAY",n[n.MAT2x2=68]="MAT2x2",n[n.MAT2x2_ARRAY=69]="MAT2x2_ARRAY",n[n.MAT2x3=70]="MAT2x3",n[n.MAT2x3_ARRAY=71]="MAT2x3_ARRAY",n[n.MAT2x4=72]="MAT2x4",n[n.MAT2x4_ARRAY=73]="MAT2x4_ARRAY",n[n.MAT3x2=74]="MAT3x2",n[n.MAT3x2_ARRAY=75]="MAT3x2_ARRAY",n[n.MAT3x3=76]="MAT3x3",n[n.MAT3x3_ARRAY=77]="MAT3x3_ARRAY",n[n.MAT3x4=78]="MAT3x4",n[n.MAT3x4_ARRAY=79]="MAT3x4_ARRAY",n[n.MAT4x2=80]="MAT4x2",n[n.MAT4x2_ARRAY=81]="MAT4x2_ARRAY",n[n.MAT4x3=82]="MAT4x3",n[n.MAT4x3_ARRAY=83]="MAT4x3_ARRAY",n[n.MAT4x4=84]="MAT4x4",n[n.MAT4x4_ARRAY=85]="MAT4x4_ARRAY",n[n.SAMPLER=86]="SAMPLER",n[n.SAMPLER_1D=87]="SAMPLER_1D",n[n.SAMPLER_2D=88]="SAMPLER_2D",n[n.SAMPLER_3D=89]="SAMPLER_3D",n[n.SAMPLER_CUBE=90]="SAMPLER_CUBE",n[n.SAMPLER_SHADOW=91]="SAMPLER_SHADOW",n[n.SAMPLER_1D_SHADOW=92]="SAMPLER_1D_SHADOW",n[n.SAMPLER_2D_SHADOW=93]="SAMPLER_2D_SHADOW",n[n.TEXTURE_1D=94]="TEXTURE_1D",n[n.TEXTURE_1D_ARRAY=95]="TEXTURE_1D_ARRAY",n[n.TEXTURE_2D=96]="TEXTURE_2D",n[n.TEXTURE_2D_ARRAY=97]="TEXTURE_2D_ARRAY",n[n.TEXTURE_3D=98]="TEXTURE_3D",n[n.TEXTURE_CUBE=99]="TEXTURE_CUBE",n[n.TEXTURE_CUBE_ARRAY=100]="TEXTURE_CUBE_ARRAY",n[n.EndBuiltinType=101]="EndBuiltinType",n[n.BeginOperation=102]="BeginOperation",n[n.ADD=103]="ADD",n[n.SUB=104]="SUB",n[n.MUL=105]="MUL",n[n.DIV=106]="DIV",n[n.AND=107]="AND",n[n.OR=108]="OR",n[n.XOR=109]="XOR",n[n.NOT=110]="NOT",n[n.BITAND=111]="BITAND",n[n.BITOR=112]="BITOR",n[n.BITXOR=113]="BITXOR",n[n.BITNOT=114]="BITNOT",n[n.BITSHIFT_L=115]="BITSHIFT_L",n[n.BITSHIFT_R=116]="BITSHIFT_R",n[n.INC=117]="INC",n[n.DEC=118]="DEC",n[n.GREATER=119]="GREATER",n[n.GREATEREQUAL=120]="GREATEREQUAL",n[n.EQUAL=121]="EQUAL",n[n.LESS=122]="LESS",n[n.LESSEQUAL=123]="LESSEQUAL",n[n.NOTEQUAL=124]="NOTEQUAL",n[n.DOT=125]="DOT",n[n.ASSIGN=126]="ASSIGN",n[n.EndOperation=127]="EndOperation",n[n.BeginAssignOperation=128]="BeginAssignOperation",n[n.ADDASSIGN=129]="ADDASSIGN",n[n.SUBASSIGN=130]="SUBASSIGN",n[n.MULASSIGN=131]="MULASSIGN",n[n.DIVASSIGN=132]="DIVASSIGN",n[n.EndAssignOperation=133]="EndAssignOperation",n))(_||{});class pa{constructor(t){s(this,"_char");s(this,"_line");s(this,"_column");s(this,"_source");s(this,"_currPosition");s(this,"_nextPosition");this.reset(t)}reset(t){this._char="",this._line=0,this._column=0,this._source=t,this._currPosition=0,this._nextPosition=0}get source(){return this._source}getChar(){return this._char}get currPosition(){return this._currPosition}peekChar(){return this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition]}readChar(){this._char=this._nextPosition>=this._source.length?"\0":this._source[this._nextPosition],this._char!==`
`?this._column++:(this._line++,this._column=0),this._currPosition=this._nextPosition,this._nextPosition++}readCharAndSkipWhitespace(){this.readChar(),this.skipWhitespace()}readIdentifier(){for(var t=this._currPosition;this.isIdentifier(this._char);)this.readChar();return this._source.substring(t,this._currPosition)}isIdentifier(t){var e=t.charCodeAt(0);return 97<=e&&e<=122||65<=e&&e<=90||48<=e&&e<=57||e==95}skipWhitespace(){for(;this.IsWhitespace(this._char);)this.readChar()}IsWhitespace(t){return t===" "||t==="	"||t==="\r"||t===`
`}skipComment(){for(;this._char!==`
`&&this._char!=="\0";)this.readChar();this.skipWhitespace()}skipMultilineComment(){if(!(this._char!=="/"&&this.peekChar()!=="*")){this.readChar(),this.readChar();for(let t=1;t>0&&this._char!=="\0";)if(this.readChar(),this._char==="/"&&this.peekChar()==="*"){t++,this.readChar();continue}else if(this._char==="*"&&this.peekChar()==="/"){t--,this.readChar();continue}this.readChar(),this.readChar(),this.skipWhitespace()}}isDigit(t){var e=t.charCodeAt(0);return 48<=e&&e<=57}readNumber(){for(var t=this._currPosition;this.isDigit(this._char);)this.readChar();if(this._char===".")for(this.readChar();this.isDigit(this._char);)this.readChar();return this._source.substring(t,this._currPosition)}readValue(){return this.isDigit(this._char)?this.readNumber():this.readIdentifier()}readLine(){var t=this._currPosition,e=this._source.indexOf(`
`,this._currPosition);return e==-1&&(e=this._source.length),this._line++,this._column=0,this._currPosition=e,this._nextPosition=e+1,this._source.substring(t,e+1)}}class Ju extends pa{constructor(e){super(e.source);s(this,"_tokenPosition",0);s(this,"_tokens",[]);this.parse()}skipToken(e){this._tokenPosition+=e}peekToken(e){return this._tokenPosition+e>=this._tokens.length?new cs(_.EOF,"\0"):this._tokens[this._tokenPosition+e]}GetNextToken(){if(this._tokenPosition>=this._tokens.length)return new cs(_.EOF,"\0");let e=this._tokens[this._tokenPosition];return this._tokenPosition++,e}get currTokenPosition(){return this._tokenPosition}parse(){this.readChar(),this._tokens=new Array;var e;do e=this.nextToken(),this._tokens.push(e);while(e.Type!=_.EOF)}nextToken(){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/")return this.skipComment(),this.nextToken();if(this.peekChar()==="*")return this.skipMultilineComment(),this.nextToken()}var e=new cs;switch(e.Line=this._line,e.Colume=this._column,this._char){case"\0":e.Type=_.EOF,e.Literal="EOF";break;case".":e.Type=_.DOT,e.Literal=".";break;case",":e.Type=_.COMMA,e.Literal=",";break;case":":e.Type=_.COLON,e.Literal=":";break;case"?":e.Type=_.QUEMARK,e.Literal="?";break;case";":e.Type=_.SEMICOLON,e.Literal=";";break;case"(":e.Type=_.LEFTSAMLL,e.Literal="(";break;case")":e.Type=_.RIGHTSAMLL,e.Literal=")";break;case"[":e.Type=_.LEFTMEDI,e.Literal="[";break;case"]":e.Type=_.RIGHTMEDI,e.Literal="]";break;case"{":e.Type=_.LEFTBIG,e.Literal="{";break;case"}":e.Type=_.RIGHTBIG,e.Literal="}";break;case"+":if(this.peekChar()==="+"){this.readChar(),e.Type=_.INC,e.Literal="++";break}else if(this.peekChar()==="="){this.readChar(),e.Type=_.ADDASSIGN,e.Literal="+=";break}e.Type=_.ADD,e.Literal="+";break;case"-":if(this.peekChar()==="-"){this.readChar(),e.Type=_.DEC,e.Literal="--";break}else if(this.peekChar()==="="){this.readChar(),e.Type=_.SUBASSIGN,e.Literal="-=";break}e.Type=_.SUB,e.Literal="-";break;case"*":if(this.peekChar()==="="){this.readChar(),e.Type=_.MULASSIGN,e.Literal="*=";break}e.Type=_.MUL,e.Literal="*";break;case"/":if(this.peekChar()==="="){this.readChar(),e.Type=_.DIVASSIGN,e.Literal="/=";break}e.Type=_.DIV,e.Literal="/";break;case"&":if(this.peekChar()==="&"){this.readChar(),e.Type=_.AND,e.Literal="&&";break}e.Type=_.BITAND,e.Literal="&";break;case"|":if(this.peekChar()==="|"){this.readChar(),e.Type=_.OR,e.Literal="||";break}e.Type=_.BITOR,e.Literal="&";break;case"^":e.Type=_.BITXOR,e.Literal="^";break;case"!":if(this.peekChar()==="="){this.readChar(),e.Type=_.NOTEQUAL,e.Literal="!=";break}e.Type=_.NOT,e.Literal="!";break;case">":if(this.peekChar()==="="){this.readChar(),e.Type=_.GREATEREQUAL,e.Literal=">=";break}else if(this.peekChar()===">"){this.readChar(),e.Type=_.BITSHIFT_R,e.Literal=">>";break}e.Type=_.GREATER,e.Literal=">";break;case"=":if(this.peekChar()==="="){this.readChar(),e.Type=_.EQUAL,e.Literal="==";break}e.Type=_.ASSIGN,e.Literal="=";break;case"<":if(this.peekChar()==="="){this.readChar(),e.Type=_.LESSEQUAL,e.Literal="<=";break}else if(this.peekChar()==="<"){this.readChar(),e.Type=_.BITSHIFT_L,e.Literal="<<";break}e.Type=_.LESS,e.Literal="<";break;default:return this.isDigit(this._char)?this.readDecimal():(e.Literal=this.readIdentifier(),e.Type=this.lookupIdentifier(e.Literal),this.getChar()=="["&&this.peekChar()=="]"&&e.isBuiltinType()&&(e.Type++,e.Literal+="[]",this.readChar(),this.readChar()),e)}return this.readChar(),e}readDecimal(){var e=new cs;e.Line=this._line,e.Colume=this._column,e.Type=_.LITERAL;var r=this.readNumber();return this._char==="e"?(e.Literal=r+this._char,this.readChar(),e.Literal+=this._char,this.readChar(),e.Literal+=this.readNumber(),e.Type=_.LITERAL,e):this._char==="u"?(this.readChar(),e.Type=_.LITERAL,e.Literal=r+"u",e):this._char==="f"?(this.readChar(),e.Type=_.LITERAL,e.Literal=r+"f",e):(e.Type=_.LITERAL,e.Literal=r,e)}lookupIdentifier(e){switch(e){case"void":return _.VOID;case"int":return _.INT;case"uint":return _.UINT;case"bool":return _.BOOL;case"true":return _.BOOL;case"false":return _.BOOL;case"float":return _.FLOAT;case"vec2":return _.VEC2;case"vec3":return _.VEC3;case"vec4":return _.VEC4;case"bvec2":return _.BVEC2;case"bvec3":return _.BVEC3;case"bvec4":return _.BVEC4;case"ivec2":return _.IVEC2;case"ivec3":return _.IVEC3;case"ivec4":return _.IVEC4;case"uvec2":return _.UVEC2;case"uvec3":return _.UVEC3;case"uvec4":return _.UVEC4;case"mat2":return _.MAT2x2;case"mat2x2":return _.MAT2x2;case"mat2x3":return _.MAT2x3;case"mat2x4":return _.MAT2x4;case"mat3":return _.MAT3x3;case"mat3x2":return _.MAT3x2;case"mat3x3":return _.MAT3x3;case"mat3x4":return _.MAT3x4;case"mat4":return _.MAT4x4;case"mat4x2":return _.MAT4x2;case"mat4x3":return _.MAT4x3;case"mat4x4":return _.MAT4x4;case"sampler":return _.SAMPLER;case"sampler1D":return _.SAMPLER_1D;case"sampler2D":return _.SAMPLER_2D;case"sampler3D":return _.SAMPLER_3D;case"samplerCube":return _.SAMPLER_CUBE;case"samplerShadow":return _.SAMPLER_SHADOW;case"sampler1DShadow":return _.SAMPLER_1D_SHADOW;case"sampler2DShadow":return _.SAMPLER_2D_SHADOW;case"texture1D":return _.TEXTURE_1D;case"texture2D":return _.TEXTURE_2D;case"texture3D":return _.TEXTURE_3D;case"textureCube":return _.TEXTURE_CUBE;case"texture1DArray":return _.TEXTURE_1D_ARRAY;case"texture2DArray":return _.TEXTURE_2D_ARRAY;case"textureCubeArray":return _.TEXTURE_CUBE_ARRAY;case"const":return _.CONST;case"layout":return _.LAYOUT;case"precision":return _.PRECISION;case"attribute":return _.ATTRIBUTE;case"uniform":return _.UNIFORM;case"varying":return _.VARYING;case"invariant":return _.INVARIANT;case"in":return _.IN;case"out":return _.OUT;case"inout":return _.INOUT;case"if":return _.IF;case"else":return _.ELSE;case"for":return _.FOR;case"while":return _.WHILE;case"do":return _.DO;case"break":return _.BREAK;case"return":return _.RETURN;case"continue":return _.CONTINUE;case"struct":return _.STRUCT}return _.IDENT}}class Zu{constructor(){s(this,"name","");s(this,"value","");s(this,"args",[])}}class $u extends pa{constructor(e){super(e);s(this,"_result");s(this,"_skipLine");s(this,"_definitionTables");this._result="",this._skipLine=!1,this._definitionTables=new Map,this.parse()}parse(){for(this.readChar();this._char!=="\0";){if(this.skipWhitespace(),this._char==="/"){if(this.peekChar()==="/"){this.skipComment();continue}if(this.peekChar()==="*"){this.skipMultilineComment();continue}}if(this._char==="#"){this.readCharAndSkipWhitespace();var e=this.readIdentifier();switch(e){case"version":this.readLine().trim();break;case"define":this.readCharAndSkipWhitespace();var r=this.readIdentifier();if(this.getChar()==="("){let h=new Zu;if(this.readCharAndSkipWhitespace(),this.getChar()!==")")do{var i=this.readIdentifier();if(h.args.push(i),this.skipWhitespace(),this.getChar()===","){this.readCharAndSkipWhitespace();continue}}while(this.getChar()!==")");this.readCharAndSkipWhitespace(),h.name=r,h.value=this.readLine().trim(),this._definitionTables.set(r,h),this.readCharAndSkipWhitespace()}else{let h=this.readLine().trim();h[0]=="="&&(h=h.substring(1)),this._definitionTables.set(r,h)}break;case"if":let l=this.readLine().trim();if(l=="0"||l=="false"){this._skipLine=!0;break}if(this._definitionTables.has(l)&&(l=this._definitionTables.get(l),l=="0"||l=="false")){this._skipLine=!0;break}break;case"ifdef":this.readCharAndSkipWhitespace();var a=this.readIdentifier();this._skipLine=!this._definitionTables.has(a);break;case"else":this._skipLine=!this._skipLine;break;case"endif":this._skipLine=!1;break;default:throw"Unknown preprocessing command:"+e}}else{var o=this.readLine();if(!this._skipLine){for(let l of this._definitionTables.keys()){let h=o.indexOf(l);if(h!=-1){let u=this._definitionTables.get(l);if(typeof u=="string")o=o.replace(l,u);else{let c=u,f=new pa(o.substring(h+l.length));if(f.readCharAndSkipWhitespace(),f.getChar()==="("){f.readCharAndSkipWhitespace();for(let x=1;f.getChar()!=="\0"&&x>0;){switch(f.getChar()){case"(":x++;break;case")":x--;break}f.readCharAndSkipWhitespace()}}let d=h,p=d+l.length+f.currPosition,A=o.substring(d,p).trim();if(c.args.length>0){let x=[],C=A.substring(A.indexOf("(")+1,A.lastIndexOf(")")).trim();C.length>0&&(x=this.parseArgs(C));let v=c.value.substring(c.value.indexOf("("));for(let y=0;y<c.args.length;y++)v=v.replace(c.args[y],x[y]);v=c.value.substring(0,c.value.indexOf("("))+v,o=o.replace(A,v)}else o=o.replace(A,c.value)}}}this._result+=o}this.readChar()}}}get source(){return this._result}parseArgs(e){let r=[],i=0,a=new pa(e),o=a.currPosition;if(a.readCharAndSkipWhitespace(),a.getChar()!=="\0")for(a.readCharAndSkipWhitespace();a.getChar()!=="\0";){switch(a.getChar()){case"(":i++;break;case")":i--;break;case",":if(i==0){let l=e.substring(o,a.currPosition);r.push(l),o=a.currPosition+1}break}a.readCharAndSkipWhitespace()}if(o<a.currPosition){let l=e.substring(o,a.currPosition);r.push(l)}return r}}class ec{constructor(t){s(this,"result");s(this,"ASTRoot");s(this,"_syntax");this.result="",this._syntax=t,this.ASTRoot=t.ASTRoot}generateWGSL(){let t=new Un;var e=new ac;let r=[],i=[],a=[];for(let c of this.ASTRoot.nodes)if(c instanceof ps)if(c.scope=="in")if(c.nodes[0]instanceof ke){t.layoutsIn.push(c);let f=new On;f.name=c.nodes[0].name,f.type=c.nodes[0].type,f.locationID=Number.parseInt(c.qualifier.get("location")),e.inputAttribute.push(f)}else if(c.qualifier.has("local_size_x"))t.workGroupSize=c;else throw"not impl";else if(c.scope=="out")if(t.layoutsOut.push(c),c.nodes[0]instanceof ke){let f=new On;f.name=c.nodes[0].name,f.type=c.nodes[0].type,f.locationID=Number.parseInt(c.qualifier.get("location")),e.outputAttribute.push(f)}else throw"not impl";else if(c.scope=="uniform")if(i.push(c),c.nodes[0]instanceof ke){let f=new Ln;f.name=c.nodes[0].name,f.type=c.nodes[0].type,f.setID=Number.parseInt(c.qualifier.get("set")),f.bindingID=Number.parseInt(c.qualifier.get("binding")),e.uniformInfo.push(f)}else if(c.nodes[0]instanceof qr){let f=new Ln;f.name="unif"+e.uniformInfo.length.toString(),f.type=c.nodes[0].name,f.setID=Number.parseInt(c.qualifier.get("set")),f.bindingID=Number.parseInt(c.qualifier.get("binding")),e.uniformInfo.push(f)}else throw"not impl";else c.scope=="buffer"&&r.push(c);else a.push(c);t.stage="fragment";let o=0,l=new pa(""),h=this._syntax.lexer.source,u=new Map;for(;(o=h.indexOf("gl_",o))!=-1;){l.reset(h.substring(o,o+32)),l.readChar();let c=l.readIdentifier();if(o+=c.length,!u.has(c))switch(u.set(c,c),c){case"gl_InstanceID":t.stage="vertex",t.builtinIn.push("@builtin(instance_index) gl_InstanceID: u32");break;case"gl_Position":t.stage="vertex",t.builtinOut.push("@builtin(position) gl_Position: vec4<f32>"),t.addIdentifier("gl_Position","stout.gl_Position");break;case"gl_VertexIndex":t.stage="vertex",t.builtinIn.push("@builtin(vertex_index) gl_VertexIndex: u32");break;case"gl_FrontFacing":t.stage="fragment",t.builtinIn.push("@builtin(front_facing) gl_FrontFacing: bool");break;case"gl_FragDepth":t.stage="fragment",t.builtinOut.push("@builtin(frag_depth) gl_FragDepth: f32"),t.addIdentifier("gl_FragDepth","stout.gl_FragDepth");break;case"gl_WorkGroupID":t.stage="compute",t.builtinIn.push("@builtin(workgroup_id) gl_WorkGroupID: vec3<u32>");break;case"gl_NumWorkGroups":t.stage="compute",t.builtinIn.push("@builtin(num_workgroups) gl_NumWorkGroups: vec3<u32>");break;case"gl_LocalInvocationID":t.stage="compute",t.builtinIn.push("@builtin(local_invocation_id) gl_LocalInvocationID: vec3<u32>");break;case"gl_LocalInvocationIndex":t.stage="compute",t.builtinIn.push("@builtin(local_invocation_index) gl_LocalInvocationIndex: u32");break;case"gl_GlobalInvocationID":t.stage="compute",t.builtinIn.push("@builtin(global_invocation_id) gl_GlobalInvocationID: vec3<u32>");break;default:throw"Unprocessed built-in variables: "+c}}for(let c of i)c.nodes[0]instanceof qr&&(e.sourceCode+=c.nodes[0].formatToWGSL(t,0),e.sourceCode+=`\r
`);for(let c of i)e.sourceCode+=c.formatToWGSL(t,0);e.sourceCode+=`\r
`;for(let c of r)c.nodes[0]instanceof qr&&(e.sourceCode+=c.nodes[0].formatToWGSL(t,0),e.sourceCode+=`\r
`);for(let c of r)e.sourceCode+=c.formatToWGSL(t,0);e.sourceCode+=`\r
`;for(let c of a)e.sourceCode+=c.formatToWGSL(t,0),c instanceof ke&&(e.sourceCode+=`;\r
`);return e}}class Un{constructor(t){s(this,"_stage","fragment");s(this,"_builtinIn",[]);s(this,"_builtinOut",[]);s(this,"_layoutsIn",[]);s(this,"_layoutsOut",[]);s(this,"_layoutUniformCount",0);s(this,"_workGroupSize");s(this,"_parentContext");s(this,"_identifierEnv",new Map);this._parentContext=t}get stage(){return this.parentContext!=null?this.parentContext.stage:this._stage}set stage(t){this.parentContext!=null&&(this.parentContext.stage=t),this._stage=t}get builtinIn(){return this.parentContext!=null?this.parentContext.builtinIn:this._builtinIn}get builtinOut(){return this.parentContext!=null?this.parentContext.builtinOut:this._builtinOut}get layoutsIn(){return this.parentContext!=null?this.parentContext.layoutsIn:this._layoutsIn}get layoutsOut(){return this.parentContext!=null?this.parentContext.layoutsOut:this._layoutsOut}get layoutUniformCount(){return this.parentContext!=null?this.parentContext.layoutUniformCount:this._layoutUniformCount}set layoutUniformCount(t){if(this.parentContext!=null){this.parentContext.layoutUniformCount=t;return}this._layoutUniformCount=t}get workGroupSize(){return this.parentContext!=null?this.parentContext.workGroupSize:this._workGroupSize}set workGroupSize(t){this.parentContext!=null&&(this.parentContext.workGroupSize=t),this._workGroupSize=t}get parentContext(){return this._parentContext}findIdentifier(t){return this._identifierEnv.has(t)?this._identifierEnv.get(t):this._parentContext!=null?this._parentContext.findIdentifier(t):t}addIdentifier(t,e){this._identifierEnv.set(t,e)}hasIdentifier(t){return this._identifierEnv.has(t)}}class Ue{constructor(){s(this,"nodes",[])}addNode(t){this.nodes.push(t)}formatToWGSL(t,e){return""}}class qr extends Ue{constructor(e){super();s(this,"name","");s(this,"fields",[]);this.name=e}static parse(e){if(e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.LEFTBIG){let r=new qr(e.peekToken(0).Literal);for(e.skipToken(2);e.peekToken(0).Type!=_.RIGHTBIG;){let i=ke.parse(e);r.fields.push(i)}return e.peekToken(0).Type==_.RIGHTBIG&&e.skipToken(1),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1),r}throw"Error parsing structure: Unexpected character"}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);i+=a+"struct "+this.name+` {\r
`;for(let o of this.fields)o.arraySize.nodes.length<=0?i+=a+"  "+o.name+": "+jt(o.type)+`,\r
`:o.arraySize.nodes[0]instanceof Zr?i+=a+"  "+o.name+": array<"+jt(o.type)+", "+o.arraySize.nodes[0].value+`>,\r
`:i+=a+"  "+o.name+": array<"+jt(o.type)+", "+o.arraySize.nodes[0].formatToWGSL(e,0)+`>,\r
`;return i+=a+`};\r
`,i}}class ro extends Ue{constructor(e,r,i,a){super();s(this,"name");s(this,"args");s(this,"body");s(this,"returnType");this.name=e,this.args=r,this.body=i,this.returnType=a}static parse(e){if((e.peekToken(0).isBuiltinType()||e.peekToken(0).Type==_.VOID)&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).Type==_.LEFTSAMLL){let r=e.peekToken(0).Literal,i=e.peekToken(1).Literal;e.skipToken(2);let a=new Array;if(e.peekToken(0).Type!=_.LEFTSAMLL)throw"Error parsing function parameter list: Unexpected character";for(e.skipToken(1);e.peekToken(0).Type!=_.EOF;){if(e.peekToken(0).Type==_.RIGHTSAMLL){e.skipToken(1);break}(e.peekToken(0).Type==_.INOUT||e.peekToken(0).Type==_.IN||e.peekToken(0).Type==_.OUT)&&e.skipToken(1);let l=ke.parse(e);a.push(l),e.peekToken(0).Type==_.COMMA&&e.skipToken(1)}let o=_r.parse(e);return new ro(i,a,o,r)}throw"Error parsing function: Unexpected character"}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r),o,l=e.layoutsOut.length>0||e.builtinOut.length>0;switch(e.stage){case"compute":o="ComputeOutput";break;case"vertex":o="VertexOutput";break;case"fragment":o="FragmentOutput";break;default:o="StructOutput";break}if(this.name=="main"&&l){i+="struct "+o+` {\r
`;for(let f of e.layoutsOut)if(f.nodes[0]instanceof ke){let d=f.nodes[0];f.qualifier.size==1&&f.qualifier.has("location")&&(i+="  @location("+f.qualifier.get("location")+") "),i+=d.name+": "+jt(d.type)+`,\r
`,e.addIdentifier(d.name,"stout."+d.name)}let c=e.builtinOut;for(let f of c)i+="  "+f+`,\r
`;i+=`};\r
\r
`}let h="";if(this.name=="main"&&(e.workGroupSize!=null?h+="@"+e.stage+" "+e.workGroupSize.formatToWGSL(e,0)+` \r
`:h+="@"+e.stage+`\r
`),e=new Un(e),h+=a+"fn "+this.name+"(",this.name!="main"){for(let c=0;c<this.args.length;c++){let f=this.args[c];c>0&&(h+=", "),h+=f.name+": "+jt(f.type),e.addIdentifier(f.name,f.name)}h+=") -> "+jt(this.returnType)}else{let c=e.layoutsIn;for(let d=0;d<c.length;d++){let p=c[d];if(d>0?h+=`,\r
    `:h+=`\r
    `,p.nodes[0]instanceof ke){let A=p.nodes[0];p.qualifier.size==1&&p.qualifier.has("location")&&(h+="@location("+p.qualifier.get("location")+") "),h+=A.name+": "+jt(A.type),e.addIdentifier(A.name,A.name)}}c.length>0&&(h+=`,\r
    `);let f=e.builtinIn;for(let d of f)h+=d+`,\r
    `;l?h+=") -> "+o:h+=") "}let u="";this.name=="main"&&l&&(u+="    var stout: "+o+` ;\r
`);for(let c of this.body.nodes)u+=c.formatToWGSL(e,r+1),!(c instanceof Qi)&&!(c instanceof Gi)&&!(c instanceof zi)&&(u+=`;\r
`);return this.name=="main"&&l&&(u+=`    return stout;\r
`),i+=h+` {\r
`,i+=u,i+=a+`}\r
`,i+=`\r
`,i}}class io extends Ue{constructor(){super();s(this,"args",[])}static parse(e){if(e.peekToken(0).Type==_.LEFTSAMLL){e.skipToken(1);let r=new io;for(;e.peekToken(0).Type!=_.EOF;){if(e.peekToken(0).Type==_.RIGHTSAMLL){e.skipToken(1);break}let i=ge.parse(e);r.args.push(i),e.peekToken(0).Type==_.COMMA&&e.skipToken(1)}return r}throw"Error parsing function argument table: Unexpected character"}}class ki extends Ue{constructor(e,r){super();s(this,"name");s(this,"args");this.name=e,this.args=r}static parse(e){if(e.peekToken(0).isDataType()&&e.peekToken(1).Type==_.LEFTSAMLL){let r=e.peekToken(0).Literal;e.skipToken(1);let i=io.parse(e);return new ki(r,i)}throw"Error parsing function argument table: Unexpected character"}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);if(this.name=="texture"&&this.args.args[0].nodes[0]instanceof ki){let o=this.args.args[0].nodes[0];if(o.name=="sampler2D"){i+=a+"textureSample(";for(let l=0;l<o.args.args.length;l++){let h=o.args.args[l];l>0&&(i+=", "),i+=h.formatToWGSL(e,0)}for(let l=1;l<this.args.args.length;l++){let h=this.args.args[l];l>0&&(i+=", "),i+=h.formatToWGSL(e,0)}return i+=")",i}}i+=a+jt(this.name)+"(";for(let o=0;o<this.args.args.length;o++){let l=this.args.args[o];o>0&&(i+=", "),i+=l.formatToWGSL(e,0)}return i+=")",i}}class ke extends Ue{constructor(e,r,i=new ge){super();s(this,"type");s(this,"name");s(this,"arraySize");s(this,"hasIn");s(this,"hasOut");s(this,"hasConst");this.type=e,this.name=r,this.hasIn=!1,this.hasOut=!1,this.hasConst=!1,this.arraySize=i}static parse(e){let r=new ke("",""),i=e.peekToken(0);if(i.Type==_.CONST)e.skipToken(1),r.hasConst=!0;else if(i.Type==_.IN)e.skipToken(1),r.hasIn=!0;else if(i.Type==_.OUT)e.skipToken(1),r.hasOut=!0;else if(i.Type==_.INOUT)e.skipToken(1),r.hasIn=!0,r.hasOut=!0;else if(!i.isDataType())throw"Error parsing declaration expression: Unexpected character("+i.Literal+")";if(i=e.peekToken(0),i.isDataType()&&e.peekToken(1).Type==_.LEFTMEDI){if(r.type=i.Literal,e.skipToken(2),r.arraySize=ge.parse(e),e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1),e.peekToken(0).Type!=_.IDENT)throw"Unexpected";r.name=e.peekToken(0).Literal,e.skipToken(1)}else if(i.isDataType()&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).Type==_.LEFTMEDI)r.type=e.peekToken(0).Literal,r.name=e.peekToken(1).Literal,e.skipToken(3),e.peekToken(0).Type==_.RIGHTMEDI?e.skipToken(1):(r.arraySize=ge.parse(e),e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1));else if(i.isDataType()&&e.peekToken(1).Type==_.IDENT)r.type=e.peekToken(0).Literal,r.name=e.peekToken(1).Literal,e.skipToken(2);else throw"Error parsing declaration expression: Unexpected character("+i.Literal+")";if(i=e.peekToken(0),i.Type==_.SEMICOLON)return e.skipToken(1),r;if(i.Type==_.RIGHTSAMLL)return r;if(i.Type==_.ASSIGN){let a=e.peekToken(0);e.skipToken(1);let o=new Jr(r.name),l=ge.parse(e);return e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1),r.addNode(new Ai(a,o,l)),r}else if(i.Type==_.COMMA){for(;e.peekToken(0).Type==_.COMMA&&e.peekToken(1).Type==_.IDENT;){let a=new ke(r.type,e.peekToken(1).Literal);r.addNode(a),e.skipToken(2),e.peekToken(0).Type==_.ASSIGN&&(e.skipToken(-1),a.addNode(ge.parse(e)))}return r}throw"Error parsing declaration expression: Unexpected character("+e.peekToken(0).Literal+")"}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);if(this.hasConst?i+=a+"let ":i+=a+"var ",e.addIdentifier(this.name,this.name),this.arraySize.nodes.length<=0?i+=this.name+": "+jt(this.type):this.arraySize.nodes[0]instanceof Zr?i+=this.name+": array<"+jt(this.type)+", "+this.arraySize.nodes[0].value+">":i+=this.name+": array<"+jt(this.type)+", "+this.arraySize.nodes[0].formatToWGSL(e,0)+">",this.nodes.length>0&&this.nodes[0]instanceof Ai)i+=" = "+this.nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof ge&&this.nodes[0].nodes[0]instanceof Ai)i+=" = "+this.nodes[0].nodes[0].rightValue.formatToWGSL(e,0);else if(this.nodes.length>0&&this.nodes[0]instanceof ke){i+=`;\r
`;for(let o of this.nodes)i+=o.formatToWGSL(e,r)+`;\r
`}else i+=`;\r
`;return i}}class zi extends Ue{constructor(e,r,i,a){super();s(this,"expression1");s(this,"condition");s(this,"expression2");s(this,"loopBody");this.expression1=e,this.condition=r,this.expression2=i,this.loopBody=a}static parse(e){if(e.peekToken(0).Type==_.FOR&&e.peekToken(1).Type==_.LEFTSAMLL){e.skipToken(2);let r;e.peekToken(0).Type==_.SEMICOLON?(e.skipToken(1),r=new ge):e.peekToken(0).isDataType()&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).Type==_.ASSIGN?(r=new ke(e.peekToken(0).Literal,e.peekToken(1).Literal),e.skipToken(1),r.addNode(ge.parse(e)),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1)):(r=ge.parse(e),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1));let i;e.peekToken(0).Type==_.SEMICOLON?(e.skipToken(1),i=new ge):(i=ge.parse(e),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1));let a;e.peekToken(0).Type==_.SEMICOLON?(e.skipToken(1),a=new ge):(a=ge.parse(e),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1)),e.peekToken(0).Type==_.RIGHTSAMLL&&e.skipToken(1);let o;return e.peekToken(0).Type==_.LEFTBIG?o=_r.parse(e):o=new _r,new zi(r,i,a,o)}throw"Error parsing for loop: Unexpected character"}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);i+=a+"for (",i+=this.expression1.formatToWGSL(e,0)+"; ",i+=this.condition.formatToWGSL(e,0)+"; ",i+=this.expression2.formatToWGSL(e,0)+")",i+=` { \r
`;for(let o of this.loopBody.nodes)i+=o.formatToWGSL(e,r+1),!(o instanceof Qi)&&!(o instanceof Gi)&&!(o instanceof zi)&&(i+=`;\r
`);return i+=a+`} \r
`,i}}class Gi extends Ue{constructor(e,r){super();s(this,"conditionExpr");s(this,"loopBody");this.conditionExpr=e,this.loopBody=r}static parse(e){if(e.peekToken(0).Type==_.WHILE){e.skipToken(1),e.peekToken(0).Type==_.LEFTSAMLL&&e.skipToken(1);let r=ge.parse(e);e.peekToken(0).Type==_.RIGHTSAMLL&&e.skipToken(1);let i=_r.parse(e);return new Gi(r,i)}throw"Error parsing while loop: Unexpected character"}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);i+=a+`loop {\r
`,i+=a+"    if ("+this.conditionExpr.formatToWGSL(e,0)+`) { break; }\r
\r
`;for(let o of this.loopBody.nodes)i+=o.formatToWGSL(e,r+1),!(o instanceof Qi)&&!(o instanceof Gi)&&!(o instanceof zi)&&(i+=`;\r
`);return i+=a+`}\r
`,i}}class uA extends null{constructor(){super()}}class Qi extends Ue{constructor(e,r,i){super();s(this,"conditionExpr");s(this,"trueBranch");s(this,"falseBranch");this.conditionExpr=e,this.trueBranch=r,this.falseBranch=i}static parse(e){if(e.peekToken(0).Type==_.IF){e.skipToken(1),e.peekToken(0).Type==_.LEFTSAMLL&&e.skipToken(1);let r=ge.parse(e),i,a=new _r;if(e.peekToken(0).Type==_.RIGHTSAMLL&&e.skipToken(1),e.peekToken(0).Type==_.LEFTBIG?i=_r.parse(e):(i=new _r,e.peekToken(0).Type==_.RETURN?i.addNode(ds.parse(e)):i.addNode(ge.parse(e))),e.peekToken(0).Type==_.ELSE)if(e.skipToken(1),e.peekToken(0).Type==_.LEFTBIG)a=_r.parse(e);else throw"not impl";return new Qi(r,i,a)}throw"Error parsing IF branch statement: Unexpected character"}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);i+=a+"if ("+this.conditionExpr.formatToWGSL(e,0)+`) {\r
`;for(let o of this.trueBranch.nodes)i+=o.formatToWGSL(e,r+1)+`;\r
`;if(this.falseBranch.nodes.length>0){i+=a+`} else {\r
`;for(let o of this.falseBranch.nodes)i+=o.formatToWGSL(e,r+1)+`;\r
`}return i+=a+`}\r
`,i}}class ge extends Ue{constructor(){super()}static parse(t){let e=new Array,r=new Array,i=0;for(;t.peekToken(0).Type!=_.EOF;){let a=t.peekToken(0);if(a.Type==_.SEMICOLON||a.Type==_.RIGHTMEDI||a.Type==_.COMMA||a.Type==_.COLON||a.Type==_.RIGHTBIG)break;if(a.isOperation()){if(a.isOperation()){if(a.Type==_.INC||a.Type==_.DEC){let o=a;t.skipToken(1);let l=ge.parse(t);r.push(new ma(o,void 0,l));continue}else if(e.length>0){if(e[e.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel)ge.unionOperation(e,r);else if(e.length>0&&e[e.length-1].Literal=="-"){let o=e.pop(),l=r.pop();r.push(new ma(o,void 0,l))}}e.push(a),t.skipToken(1)}}else if(a.Type==_.LITERAL){r.push(new Zr(a.Literal)),t.skipToken(1);continue}else if(a.Type==_.LEFTSAMLL){i++,e.push(a),t.skipToken(1);continue}else if(a.Type==_.RIGHTSAMLL){if(i<=0)break;for(i--;ge.unionOperation(e,r););if(e[e.length-1].Type==_.LEFTSAMLL){e.pop();let o=new tc;o.addNode(r.pop()),r.push(o)}t.skipToken(1);continue}else if(a.Type==_.IDENT){if(t.peekToken(1).Type==_.INC||t.peekToken(1).Type==_.DEC){let o=t.peekToken(1),l=new Jr(a.Literal);r.push(new ma(o,l,void 0)),t.skipToken(2);continue}else if(t.peekToken(1).Type==_.LEFTSAMLL){r.push(ki.parse(t));continue}else if(t.peekToken(1).Type==_.DOT){r.push(gs.parse(t));continue}else if(t.peekToken(1).Type==_.LEFTMEDI){r.push(Vi.parse(t));continue}r.push(new Jr(a.Literal)),t.skipToken(1);continue}else{if(a.isBuiltinType()&&t.peekToken(1).Type==_.LEFTSAMLL){r.push(ki.parse(t));continue}if(a.isAssignOperation()){let o=a;t.skipToken(1);let l=r.pop(),h=ge.parse(t);r.push(new Ai(o,l,h));continue}if(a.Type==_.LEFTBIG&&(t.peekToken(1).Type==_.LITERAL||t.peekToken(1).Type==_.SUB&&t.peekToken(2).Type==_.LITERAL)){r.push(fs.parse(t));continue}if(a.Type==_.QUEMARK){e.length>0&&e[e.length-1].nOperationPriorityLevel<=a.nOperationPriorityLevel&&ge.unionOperation(e,r),t.skipToken(1);let o=r.pop(),l=ge.parse(t);t.peekToken(0).Type==_.COLON&&t.skipToken(1);let h=ge.parse(t);if(r.push(new rc(o,l,h)),t.peekToken(-1).Type==_.SEMICOLON)break;continue}if(a.Type==_.LEFTMEDI){t.skipToken(1);let o=ge.parse(t);t.peekToken(0).Type==_.RIGHTMEDI&&t.skipToken(1);let l=r.pop();r.push(new Vi(l,o));continue}throw"An unexpected character"}}for(;e.length>0&&ge.unionOperation(e,r););if(e.length<=0&&r.length==1){let a=new ge;return a.addNode(r.pop()),a}throw"Error parsing expression: Unexpected character("+t.peekToken(0).Literal+")"}formatToWGSL(t,e){return this.nodes[0].formatToWGSL(t,e)}static unionOperation(t,e){if(t.length<0||e.length<2){if(t.length>0&&t[t.length-1].Literal=="-"){let r=t.pop(),i=e.pop();return e.push(new ma(r,void 0,i)),!0}return!1}if(t[t.length-1].isOperation()){let r=e.pop(),i=t.pop(),a=e.pop();return i.Type==_.DOT?e.push(new gs(a,r)):e.push(new Ai(i,a,r)),!0}return!1}}class tc extends Ue{constructor(){super()}formatToWGSL(t,e){return(e<=0?"":"    ".repeat(e))+"("+this.nodes[0].formatToWGSL(t,0)+")"}}class Jr extends Ue{constructor(e){super();s(this,"name");this.name=e}formatToWGSL(e,r){return(r<=0?"":"    ".repeat(r))+e.findIdentifier(this.name)}}class Zr extends Ue{constructor(e){super();s(this,"value");this.value=e}static parse(e){let r=e.peekToken(0);if(r.Type==_.SUB&&e.peekToken(1).Type==_.LITERAL){let i=new Zr("-"+e.peekToken(1).Literal);return e.skipToken(2),i}else if(r.Type==_.LITERAL){let i=new Zr(r.Literal);return e.skipToken(1),i}throw"Error parsing literal constants: Unexpected characters("+r.Literal+")"}formatToWGSL(e,r){return(r<=0?"":"    ".repeat(r))+this.value}}class fs extends Zr{constructor(e){super("");s(this,"arrayValue");this.arrayValue=e}static parse(e){if(e.peekToken(0).Type==_.LEFTBIG&&e.peekToken(1).Type==_.LITERAL||e.peekToken(0).Type==_.LEFTBIG&&e.peekToken(1).Type==_.SUB&&e.peekToken(2).Type==_.LITERAL){e.skipToken(1);let r=[];for(;e.peekToken(0).Type!=_.RIGHTBIG;){if(e.peekToken(0).Type==_.LEFTSAMLL){r.push(fs.parse(e));continue}if(r.push(Zr.parse(e)),e.peekToken(0).Type==_.COMMA){e.skipToken(1);continue}else if(e.peekToken(0).Type==_.RIGHTBIG){e.skipToken(1);break}else throw"Error parsing array constants: Unexpected characters"}return new fs(r)}throw"Error parsing array constants: Unexpected characters"}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);this.arrayValue[0].value.includes(".")?i+=a+"array<f32, "+this.arrayValue.length.toString()+">(":i+=a+"array<i32, "+this.arrayValue.length.toString()+">(";for(let o=0;o<this.arrayValue.length;o++)o>0&&(i+=", "),i+=this.arrayValue[o].formatToWGSL(e,0);return i+=")",i}}class cA extends null{constructor(){super()}}class fA extends null{constructor(){super()}}class ao extends Ue{constructor(){super()}static parse(t){if(t.peekToken(0).Type==_.CONTINUE&&t.peekToken(1).Type==_.SEMICOLON)return t.skipToken(2),new ao;throw"Error parsing continue: Unexpected character"}formatToWGSL(t,e){let r="",i=e<=0?"":"    ".repeat(e);return r+=i+"continue",r}}class ds extends Ue{constructor(e){super();s(this,"value");this.value=e}static parse(e){if(e.peekToken(0).Type==_.RETURN){e.skipToken(1);let r=ge.parse(e);return e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1),new ds(r)}throw"Error parsing return expression: Unexpected character"}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);return i+=a+"return "+this.value.formatToWGSL(e,0),i}}class ma extends Ue{constructor(e,r,i){super();s(this,"op");s(this,"leftValue");s(this,"rightValue");this.op=e,this.leftValue=r,this.rightValue=i}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);if(this.op.Literal=="++"||this.op.Literal=="--")if(this.leftValue!=null){let o=this.leftValue.formatToWGSL(e,0);i+=a+o+" = "+o+" "+this.op.Literal[0]+" 1"}else{let o=this.rightValue.formatToWGSL(e,0);i+=a+o+" = "+o+" "+this.op.Literal[0]+" 1"}else this.leftValue!=null?i+=a+this.leftValue.formatToWGSL(e,0)+this.op.Literal:i+=a+this.op.Literal+this.rightValue.formatToWGSL(e,0);return i}}class Ai extends Ue{constructor(e,r,i){super();s(this,"op");s(this,"leftValue");s(this,"rightValue");this.op=e,this.leftValue=r,this.rightValue=i}formatToWGSL(e,r){let i="",a=r<=0?"":"    ".repeat(r);return i+=a+this.leftValue.formatToWGSL(e,0)+" "+this.op.Literal+" "+this.rightValue.formatToWGSL(e,0),i}}class rc extends Ue{constructor(e,r,i){super();s(this,"condition");s(this,"expression1");s(this,"expression2");this.condition=e,this.expression1=r,this.expression2=i}static parse(e){throw"Error parsing ternary operation expression: Unexpected character"}formatToWGSL(e,r){return""}}class gs extends Ue{constructor(e,r){super();s(this,"leftValue");s(this,"rightValue");this.leftValue=e,this.rightValue=r}static parse(e){if(e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.DOT&&e.peekToken(2).Type==_.IDENT){let r=new Jr(e.peekToken(0).Literal),i=new Jr(e.peekToken(2).Literal);return e.skipToken(3),new gs(r,i)}throw"Error parsing selection expression: Unexpected character"}formatToWGSL(e,r){return(r<=0?"":"    ".repeat(r))+this.leftValue.formatToWGSL(e,0)+"."+this.rightValue.formatToWGSL(e,0)}}class Vi extends Ue{constructor(e,r){super();s(this,"leftValue");s(this,"indexValue");this.leftValue=e,this.indexValue=r}static parse(e){if(e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.LEFTMEDI){let r=new Jr(e.peekToken(0).Literal);e.skipToken(2);let i=ge.parse(e);e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1);let a=new Vi(r,i);for(;e.peekToken(0).Type==_.LEFTMEDI;)e.skipToken(1),i=ge.parse(e),e.peekToken(0).Type==_.RIGHTMEDI&&e.skipToken(1),a=new Vi(a,i);return a}throw"Error parsing index expression: Unexpected character"}formatToWGSL(e,r){return(r<=0?"":"    ".repeat(r))+this.leftValue.formatToWGSL(e,0)+"["+this.indexValue.formatToWGSL(e,0)+"]"}}class _r extends Ue{constructor(){super()}static parse(t){if(t.peekToken(0).Type==_.LEFTBIG){t.skipToken(1);let e=new _r;for(let r=1;r>0&&t.peekToken(0).Type!=_.EOF;){let i=t.peekToken(0);if(i.Type==_.LEFTBIG){r++,t.skipToken(1);continue}if(i.Type==_.RIGHTBIG){r--,t.skipToken(1);continue}if(i.Type==_.SEMICOLON){t.skipToken(1);continue}if(i.isDataType()&&t.peekToken(1).Type==_.IDENT){e.addNode(ke.parse(t));continue}if(i.Type==_.CONST&&t.peekToken(1).isDataType()&&t.peekToken(2).Type==_.IDENT){e.addNode(ke.parse(t));continue}else if(i.Type==_.IDENT&&t.peekToken(1).Type==_.ASSIGN){e.addNode(ge.parse(t)),t.peekToken(0).Type==_.SEMICOLON&&t.skipToken(1);continue}else if(i.Type==_.IDENT&&t.peekToken(1).Type==_.LEFTMEDI){let a=Vi.parse(t);if(t.peekToken(0).Type==_.ASSIGN){let o=t.peekToken(0);t.skipToken(1);let l=ge.parse(t);t.peekToken(0).Type==_.RIGHTMEDI&&t.skipToken(1),e.addNode(new Ai(o,a,l));continue}e.addNode(a);continue}else if(i.Type==_.IDENT&&t.peekToken(1).Type==_.DOT){let a=ge.parse(t);e.addNode(a);continue}else if(i.Type==_.IDENT&&t.peekToken(1).isAssignOperation()){let a=t.peekToken(1),o=new Jr(i.Literal);t.skipToken(2);let l=ge.parse(t);t.peekToken(0).Type==_.SEMICOLON&&t.skipToken(1),e.addNode(new Ai(a,o,l));continue}else if(i.Type==_.IDENT&&(t.peekToken(1).Type==_.INC||t.peekToken(1).Type==_.DEC)&&t.peekToken(2).Type==_.SEMICOLON){let a=t.peekToken(1);e.addNode(new ma(a,new Jr(i.Literal),void 0)),t.skipToken(3);continue}else if(i.Type==_.RETURN){e.addNode(ds.parse(t));continue}else if(i.Type==_.CONTINUE){e.addNode(ao.parse(t));continue}else if(i.Type==_.WHILE){e.addNode(Gi.parse(t));continue}else if(i.Type==_.FOR){e.addNode(zi.parse(t));continue}else if(i.Type==_.IF){e.addNode(Qi.parse(t));continue}else if(i.Type==_.IDENT&&t.peekToken(1).Type==_.LEFTSAMLL){e.addNode(ki.parse(t)),t.peekToken(0).Type==_.SEMICOLON&&t.skipToken(0);continue}throw"Error parsing block: Unexpected symbol("+i.Literal+")"}return e}throw"Error parsing block: Unexpected symbol"}}class so extends Ue{constructor(e,r){super();s(this,"type");s(this,"qualifier");this.type=r,this.qualifier=e}static parse(e){if(e.peekToken(0).Type==_.PRECISION&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).isBuiltinType()){let r=new so(e.peekToken(1).Literal,e.peekToken(2).Literal);return e.skipToken(3),e.peekToken(0).Type==_.SEMICOLON&&e.skipToken(1),r}throw"Error parsing precision qualifier: Unexpected character"}formatToWGSL(e,r){return""}}class ps extends Ue{constructor(){super();s(this,"scope","");s(this,"qualifier",new Map)}addQualifier(e,r=""){this.qualifier.set(e,r)}static parse(e){if(e.peekToken(0).Type==_.LAYOUT&&e.peekToken(1).Type==_.LEFTSAMLL){let r=new ps;e.skipToken(2);do if(e.peekToken(0).Type==_.IDENT){if(e.peekToken(1).Type==_.ASSIGN&&e.peekToken(2).Type==_.LITERAL){let i=e.peekToken(0).Literal,a=e.peekToken(2).Literal;if(r.addQualifier(i,a),e.skipToken(3),e.peekToken(0).Type==_.COMMA){e.skipToken(1);continue}let o=e.peekToken(0);o.Line=0}else if(e.peekToken(1).Type==_.RIGHTSAMLL){let i=e.peekToken(0).Literal;r.addQualifier(i,""),e.skipToken(1);break}else if(e.peekToken(1).Type==_.COMMA){let i=e.peekToken(0).Literal;r.addQualifier(i,""),e.skipToken(2);continue}}while(e.peekToken(0).Type!=_.RIGHTSAMLL);if(e.peekToken(0).Type==_.RIGHTSAMLL&&e.skipToken(1),r.scope=e.peekToken(0).Literal,e.skipToken(1),e.peekToken(0).Type==_.SEMICOLON)return e.skipToken(1),r;if(e.peekToken(0).isBuiltinType()&&e.peekToken(1).Type==_.IDENT&&e.peekToken(2).Type==_.SEMICOLON){let i=new ke(e.peekToken(0).Literal,e.peekToken(1).Literal);return r.addNode(i),e.skipToken(3),r}else if(e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.LEFTBIG){let i=qr.parse(e);return r.addNode(i),e.peekToken(0).Type==_.IDENT&&e.peekToken(1).Type==_.SEMICOLON&&(i.addNode(new ke(i.name,e.peekToken(0).Literal)),e.skipToken(2)),r}else throw"Error parsing layout qualifier type: Unexpected symbol("+e.peekToken(0).Literal+")"}throw"Error parsing layout qualifier: Unexpected symbol"}formatToWGSL(e,r){let i="";if(this.qualifier.size==1&&this.qualifier.has("location"))i+="@location("+this.qualifier.get("location")+") ";else if(this.qualifier.size==2&&this.qualifier.has("set")&&this.qualifier.has("binding"))i+="@group("+this.qualifier.get("set")+") @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size>=1&&this.qualifier.has("binding"))i+="@group(0) @binding("+this.qualifier.get("binding")+") ";else if(this.qualifier.size==1&&this.qualifier.has("push_constant"))i+="@push_constant ";else if(this.qualifier.size>=1&&this.qualifier.has("local_size_x"))i+="@workgroup_size(",i+=this.qualifier.get("local_size_x")+", ",i+=this.qualifier.has("local_size_y")?this.qualifier.get("local_size_y")+", ":"1, ",i+=this.qualifier.has("local_size_z")?this.qualifier.get("local_size_z")+"":"1",i+=")";else if(this.nodes.length<=0)return"";let a=this.nodes[0];if(a instanceof ke){switch(a.type){case"sampler":case"texture2D":i+="var ";break;default:this.scope=="buffer"?e.stage=="compute"?i+="var<storage, read_write> ":i+="var<storage, read> ":i+="var<"+this.scope+"> ";break}e.addIdentifier(a.name,a.name),i+=a.name+": "+jt(a.type)+`;\r
`}else if(a instanceof qr){if(this.scope=="buffer"?e.stage=="compute"?i+="var<storage, read_write> ":i+="var<storage, read> ":i+="var<"+this.scope+"> ",a.nodes.length<=0){let o="unif"+e.layoutUniformCount.toString();for(;e.hasIdentifier(o);)e.layoutUniformCount++,o="unif"+e.layoutUniformCount.toString();for(let l of a.fields)e.addIdentifier(l.name,o+"."+l.name);i+=o+": "+a.name+`;\r
`,e.layoutUniformCount++}else{let o=a.nodes[0];i+=o.name+": "+o.type+`;\r
`}return i}return i}}function jt(n){switch(n){case"int":return"i32";case"int[]":return"array<i32>";case"uint":return"u32";case"uint[]":return"array<u32>";case"float":return"f32";case"float[]":return"array<f32>";case"vec2":return"vec2<f32>";case"vec3":return"vec3<f32>";case"vec4":return"vec4<f32>";case"vec2[]":return"array<vec2<f32>>";case"vec3[]":return"array<vec3<f32>>";case"vec4[]":return"array<vec4<f32>>";case"ivec2":return"vec2<i32>";case"ivec3":return"vec3<i32>";case"ivec4":return"vec4<i32>";case"ivec2[]":return"array<vec2<i32>>";case"ivec3[]":return"array<vec3<i32>>";case"ivec4[]":return"array<vec4<i32>>";case"mat2":return"mat2x2<f32>";case"mat2x2":return"mat2x2<f32>";case"mat2x3":return"mat2x3<f32>";case"mat2x4":return"mat2x4<f32>";case"mat2[]":return"array<mat2x2<f32>>";case"mat2x2[]":return"array<mat2x2<f32>>";case"mat2x3[]":return"array<mat2x3<f32>>";case"mat2x4[]":return"array<mat2x4<f32>>";case"mat3":return"mat3x3<f32>";case"mat3x2":return"mat3x2<f32>";case"mat3x3":return"mat3x3<f32>";case"mat3x4":return"mat3x4<f32>";case"mat3[]":return"array<mat3x3<f32>>";case"mat3x2[]":return"array<mat3x2<f32>>";case"mat3x3[]":return"array<mat3x3<f32>>";case"mat3x4[]":return"array<mat3x4<f32>>";case"mat4":return"mat4x4<f32>";case"mat4x2":return"mat4x2<f32>";case"mat4x3":return"mat4x3<f32>";case"mat4x4":return"mat4x4<f32>";case"mat4[]":return"array<mat4x4<f32>>";case"mat4x2[]":return"array<mat4x2<f32>>";case"mat4x3[]":return"array<mat4x3<f32>>";case"mat4x4[]":return"array<mat4x4<f32>>";case"texture2D":return"texture_2d<f32>"}return n}class ic{constructor(t){s(this,"_lexer");s(this,"_rootNode");this._lexer=t,this._rootNode=new Ue,this.parse()}get lexer(){return this._lexer}parse(){for(;this.peekToken(0).Type!==_.EOF;){if(this.peekToken(0).Type==_.SEMICOLON){this.skipToken(1);continue}let t=this.parseStatement();t!==null&&this._rootNode.addNode(t)}}parseStatement(){let t=this.peekToken();if(t.Type==_.LAYOUT&&this.peekToken(1).Type==_.LEFTSAMLL)return ps.parse(this._lexer);if(t.Type==_.STRUCT)return this.skipToken(1),qr.parse(this._lexer);if((t.isBuiltinType()||t.Type==_.VOID)&&this.peekToken(1).Type==_.IDENT&&this.peekToken(2).Type==_.LEFTSAMLL)return ro.parse(this._lexer);if(t.Type==_.CONST&&this.peekToken(1).isDataType())return ke.parse(this._lexer);if(t.isDataType()&&this.peekToken(1).Type==_.IDENT)return ke.parse(this._lexer);if(t.Type==_.OUT&&this.peekToken(1).isDataType()&&this.peekToken(2).Type==_.IDENT)return ke.parse(this._lexer);if(t.Type==_.PRECISION)return so.parse(this._lexer);throw"Error parsing statement: Unexpected character"}skipToken(t){this._lexer.skipToken(t)}peekToken(t=0){return this._lexer.peekToken(t)}getNextToken(){return this._lexer.GetNextToken()}get ASTRoot(){return this._rootNode}}class oo{static convertGLSL(t){var e=new $u(t),r=new Ju(e),i=new ic(r),a=new ec(i);return a.generateWGSL()}}s(oo,"VertexShader","VertexShader"),s(oo,"FragmentShader","FragmentShader");class Ln{constructor(){s(this,"setID",0);s(this,"bindingID",0);s(this,"name","");s(this,"type","")}}class On{constructor(){s(this,"name","");s(this,"type","");s(this,"locationID",0);s(this,"builtinName","")}isBuiltinAttribute(){return this.builtinName!=""}}class ac{constructor(){s(this,"uniformInfo",[]);s(this,"inputAttribute",[]);s(this,"outputAttribute",[]);s(this,"sourceCode","")}}var yr=(n=>(n[n.vertex=0]="vertex",n[n.fragment=1]="fragment",n[n.computer=2]="computer",n))(yr||{});class sc{constructor(){s(this,"blendMode",oe.NONE);s(this,"depthCompare",ct.less_equal);s(this,"depthWriteEnabled",!0);s(this,"frontFace","ccw");s(this,"cullMode",Pt.back);s(this,"topology",dh.triangle_list);s(this,"depthBias",10);s(this,"useLight",!1);s(this,"useProbe",!1);s(this,"acceptGI",!1);s(this,"acceptShadow",!1);s(this,"castShadow",!1);s(this,"castReflection",!0);s(this,"receiveEnv",!1);s(this,"renderLayer",1e3);s(this,"renderOrder",2e3);s(this,"unclippedDepth",!1);s(this,"transparent",!1);s(this,"multisample",0);s(this,"label");s(this,"useZ",!0);s(this,"splitTexture",!1);s(this,"alphaCutoff");s(this,"useFragDepth",!1);s(this,"writeMasks",[])}setFromMapValues(t){t.has("blendMode")&&(this.blendMode=this.convertBlendMode(t.get("blendMode"))),t.has("depthCompare")&&(this.depthCompare=t.get("depthCompare")),t.has("depthWriteEnabled")&&(this.depthWriteEnabled=t.get("depthWriteEnabled")),t.has("frontFace")&&(this.frontFace=t.get("frontFace")),t.has("cullMode")&&(this.cullMode=t.get("cullMode")),t.has("topology")&&(this.topology=t.get("topology")),t.has("depthBias")&&(this.depthBias=t.get("depthBias")),t.has("useLight")&&(this.useLight=t.get("useLight")),t.has("useProbe")&&(this.useProbe=t.get("useProbe")),t.has("acceptGI")&&(this.acceptGI=t.get("acceptGI")),t.has("acceptShadow")&&(this.acceptShadow=t.get("acceptShadow")),t.has("castShadow")&&(this.castShadow=t.get("castShadow")),t.has("receiveEnv")&&(this.receiveEnv=t.get("receiveEnv")),t.has("renderLayer")&&(this.renderLayer=t.get("renderLayer")),t.has("renderOrder")&&(this.renderOrder=t.get("renderOrder")),t.has("unclippedDepth")&&(this.unclippedDepth=t.get("unclippedDepth")),t.has("multisample")&&(this.multisample=t.get("multisample")),t.has("label")&&(this.label=t.get("label")),t.has("useZ")&&(this.useZ=t.get("useZ"))}convertBlendMode(t){switch(t){case"ABOVE":return oe.ABOVE;case"ALPHA":return oe.ALPHA;case"NORMAL":return oe.NORMAL;case"ADD":return oe.ADD;case"BELOW":return oe.BELOW;case"ERASE":return oe.ERASE;case"MUL":return oe.MUL;case"SCREEN":return oe.SCREEN;case"DIVD":return oe.DIVD;case"SOFT_ADD":return oe.SOFT_ADD}return oe.NONE}}class oc extends fi{constructor(){super();s(this,"uniformNodes",[]);s(this,"_onChange",!0);this.bufferType=vr.MaterialDataUniformGPUBuffer}initDataUniform(e){this.uniformNodes=e;let r=0;for(const i in e){const a=e[i];a||console.error(i,"is empty"),r+=a.size*4}r=Math.floor(r/256+1)*256,this.createBuffer(GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,r/4,null,"MaterialDataUniformGPUBuffer");for(const i in e){const a=e[i];a||console.error(i,"is empty");let o=this.memory.allocation_node(a.size*4);a.memoryInfo=o,a.bindOnChange=()=>this.onChange()}}onChange(){this._onChange=!0}apply(){if(this.uniformNodes.length!=0&&this._onChange){for(const e in this.uniformNodes)this.uniformNodes[e].update();super.apply(),this._onChange=!1}}}class Sr{static init(){this.renderShaderModulePool=new Map,this.renderShader=new Map}}s(Sr,"renderShaderModulePool"),s(Sr,"renderShader");const Gs=class Gs{constructor(){s(this,"reference")}static getInstance(){return this._ins||(this._ins=new Gs),this._ins}attached(t,e){this.reference||(this.reference=new Map);let r=this.reference.get(t);r||(r=new Map),r.set(e,t),this.reference.set(t,r)}detached(t,e){let r=this.reference.get(t);r&&r.delete(e)}hasReference(t){let e=this.reference.get(t);return e?e.size>0:!1}getReferenceCount(t){let e=this.reference.get(t);return e?e.size:0}getReference(t){return this.reference.get(t)||null}};s(Gs,"_ins");let Ae=Gs;class no{static getSharePipeline(t){return this.pipelineMap.get(t)||null}static setSharePipeline(t,e){this.pipelineMap.set(t,e)}}s(no,"pipelineMap",new Map);class Le extends An{constructor(e,r){super();s(this,"passType",J.COLOR);s(this,"useRz",!1);s(this,"vsName");s(this,"fsName");s(this,"shaderState");s(this,"textures");s(this,"pipeline");s(this,"bindGroupLayouts");s(this,"envMap");s(this,"prefilterMap");s(this,"reflectionMap");s(this,"_sourceVS");s(this,"_sourceFS");s(this,"_destVS");s(this,"_destFS");s(this,"_vsShaderModule");s(this,"_fsShaderModule");s(this,"_textureGroup",-1);s(this,"_textureChange",!1);s(this,"_groupsShaderReflectionVarInfos");s(this,"outBufferMask");s(this,"_cacheEntries");this.vsName=e.toLowerCase(),this.fsName=r.toLowerCase(),this.vsName in H||console.error("Shader Not Register, Please Register Shader!",this.vsName),this.fsName in H||console.error("Shader Not Register, Please Register Shader!",this.fsName),H[this.vsName]&&(this._sourceVS=H[this.vsName]),H[this.fsName]&&(this._sourceFS=H[this.fsName]),this.textures={},this.bindGroups=[],this.shaderState=new sc,this.materialDataUniformBuffer=new oc,this.materialDataUniformBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this._bufferDic.set("global",this.materialDataUniformBuffer),this._bufferDic.set("materialUniform",this.materialDataUniformBuffer)}get renderOrder(){return this.shaderState.renderOrder}set renderOrder(e){this.shaderState.renderOrder!=e&&(this._valueChange=!0),this.shaderState.renderOrder=e}get doubleSide(){return this.shaderState.cullMode==Pt.none}set doubleSide(e){let r=e?Pt.none:this.cullMode;this.shaderState.cullMode!=r&&(this._valueChange=!0),this.shaderState.cullMode=r}get depthWriteEnabled(){return this.shaderState.depthWriteEnabled}set depthWriteEnabled(e){this.shaderState.depthWriteEnabled!=e&&(this._valueChange=!0),this.shaderState.depthWriteEnabled=e}get cullMode(){return this.shaderState.cullMode}set cullMode(e){this.shaderState.cullMode!=e&&(this._valueChange=!0),this.shaderState.cullMode=e}get frontFace(){return this.shaderState.frontFace}set frontFace(e){this.shaderState.frontFace!=e&&(this._valueChange=!0),this.shaderState.frontFace=e}get depthBias(){return this.shaderState.depthBias}set depthBias(e){this.shaderState.depthBias!=e&&(this._valueChange=!0),this.shaderState.depthBias=e}get topology(){return this.shaderState.topology}set topology(e){this.shaderState.topology!=e&&(this._valueChange=!0),this.shaderState.topology=e}get blendMode(){return this.shaderState.blendMode}set blendMode(e){this.shaderState.blendMode!=e&&(this._valueChange=!0,e!=oe.NORMAL&&e!=oe.NONE&&(this.renderOrder=3e3)),this.shaderState.blendMode=e}get depthCompare(){return this.shaderState.depthCompare}set depthCompare(e){this.shaderState.depthCompare!=e&&(this._valueChange=!0),this.shaderState.depthCompare=e}setShaderEntry(e="",r=""){this.vsEntryPoint=e,this.fsEntryPoint=r}setUniform(e,r){super.setUniform(e,r),this.materialDataUniformBuffer.onChange()}setTexture(e,r){r&&this.textures[e]!=r&&(this.textures[e]&&this.textures[e].unBindStateChange(this),this._textureChange=!0,this.textures[e]=r,e=="envMap"?this.envMap=r:e=="prefilterMap"?this.prefilterMap=r:e=="reflectionMap"&&(this.reflectionMap=r),r.bindStateChange(()=>{this._textureChange=!0},this))}get baseColor(){return this.getUniform("baseColor")}set baseColor(e){this.setUniform("baseColor",e)}getTexture(e){return this.textures[e]}genRenderPipeline(e,r){let i=this.createGroupLayouts();this.createPipeline(e,r,i)}reBuild(e,r){this.compileShader(yr.vertex,this._destVS,r),this.compileShader(yr.fragment,this._destFS,r),this.genRenderPipeline(e,r)}apply(e,r,i){this.materialDataUniformBuffer.apply(),this._textureChange&&this._textureGroup!=-1&&(this._textureChange=!1,this.genGroups(this._textureGroup,this.shaderReflection.groups,!0)),this._valueChange&&(this._shaderChange&&(this.preCompile(e),this._shaderChange=!1),this.shaderVariant=zt.genRenderShaderVariant(this),this.reBuild(e,r),this._valueChange=!1,i&&i())}preCompile(e){this.preDefine(e),this.preCompileShader(yr.vertex,this._sourceVS.concat()),this.preCompileShader(yr.fragment,this._sourceFS.concat()),this.genReflection()}applyPostDefine(e,r){return r.renderTargetTextures.length>1?(this.defineValue.USE_WORLDPOS=!0,this.defineValue.USEGBUFFER=!0):(this.defineValue.USE_WORLDPOS=!1,this.defineValue.USEGBUFFER=!1),m.setting.render.useCompressGBuffer?this.defineValue.USE_COMPRESSGBUFFER=!0:this.defineValue.USE_COMPRESSGBUFFER=!1,xr.parse(e,this.defineValue)}setBindGroup(e,r){this.bindGroups[e]=r}checkBuffer(e,r){}preCompileShader(e,r,i){let a=r;if(a.indexOf("version ")!=-1){var o=oo.convertGLSL(a);a=o.sourceCode}for(const l in this.constValues)if(Object.prototype.hasOwnProperty.call(this.constValues,l)){const h=this.constValues[l];a=a.replaceAll(`&${l}`,h.toString())}switch(e){case yr.vertex:this._destVS=a;break;case yr.fragment:this._destFS=a;break}}compileShader(e,r,i){let a=r;a=this.applyPostDefine(a,i);let o=r;for(let h in this.defineValue)o+=`${h}=${this.defineValue[h]},`;let l=Sr.renderShaderModulePool.get(o);switch(l||(a=this.applyPostDefine(a,i),l=E.device.createShaderModule({label:e==yr.vertex?this.vsName:this.fsName,code:a}),l.getCompilationInfo().then(h=>{h.messages.length>0&&(console.log(a),console.log(h))}),Sr.renderShaderModulePool.set(o,l)),e){case yr.vertex:this._vsShaderModule=l,this._destVS=a;break;case yr.fragment:this._fsShaderModule=l,this._destFS=a;break}}getGroupLayout(e,r){let i=[];for(let a=0;a<r.length;a++){const o=r[a];if(o)if(o.varType=="uniform"){this._bufferDic.has(o.varName)||console.error(`not set ${o.varName} buffer`);let l=this._bufferDic.get(o.varName).visibility,h={binding:o.binding,visibility:l,buffer:{type:"uniform"}};i.push(h)}else if(o.varType=="storage-read"){this._bufferDic.has(o.varName)||console.error(`not set ${o.varName} buffer`);let l=this._bufferDic.get(o.varName).visibility,h={binding:o.binding,visibility:l,buffer:{type:"read-only-storage"}};i.push(h)}else if(o.varType=="var")switch(o.dataType){case"sampler":{let l=o.varName.replace("Sampler",""),h=this.textures[l]?this.textures[l]:m.res.redTexture,u={binding:o.binding,visibility:h.visibility,sampler:h.samplerBindingLayout};i.push(u),this._textureGroup=e}break;case"sampler_comparison":{let l=o.varName.replace("Sampler",""),h=this.textures[l]?this.textures[l]:m.res.redTexture,u={binding:o.binding,visibility:h.visibility,sampler:h.sampler_comparisonBindingLayout};i.push(u),this._textureGroup=e}break;case"texture_2d<f32>":case"texture_2d_array<f32>":case"texture_cube<f32>":case"texture_depth_2d":case"texture_depth_2d_array":case"texture_depth_cube":case"texture_depth_cube_array":{let l=this.textures[o.varName]?this.textures[o.varName]:m.res.redTexture,h={binding:o.binding,visibility:l.visibility,texture:l.textureBindingLayout};i.push(h),this._textureGroup=e,Ae.getInstance().attached(l,this)}break;case"texture_external":{let l=this.textures[o.varName]?this.textures[o.varName]:m.res.redTexture,h={binding:o.binding,visibility:l.visibility,externalTexture:{}};i.push(h),this._textureGroup=e,Ae.getInstance().attached(l,this)}break;default:{let l=this.textures[o.varName]?this.textures[o.varName]:m.res.redTexture,h={binding:o.binding,visibility:l.visibility,texture:l.textureBindingLayout};i.push(h),this._textureGroup=e,Ae.getInstance().attached(l,this)}break}else{debugger;console.error("bind group can't empty")}}return i}genGroups(e,r,i=!1){if(!this.bindGroups[e]||i){const a=r[e];let o=[];for(let h=0;h<a.length;h++){const u=a[h];if(u){if(u.varType=="uniform"){let c=this._bufferDic.get(u.varName);if(c){if(c.bufferType==vr.MaterialDataUniformGPUBuffer){let d=[];for(let p=0;p<u.dataFields.length;p++){const A=u.dataFields[p];this.uniforms[A.name]||console.error(`shader-${this.vsName}:${this.fsName} ${A.name}is empty`),d.push(this.uniforms[A.name])}this.materialDataUniformBuffer.initDataUniform(d)}let f={binding:u.binding,resource:{buffer:c.buffer,offset:0,size:c.memory.shareDataBuffer.byteLength}};o.push(f),this.checkBuffer(u.varName,c)}else console.error(`shader${this.vsName}-${this.fsName}`,`buffer ${u.varName} is missing!`)}else if(u.varType=="storage-read"){let c=this._bufferDic.get(u.varName);if(c){let f={binding:u.binding,resource:{buffer:c.buffer,offset:0,size:c.memory.shareDataBuffer.byteLength}};o.push(f),this.checkBuffer(u.varName,c)}else console.error(`buffer ${u.varName} is missing!`)}else if(u.varType=="var")if(u.dataType=="sampler"){let c=u.varName.replace("Sampler",""),f=this.textures[c];if(f||(f=m.res.blackTexture,this.setTexture(c,f)),f){let d={binding:u.binding,resource:f.gpuSampler};o.push(d)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${u.varName} is missing! `)}else if(u.dataType=="sampler_comparison"){let c=u.varName.replace("Sampler",""),f=this.textures[c];if(f){let d={binding:u.binding,resource:f.gpuSampler_comparison};o.push(d)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${u.varName} is missing! `)}else{let c=this.textures[u.varName];if(c||(c=m.res.whiteTexture,this.setTexture(u.varName,c)),c){let f={binding:u.binding,resource:c.getGPUView()};o.push(f)}else console.error(`shader${this.vsName}-${this.fsName}`,`texture ${u.varName} is missing! `)}}}let l=E.device.createBindGroup({layout:this.bindGroupLayouts[e],entries:o});this.bindGroups[e]=l}}createPipeline(e,r,i){let a=e,o=this.shaderState,l=[];for(const c of r.renderTargetTextures)l.push({format:c.format});for(let c=0;c<l.length;c++){const f=l[c];o.writeMasks&&o.writeMasks.length>0&&(f.writeMask=o.writeMasks[c])}if(r.outColor!=-1){let c=l[r.outColor];o.blendMode!=oe.NONE?c.blend=ju.getBlend(o.blendMode):delete c.blend}let h={label:this.vsName+"|"+this.fsName,layout:i,primitive:{topology:o.topology,cullMode:o.cullMode,frontFace:o.frontFace},vertex:void 0};this.vsEntryPoint!=""&&(h.vertex={module:this._vsShaderModule,entryPoint:this.vsEntryPoint,buffers:a.vertexBuffer.vertexBufferLayouts}),this.fsEntryPoint!=""&&(h.fragment={module:this._fsShaderModule,entryPoint:this.fsEntryPoint,targets:l}),o.multisample>0&&(h.multisample={count:o.multisample}),(r.zPreTexture||r.depthTexture)&&(o.blendMode!=oe.NONE,m.setting.render.zPrePass&&r.zPreTexture&&o.useZ?h.depthStencil={depthWriteEnabled:!1,depthCompare:ct.less,format:r.zPreTexture.format}:h.depthStencil={depthWriteEnabled:o.depthWriteEnabled,depthCompare:o.depthCompare,format:r.depthTexture.format});let u=no.getSharePipeline(this.shaderVariant);u?this.pipeline=u:(this.pipeline=S.createPipeline(h),no.setSharePipeline(this.shaderVariant,this.pipeline))}createGroupLayouts(){this._groupsShaderReflectionVarInfos=[];let e=this.shaderReflection;this.bindGroupLayouts=[eo.getGlobalDataBindGroupLayout()];for(let i=1;i<e.groups.length;i++){let a=e.groups[i];if(a){let o=this.getGroupLayout(i,a);this._groupsShaderReflectionVarInfos[i]=a;let l=E.device.createBindGroupLayout({entries:o,label:`vs${this.vsName} fs${this.fsName} ${a.length}`});this.bindGroupLayouts[i]=l}else console.error("can't set empty group!",i)}let r=E.device.createPipelineLayout({bindGroupLayouts:this.bindGroupLayouts});return this._groupsShaderReflectionVarInfos[0],this._groupsShaderReflectionVarInfos[1]&&this.genGroups(1,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[2]&&this.genGroups(2,this._groupsShaderReflectionVarInfos),this._groupsShaderReflectionVarInfos[3]&&this.genGroups(3,this._groupsShaderReflectionVarInfos),r}preDefine(e){let r=e.hasAttribute(O.TEXCOORD_1),i=e.hasAttribute(O.joints0),a=e.hasAttribute(O.a_morphPositions_0),o=e.hasAttribute(O.TANGENT),l=e.hasAttribute(O.color),h=this.shaderState.acceptGI,u=this.shaderState.useLight;r&&(this.defineValue.USE_SECONDUV=!0),i&&a?this.defineValue.USE_METAHUMAN=!0:(this.defineValue.USE_SKELETON=i,this.defineValue.USE_MORPHTARGETS=a),"USE_TANGENT"in this.defineValue||(this.defineValue.USE_TANGENT=o),this.defineValue.USE_GI=h,this.defineValue.USE_SHADOWMAPING=this.shaderState.acceptShadow,this.defineValue.USE_LIGHT=u,this.defineValue.USE_VERTXCOLOR=l,m.setting.pick.mode=="pixel"&&(this.defineValue.USE_WORLDPOS=!0),m.setting.gi.enable?this.defineValue.USEGI=!0:this.defineValue.USEGI=!1,m.setting.render.debug&&(this.defineValue.USE_DEBUG=!0,this.defineValue.DEBUG_CLUSTER=!0),this.shaderState.useLight?this.defineValue.USE_LIGHT=!0:this.defineValue.USE_LIGHT=!1,m.setting.render.useLogDepth?(this.defineValue.USE_LOGDEPTH=!0,this.shaderState.useFragDepth=!0):this.defineValue.USE_LOGDEPTH=!1,this.shaderState.useFragDepth?this.defineValue.USE_OUTDEPTH=!0:this.defineValue.USE_OUTDEPTH=!1,this.defineValue.USE_PCF_SHADOW=m.setting.shadow.type=="PCF",this.defineValue.USE_HARD_SHADOW=m.setting.shadow.type=="HARD",this.defineValue.USE_SOFT_SHADOW=m.setting.shadow.type=="SOFT",this.defineValue.USE_CSM=nr.Cascades>1,this.defineValue.USE_IES_PROFILE=ga.use}genReflection(){this.shaderVariant=zt.genRenderShaderVariant(this);let e=zt.poolGetReflection(this.shaderVariant);if(e)this.shaderReflection=e;else{let r=xr.parse(this._destVS,this.defineValue);r=xr.parse(r,this.defineValue),zt.getShaderReflection2(r,this);let i=xr.parse(this._destFS,this.defineValue);i=xr.parse(i,this.defineValue),zt.getShaderReflection2(i,this),zt.final(this)}this.shaderState.splitTexture=this.shaderReflection.useSplit}destroy(e){for(const r in this.textures)if(Object.prototype.hasOwnProperty.call(this.textures,r)){const i=this.textures[r];Ae.getInstance().detached(i,this),e&&!Ae.getInstance().hasReference(i)?i.destroy(e):i.destroy(!1)}this.bindGroups.length=0,this.shaderState=null,this.textures=null,this.pipeline=null,this.bindGroupLayouts=null,this._sourceVS=null,this._sourceFS=null,this._destVS=null,this._destFS=null,this._vsShaderModule=null,this._fsShaderModule=null,this.materialDataUniformBuffer.destroy(),this.materialDataUniformBuffer=null}static destroyShader(e){Sr.renderShader.has(e)&&(Sr.renderShader.get(e).destroy(),Sr.renderShader.delete(e))}static getShader(e){return Sr.renderShader.get(e)}static createShader(e,r){let i=new Le(e,r);return Sr.renderShader.set(i.instanceID,i),i.instanceID}}class nc extends Le{constructor(){super("sky_vs_frag_wgsl","SkyGBuffer_fs"),this.passType=J.GI,this.setUniformVector3("eyesPos",new g),this.setUniformFloat("exposure",1),this.setUniformFloat("roughness",0);let t=this.shaderState;t.frontFace="ccw",t.cullMode=Pt.front,t.depthWriteEnabled=!1,t.depthCompare=ct.less_equal}}class lc extends Le{constructor(){super("gbuffer_vs","gbuffer_fs");s(this,"transparency");this.setShaderEntry("VertMain","FragMain"),this.passType=J.GI,this.setUniformColor("baseColor",new K),this.setUniformColor("emissiveColor",new K),this.setUniformFloat("emissiveIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("alphaCutoff",1),this.blendMode=oe.NONE,this.setTexture("normalMap",m.res.normalTexture)}}class hc extends Le{constructor(){super("shadowCastMap_vert","directionShadowCastMap_frag"),this.passType=J.SHADOW,this.setShaderEntry("main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",g.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class uc extends Le{constructor(){super("castPointShadowMap_vert","shadowCastMap_frag"),this.passType=J.POINT_SHADOW,this.setShaderEntry("main","main"),this.setUniformFloat("cameraFar",5e3),this.setUniformVector3("lightWorldPos",g.ZERO),this.shaderState.receiveEnv=!1,this.shaderState.castShadow=!1,this.shaderState.acceptShadow=!1,this.setDefine("USE_ALPHACUT",!0)}}class cc extends Le{constructor(){super("ZPass_shader_vs","ZPass_shader_vs"),this.passType=J.DEPTH,this.setShaderEntry("main"),this.useRz=!1;let t=this.shaderState;t.receiveEnv=!1}}class ms{static createGIPass(t,e){if(sr.hasMask(t.rendererMask,ye.Sky)){if(!e.passShader.get(J.GI)){let r=e.getSubShaders(J.COLOR)[0],i=new nc;i.setTexture("baseMap",r.getTexture("baseMap")),i.cullMode=r.cullMode,i.frontFace=r.frontFace,e.addRenderPass(i,0),i.preCompile(t.geometry)}}else this.castGBufferPass(t,e)}static castGBufferPass(t,e){let r=e.getDefaultShaders();for(let i=0;i<r.length;i++){const a=r[i];let o=e.getSubShaders(J.GI);if(!o||o.length==0||o.length<i){let l=new lc;l.setTexture("baseMap",a.getTexture("baseMap")),l.setTexture("normalMap",a.getTexture("normalMap")),l.setTexture("emissiveMap",a.getTexture("emissiveMap")),l.setUniform("baseColor",a.getUniform("baseColor")),l.setUniform("envIntensity",a.getUniform("envIntensity")),l.setUniform("emissiveColor",a.getUniform("emissiveColor")),l.setUniform("emissiveIntensity",a.getUniform("emissiveIntensity")),l.setUniform("alphaCutoff",a.getUniform("alphaCutoff")),l.cullMode=a.cullMode,l.frontFace=a.frontFace,l.preCompile(t.geometry),e.addRenderPass(l)}}}static createShadowPass(t,e){let r=sr.hasMask(t.rendererMask,ye.SkinnedMesh),i=t.geometry.hasAttribute(O.TANGENT),a=t.geometry.hasAttribute(Ce.MORPH_POSITION_PREFIX+"0"),o=t.geometry.hasAttribute(Ce.MORPH_NORMAL_PREFIX+"0"),l=e.getSubShaders(J.COLOR);for(let h=0;h<l.length;h++){const u=l[h];let c=e.getSubShaders(J.SHADOW);if(!c||c.length<h+1){let d=new hc;d.setTexture("baseMap",u.getTexture("baseMap")),d.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),i&&d.setDefine("USE_TANGENT",i),r&&d.setDefine("USE_SKELETON",r),a&&d.setDefine("USE_MORPHTARGETS",a),o&&d.setDefine("USE_MORPHNORMALS",o),d.preCompile(t.geometry),e.addRenderPass(d)}let f=e.getSubShaders(J.POINT_SHADOW);if(!f||f.length<h+1){let d=new uc;d.setTexture("baseMap",u.getTexture("baseMap")),d.setUniform("alphaCutoff",u.getUniform("alphaCutoff")),d.setDefine("USE_ALPHACUT",1);for(let p=0;p<1;p++)i&&d.setDefine("USE_TANGENT",i),r&&d.setDefine("USE_SKELETON",r),a&&d.setDefine("USE_MORPHTARGETS",a),o&&d.setDefine("USE_MORPHNORMALS",o),d.shaderState.cullMode="front",d.preCompile(t.geometry);e.addRenderPass(d)}}}static createDepthPass(t,e){let r=e.getSubShaders(J.COLOR),i=t.geometry.hasAttribute("TANGENT"),a=t.geometry.hasAttribute(Ce.MORPH_POSITION_PREFIX+"0"),o=t.geometry.hasAttribute(Ce.MORPH_NORMAL_PREFIX+"0"),l=sr.hasMask(t.rendererMask,ye.SkinnedMesh);for(let h=0;h<r.length;h++){const u=r[h];let c=e.getSubShaders(J.DEPTH);if(!c&&u.shaderState.useZ&&(!c||c.length<h)){let f=new cc;f.setTexture("baseMap",u.getTexture("baseMap")),i||f.setDefine("USE_TANGENT",i),l&&f.setDefine("USE_SKELETON",l),a&&f.setDefine("USE_MORPHTARGETS",a),o&&f.setDefine("USE_MORPHNORMALS",o),f.cullMode=u.cullMode,f.frontFace=u.frontFace,f.preCompile(t.geometry),e.addRenderPass(f)}}}static createReflectionPass(t,e){let r=e.getDefaultShaders();for(let l=0;l<r.length;l++){const h=r[l];let u=e.getSubShaders(J.REFLECTION);if(!u||u.length==0||u.length<l){let c=new Le(h.vsName,h.fsName);c.vsEntryPoint=h.vsEntryPoint,c.fsEntryPoint=h.fsEntryPoint,c.passType=J.REFLECTION;for(const f in h.shaderState){var i=h.shaderState[f];c.shaderState[f]=i}for(const f in h.textures){var a=h.getTexture(f);c.setTexture(f,a)}for(const f in h.uniforms){var o=h.getUniform(f);c.setUniform(f,o)}for(const f in h.defineValue){var o=h.defineValue[f];c.setDefine(f,o)}c.setDefine("USE_CASTREFLECTION",!0),c.preCompile(t.geometry),e.addRenderPass(c)}}}}class fc{constructor(t){s(this,"renderer");s(this,"owner");s(this,"uuid");this.renderer=t,this.uuid=t.object3D.instanceID}leaveNode(){this.owner&&(this.owner.entities.delete(this.uuid),this.owner=null)}enterNode(t){this.owner&&this.leaveNode(),this.owner=t,t.entities.set(this.uuid,this)}update(t){var e;return(e=this.owner)!=null&&e.tryInsertEntity(this)||(this.leaveNode(),t.tryInsertEntity(this)),this.owner}}var dc=Object.defineProperty,gc=Object.getOwnPropertyDescriptor,lo=(n,t,e,r)=>{for(var i=gc(t,e),a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=o(t,e,i)||i);return i&&dc(t,e,i),i};class Aa extends Qt{constructor(){super(...arguments);s(this,"instanceCount",0);s(this,"lodLevel",0);s(this,"alwaysRender",!1);s(this,"instanceID");s(this,"drawType",0);s(this,"_geometry");s(this,"_materials",[]);s(this,"_castShadow",!0);s(this,"_castReflection",!0);s(this,"_castGI",!1);s(this,"_rendererMask",ye.Default);s(this,"_inRenderer",!1);s(this,"_readyPipeline",!1);s(this,"_combineShaderRefection");s(this,"_ignoreEnvMap");s(this,"_ignorePrefilterMap");s(this,"__renderOrder",0);s(this,"_renderOrder",0);s(this,"_passInit",new Map);s(this,"isRenderOrderChange");s(this,"needSortOnCameraZ");s(this,"isRecievePostEffectUI");s(this,"_octreeBinder");s(this,"_renderLayer",us.None);s(this,"_computes")}init(e){this.renderOrder=0,this.rendererMask=ye.Default,this.instanceID=mn().toString(),this._computes=[]}attachSceneOctree(e){this._octreeBinder={octree:e,entity:new fc(this)},this.transform.eventDispatcher.addEventListener(Cr.LOCAL_ONCHANGE,this.updateOctreeEntity,this)}detachSceneOctree(){var e;this._octreeBinder&&((e=this._octreeBinder.entity)==null||e.leaveNode(),this.transform.eventDispatcher.removeEventListener(Cr.LOCAL_ONCHANGE,this.updateOctreeEntity,this),this._octreeBinder=null)}updateOctreeEntity(e){var r,i;(i=(r=this._octreeBinder)==null?void 0:r.entity)==null||i.update(this._octreeBinder.octree)}copyComponent(e){return super.copyComponent(e),this.geometry=e._geometry,this.materials=e._materials.slice(),this.drawType=e.drawType,this.alwaysRender=e.alwaysRender,this.needSortOnCameraZ=e.needSortOnCameraZ,this.isRenderOrderChange=e.isRenderOrderChange,this.castShadow=e.castShadow,this.castGI=e.castGI,this.rendererMask=e.rendererMask,this.isRecievePostEffectUI=e.isRecievePostEffectUI,this}get renderLayer(){return this._renderLayer}set renderLayer(e){this._renderLayer=e}get geometry(){return this._geometry}set geometry(e){this._geometry!=e&&(this._readyPipeline=!1,this._geometry&&Ae.getInstance().detached(this._geometry,this),e&&Ae.getInstance().attached(e,this)),this._geometry=e}addMask(e){this._rendererMask=sr.addMask(this.rendererMask,e)}removeMask(e){this._rendererMask=sr.removeMask(this.rendererMask,e)}hasMask(e){return sr.hasMask(this.rendererMask,e)}get rendererMask(){return this._rendererMask}set rendererMask(e){this._rendererMask=e}get renderOrder(){return this._renderOrder}set renderOrder(e){e!=this._renderOrder&&(this.isRenderOrderChange=!0,this.__renderOrder=e),this._renderOrder=e}get materials(){return this._materials}set materials(e){this._readyPipeline=!1;for(let i=0;i<this._materials.length;i++){let a=this._materials[i];Ae.getInstance().detached(a,this),a.shader&&a.shader.computes&&this.removeComputes(a.shader.computes)}for(let i=0;i<e.length;i++){let a=e[i];Ae.getInstance().attached(a,this),a.shader&&a.shader.computes&&this.addComputes(a.shader.computes)}this._materials=e;let r=0;for(let i=0;i<e.length;i++){const a=e[i].getPass(J.COLOR)[0];a.shaderState.transparent&&(r=r>a.renderOrder?r:a.renderOrder)}this.renderOrder=r,this._readyPipeline||this.initPipeline()}addComputes(e){this._computes.push(...e)}removeComputes(e){for(const r of e){let i=this._computes.indexOf(r);i!=-1&&this._computes.splice(i,1)}}addRendererMask(e){this._rendererMask=sr.addMask(this._rendererMask,e)}removeRendererMask(e){this._rendererMask=sr.removeMask(this._rendererMask,e)}onEnable(){this._readyPipeline||this.initPipeline(),X.instance.addRenderNode(this.transform.scene3D,this),this.updateOctreeEntity()}onDisable(){var e;this._enable=!1,X.instance.removeRenderNode(this.transform.scene3D,this),(e=super.onDisable)==null||e.call(this)}selfCloneMaterials(e){let r=[];for(let i=0,a=this.materials.length;i<a;i++){const o=this.materials[i].clone();r.push(o)}return this.materials=r,this._readyPipeline=!1,this.initPipeline(),this}initPipeline(){if(this._geometry&&this._materials.length>0){for(let r=0;r<this._materials.length;r++){let i=this._materials[r].getPass(J.COLOR);for(let a=0;a<i.length;a++){const o=i[a];o.shaderReflection||o.preCompile(this._geometry),this._geometry.generate(o.shaderReflection)}this.object3D.bound=this._geometry.bounds.clone()}this._readyPipeline=!0;let e=0;for(let r=0;r<this.materials.length;r++){const i=this.materials[r].getPass(J.COLOR)[0];i.renderOrder>=3e3?e=e>i.renderOrder?e:i.renderOrder:e=Math.max(e-3e3,0),this.castNeedPass()}this.renderOrder=e,this.enable&&this.transform&&this.transform.scene3D&&X.instance.addRenderNode(this.transform.scene3D,this)}}castNeedPass(){if(this.castGI)for(let e=0;e<this.materials.length;e++){const r=this.materials[e];ms.createGIPass(this,r.shader)}for(let e=0;e<this.materials.length;e++){const r=this.materials[e];r.castShadow&&ms.createShadowPass(this,r.shader)}if(this.castReflection)for(let e=0;e<this.materials.length;e++){const r=this.materials[e];r.castReflection&&ms.createReflectionPass(this,r.shader)}if(!sr.hasMask(this.rendererMask,ye.IgnoreDepthPass)&&m.setting.render.zPrePass)for(let e=0;e<this.materials.length;e++){const r=this.materials[e];ms.createDepthPass(this,r.shader)}else for(let e=0;e<this.materials.length;e++)this.materials[e].shader.removeShaderByIndex(J.DEPTH,0)}get castShadow(){return this._castShadow}set castShadow(e){this._castShadow=e}get castGI(){return this._castGI}set castGI(e){this._castGI=e}get castReflection(){return this._castReflection}set castReflection(e){this._castReflection=e}renderPass(e,r,i){if(!this._geometry)return;let a=this,o=a.transform._worldMatrix;const l=Math.max(a.materials.length,a._geometry.subGeometries.length);for(let h=0;h<l;h++){const u=h>=a.materials.length?a.materials[0]:a.materials[h];if(!u||!u.enable)continue;let c=u.getPass(r);if(!(!c||c.length==0)){S.bindGeometryBuffer(i.encoder,a._geometry),Fe.viewCount_vertex(e,J[r],a._geometry.vertexCount);for(let f=0;f<c.length;f++){if(!c||c.length==0)continue;const d=c[f];if(d.pipeline){d.shaderState.splitTexture&&(i.endRenderPass(),Vt.WriteSplitColorTexture(a.instanceID),i.beginOpaqueRenderPass(),S.bindCamera(i.encoder,e.camera),S.bindGeometryBuffer(i.encoder,a._geometry)),S.bindPipeline(i.encoder,d)&&Fe.viewCount_pipeline(e,J[r]);let p=(h>=a._geometry.subGeometries.length?a._geometry.subGeometries[0]:a._geometry.subGeometries[h]).lodLevels[a.lodLevel];a.instanceCount>0?(Fe.viewCount_instance(e,J[r],a.instanceCount),Fe.viewCount_indices(e,J[r],p.indexCount),Fe.viewCount_tri(e,J[r],p.indexCount/3*a.instanceCount),S.drawIndexed(i.encoder,p.indexCount,a.instanceCount,p.indexStart,0,0)):(Fe.viewCount_indices(e,J[r],p.indexCount),Fe.viewCount_tri(e,J[r],p.indexCount/3),S.drawIndexed(i.encoder,p.indexCount,1,p.indexStart,0,o.index)),Fe.viewCount_draw(e,J[r])}}}}}renderPass2(e,r,i,a,o,l=!1){if(!this.enable||!this._geometry)return;let h=this,u=h.object3D.transform._worldMatrix;for(let c=0;c<this.materials.length;c++){const f=this.materials[c];if(!f.castShadow&&r==J.SHADOW)continue;let d=f.getPass(r);if(!d||d.length==0)return;if(this.drawType==2)for(let p of d)p.pipeline&&(S.bindPipeline(o,p),S.draw(o,6,1,0,u.index));else{S.bindGeometryBuffer(o,h._geometry);for(let p of d)if(p.pipeline){S.bindPipeline(o,p);let A=h._geometry.subGeometries[c].lodLevels[h.lodLevel];S.drawIndexed(o,A.indexCount,1,A.indexStart,0,u.index)}}}}recordRenderPass2(e,r,i,a,o,l=!1){if(!this.enable)return;let h=this;for(let u=0;u<this.materials.length;u++){let c=this.materials[u].getPass(r);if(!c||c.length==0)return;let f=h.object3D.transform._worldMatrix;for(let d=0;d<c.length;d++){const p=c[d];S.bindPipeline(o,p);let A=h._geometry.subGeometries[u].lodLevels[h.lodLevel];S.drawIndexed(o,A.indexCount,1,A.indexStart,0,f.index)}}}noticeShaderChange(){this.enable&&(this.onEnable(),this._passInit.forEach((e,r)=>{this._passInit.set(r,!1)}))}preInit(e){return this._passInit.get(e)}nodeUpdate(e,r,i,a){let o=this,l=e.scene.envMap;for(let h=0;h<o.materials.length;h++){let u=o.materials[h].getPass(r);if(u)for(let c=0;c<u.length;c++){const f=u[c];if(f.shaderState.splitTexture){let y=Vt.CreateSplitTexture(o.instanceID);f.setTexture("splitTexture_Map",y)}!o._ignoreEnvMap&&f.envMap!=l&&f.setTexture("envMap",l),f.prefilterMap||f.setTexture("prefilterMap",l);let d=re.getReflectionEntries(e.scene);if(!f.reflectionMap&&d&&d.reflectionMap&&(f.setTexture("reflectionMap",d.reflectionMap),f.setStorageBuffer("reflectionBuffer",d.storageGPUBuffer)),f.pipeline){f.apply(o._geometry,i,()=>o.noticeShaderChange());continue}let p=m.res.getTexture("BRDFLUT");f.setTexture("brdflutMap",p);let A=m.getRenderJob(e).shadowMapPassRenderer;A&&A.depth2DArrayTexture&&f.setTexture("shadowMap",m.getRenderJob(e).shadowMapPassRenderer.depth2DArrayTexture);let x=m.getRenderJob(e).pointLightShadowRenderer;x&&x.cubeArrayTexture&&f.setTexture("pointShadowMap",x.cubeArrayTexture);let C=ga.iesTexture;C&&f.setTexture("iesTextureArrayMap",C),i.irradianceBuffer&&i.irradianceBuffer.length>0&&(f.setTexture("irradianceMap",i.irradianceBuffer[0]),f.setTexture("irradianceDepthMap",i.irradianceBuffer[1]));let v=re.getLightEntries(e.scene);v&&(f.setStorageBuffer("lightBuffer",v.storageGPUBuffer),v.irradianceVolume&&f.setUniformBuffer("irradianceData",v.irradianceVolume.irradianceVolumeBuffer)),a&&(f.setStorageBuffer("clustersUniform",a.clustersUniformBuffer),f.setStorageBuffer("lightAssignBuffer",a.lightAssignBuffer),f.setStorageBuffer("assignTable",a.assignTableBuffer),f.setStorageBuffer("clusterBuffer",a.clusterBuffer)),f.apply(o._geometry,i),this._passInit.set(r,!0)}}}beforeDestroy(e){Ae.getInstance().detached(this._geometry,this),Ae.getInstance().hasReference(this._geometry)||this._geometry.destroy(e);for(let r=0;r<this._materials.length;r++){const i=this._materials[r];Ae.getInstance().detached(i,this),Ae.getInstance().hasReference(i)||i.destroy(e)}super.beforeDestroy(e)}destroy(e){super.destroy(e),this._geometry=void 0,this._materials.length=0,this._combineShaderRefection=void 0}}lo([ha],Aa.prototype,"materials"),lo([ha],Aa.prototype,"castShadow"),lo([ha],Aa.prototype,"castGI");var pc=Object.defineProperty,mc=Object.getOwnPropertyDescriptor,ho=(n,t,e,r)=>{for(var i=r>1?void 0:r?mc(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&pc(t,e,i),i};let $=class extends Aa{constructor(){super();s(this,"receiveShadow");s(this,"morphData")}onEnable(){super.onEnable()}onDisable(){super.onDisable()}cloneTo(t){t.addComponent($).copyComponent(this)}copyComponent(t){return super.copyComponent(t),this.receiveShadow=t.receiveShadow,this}get geometry(){return this._geometry}set geometry(t){var e;if(super.geometry=t,t){let r=t.morphTargetDictionary!=null;r&&(this.morphData||(this.morphData=new Wu),this.morphData.morphTargetsRelative=t.morphTargetsRelative,this.morphData.initMorphTarget(t)),this.morphData&&(this.morphData.enable=r),(e=this.morphData)!=null&&e.enable?this.addRendererMask(ye.MorphTarget):this.removeRendererMask(ye.MorphTarget),this.object3D.bound=this._geometry.bounds.clone()}else this.morphData&&(this.morphData.enable=!1),this.removeRendererMask(ye.MorphTarget);this._readyPipeline||(this.initPipeline(),this._computes&&(this.onCompute=qs(this.onCompute,()=>{for(let r=0;r<this._computes.length;r++)this._computes[r].onUpdate()})))}get material(){return this._materials[0]}set material(t){this.materials=[t]}setMorphInfluence(t,e){if(this.morphData&&this.morphData.enable){let r=this._geometry.morphTargetDictionary[t];r>=0&&this.morphData.updateInfluence(r,e)}}setMorphInfluenceIndex(t,e){this.morphData&&this.morphData.enable&&t>=0&&this.morphData.updateInfluence(t,e)}onCompute(t,e){this.morphData&&this.morphData.enable&&this.morphData.computeMorphTarget(e)}nodeUpdate(t,e,r,i){if(this.morphData&&this.morphData.enable)for(let a=0;a<this.materials.length;a++){let o=this.materials[a].getPass(e);if(o)for(let l=0;l<o.length;l++)this.morphData.applyRenderShader(o[l])}super.nodeUpdate(t,e,r,i)}destroy(t){super.destroy(t)}};ho([ha],$.prototype,"geometry",1),ho([ha],$.prototype,"material",1),$=ho([or($,"MeshRenderer")],$);class ht{}s(ht,"compressGBufferTex_NAME","compressGBufferTex_NAME"),s(ht,"colorBufferTex_NAME","colorBufferTex"),s(ht,"positionBufferTex_NAME","positionBufferTex"),s(ht,"normalBufferTex_NAME","normalBufferTex"),s(ht,"materialBufferTex_NAME","materialBufferTex"),s(ht,"zBufferTexture_NAME","zBufferTexture"),s(ht,"zPreDepthTexture_NAME","zPreDepthTexture"),s(ht,"outTex_NAME","outTex");class Ac{constructor(){s(this,"label","");s(this,"customSize",!1);s(this,"zPreTexture",null);s(this,"depthTexture",null);s(this,"renderTargetTextures");s(this,"outColor",-1);s(this,"renderTargets");s(this,"rtTextureDescriptors");s(this,"irradianceBuffer");s(this,"multisample",0);s(this,"multiTexture");s(this,"depthViewIndex",0);s(this,"depthCleanValue",0);s(this,"isOutTarget",!0);s(this,"camera3D");s(this,"rtFrame");s(this,"renderPassDescriptor");s(this,"renderBundleEncoderDescriptor");s(this,"depthLoadOp")}getLastRenderTexture(){return this.renderTargets&&this.renderTargets.length>0?this.renderTargets[0]:m.res.redTexture}}class bt extends It{constructor(e,r,i=j.rgba8unorm,a=!1,o,l=1,h=0,u=!0,c=!0){super(e,r,l);s(this,"resolveTarget");s(this,"sampleCount");s(this,"autoResize");s(this,"clear");this.name=kt(),this.autoResize=c,this.useMipmap=a,this.sampleCount=h,this.format=i,this.numberLayer=l,this.clear=u,o!=null?this.usage=o:this.usage=o|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.resize(e,r),this.autoResize&&E.addEventListener(Wr.RESIZE,f=>{let{width:d,height:p}=f.data;this.resize(d,p),this._textureChange=!0},this)}resize(e,r){let i=E.device;this.gpuTexture&&(It.delayDestroyTexture(this.gpuTexture),this.gpuTexture=null,this.view=null),this.width=e,this.height=r,this.createTextureDescriptor(e,r,1,this.format,this.usage,this.numberLayer,this.sampleCount),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this.format==j.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=i.createSampler({})):this.format==j.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=E.device.createSampler({}),this.gpuSampler_comparison=E.device.createSampler({compare:"less",label:"sampler_comparison"})):this.format==j.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=E.device.createSampler({}),this.gpuSampler_comparison=E.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.sampleCount>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="linear",this.addressModeU=Wt.clamp_to_edge,this.addressModeV=Wt.clamp_to_edge,this.gpuSampler=i.createSampler(this)),this._textureChange=!0}create(e,r,i=!0){let a=E.device;const o=e*4;let l=new Float32Array(e*r*4);const h=a.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(h,0,l);const u=S.beginCommandEncoder();u.copyBufferToTexture({buffer:h,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:r,depthOrArrayLayers:1}),S.endCommandEncoder(u)}clone(){let e=new bt(this.width,this.height,this.format,this.useMipmap,this.usage,this.numberLayer,this.sampleCount,this.clear,this.autoResize);return e.name="clone_"+e.name,e}readTextureToImage(){let e=E.device,r=E.windowWidth,i=E.windowHeight,a=new Float32Array(r*i*4);const o=e.createBuffer({size:a.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return S.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:o},[r,i]),o.getMappedRange(0,a.byteLength)}}class Me{constructor(){s(this,"storeOp","store");s(this,"loadOp","clear");s(this,"clearValue",[0,0,0,0])}}class Je{constructor(t,e,r,i,a=!0){s(this,"label");s(this,"customSize",!1);s(this,"renderTargets");s(this,"rtDescriptors");s(this,"zPreTexture");s(this,"depthTexture");s(this,"depthViewIndex",0);s(this,"depthCleanValue",1);s(this,"depthLoadOp","clear");s(this,"isOutTarget",!0);this.renderTargets=t,this.rtDescriptors=e,this.depthTexture=r,this.zPreTexture=i,this.isOutTarget=a}clone2Frame(t){t.renderTargets.push(...this.renderTargets.concat());for(let e=0;e<this.rtDescriptors.length;e++){const r=this.rtDescriptors[e];let i=new Me;i.loadOp=r.loadOp,i.storeOp=r.storeOp,i.clearValue=r.clearValue,t.rtDescriptors.push(i)}t.depthTexture=this.depthTexture,t.zPreTexture=this.zPreTexture,t.customSize=this.customSize}clone(){let t=new Je([],[]);return this.clone2Frame(t),t}}const Ht=class Ht extends Je{constructor(){super([],[]);s(this,"_colorBufferTex");s(this,"_compressGBufferTex")}createGBuffer(e,r,i,a=!0,o=!0,l){let h=this.renderTargets,u=this.rtDescriptors;if(o){let f=new Me;f.loadOp="clear",this._colorBufferTex=Vt.createRTTexture(e+ht.colorBufferTex_NAME,r,i,j.rgba16float,!0),h.push(this._colorBufferTex),u.push(f)}this._compressGBufferTex=new bt(r,i,j.rgba32float,!1,void 0,1,0,!0,!0),h.push(this._compressGBufferTex),l?this.depthTexture=l:(this.depthTexture=new bt(r,i,j.depth24plus,!1,void 0,1,0,!0,!0),this.depthTexture.name=e+"_depthTexture");let c;c=new Me,u.push(c)}getPositionMap(){return this.renderTargets[1]}getNormalMap(){return this.renderTargets[2]}getColorTexture(){return this._colorBufferTex}getCompressGBufferTexture(){return this._compressGBufferTex}static getGBufferFrame(e,r=0,i=0,a=!0,o){let l;if(Ht.gBufferMap.has(e))l=Ht.gBufferMap.get(e);else{l=new Ht;let h=E.presentationSize;l.createGBuffer(e,r==0?h[0]:r,i==0?h[1]:i,r!=0&&i!=0,a,o),Ht.gBufferMap.set(e,l)}return l}static getGUIBufferFrame(){let e=this.getGBufferFrame(this.colorPass_GBuffer);return Ht.getGBufferFrame(Ht.gui_GBuffer,0,0,!0,e.depthTexture)}clone(){let e=new Ht;return this.clone2Frame(e),e}};s(Ht,"colorPass_GBuffer","ColorPassGBuffer"),s(Ht,"reflections_GBuffer","reflections_GBuffer"),s(Ht,"gui_GBuffer","gui_GBuffer"),s(Ht,"gBufferMap",new Map);let fe=Ht;const Vr=class Vr{static createRendererPassState(t,e=null){let r=Vr.rendererPassState.get(t);if(r||(r=new Ac,r.label=t.label,r.customSize=t.customSize,r.rtFrame=t,r.zPreTexture=t.zPreTexture,r.depthTexture=t.depthTexture,r.depthViewIndex=t.depthViewIndex,r.isOutTarget=t.isOutTarget,r.depthCleanValue=t.depthCleanValue,r.depthLoadOp=t.depthLoadOp,Vr.rendererPassState.set(t,r)),t&&t.renderTargets.length>0){r.renderTargets=t.renderTargets,r.rtTextureDescriptors=t.rtDescriptors,r.renderPassDescriptor=Vr.getRenderPassDescriptor(r),r.renderPassDescriptor.depthStencilAttachment&&(r.renderPassDescriptor.depthStencilAttachment.depthLoadOp=t.depthLoadOp),e=="load"&&(t!=null&&t.renderTargets[0])&&t.renderTargets[0].name.startsWith(fe.gui_GBuffer)&&(r.renderPassDescriptor.colorAttachments[0].loadOp="load"),r.depthLoadOp=t.depthLoadOp,r.renderBundleEncoderDescriptor=Vr.getRenderBundleDescriptor(r),r.renderTargetTextures=[];for(let i=0;i<t.renderTargets.length;i++){const a=t.renderTargets[i];r.renderTargetTextures[i]={format:a.format},a.name.indexOf(ht.colorBufferTex_NAME)!=-1&&(r.outColor=i)}}else r.renderPassDescriptor=Vr.getRenderPassDescriptor(r,e),r.renderBundleEncoderDescriptor=Vr.getRenderBundleDescriptor(r),r.renderTargetTextures=[{format:E.presentationFormat}],r.outColor=0;return r}static getRenderPassDescriptor(t,e=null){if(t.renderPassDescriptor)return t.renderPassDescriptor;E.device,E.presentationSize;let r=[];if(t.renderTargets&&t.renderTargets.length>0){t.renderTargets[0].width,t.renderTargets[0].height;for(let a=0;a<t.renderTargets.length;a++){const o=t.renderTargets[a],l=t.rtTextureDescriptors[a];r.push({view:o.getGPUView(),resolveTarget:void 0,loadOp:l.loadOp,clearValue:l.clearValue,storeOp:l.storeOp})}}else if(!t.customSize){let a=E.canvasConfig&&E.canvasConfig.alpha?[1,1,1,0]:[0,0,0,1];t.isOutTarget==!0&&r.push({view:void 0,resolveTarget:void 0,loadOp:E.canvasConfig&&E.canvasConfig.alpha||e!=null?"load":"clear",clearValue:a,storeOp:"store"})}let i=null;return t.depthTexture||t.zPreTexture?(t.zPreTexture&&(t.depthTexture=t.zPreTexture),i={label:`${t.label} renderPassDescriptor zPreTexture${t.zPreTexture?"load":"clear"}`,colorAttachments:r,depthStencilAttachment:{view:t.depthTexture.getGPUView(),depthLoadOp:t.zPreTexture?"load":t.depthLoadOp,depthClearValue:t.zPreTexture?1:t.depthCleanValue,depthStoreOp:"store"}}):i={colorAttachments:r,label:"renderPassDescriptor not writeDepth"},t.renderPassDescriptor=i,i}static getRenderBundleDescriptor(t){if(t.renderBundleEncoderDescriptor)return t.renderBundleEncoderDescriptor;E.presentationSize;let e=[];if(t.renderTargets&&t.renderTargets.length>0){t.renderTargets[0].width,t.renderTargets[0].height;for(let i=0;i<t.renderTargets.length;i++){const a=t.renderTargets[i];e.push(a.format)}}let r=null;return t.depthTexture?r={colorFormats:e,depthStencilFormat:t.depthTexture.format}:r={colorFormats:e},t.renderBundleEncoderDescriptor=r,t.renderBundleEncoderDescriptor}};s(Vr,"rendererPassState",new Map);let Ze=Vr;class uo extends fi{constructor(e){super();s(this,"node");this.bufferType=vr.VertexGPUBuffer,this.createVertexBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.VERTEX,e)}createVertexBuffer(e,r){let i=E.device;this.byteSize=r*Float32Array.BYTES_PER_ELEMENT,this.usage=e,this.buffer&&this.destroy(),this.buffer=i.createBuffer({label:"VertexGPUBuffer",size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new ua,this.memoryNodes=new Map,this.memory.allocation(this.byteSize),this.node=this.memory.allocation_node(this.byteSize)}}var wt=(n=>(n[n.split=0]="split",n[n.compose=1]="compose",n[n.compose_bin=2]="compose_bin",n))(wt||{});class vc{constructor(){s(this,"vertexCount",0);s(this,"vertexGPUBuffer");s(this,"geometryType",wt.compose);s(this,"_vertexBufferLayouts");s(this,"_attributeSlotLayouts");s(this,"_attributeLocation");this._vertexBufferLayouts=[],this._attributeLocation={},this._attributeSlotLayouts=[]}get vertexBufferLayouts(){return this._vertexBufferLayouts}createVertexBuffer(t,e){switch(this.geometryType){case wt.split:this.createSplitVertexBuffer(t,e);break;case wt.compose:this.createComposeVertexBuffer(t,e);break;case wt.compose_bin:this.createComposBinVertexBuffer(t,e);break}}createSplitVertexBuffer(t,e){let r=0;for(let i=0;i<e.attributes.length;i++){const a=e.attributes[i];if(a.name=="index")continue;this._attributeLocation[a.name]=a.location;let o={name:a.name,format:a.format,offset:0,shaderLocation:a.location,stride:gi[a.format]};this._attributeSlotLayouts[a.location]=[o];let l=t.get(a.name);l||(l={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},t.set(a.name,l));let h=l.data.length/o.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h,this._vertexBufferLayouts[a.location]={name:a.name,arrayStride:a.size*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[a.location],offset:r*4,size:this.vertexCount*a.size*4},r+=this.vertexCount*a.size}this.vertexGPUBuffer=new uo(r)}createComposeVertexBuffer(t,e){this._attributeSlotLayouts[0]=[];let r=0;for(let i=0;i<e.attributes.length;i++){const a=e.attributes[i];if(a.name=="index"||a.type=="builtin")continue;this._attributeLocation[a.name]=a.location;let o={name:a.name,format:a.format,offset:r*4,shaderLocation:a.location,stride:gi[a.format]};this._attributeSlotLayouts[0][a.location]=o;let l=t.get(a.name);if(l||(l={attribute:a.name,data:new Float32Array(a.size*this.vertexCount)},t.set(a.name,l)),l.data){let h=l.data.length/o.stride;this.vertexCount!=0&&this.vertexCount!=h&&console.error(" vertex count not match attribute count"),this.vertexCount=h}r+=a.size}this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new uo(this.vertexCount*r)}createComposBinVertexBuffer(t,e){this._attributeSlotLayouts[0]=[];let r=0;for(let a=0;a<e.attributes.length;a++){const o=e.attributes[a];if(o.name=="index"||o.type=="builtin")continue;this._attributeLocation[o.name]=o.location;let l={name:o.name,format:o.format,offset:r*4,shaderLocation:o.location,stride:gi[o.format]};this._attributeSlotLayouts[0][o.location]=l;let h=t.get(o.name);if(h||(h={attribute:o.name,data:new Float32Array(o.size*this.vertexCount)},t.set(o.name,h)),h.data){let u=h.data.length/l.stride;this.vertexCount!=0&&this.vertexCount!=u&&console.error(" vertex count not match attribute count"),this.vertexCount=u}r+=o.size}let i=t.get(O.all).data.length/r;this.vertexCount=i,this._vertexBufferLayouts[0]={name:"composeStruct",arrayStride:r*4,stepMode:"vertex",attributes:this._attributeSlotLayouts[0],offset:0,size:this.vertexCount*r*4},this.vertexGPUBuffer=new uo(this.vertexCount*r)}upload(t,e){var r;if(this.vertexGPUBuffer){switch(this.geometryType){case wt.split:{let i=this._attributeLocation[t],a=this._vertexBufferLayouts[i];this.vertexGPUBuffer.node.setFloat32Array(a.offset/4,e.data)}break;case wt.compose:for(let i=0;i<this.vertexCount;i++){const a=this._attributeSlotLayouts[0][this._attributeLocation[t]];for(let o=0;o<a.stride;o++){let l=e.data[i*a.stride+o],h=i*(this._vertexBufferLayouts[0].arrayStride/4)+a.offset/4+o;this.vertexGPUBuffer.node.setFloat(l,h)}}break;case wt.compose_bin:this.vertexGPUBuffer.node.setFloat32Array(0,e.data);break}(r=this.vertexGPUBuffer)==null||r.apply()}}updateAttributes(t){switch(this.geometryType){case wt.split:for(let e=0;e<this._vertexBufferLayouts.length;e++){const r=this._vertexBufferLayouts[e];let i=t.get(r.name);this.vertexGPUBuffer.node.setFloat32Array(r.offset/4,i.data)}break;case wt.compose:for(let e=0;e<this.vertexCount;e++)this._attributeSlotLayouts.forEach(r=>{for(let i=0;i<r.length;i++){const a=r[i];let o=t.get(a.name);for(let l=0;l<a.stride;l++){let h=o.data[e*a.stride+l],u=e*(this._vertexBufferLayouts[0].arrayStride/4)+a.offset/4+l;this.vertexGPUBuffer.node.setFloat(h,u)}}});break;case wt.compose_bin:{let e=t.get(O.all);this.vertexGPUBuffer.node.setFloat32Array(0,e.data)}break}this.vertexGPUBuffer.apply()}compute(){}destroy(){this.vertexCount=null,this.geometryType=null,this._vertexBufferLayouts=null,this._attributeSlotLayouts=null,this._attributeLocation=null,this.vertexGPUBuffer&&this.vertexGPUBuffer.destroy(),this.vertexGPUBuffer=null}}class xc extends fi{constructor(e){super();s(this,"indicesNode");this.bufferType=vr.IndicesGPUBuffer,this.createIndicesBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.INDEX|GPUBufferUsage.INDIRECT,e)}createIndicesBuffer(e,r){let i=E.device;this.byteSize=r.length*4,this.usage=e,this.buffer&&this.destroy(),this.buffer=i.createBuffer({label:"IndicesGPUBuffer",size:this.byteSize,usage:e,mappedAtCreation:!1}),this.memory=new ua,this.memoryNodes=new Map,this.memory.allocation(this.byteSize),r&&(this.indicesNode=this.memory.allocation_node(r.length*4),this.indicesNode.setArrayBuffer(0,r),this.apply())}}class Cc{constructor(){s(this,"uuid","");s(this,"name");s(this,"indicesGPUBuffer");s(this,"indicesFormat","uint16");s(this,"indicesCount",0)}createIndicesBuffer(t){t.data instanceof Uint16Array?this.indicesFormat="uint16":t.data instanceof Uint32Array&&(this.indicesFormat="uint32"),this.indicesCount=t.data.length,this.indicesGPUBuffer=new xc(t.data)}upload(t){this.indicesGPUBuffer.indicesNode.setArrayBuffer(0,t),this.indicesGPUBuffer.apply()}compute(){}destroy(){this.uuid=null,this.name=null,this.indicesFormat=null,this.indicesCount=null,this.indicesGPUBuffer.destroy(),this.indicesGPUBuffer=null}}class _c{constructor(){s(this,"lodLevels")}}const Lt=class Lt{constructor(){s(this,"instanceID");s(this,"name");s(this,"subGeometries",[]);s(this,"morphTargetsRelative");s(this,"morphTargetDictionary");s(this,"skinNames");s(this,"bindPose");s(this,"blendShapeData");s(this,"vertexDim");s(this,"vertexCount",0);s(this,"_bounds");s(this,"_attributeMap");s(this,"_attributes");s(this,"_indicesBuffer");s(this,"_vertexBuffer");s(this,"_onChange",!0);s(this,"_wireframeLines");this.instanceID=kt(),this._attributeMap=new Map,this._attributes=[],this._vertexBuffer=new vc}get indicesBuffer(){return this._indicesBuffer}get vertexBuffer(){return this._vertexBuffer}get vertexAttributes(){return this._attributes}get vertexAttributeMap(){return this._attributeMap}get geometryType(){return this._vertexBuffer.geometryType}set geometryType(t){this._vertexBuffer.geometryType=t}get bounds(){if(!this._bounds){this._bounds=new Oe(new g,new g(1,1,1)),this._bounds.min.x=Number.MAX_VALUE,this._bounds.min.y=Number.MAX_VALUE,this._bounds.min.z=Number.MAX_VALUE,this._bounds.max.x=-Number.MAX_VALUE,this._bounds.max.y=-Number.MAX_VALUE,this._bounds.max.z=-Number.MAX_VALUE;let t=this.getAttribute(O.position);if(t&&t.data)for(let e=0;e<t.data.length/3;e++){const r=t.data[e*3+0],i=t.data[e*3+1],a=t.data[e*3+2];this._bounds.min.x>r&&(this._bounds.min.x=r),this._bounds.min.y>i&&(this._bounds.min.y=i),this._bounds.min.z>a&&(this._bounds.min.z=a),this._bounds.max.x<r&&(this._bounds.max.x=r),this._bounds.max.y<i&&(this._bounds.max.y=i),this._bounds.max.z<a&&(this._bounds.max.z=a)}this._bounds.setFromMinMax(this._bounds.min,this._bounds.max)}return this._bounds}set bounds(t){this._bounds=t}addSubGeometry(...t){let e=new _c;return e.lodLevels=t,this.subGeometries.push(e),e}generate(t){this._onChange&&(this._onChange=!1,this._indicesBuffer.upload(this.getAttribute(O.indices).data),this._vertexBuffer.createVertexBuffer(this._attributeMap,t),this._vertexBuffer.updateAttributes(this._attributeMap),this.vertexCount=this._vertexBuffer.vertexCount)}setIndices(t){if(!this._attributeMap.has(O.indices)){let e={attribute:O.indices,data:t};this._attributeMap.set(O.indices,e),this._indicesBuffer=new Cc,this._indicesBuffer.createIndicesBuffer(e)}}setAttribute(t,e){if(t==O.indices)this.setIndices(e);else{let r={attribute:t,data:e};this._attributeMap.set(t,r),this._attributes.push(t)}}getAttribute(t){return this._attributeMap.get(t)}hasAttribute(t){return this._attributeMap.has(t)}genWireframe(){if(this._wireframeLines)return this._wireframeLines;if(this.geometryType==wt.split||this.geometryType==wt.compose){let t=this.getAttribute(O.position),e=this.getAttribute(O.indices);if(e&&t&&e.data.length>0){let r=t.data,i=[];for(let a=0;a<e.data.length/3;a++){const o=e.data[a*3+0],l=e.data[a*3+1],h=e.data[a*3+2];let u=new g(r[o*3+0],r[o*3+1],r[o*3+2]),c=new g(r[l*3+0],r[l*3+1],r[l*3+2]),f=new g(r[h*3+0],r[h*3+1],r[h*3+2]);i.push(u,c),i.push(c,f),i.push(f,u)}return this._wireframeLines=i,i}}else if(this.geometryType==wt.compose_bin){let t=this.getAttribute(O.all),e=this.vertexDim,r=this.getAttribute(O.indices);if(r&&t&&r.data.length>0){let i=t.data,a=[];for(let o=0;o<r.data.length/3;o++){const l=r.data[o*3+0],h=r.data[o*3+1],u=r.data[o*3+2];let c=new g(i[l*e+0],i[l*e+1],i[l*e+2]),f=new g(i[h*e+0],i[h*e+1],i[h*e+2]),d=new g(i[u*e+0],i[u*e+1],i[u*e+2]);a.push(c,f),a.push(f,d),a.push(d,c)}return this._wireframeLines=a,a}}return null}compute(){this._indicesBuffer&&this._indicesBuffer.compute(),this._vertexBuffer&&this._vertexBuffer.compute()}computeNormals(){let t=this.getAttribute(O.position),e=this.getAttribute(O.normal),r=this.getAttribute(O.indices);if(!t||!e||!r)return this;let i=r.data.length/3,a=Lt.point1,o=Lt.point2,l=Lt.point3,h=Lt.crossA,u=Lt.crossB,c=Lt.crossRet;for(let f=0;f<i;f++){let d=r.data[f*3],p=r.data[f*3+1],A=r.data[f*3+2];a.set(t.data[d*3],t.data[d*3+1],t.data[d*3+2]),o.set(t.data[p*3],t.data[p*3+1],t.data[p*3+2]),l.set(t.data[A*3],t.data[A*3+1],t.data[A*3+2]),g.sub(a,o,h).normalize(),g.sub(a,l,u).normalize();let x=h.crossProduct(u,c).normalize();e.data[d*3]=e.data[p*3]=e.data[A*3]=x.x,e.data[d*3+1]=e.data[p*3+1]=e.data[A*3+1]=x.y,e.data[d*3+2]=e.data[p*3+2]=e.data[A*3+2]=x.z}return this._vertexBuffer.upload(O.normal,e),this}isPrimitive(){return!1}destroy(t){this.instanceID=null,this.name=null,this.subGeometries=null,this.morphTargetDictionary=null,this._bounds.destroy(),this._bounds=null,this._attributeMap=null,this._attributes=null,this._indicesBuffer.destroy(),this._vertexBuffer.destroy(),this._indicesBuffer=null,this._vertexBuffer=null}};s(Lt,"crossA",g.UP.clone()),s(Lt,"crossB",g.UP.clone()),s(Lt,"crossRet",g.UP.clone()),s(Lt,"point1",g.UP.clone()),s(Lt,"point2",g.UP.clone()),s(Lt,"point3",g.UP.clone());let qt=Lt;class va extends qt{constructor(e,r,i=1,a=1,o=g.Y_AXIS){super();s(this,"width");s(this,"height");s(this,"segmentW");s(this,"segmentH");s(this,"up");this.width=e,this.height=r,this.segmentW=i,this.segmentH=a,this.up=o,this.buildGeometry(this.up)}buildGeometry(e){var r,i,a,o,l=this.segmentW+1;(this.segmentH+1)*l,this.bounds=new Oe(g.ZERO.clone(),new g(this.width,1,this.height)),a=this.segmentH*this.segmentW*6;let h=(this.segmentW+1)*(this.segmentH+1),u=new Float32Array(h*3),c=new Float32Array(h*3),f=new Float32Array(h*2),d;this.segmentW*this.segmentH*2*3>=Uint16Array.length?d=new Uint32Array(this.segmentW*this.segmentH*2*3):d=new Uint16Array(this.segmentW*this.segmentH*2*3),a=0;for(var p=0,A=0,x=0,C=0;C<=this.segmentH;++C)for(var v=0;v<=this.segmentW;++v){switch(r=(v/this.segmentW-.5)*this.width,i=(C/this.segmentH-.5)*this.height,e){case g.Y_AXIS:u[p++]=r,u[p++]=0,u[p++]=i,c[A++]=0,c[A++]=1,c[A++]=0;break;case g.Z_AXIS:u[p++]=r,u[p++]=-i,u[p++]=0,c[A++]=0,c[A++]=0,c[A++]=1;break;case g.X_AXIS:u[p++]=0,u[p++]=r,u[p++]=i,c[A++]=1,c[A++]=0,c[A++]=0;break;default:u[p++]=r,u[p++]=0,u[p++]=i,c[A++]=0,c[A++]=1,c[A++]=0;break}f[x++]=v/this.segmentW,f[x++]=C/this.segmentH,v!=this.segmentW&&C!=this.segmentH&&(o=v+C*l,d[a++]=o+1,d[a++]=o,d[a++]=o+l,d[a++]=o+1,d[a++]=o+l,d[a++]=o+l+1)}this.setIndices(d),this.setAttribute(O.position,u),this.setAttribute(O.normal,c),this.setAttribute(O.uv,f),this.setAttribute(O.TEXCOORD_1,f),this.addSubGeometry({indexStart:0,indexCount:d.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class $r{constructor(){s(this,"instanceID");s(this,"name");s(this,"enable",!0);s(this,"_defaultSubShader");s(this,"_shader");this.instanceID=kt()}set shader(t){this._shader=t,this._defaultSubShader=t.getDefaultShaders()[0]}get shader(){return this._shader}get doubleSide(){return this._defaultSubShader.doubleSide}set doubleSide(t){this._defaultSubShader.doubleSide=t}get castShadow(){return this._defaultSubShader.shaderState.castShadow}set castShadow(t){let e=this._defaultSubShader.shaderState;t!=e.castShadow&&(e.castShadow=t)}get acceptShadow(){return this._defaultSubShader.shaderState.acceptShadow}set acceptShadow(t){let e=this._defaultSubShader.shaderState;e.acceptShadow!=t&&(e.acceptShadow=t,this._defaultSubShader.noticeShaderChange(),this._defaultSubShader.noticeValueChange())}get castReflection(){return this._defaultSubShader.shaderState.castReflection}set castReflection(t){this._defaultSubShader.shaderState.castReflection=t}get blendMode(){return this._defaultSubShader.blendMode}set blendMode(t){this._defaultSubShader.blendMode=t}get depthCompare(){return this._defaultSubShader.depthCompare}set depthCompare(t){this._defaultSubShader.depthCompare=t;for(let e of this._shader.passShader.values())for(let r of e)r.depthCompare=t}get transparent(){return this._defaultSubShader.shaderState.transparent}set transparent(t){this._defaultSubShader.shaderState.transparent=t,t&&(this._defaultSubShader.renderOrder=3e3)}get cullMode(){return this._defaultSubShader.cullMode}set cullMode(t){if(this._defaultSubShader.cullMode!=t){for(let e of this._shader.passShader.values())for(let r of e)r.cullMode=t;this._defaultSubShader.cullMode=t}}get depthWriteEnabled(){return this._defaultSubShader.depthWriteEnabled}set depthWriteEnabled(t){this._defaultSubShader.depthWriteEnabled=t}set useBillboard(t){this._defaultSubShader.setDefine("USE_BILLBOARD",t)}get topology(){return this._defaultSubShader.topology}set topology(t){this._defaultSubShader.topology=t}set baseColor(t){this.shader.setUniformColor("baseColor",t)}get baseColor(){return this.shader.getUniformColor("baseColor")}getPass(t){return this._shader.getSubShaders(t)}getAllPass(){return this._shader.getSubShaders(J.COLOR)}clone(){let t=new $r;return t.shader=this.shader.clone(),t}destroy(t){this.name=null,this.instanceID=null,this._shader.destroy(t),this._shader=null}setDefine(t,e){this.shader.setDefine(t,e)}setTexture(t,e){this._shader.setTexture(t,e)}setStorageBuffer(t,e){this._shader.setStorageBuffer(t,e)}setUniformBuffer(t,e){this._shader.setStorageBuffer(t,e)}setUniformFloat(t,e){this._shader.setUniformFloat(t,e)}setUniformVector2(t,e){this._shader.setUniformVector2(t,e)}setUniformVector3(t,e){this._shader.setUniformVector3(t,e)}setUniformVector4(t,e){this._shader.setUniformVector4(t,e)}setUniformColor(t,e){this._shader.setUniformColor(t,e)}getUniformFloat(t){return this._shader.getUniform(t).data}getUniformV2(t){return this._shader.getUniformVector2(t)}getUniformV3(t){return this._shader.getUniformVector3(t)}getUniformV4(t){return this._shader.getUniformVector4(t)}getUniformColor(t){return this._shader.getUniformColor(t)}getTexture(t){return this._shader.getTexture(t)}getStorageBuffer(t){return this._shader.getStorageBuffer(t)}getStructStorageBuffer(t){return this._shader.getStructStorageBuffer(t)}getUniformBuffer(t){return this._shader.getUniformBuffer(t)}applyUniform(){this._shader.applyUniform()}}class gt{constructor(){s(this,"computes");s(this,"passShader");this.computes=[],this.passShader=new Map}addRenderPass(t,e=-1){let r=this.passShader.get(t.passType)||[];e==-1?r.push(t):r.splice(e,-1,t),this.passShader.set(t.passType,r)}removeShader(t,e=-1){let r=this.passShader.get(t.passType);if(r)if(e==-1){let i=r.indexOf(t);i!=-1&&r.splice(i)}else r.splice(e,1)}removeShaderByIndex(t,e=-1){let r=this.passShader.get(t);r&&(e==-1?this.passShader.delete(t):r.splice(e,1))}getSubShaders(t){return this.passShader.get(t)||[]}hasSubShaders(t){return this.passShader.get(t).length>0}getDefaultShaders(){return this.passShader.get(J.COLOR)}getDefaultColorShader(){return this.passShader.get(J.COLOR)[0]}setDefine(t,e){for(const r of this.passShader)for(const i of r[1])i.setDefine(t,e)}hasDefine(t){for(const e of this.passShader)for(const r of e[1]){let i=r.hasDefine(t);if(i)return i}return!1}deleteDefine(t){for(const e of this.passShader)for(const r of e[1])r.deleteDefine(t)}setUniform(t,e){for(const r of this.passShader)for(const i of r[1])i.setUniform(t,e)}setUniformFloat(t,e){for(const r of this.passShader)for(const i of r[1])i.setUniformFloat(t,e)}setUniformVector2(t,e){for(const r of this.passShader)for(const i of r[1])i.setUniformVector2(t,e)}setUniformVector3(t,e){for(const r of this.passShader)for(const i of r[1])i.setUniformVector3(t,e)}setUniformVector4(t,e){for(const r of this.passShader)for(const i of r[1])i.setUniformVector4(t,e)}setUniformColor(t,e){for(const r of this.passShader)for(const i of r[1])i.setUniformColor(t,e)}getUniform(t){return this.getDefaultColorShader().getUniform(t)}getUniformFloat(t){return this.getDefaultColorShader().getUniformFloat(t)}getUniformVector2(t){return this.getDefaultColorShader().getUniformVector2(t)}getUniformVector3(t){return this.getDefaultColorShader().getUniformVector3(t)}getUniformVector4(t){return this.getDefaultColorShader().getUniformVector4(t)}getUniformColor(t){return this.getDefaultColorShader().getUniformColor(t)}setTexture(t,e){for(const r of this.passShader)for(const i of r[1])i.setTexture(t,e);this.setDefine(`USE_${t.toLocaleUpperCase()}`,!0)}getTexture(t){return this.getDefaultColorShader().textures[t]}setUniformBuffer(t,e){for(const r of this.passShader)for(const i of r[1])i.setUniformBuffer(t,e)}getUniformBuffer(t){return this.getDefaultColorShader().getBuffer(t)}setStorageBuffer(t,e){for(const r of this.passShader)for(const i of r[1])i.setStorageBuffer(t,e)}getStorageBuffer(t){return this.getDefaultColorShader().getBuffer(t)}setStructStorageBuffer(t,e){for(const r of this.passShader)for(const i of r[1])i.setStructStorageBuffer(t,e)}getStructStorageBuffer(t){return this.getDefaultColorShader().getBuffer(t)}noticeValueChange(){for(const t of this.passShader)for(const e of t[1])e.noticeValueChange()}destroy(t){this.getDefaultColorShader().destroy(t)}clone(){let t=new gt,e=this.getDefaultShaders();for(const r of e)t.addRenderPass(r);return t}applyUniform(){for(const t of this.passShader)for(const e of t[1])e.applyUniform()}}var yc=Object.defineProperty,Sc=Object.getOwnPropertyDescriptor,Ic=(n,t,e,r)=>{for(var i=r>1?void 0:r?Sc(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&yc(t,e,i),i};let co=class extends gt{constructor(n="QuadGlsl_vs",t="QuadGlsl_fs"){super();let e=new Le(n,t);this.addRenderPass(e);let r=e.shaderState;e.blendMode=oe.NONE,r.frontFace="cw",r.depthWriteEnabled=!1,r.depthCompare=ct.always,r.multisample=0,this.setTexture("baseMap",m.res.blackTexture),this.setUniformFloat("x",0),this.setUniformFloat("y",0),this.setUniformFloat("width",100),this.setUniformFloat("height",100)}};co=Ic([ci],co);class Nn extends ee{constructor(e="QuadGlsl_vs",r="QuadGlsl_fs",i,a=0,o=!1){super();s(this,"width",128);s(this,"height",128);s(this,"quadRenderer");s(this,"material");s(this,"rendererPassState");s(this,"quadShader");let l=i?i.renderTargets:[];this.material=new $r,this.quadShader=new co(e,r),this.material.shader=this.quadShader,this.quadRenderer=this.addComponent($),this.quadRenderer.material=this.material,this.quadRenderer.castGI=!1,this.quadRenderer.castShadow=!1,this.quadRenderer.drawType=o?2:0,this.quadRenderer.geometry=new va(100,100,1,1),this.quadRenderer.material=this.material,this.quadRenderer.__start(),this.quadRenderer._enable=!0,this.quadRenderer.onEnable(),this.rendererPassState=Ze.createRendererPassState(i,"load"),a>0&&(this.rendererPassState.multisample=this.quadShader.getDefaultColorShader().shaderState.multisample,this.rendererPassState.multiTexture=E.device.createTexture({size:{width:E.presentationSize[0],height:E.presentationSize[1]},sampleCount:a,format:l.length>0?l[0].format:E.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT})),E.addEventListener(Wr.RESIZE,h=>{this.rendererPassState=Ze.createRendererPassState(i,"load"),a>0&&(this.rendererPassState.multisample=this.quadShader.getDefaultColorShader().shaderState.multisample,this.rendererPassState.multiTexture=E.device.createTexture({size:{width:E.presentationSize[0],height:E.presentationSize[1]},sampleCount:a,format:l.length>0?l[0].format:E.presentationFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT}))},this)}renderTarget(e,r,i){let a=e.camera,o=S.beginRenderPass(i,r.rendererPassState);S.bindCamera(o,a),r.quadRenderer.nodeUpdate(e,J.COLOR,r.rendererPassState,null),r.quadRenderer.renderPass2(e,J.COLOR,r.rendererPassState,null,o),S.endPass(o)}renderToViewQuad(e,r,i,a){let o=e.camera;r.quadShader.setTexture("baseMap",a);let l=S.beginRenderPass(i,r.rendererPassState);S.bindCamera(l,o),r.quadRenderer.nodeUpdate(e,J.COLOR,r.rendererPassState,null),r.quadRenderer.renderPass2(e,J.COLOR,r.rendererPassState,null,l),S.endPass(l)}}const wi=class wi{static init(){this.rtTextureMap=new Map,this.rtViewQuad=new Map}static createRTTexture(t,e,r,i,a=!1,o=0){let l=this.rtTextureMap.get(t);return l||(t==ht.colorBufferTex_NAME?l=new bt(e,r,i,a,void 0,1,o,!1):l=new bt(e,r,i,a,void 0,1,o,!0),l.name=t,wi.rtTextureMap.set(t,l)),l}static createRTTextureArray(t,e,r,i,a=1,o=!1,l=0){let h=this.rtTextureMap.get(t);return h||(h=new bt(e,r,i,o,void 0,a,l),h.name=t,wi.rtTextureMap.set(t,h)),h}static createViewQuad(t,e,r,i,a=0){let o=new Je([i],[new Me]),l=new Nn(e,r,o,a);return wi.rtViewQuad.set(t,l),l}static getTexture(t){return this.rtTextureMap.get(t)}static CreateSplitTexture(t){let e=this.getTexture(ht.colorBufferTex_NAME),r=this.getTexture(t+"_split");return r||(r=this.createRTTexture(t+"_split",e.width,e.height,e.format,!1)),r}static WriteSplitColorTexture(t){let e=this.getTexture(ht.colorBufferTex_NAME),r=this.getTexture(t+"_split");const i=S.beginCommandEncoder();i.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{width:r.width,height:r.height,depthOrArrayLayers:1}),S.endCommandEncoder(i)}};s(wi,"rtTextureMap"),s(wi,"rtViewQuad");let Vt=wi;class Fn{constructor(t){s(this,"command");s(this,"encoder");s(this,"rendererPassStates");s(this,"rtFrame");this.rtFrame=t,this.rendererPassStates=[]}clean(){this.rendererPassStates.length=0,S.cleanCache()}beginContinueRendererPassState(t="load",e="load"){if(this.rendererPassStates.length>0){let r=this.rtFrame.clone();for(const a of r.rtDescriptors)a.loadOp="load";r.depthLoadOp=e;let i=Ze.createRendererPassState(r,t);return this.rendererPassStates.push(i),i}else{this.rtFrame.depthLoadOp=e;let r=Ze.createRendererPassState(this.rtFrame,t);return this.rendererPassStates.push(r),r}}get rendererPassState(){return this.rendererPassStates[this.rendererPassStates.length-1]}beginOpaqueRenderPass(){this.beginContinueRendererPassState("clear","clear"),this.begineNewCommand(),this.beginNewEncoder()}beginTransparentRenderPass(){this.beginContinueRendererPassState("load","load"),this.begineNewCommand(),this.beginNewEncoder()}specialtRenderPass(){this.beginContinueRendererPassState("load","load"),this.begineNewCommand(),this.beginNewEncoder()}endRenderPass(){this.endEncoder(),this.endCommand()}begineNewCommand(){return this.command=S.beginCommandEncoder(),this.command}endCommand(){S.endCommandEncoder(this.command),this.command=null}beginNewEncoder(){return this.encoder=S.beginRenderPass(this.command,this.rendererPassState),this.encoder}endEncoder(){S.endPass(this.encoder),this.encoder=null}}class Lr extends ir{constructor(){super();s(this,"rendererPassState");s(this,"splitRendererPassState");s(this,"useRenderBundle",!1);s(this,"debugViewQuads");s(this,"debugTextures");s(this,"renderContext");s(this,"_rendererType");s(this,"_rtFrame");this.debugTextures=[],this.debugViewQuads=[]}get passType(){return this._rendererType}set passType(e){this._rendererType=e}setRenderStates(e){if(this._rtFrame=e,e){this.rendererPassState=Ze.createRendererPassState(e);let r=e.clone();r.depthLoadOp="load";for(const i of r.rtDescriptors)i.loadOp="load";this.splitRendererPassState=Ze.createRendererPassState(r)}this.renderContext=new Fn(e)}getRenderContext(e){return this._rtFrame=e,new Fn(e)}setIrradiance(e,r){this.rendererPassState.irradianceBuffer=[e,r]}compute(e,r){}render(e,r,i,a=!1){S.cleanCache();let o=e.camera,l=e.scene;this.rendererPassState.camera3D=o;let h=X.instance.getRenderNodes(l,o),u=this.renderBundleOp(e,h,r,i),c=a?[]:this.renderBundleTr(e,h,r,i);{let f=S.beginCommandEncoder(),d=S.beginRenderPass(f,this.rendererPassState);u.length>0&&d.executeBundles(u),!a&&X.instance.sky&&(S.bindCamera(d,o),X.instance.sky.renderPass2(e,this._rendererType,this.rendererPassState,i,d)),this.drawRenderNodes(e,d,f,h.opaqueList,r),S.endPass(d),S.endCommandEncoder(f)}{let f=S.beginCommandEncoder(),d=S.beginRenderPass(f,this.rendererPassState);c.length>0&&d.executeBundles(c),a||(S.bindCamera(d,o),this.drawRenderNodes(e,d,f,h.transparentList,r)),S.endPass(d),S.endCommandEncoder(f)}}nodeUpload(e,r,i){}occlusionRenderNodeTest(e,r,i){return i?i.occlusionRenderNodeTest(e)>0:!0}renderOp(e,r,i,a,o){}renderTr(e,r,i,a,o){}renderBundleOp(e,r,i,a){let o=X.instance.getOpRenderGroup(e.scene);if(o){let l=[];return o.renderGroup.forEach(h=>{if(h.bundleMap.has(this._rendererType))l.push(h.bundleMap.get(this._rendererType));else{let u=S.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,u,h.renderNodes,a);let c=u.finish();h.bundleMap.set(this._rendererType,c),l.push(c)}}),l}return[]}renderBundleTr(e,r,i,a){let o=X.instance.getTrRenderGroup(e.scene);if(o){let l=[];return o.renderGroup.forEach(h=>{if(h.bundleMap.has(this._rendererType))l.push(h.bundleMap.get(this._rendererType));else{let u=S.recordBundleEncoder(this.rendererPassState.renderBundleEncoderDescriptor);this.recordRenderBundleNode(e,u,h.renderNodes,a);let c=u.finish();h.bundleMap.set(this._rendererType,c),l.push(c)}}),l}return[]}recordRenderBundleNode(e,r,i,a){S.bindCamera(r,e.camera),S.bindGeometryBuffer(r,i[0].geometry);for(let o=0;o<i.length;++o){let l=i[o];l.transform.worldMatrix.index,l.transform.enable&&l.recordRenderPass2(e,this._rendererType,this.rendererPassState,a,r)}}drawRenderNodes(e,r,i,a,o,l){S.bindCamera(r,e.camera);for(let h=m.setting.render.drawOpMin;h<Math.min(a.length,m.setting.render.drawOpMax);++h){let u=a[h];u.transform.enable&&u.enable&&u.renderPass2(e,this._rendererType,this.rendererPassState,l,r)}}}class bc extends Lr{constructor(){super(),this.passType=J.COLOR}render(t,e,r,i=!1){this.renderContext.clean();let a=t.scene,o=t.camera;re.updateCameraGroup(o),this.rendererPassState.camera3D=o;let l=X.instance.getRenderNodes(a,o),h=this.renderBundleOp(t,l,e,r),u=i?[]:this.renderBundleTr(t,l,e,r);{this.renderContext.beginOpaqueRenderPass();let c=this.renderContext.encoder;h.length>0&&(X.instance.getOpRenderGroup(a),c.executeBundles(h)),!i&&X.instance.sky&&(S.bindCamera(c,o),X.instance.sky.preInit(this._rendererType)||X.instance.sky.nodeUpdate(t,this._rendererType,this.rendererPassState,r),X.instance.sky.renderPass2(t,this._rendererType,this.rendererPassState,r,c)),l.opaqueList&&(S.bindCamera(c,o),this.drawNodes(t,this.renderContext,l.opaqueList,e,r))}{let c=this.renderContext.encoder;u.length>0&&c.executeBundles(u),!i&&l.transparentList&&(S.bindCamera(c,o),this.drawNodes(t,this.renderContext,l.transparentList,e,r));let f=X.instance.getGraphicList();for(let d=0;d<f.length;d++){const p=f[d];p.nodeUpdate(t,this._rendererType,this.splitRendererPassState,r),p.renderPass2(t,this._rendererType,this.splitRendererPassState,r,c)}this.renderContext.endRenderPass(),Fe.end("ColorPass Draw Transparent")}}drawNodes(t,e,r,i,a){let o=X.instance.getRenderShaderCollect(t);if(o){for(const l of o){let h=l[1];for(const u of h){let c=u[1];if(!c.isDestroyed&&c.preInit(this._rendererType)){c.nodeUpdate(t,this._rendererType,this.rendererPassState,a);break}}}for(let l=m.setting.render.drawOpMin;l<Math.min(r.length,m.setting.render.drawOpMax);++l){let h=r[l];h.transform.enable&&h.enable&&(h.hasMask(ye.UI)&&!h.isRecievePostEffectUI||h.isDestroyed||(h.preInit(this._rendererType)||h.nodeUpdate(t,this._rendererType,this.rendererPassState,a),h.renderPass(t,this.passType,this.renderContext)))}}}occlusionRenderNodeTest(t,e,r){return r.zDepthRenderNodeTest(e)>0}}class fo{constructor(){s(this,"frustumCullingList");s(this,"zVisibleList");s(this,"_renderList");this._renderList=new Map}occlusionRenderNodeTest(t){return m.setting.occlusionQuery.enable?this.frustumCullingList?this.frustumCullingList[t]:0:1}zDepthRenderNodeTest(t){return this.zVisibleList?this.zVisibleList[t]:0}update(t,e){}collect(t,e){}renderCommitTesting(t,e){return!0}}s(fo,"enable",!0);class xa extends fi{constructor(t,e){super(),this.bufferType=vr.ComputeGPUBuffer,this.createBuffer(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST,t,e,"ComputeGPUBuffer")}}class wc{constructor(t,e){s(this,"clusterBuffer");s(this,"lightAssignBuffer");s(this,"assignTableBuffer");s(this,"clustersUniformBuffer");this.clusterBuffer=new xa(t*2*4),this.clustersUniformBuffer=new Ct(10),this.clustersUniformBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.lightAssignBuffer=new xa(t*e),this.lightAssignBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE,this.assignTableBuffer=new xa(t*4),this.assignTableBuffer.visibility=GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE}update(t,e,r,i,a,o,l,h,u,c){this.clustersUniformBuffer.setFloat("clusterTileX",i),this.clustersUniformBuffer.setFloat("clusterTileY",a),this.clustersUniformBuffer.setFloat("clusterTileZ",o),this.clustersUniformBuffer.setFloat("numLights",l),this.clustersUniformBuffer.setFloat("maxNumLightsPerCluster",h),this.clustersUniformBuffer.setFloat("near",u),this.clustersUniformBuffer.setFloat("far",c),this.clustersUniformBuffer.setFloat("screenWidth",t),this.clustersUniformBuffer.setFloat("screenHeight",e),this.clustersUniformBuffer.setFloat("clusterPix",r),this.clustersUniformBuffer.apply()}}class it{}s(it,"clusterTileX",16),s(it,"clusterTileY",16),s(it,"clusterTileZ",32);let Tc=`
  #include "GlobalUniform"

        struct ClusterBox{
            minPoint:vec4<f32>,
            maxPoint:vec4<f32>
        }

        struct ClustersUniform{
            clusterTileX:f32,
            clusterTileY:f32,
            clusterTileZ:f32,
            numLights:f32,
            maxNumLightsPerCluster:f32,
            near:f32,
            far:f32,
            screenWidth:f32,
            screenHeight:f32,
            clusterPix:f32
        }
     
        @group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
        @group(0) @binding(2) var<storage,read_write> clusterBuffer : array<ClusterBox>;


        var<private> clusterTileX:f32 ;
        var<private> clusterTileY:f32 ;
        var<private> clusterTileZ:f32 ;
        fn convertNDCToView( v4:vec4<f32> ) -> vec4<f32> {
            var v = globalUniform.pvMatrixInv * v4 ;
            v = v / v.w ;
            return v ;
        }

        fn ScreenToView(screen : vec4<f32>) -> vec4<f32> {
            let texCoord = screen.xy / vec2<f32>(clustersUniform.screenWidth, clustersUniform.screenHeight);
            let clip = vec4<f32>(vec2<f32>(texCoord.x, 1.0 - texCoord.y) * 2.0 - vec2<f32>(1.0, 1.0), screen.z, screen.w);
            return convertNDCToView(clip);
        }

        fn gridToIndex(i:vec3<u32>) -> u32{
            return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
        }

        fn LineIntersectionToZPlane( eye:vec3<f32> , ndcPoint :vec3<f32> , z:f32) -> vec3<f32>
        {
            var normal = vec3<f32>(0.0, 0.0, 1.0);
            var dir = ndcPoint - eye;
            var t = (z - dot(normal, eye)) / dot(normal, dir);
            var result = eye + t * dir;
            return result;
        }

        @compute @workgroup_size(${it.clusterTileX},${it.clusterTileY},1)
        fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){

            let i = local_invocation_id.x ;
            let j = local_invocation_id.y ;
            let k = workgroup_id.x ;

            clusterTileX = clustersUniform.clusterTileX;
            clusterTileY = clustersUniform.clusterTileY;
            clusterTileZ = clustersUniform.clusterTileZ;

            let clusterGrid = vec3<u32>(i,j,k);
            let tileIndex = gridToIndex(clusterGrid);
            let eyePos = vec3<f32>(0.0, 0.0, 0.0);

            let tx = clusterTileX;
            let ty = clusterTileY;
            let tz = clusterTileZ ;
            let near = clustersUniform.near ;
            let far = clustersUniform.far ;

            let titleSize = vec2<f32>( globalUniform.windowWidth / tx , globalUniform.windowHeight / ty ) ;

            var maxPointSs = vec4<f32>(vec2<f32>(f32(i) + 1.0, f32(j) + 1.0) * titleSize, 0.0, 1.0);
	        var minPointSs = vec4<f32>(vec2<f32>(f32(i) , f32(j)) * titleSize, 0.0, 1.0);

            var maxPointVs = ScreenToView(maxPointSs).xyz;
	        var minPointVs = ScreenToView(minPointSs).xyz;
 
            var tileNear = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, f32(k) / clustersUniform.clusterTileZ);
	        var tileFar = clustersUniform.near * pow(clustersUniform.far / clustersUniform.near, (f32(k) + 1.0) / clustersUniform.clusterTileZ);

            var minPointNear = LineIntersectionToZPlane(eyePos, minPointVs, tileNear);
            var minPointFar = LineIntersectionToZPlane(eyePos, minPointVs, tileFar);
            var maxPointNear = LineIntersectionToZPlane(eyePos, maxPointVs, tileNear);
            var maxPointFar = LineIntersectionToZPlane(eyePos, maxPointVs, tileFar);

            var minPointAABB = min(min(minPointNear, minPointFar), min(maxPointNear, maxPointFar));
            var maxPointAABB = max(max(minPointNear, minPointFar), max(maxPointNear, maxPointFar));

            var clusterBox : ClusterBox ;
            clusterBox.minPoint = vec4<f32>(minPointAABB,f32(tileIndex)) ;
            clusterBox.maxPoint = vec4<f32>(maxPointAABB,f32(tileIndex)) ;
            clusterBuffer[tileIndex] = clusterBox;
        }
`,Ec=`
#include "GlobalUniform"

struct ClusterBox{
    min:vec4<f32>,
    max:vec4<f32>
}

struct Light {
    index:f32,
    lightType:i32,
    radius:f32,
    linear:f32,

    position:vec3<f32>,
    lightMatrixIndex:f32,

    direction:vec3<f32>,
    quadratic:f32,

    lightColor:vec3<f32>,
    intensity:f32,

    innerCutOff :f32,
    outerCutOff:f32,
    range :f32,
    castShadow:f32,

    lightTangent:vec3<f32>,
    ies:f32,
};

struct LightIndex
{
    count:f32,
    start:f32,
    empty0:f32,
    empty1:f32,
};

struct ClustersUniform{
    clusterTileX:f32,
    clusterTileY:f32,
    clusterTileZ:f32,
    numLights:f32,
    maxNumLightsPerCluster:f32,
    near:f32,
    far:f32,
    screenWidth:f32,
    screenHeight:f32,
    clusterPix:f32, 
}

var<private> clusterTileX:f32 ;
var<private> clusterTileY:f32 ;
var<private> clusterTileZ:f32 ;

// @group(0) @binding(1) var<storage, read> models : Uniforms;
@group(0) @binding(1) var<uniform> clustersUniform : ClustersUniform;
@group(0) @binding(2) var<storage,read> clusterBuffer : array<ClusterBox>;
@group(0) @binding(3) var<storage,read> lightBuffer : array<Light>; 
@group(0) @binding(4) var<storage,read_write> lightAssignBuffer : array<f32>;
@group(0) @binding(5) var<storage,read_write> assignTable : array<LightIndex>;

fn gridToIndex(i:vec3<u32>) -> u32{
    return i.z * u32(clusterTileX) * u32(clusterTileY) + i.y * u32(clusterTileX) + i.x ;
}

fn GetSqdisPointAABB( pos:vec3<f32>,  cluster:ClusterBox  ) -> f32
{
    var sqDistance = 0.0;
    for (var i = 0u; i < 3u; i+=1u)
    {
        var v = pos[i];
        if (v < cluster.min[i])
        {
            let diff = cluster.min[i] - v;
            sqDistance += diff * diff;
        }

        if (v > cluster.max[i])
        {
            let diff =  v - cluster.max[i];
            sqDistance += diff * diff;
        }
    }
    return sqDistance;
}

fn TestSphereAABB( box:ClusterBox ,light:Light ) -> bool
{
    let lightPos = light.position.xyz;
    var radius = light.range * 2.0 ;
    var spherePos = globalUniform.viewMat * vec4<f32>(lightPos.xyz, 1.0) ;
    spherePos = spherePos / spherePos.w ;
    let sqDistance = GetSqdisPointAABB(spherePos.xyz , box);
    return sqDistance <= (radius*radius);
}

@compute @workgroup_size(${it.clusterTileX},${it.clusterTileY},1)
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
    // cluster ID 
    let i = local_invocation_id.x ;
    let j = local_invocation_id.y ;
    let k = workgroup_id.x ;

    clusterTileX = clustersUniform.clusterTileX;
    clusterTileY = clustersUniform.clusterTileY;
    clusterTileZ = clustersUniform.clusterTileZ;

    var clusterId_3D = vec3<u32>(i,j,k);
    var clusterId_1D = gridToIndex(clusterId_3D);

    var box:ClusterBox = clusterBuffer[clusterId_1D];

    var startIndex = i32(clusterId_1D) * i32(clustersUniform.maxNumLightsPerCluster) ;
    var endIndex = startIndex;

    for(var lightID = 0 ; lightID < i32(clustersUniform.numLights) ; lightID+=1)
    {
        let li:Light = lightBuffer[lightID];
        if(!TestSphereAABB(box, li)) {
            continue;
        }
        lightAssignBuffer[endIndex] = f32(lightID);
        endIndex++;
    }

    var idx: LightIndex;
    idx.count = f32(endIndex-startIndex);
    idx.start = f32(startIndex);
    idx.empty0 = f32(clusterId_1D);
    idx.empty1 = f32(clustersUniform.maxNumLightsPerCluster);
    assignTable[clusterId_1D] = idx;
}
`;class Bc extends Lr{constructor(e){super();s(this,"maxNumLightsPerCluster",64);s(this,"clusterPix",1);s(this,"clusterLightingBuffer");s(this,"_currentLightCount",0);s(this,"_clusterGenerateCompute");s(this,"_clusterLightingCompute");s(this,"_useCamera");s(this,"resize",!1);this.passType=J.Cluster,this.initCompute(e)}initCompute(e){this._clusterGenerateCompute=new ce(Tc),this._clusterLightingCompute=new ce(Ec);let r=E.presentationSize,i=it.clusterTileX*it.clusterTileY*it.clusterTileZ,a=e.camera,o=a.near,l=a.far;this.clusterLightingBuffer=new wc(i,this.maxNumLightsPerCluster),this.clusterLightingBuffer.update(r[0],r[1],this.clusterPix,it.clusterTileX,it.clusterTileY,it.clusterTileZ,0,this.maxNumLightsPerCluster,o,l),this._clusterGenerateCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterGenerateCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer);let h=re.getLightEntries(e.scene);this._clusterLightingCompute.setStorageBuffer("models",re.modelMatrixBindGroup.matrixBufferDst),this._clusterLightingCompute.setUniformBuffer("clustersUniform",this.clusterLightingBuffer.clustersUniformBuffer),this._clusterLightingCompute.setStorageBuffer("clusterBuffer",this.clusterLightingBuffer.clusterBuffer),this._clusterLightingCompute.setStorageBuffer("lightBuffer",h.storageGPUBuffer),this._clusterLightingCompute.setStorageBuffer("lightAssignBuffer",this.clusterLightingBuffer.lightAssignBuffer),this._clusterLightingCompute.setStorageBuffer("assignTable",this.clusterLightingBuffer.assignTableBuffer),this.resize=!0}render(e,r){let i=e.scene,a=X.instance.getLights(i);if(this._useCamera!=e.camera){this._useCamera=e.camera;let h=re.getCameraGroup(this._useCamera);this._clusterGenerateCompute.setUniformBuffer("globalUniform",h.uniformGPUBuffer),this._clusterLightingCompute.setUniformBuffer("globalUniform",h.uniformGPUBuffer)}this._currentLightCount!=a.length&&(this._currentLightCount=a.length,this.clusterLightingBuffer.clustersUniformBuffer.setFloat("numLights",a.length),this.clusterLightingBuffer.clustersUniformBuffer.apply(),this._clusterGenerateCompute.workerSizeX=it.clusterTileZ,this._clusterLightingCompute.workerSizeX=it.clusterTileZ);let o=E.presentationSize;this.clusterLightingBuffer.update(o[0],o[1],this.clusterPix,it.clusterTileX,it.clusterTileY,it.clusterTileZ,a.length,this.maxNumLightsPerCluster,e.camera.near,e.camera.far),this.resize=!1;let l=S.beginCommandEncoder();S.computeCommand(l,[this._clusterGenerateCompute,this._clusterLightingCompute]),S.endCommandEncoder(l)}}class pe extends It{constructor(e,r,i=j.rgba8unorm,a=!1,o,l=1,h=0,u=1){super(e,r,l);s(this,"resolveTarget");s(this,"sampleCount");E.device,this.name=kt(),this.useMipmap=a,this.sampleCount=h,this.format=i,this.numberLayer=l,this.mipmapCount=u,o!=null?this.usage=o:this.usage=o|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST,this.resize(e,r)}clone(){let e=new pe(this.width,this.height,this.format,this.useMipmap,this.usage,this.numberLayer,this.sampleCount);return e.name="clone_"+e.name,e}resize(e,r){let i=E.device;this.gpuTexture&&(It.delayDestroyTexture(this.gpuTexture),this.gpuTexture=null,this.view=null),this.width=e,this.height=r,this.createTextureDescriptor(e,r,this.mipmapCount,this.format,this.usage,this.numberLayer,this.sampleCount),this.useMipmap=!1,this.visibility=GPUShaderStage.COMPUTE|GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,this.format==j.rgba32float?(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=i.createSampler({})):this.format==j.depth32float?(this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison",this.textureBindingLayout.sampleType="depth",this.gpuSampler=E.device.createSampler({}),this.gpuSampler_comparison=E.device.createSampler({compare:"less",label:"sampler_comparison"})):this.format==j.depth24plus?(this.samplerBindingLayout={type:"filtering"},this.sampler_comparisonBindingLayout={type:"comparison"},this.textureBindingLayout.sampleType="depth",this.gpuSampler=E.device.createSampler({}),this.gpuSampler_comparison=E.device.createSampler({compare:"less",label:"sampler_comparison"})):(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.sampleCount>0&&(this.textureBindingLayout.multisampled=!0),this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="nearest",this.maxAnisotropy=1,this.addressModeU=Wt.mirror_repeat,this.addressModeV=Wt.mirror_repeat,this.gpuSampler=i.createSampler(this)),this._textureChange=!0}create(e,r,i=!0){let a=E.device;const o=e*4;let l=new Float32Array(e*r*4);const h=a.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(h,0,l);const u=S.beginCommandEncoder();u.copyBufferToTexture({buffer:h,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:r,depthOrArrayLayers:1}),S.endCommandEncoder(u)}readTextureToImage(){let e=E.device,r=E.windowWidth,i=E.windowHeight,a=new Float32Array(r*i*4);const o=e.createBuffer({size:a.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});return S.beginCommandEncoder().copyTextureToBuffer({texture:this.getGPUTexture()},{buffer:o},[r,i]),o.getMappedRange(0,a.byteLength)}}class Dc extends ee{constructor(e=.001,r=1e4,i=90,a=!1){super();s(this,"up_camera");s(this,"down_camera");s(this,"left_camera");s(this,"right_camera");s(this,"front_camera");s(this,"back_camera");this.initCubeCamera(e,r,i,a)}set label(e){this.up_camera.name=e+"up",this.down_camera.name=e+"down",this.left_camera.name=e+"left",this.right_camera.name=e+"right",this.front_camera.name=e+"front",this.back_camera.name=e+"back"}initCubeCamera(e,r,i=90,a=!1){this.up_camera=rt.createCamera3DObject(this,"up"),this.down_camera=rt.createCamera3DObject(this,"down"),this.left_camera=rt.createCamera3DObject(this,"left"),this.right_camera=rt.createCamera3DObject(this,"right"),this.front_camera=rt.createCamera3DObject(this,"front"),this.back_camera=rt.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=a,this.down_camera.isShadowCamera=a,this.left_camera.isShadowCamera=a,this.right_camera.isShadowCamera=a,this.front_camera.isShadowCamera=a,this.back_camera.isShadowCamera=a;let o=1;this.up_camera.perspective(i,o,e,r),this.up_camera.lookAt(g.ZERO,g.UP,g.DOWN),this.up_camera.object3D.scaleX=-1,this.up_camera.object3D.rotationY=180,this.down_camera.perspective(i,o,e,r),this.down_camera.lookAt(g.ZERO,g.DOWN,g.DOWN),this.down_camera.object3D.scaleX=-1,this.down_camera.object3D.rotationY=180,this.left_camera.perspective(i,o,e,r),this.left_camera.lookAt(g.ZERO,g.LEFT),this.left_camera.object3D.scaleX=-1,this.right_camera.perspective(i,o,e,r),this.right_camera.lookAt(g.ZERO,g.RIGHT),this.right_camera.object3D.scaleX=-1,this.front_camera.perspective(i,o,e,r),this.front_camera.lookAt(g.ZERO,g.FORWARD),this.front_camera.object3D.scaleX=-1,this.back_camera.perspective(i,o,e,r),this.back_camera.lookAt(g.ZERO,g.BACK),this.back_camera.object3D.scaleX=-1,this.up_camera.type=qe.shadow,this.down_camera.type=qe.shadow,this.left_camera.type=qe.shadow,this.right_camera.type=qe.shadow,this.front_camera.type=qe.shadow,this.back_camera.type=qe.shadow}}class Mc extends It{constructor(t,e,r){super(t,e,r),this.format=j.depth32float,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="cube-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:6*this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"cube-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=E.device.createSampler({minFilter:pi.linear,magFilter:pi.linear}),this.gpuSampler_comparison=E.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Pc extends Lr{constructor(){super();s(this,"shadowPassCount");s(this,"_forceUpdate",!1);s(this,"_shadowCameraDic");s(this,"shadowCamera");s(this,"cubeArrayTexture");s(this,"colorTexture");s(this,"shadowSize",1024);this.passType=J.POINT_SHADOW,this._shadowCameraDic=new Map,this.cubeArrayTexture=new Mc(this.shadowSize,this.shadowSize,8),this.colorTexture=new pe(this.shadowSize,this.shadowSize,j.bgra8unorm,!1),Ae.getInstance().attached(this.cubeArrayTexture,this)}getShadowCamera(e,r){let i;if(this._shadowCameraDic.has(r))i=this._shadowCameraDic.get(r);else{let a=new Dc(e.camera.near,e.camera.far,90,!0);a.label=r.name;let o=[],l=[];for(let h=0;h<6;h++){let u=new pe(this.shadowSize,this.shadowSize,this.cubeArrayTexture.format,!1),c=new Je([this.colorTexture],[new Me]);u.name="shadowDepthTexture_"+r.name+h+"_face",o[h]=u,c.depthTexture=u,c.label="shadowRender",c.customSize=!0,l[h]=this.getRenderContext(c)}i={cubeCamera:a,depthTexture:o,renderContext:l},this._shadowCameraDic.set(r,i)}return i}render(e,r){if(!m.setting.shadow.enable)return;this.shadowPassCount=0,e.camera;let i=e.scene,a=Kt.getPointShadowLightWhichScene(i),o=a.length;for(let l=0;l<o;l++){let h=a[l];if(h.lightData.lightType!=tt.DirectionLight&&h.lightData.castShadowIndex>-1&&(h.needUpdateShadow||this._forceUpdate||me.frame<5||h.realTimeShadow)){h.needUpdateShadow=!1;let u=this.getShadowCamera(e,h),c=h.transform.worldPosition;u.cubeCamera.x=c.x,u.cubeCamera.y=c.y,u.cubeCamera.z=c.z;let f;u.cubeCamera.transform.updateWorldMatrix(!0),r.update(u.cubeCamera.right_camera,i),f=X.instance.getRenderNodes(i,u.cubeCamera.right_camera),this.renderSceneOnce(0,u,e,u.cubeCamera.right_camera,f,r),r.update(u.cubeCamera.left_camera,i),f=X.instance.getRenderNodes(i,u.cubeCamera.left_camera),this.renderSceneOnce(1,u,e,u.cubeCamera.left_camera,f,r),r.update(u.cubeCamera.up_camera,i),f=X.instance.getRenderNodes(i,u.cubeCamera.up_camera),this.renderSceneOnce(2,u,e,u.cubeCamera.up_camera,f,r),r.update(u.cubeCamera.down_camera,i),f=X.instance.getRenderNodes(i,u.cubeCamera.down_camera),this.renderSceneOnce(3,u,e,u.cubeCamera.down_camera,f,r),r.update(u.cubeCamera.front_camera,i),f=X.instance.getRenderNodes(i,u.cubeCamera.front_camera),this.renderSceneOnce(4,u,e,u.cubeCamera.front_camera,f,r),r.update(u.cubeCamera.back_camera,i),f=X.instance.getRenderNodes(i,u.cubeCamera.back_camera),this.renderSceneOnce(5,u,e,u.cubeCamera.back_camera,f,r);let d=S.beginCommandEncoder();for(let p=0;p<6;p++)d.copyTextureToTexture({texture:u.depthTexture[p].getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.cubeArrayTexture.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:h.shadowIndex*6+p}},{width:this.shadowSize,height:this.shadowSize,depthOrArrayLayers:1});S.endCommandEncoder(d)}}this._forceUpdate=!1}renderSceneOnce(e,r,i,a,o,l){let h=r.renderContext[e];h.clean(),h.beginOpaqueRenderPass(),h.encoder.setViewport(0,0,this.shadowSize,this.shadowSize,0,1),h.encoder.setScissorRect(0,0,this.shadowSize,this.shadowSize),a.onUpdate(),a.transform.updateWorldMatrix(!0);for(const u of o.opaqueList){let c=u;if(!c.isDestroyed&&c.preInit(this._rendererType)){c.nodeUpdate(i,this._rendererType,h.rendererPassState,null);break}}this.drawShadowRenderNodes(i,a,h,o.opaqueList,l),this.drawShadowRenderNodes(i,a,h,o.transparentList,l),h.endRenderPass()}drawShadowRenderNodes(e,r,i,a,o){re.updateCameraGroup(r),S.bindCamera(i.encoder,r),e.scene,e.camera,this.drawNodes(e,r,i,a,o,null)}drawNodes(e,r,i,a,o,l){let h=X.instance.getRenderShaderCollect(e);if(h){for(const u of h){let c=u[1];for(const f of c){let d=f[1];if(!d.isDestroyed&&d.preInit(this._rendererType)){d.nodeUpdate(e,this._rendererType,i.rendererPassState,l);break}}}for(let u=m.setting.render.drawOpMin;u<Math.min(a.length,m.setting.render.drawOpMax);++u){let c=a[u];if(c.transform.enable&&c.enable&&c.castShadow&&!c.isDestroyed){c.preInit(this._rendererType)||c.nodeUpdate(e,this._rendererType,i.rendererPassState,l);for(let f of c.materials){let d=f.getPass(this._rendererType);if(!(!d||d.length==0))for(let p of d){const A=p;A.pipeline&&(A.setUniformFloat("cameraFar",r.far),A.setUniformVector3("lightWorldPos",r.transform.worldPosition),A.materialDataUniformBuffer.apply())}}c.renderPass(e,this.passType,i)}}}}}class Rc extends It{constructor(t,e,r=j.depth32float,i=4){super(t,e,i),this.format=r,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.textureBindingLayout.sampleType="depth",this.textureBindingLayout.viewDimension="2d-array",this.samplerBindingLayout.type="filtering",this.sampler_comparisonBindingLayout.type="comparison"}internalCreateTexture(){this.textureDescriptor={format:this.format,size:{width:this.width,height:this.height,depthOrArrayLayers:this.numberLayer},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"2d-array"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=E.device.createSampler({}),this.gpuSampler_comparison=E.device.createSampler({compare:"less",label:"sampler_comparison"})}}class Uc extends Lr{constructor(){super();s(this,"shadowPassCount");s(this,"depth2DArrayTexture");s(this,"rendererPassStates");s(this,"_forceUpdate",!1);s(this,"_shadowPos",new g);s(this,"_shadowCameraTarget",new g);this.setShadowMap(m.setting.shadow.shadowSize,nr.Cascades),this.passType=J.SHADOW}setShadowMap(e,r){this.rendererPassStates=[],this.depth2DArrayTexture=new Rc(e,e,j.depth32float,8),Ae.getInstance().attached(this.depth2DArrayTexture,this);for(let i=0;i<8;i++){let a=new Je([],[]);const o=new pe(e,e,j.depth32float,!1);o.name=`shadowDepthTexture_${i}`,a.depthTexture=o,a.label="shadowRender",a.customSize=!0,a.depthCleanValue=1;let l=Ze.createRendererPassState(a);this.rendererPassStates[i]=l}}render(e,r){let i=m.setting.shadow;if(!i.enable)return;let a=e.camera,o=e.scene;if(this.shadowPassCount=0,!i.needUpdate||me.frame%i.updateFrameRate!=0)return;let l=Kt.getDirectShadowLightWhichScene(o),h=i.shadowSize;const u=nr.Cascades;for(let c of l){const f=c;let d=f.shadowIndex;this.rendererPassState=this.rendererPassStates[d],h=this.rendererPassState.depthTexture.width;let p=X.instance.getRenderShaderCollect(e);for(const A of p){let x=A[1];for(const C of x){let v=C[1];if(!v.isDestroyed&&v.preInit(this._rendererType)){v.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}if(f.castShadow&&f.needUpdateShadow||this._forceUpdate||f.castShadow&&i.autoUpdate)if(f.needUpdateShadow=!1,a.enableCSM&&d==0)for(let A=0;A<u;A++){this.rendererPassState=this.rendererPassStates[A];let x=a.csm.children[A],C=a.getCSMShadowWorldExtents(A);this.poseShadowCamera(a,f.direction,x.shadowCamera,C,x.bound.center),this.renderShadow(e,x.shadowCamera,r,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,A,h)}else{a.enableCSM&&(d+=u-1);let A=a.getShadowWorldExtents();this.rendererPassState=this.rendererPassStates[d],this.poseShadowCamera(a,f.direction,f.shadowCamera,A,a.lookTarget),this.renderShadow(e,f.shadowCamera,r,this.rendererPassState),this.copyDepthTexture(this.rendererPassState.depthTexture,this.depth2DArrayTexture,d,h)}}this._forceUpdate=!1}copyDepthTexture(e,r,i,a){let o=S.beginCommandEncoder();o.copyTextureToTexture({texture:e.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:0}},{texture:r.getGPUTexture(),mipLevel:0,origin:{x:0,y:0,z:i}},{width:a,height:a,depthOrArrayLayers:1}),S.endCommandEncoder(o)}poseShadowCamera(e,r,i,a,o){this._shadowPos.copy(r).normalize(e.far),o.add(this._shadowPos,this._shadowCameraTarget),o.subtract(this._shadowPos,this._shadowPos),i.transform.lookAt(this._shadowPos,this._shadowCameraTarget),i.orthoOffCenter(-a,a,-a,a,e.near,e.far*2)}compute(){}renderShadow(e,r,i,a){let o=X.instance.getRenderNodes(e.scene,r),l=S.beginCommandEncoder(),h=S.beginRenderPass(l,a);r.transform.updateWorldMatrix(),fo.enable&&(i.update(r,e.scene),i.collect(o,r)),re.updateCameraGroup(r),S.bindCamera(h,r);let u=this.renderShadowBundleOp(e,r,a),c=this.renderShadowBundleTr(e,r,a);u.length>0&&h.executeBundles(u),this.drawShadowRenderNodes(e,r,h,o.opaqueList),c.length>0&&h.executeBundles(c),this.drawShadowRenderNodes(e,r,h,o.transparentList),S.endPass(h),S.endCommandEncoder(l)}renderShadowBundleOp(e,r,i){let a=X.instance.getOpRenderGroup(e.scene);if(a){let o=[];return a.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))o.push(l.bundleMap.get(this._rendererType));else{let h=S.recordBundleEncoder(i.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,r,h,l.renderNodes);let u=h.finish();l.bundleMap.set(this._rendererType,u),o.push(u)}}),o}return[]}renderShadowBundleTr(e,r,i){let a=X.instance.getTrRenderGroup(e.scene);if(a){let o=[];return a.renderGroup.forEach(l=>{if(l.bundleMap.has(this._rendererType))o.push(l.bundleMap.get(this._rendererType));else{let h=S.recordBundleEncoder(i.renderBundleEncoderDescriptor);this.recordShadowRenderBundleNode(e,r,h,l.renderNodes);let u=h.finish();l.bundleMap.set(this._rendererType,u),o.push(u)}}),o}return[]}recordShadowRenderBundleNode(e,r,i,a,o){if(re.updateCameraGroup(r),S.bindCamera(i,r),a){S.bindGeometryBuffer(i,a[0].geometry);for(let l=0;l<a.length;++l){let h=a[l];h.transform.enable&&h.recordRenderPass2(e,this._rendererType,this.rendererPassState,o,i)}}}drawShadowRenderNodes(e,r,i,a,o){if(re.updateCameraGroup(r),S.bindCamera(i,r),a)for(let l=m.setting.render.drawOpMin;l<Math.min(a.length,m.setting.render.drawOpMax);++l){let h=a[l];h.transform.enable&&h.enable&&h.castShadow&&(h.isDestroyed||(h.preInit(this._rendererType)||h.nodeUpdate(e,this._rendererType,this.rendererPassState,o),h.renderPass2(e,this._rendererType,this.rendererPassState,o,i)))}}}class Lc extends Lr{constructor(){super();s(this,"zBufferTexture");s(this,"useRenderBundle",!1);s(this,"shadowPassCount");s(this,"zCullingCompute");this.passType=J.DEPTH;let e=E.presentationSize,r=1;this.zBufferTexture=Vt.createRTTexture(ht.zBufferTexture_NAME,Math.floor(e[0]*r),Math.floor(e[1]*r),j.rgba16float,!1);let i=new Me;i.clearValue=[0,0,0,0],i.loadOp="clear";let a=new Je([],[],Vt.createRTTexture(ht.zPreDepthTexture_NAME,Math.floor(e[0]),Math.floor(e[1]),j.depth32float,!1),null,!1);this.setRenderStates(a)}render(e,r){let i=e.camera,a=e.scene;S.cleanCache(),Fe.start("DepthPass Renderer");let o=a;this.rendererPassState.camera3D=i;let l=X.instance.getRenderNodes(o,i);this.compute(e,r);let h=this.renderBundleOp(e,l,r),u=[],c=S.beginCommandEncoder(),f=S.beginRenderPass(c,this.rendererPassState);h.length>0&&f.executeBundles(h);let d=X.instance.getRenderShaderCollect(e);for(const p of d){let A=p[1];for(const x of A){let C=x[1];if(!C.isDestroyed&&C.preInit(this._rendererType)){C.nodeUpdate(e,this._rendererType,this.rendererPassState,null);break}}}this.drawRenderNodes(e,f,c,l.opaqueList,r),u.length>0&&f.executeBundles(u),S.endPass(f),S.endCommandEncoder(c),Fe.end("DepthPass Renderer")}drawRenderNodes(e,r,i,a,o,l){S.bindCamera(r,e.camera);for(let h=m.setting.render.drawOpMin;h<Math.min(a.length,m.setting.render.drawOpMax);++h){let u=a[h];u.transform.enable&&u.enable&&(u.isDestroyed||(u.preInit(this._rendererType)||u.nodeUpdate(e,this._rendererType,this.rendererPassState),u.renderPass2(e,this._rendererType,this.rendererPassState,l,r)))}}}class Oc{constructor(){s(this,"map");s(this,"passRendererList");this.map=new Map,this.passRendererList=[]}addRenderer(t){this.map.has(t.passType)?console.error("same renderer pass repeat!"):(this.map.set(t.passType,t),t.passType<=8&&this.addPassRenderer(t))}getRenderer(t){return this.map.get(t)}addPassRenderer(t){this.passRendererList.push(t)}getAllRenderer(){return this.map}getAllPassRenderer(){return this.passRendererList}}class Nc extends Lr{constructor(){super();s(this,"finalQuadView");s(this,"postList");this._rendererType=J.POST,this.postList=new Map,this.initRenderer()}initRenderer(){H.register("FullQuad_vert_wgsl",Vh),this.finalQuadView=new Nn("Quad_vert_wgsl","Quad_frag_wgsl",new Je([],[]),0,!1)}attachPost(e,r){r.postRenderer=this;let i=r.constructor.name;this.postList.get(i)||(this.postList.set(i,r),r.onAttach(e))}detachPost(e,r){let i=r.constructor.name,a=this.postList.get(i);return a&&(this.postList.delete(i),r.onDetach(e),r.postRenderer=null),a!=null}render(e){this.postList.forEach(i=>{i.enable&&i.compute(e)});let r=S.beginCommandEncoder();this.postList.forEach(i=>{i.enable&&(i.render(e,r),i.rendererPassState&&(S.lastRenderPassState=i.rendererPassState))}),S.endCommandEncoder(r)}presentContent(e,r){let i=S.beginCommandEncoder();this.finalQuadView.renderToViewQuad(e,this.finalQuadView,i,r),S.endCommandEncoder(i)}}class go{constructor(){s(this,"enable",!0);s(this,"postRenderer");s(this,"rendererPassState");s(this,"rtViewQuad");s(this,"virtualTexture");this.rtViewQuad=new Map,this.virtualTexture=new Map,E.addEventListener(Wr.RESIZE,this.onResize,this)}createRTTexture(t,e,r,i,a=!1,o=0){let l=Vt.createRTTexture(t,e,r,i,a,o);return l.name=t,this.virtualTexture.set(t,l),Ae.getInstance().attached(l,this),l}createViewQuad(t,e,r,i=0){let a=Vt.createViewQuad(t,"Quad_vert_wgsl",e,r,i);return this.rtViewQuad.set(t,a),a}getLastRenderTexture(){let t,e=S.lastRenderPassState.renderTargets;return e.length>0?t=e[0]:t=Vt.getTexture(ht.colorBufferTex_NAME),t}compute(t){}onAttach(t){}onDetach(t){}onResize(){}render(t,e){}destroy(t){this.postRenderer=null;for(let e=0;e<this.rtViewQuad.size;e++)this.rtViewQuad.values[e].destroy(t);this.rtViewQuad.clear(),this.rtViewQuad=null;for(let e=0;e<this.virtualTexture.size;e++){const r=this.virtualTexture.values[e];Ae.getInstance().detached(r,this),r.destroy(t)}}}class kn extends ee{constructor(e=.001,r=1e4,i=90,a=!1){super();s(this,"up_camera");s(this,"down_camera");s(this,"left_camera");s(this,"right_camera");s(this,"front_camera");s(this,"back_camera");s(this,"_near");s(this,"_far");this.initCubeCamera(e,r,i,a)}initCubeCamera(e,r,i=90,a=!1){this.up_camera=rt.createCamera3DObject(this,"up"),this.down_camera=rt.createCamera3DObject(this,"down"),this.left_camera=rt.createCamera3DObject(this,"left"),this.right_camera=rt.createCamera3DObject(this,"right"),this.front_camera=rt.createCamera3DObject(this,"front"),this.back_camera=rt.createCamera3DObject(this,"back"),this.up_camera.isShadowCamera=a,this.down_camera.isShadowCamera=a,this.left_camera.isShadowCamera=a,this.right_camera.isShadowCamera=a,this.front_camera.isShadowCamera=a,this.back_camera.isShadowCamera=a;let o=1;this.up_camera.perspective(i,o,e,r),this.up_camera.lookAt(g.ZERO,g.UP,g.DOWN),this.down_camera.perspective(i,o,e,r),this.down_camera.lookAt(g.ZERO,g.DOWN,g.DOWN),this.left_camera.perspective(i,o,e,r),this.left_camera.lookAt(g.ZERO,g.LEFT),this.right_camera.perspective(i,o,e,r),this.right_camera.lookAt(g.ZERO,g.RIGHT),this.front_camera.perspective(i,o,e,r),this.front_camera.lookAt(g.ZERO,g.FORWARD),this.back_camera.perspective(i,o,e,r),this.back_camera.lookAt(g.ZERO,g.BACK),this.up_camera.type=qe.shadow,this.down_camera.type=qe.shadow,this.left_camera.type=qe.shadow,this.right_camera.type=qe.shadow,this.front_camera.type=qe.shadow,this.back_camera.type=qe.shadow}set near(e){this._near=e,this.up_camera.near=e,this.down_camera.near=e,this.left_camera.near=e,this.right_camera.near=e,this.front_camera.near=e,this.back_camera.near=e}get near(){return this._near}set far(e){this._far=e,this.up_camera.far=e,this.down_camera.far=e,this.left_camera.far=e,this.right_camera.far=e,this.front_camera.far=e,this.back_camera.far=e}get far(){return this._far}}let Fc=`
    // input reflection buffer texture
    // sample prefiltered cube uv texture 
    // storge info to oct map 
    #include "GenerayRandomDir"
    #include "BitUtil"
    #include "MathShader"
    #include "ColorUtil_frag"
    
    struct UniformData{
        probeSize : f32 ,
        probeCount : f32 ,
        width : f32 ,
        height : f32 ,
    }

    @group(0) @binding(0) var inputTex : texture_2d<f32>;
    @group(0) @binding(1) var outputTexture : texture_storage_2d<rgba16float, write>;//rgba32float rgba16float
    @group(1) @binding(0) var<uniform> uniformData:UniformData;//rgba32float

    var<private> reflectionSize : vec2f ; 
    var<private> PROBE_SOURCESIZE : vec2f ; 
    var<private> PROBEMAP_SOURCESIZE : vec2f ; 
    var<private> aspect : vec2f ; 
    var<private> spaceV : f32 ; 
    
    var<private> i32InputFragCoord : vec2i;
    var<private> PI_2 : f32 = 3.1415926 * 2.0 ;
    var<private> PI : f32 = 3.1415926 ;

    var<private> probeSize : f32 = 256.0 ;
    var<private> probeCount : f32 = 8.0 ;
    var<private> faceCount : f32 = 6.0 ;
    var<private> mipCount : f32 = 8.0 ;

    const NUM_SAMPLES = 256u;
    var<private> inputSize : vec2f ; 
    var<private> outSize : vec2f ; 

    fn useSphereReflection(){
        probeSize = uniformData.probeSize ;
        probeCount = uniformData.probeCount;
        reflectionSize = vec2f(textureDimensions(inputTex).xy);
        PROBE_SOURCESIZE = reflectionSize / vec2f(faceCount,probeCount);
        PROBEMAP_SOURCESIZE = reflectionSize ;
        aspect = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
        spaceV = 1.0 / probeCount ;
    }

    @compute @workgroup_size( 16 , 16 , 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
        var color : vec4f ;
        useSphereReflection();
        inputSize = vec2f(textureDimensions(inputTex).xy);
        outSize = vec2f(textureDimensions(outputTexture).xy);
        
        i32InputFragCoord = vec2<i32>( globalInvocation_id.xy ) ;

        let i = f32(globalInvocation_id.z) ;
        let count = floor(i / mipCount) ;
        preOneMip(count,floor(i % mipCount));
    }

    fn preOneMip( gid:f32,mip:f32 ){
        let isuv = vec2f(i32InputFragCoord) ;
        let suv = isuv * (inputSize/outSize);
        let probeID = i32(floor(suv.y / probeSize));
        let mipID = i32((isuv.x / probeSize));
        if(probeID == i32(gid) && mipID == i32(mip)){

            let sphereUV = vec2f((isuv.x+0.5) % (probeSize),(isuv.y+0.5) % probeSize) / vec2f( (probeSize), probeSize ) ;
            var dir: vec3<f32> = octDecode(sphereUV * 2.0 - 1.0) ;
            var preColor = PreFilterEnvMap(mip/mipCount + 0.05,dir,gid);
            textureStore(outputTexture,vec2i(i32InputFragCoord),preColor);
        }
    }

    fn PreFilterEnvMap( roughness2:f32,  R:vec3f , gid:f32 ) -> vec4f
    {
        var resColor = vec3f(0.0f);  
        var resDepth = 0.0;  

        var totalColorWeight = 0.0f;   
        var totalDepthWeight = 0.0f;   
        
        var normal = normalize(R);
        var toEye = normal;
        
        var roughness = roughness2;
        
        for(var i=1u;i<=NUM_SAMPLES;i+=1u)
        {
            var xi:vec2f = hammersley(i, NUM_SAMPLES) ; 
            
            var halfway = ImportanceSampleGGX(xi,roughness,normal);
            var lightVec = 2.0f * dot( toEye,halfway ) * halfway - toEye;
            
            var NdotL = dot( normal, lightVec )  ;
            var NdotH = max(0.0,dot( normal, halfway ))  ;
            var HdotV = max(0.0,dot( halfway, toEye ))  ;
            
            if( NdotL > 0.0 )
            {
                var D = specularD(roughness,NdotH);
                var pdf = (D * NdotH / (4.0 * HdotV)) + 0.0001f  ;

                var saSample = 1.0f / (f32(NUM_SAMPLES) * pdf + 0.00001f);
                lightVec = normalize(lightVec);

                var buffer = getReflectionsMap(lightVec,gid); 
                var rgb = unpack4x8unorm(u32(buffer.z)).rgb;
                var m = unpack4x8unorm(u32(buffer.w)).z;
                var rgbmColor = DecodeRGBM(vec4f(rgb,m));
                resDepth += buffer.x ;
                resColor += rgbmColor * NdotL;

                totalColorWeight += NdotL;
                totalDepthWeight += 1.0;
            }
        }

        resDepth = resDepth / max(totalDepthWeight,0.001f);
        resColor = resColor / max(totalColorWeight,0.001f);
        
        let rgbm = EncodeRGBM(resColor) ; 
        let gBuffer = vec4f(
            resDepth,
            0.0,
            f32(pack4x8unorm(vec4f(rgbm.rgb,0.0))),
            f32(pack4x8unorm(vec4f(0.0,0.0,rgbm.w,0.0))),
        ) ;
        // return gBuffer ;
        return vec4f(resColor,1.0) ;
    } 

    fn getReflectionsMap(n:vec3<f32>,gid:f32) -> vec4f {
        var uv = getSampleProbeUV(n,gid);
        let color = textureLoad(inputTex, vec2i(uv*inputSize) , 0);
        return color ;
    }

    fn getSampleProbeUV(dir:vec3<f32>,gid:f32) -> vec2<f32> {
        let faceId = dir_to_faceId(dir);
        var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
        targetUV.x = 1.0 - targetUV.x;
        let threshould = 0.5 / PROBE_SOURCESIZE;
        targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));
        targetUV.x = f32(faceId) + targetUV.x;
        let aspect:vec2f = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
        targetUV = targetUV * aspect ;
        targetUV.y = targetUV.y + (spaceV * gid);
        return targetUV ;
     }

    fn radicalInverse_VdC( bits2:u32) -> f32
    {
        var bits = bits2; 
        bits = (bits << 16u) | (bits >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        return f32(bits) * 2.3283064365386963e-10f; // / 0x100000000
    }

    fn hammersley( i:u32, N:u32) -> vec2f
    {
        return vec2f(f32(i) / f32(N), radicalInverse_VdC(i));
    }

    fn ImportanceSampleGGX( xi:vec2f,  roughness:f32,  N:vec3f) -> vec3f
    {
        var alpha2 = roughness * roughness * roughness * roughness;
        
        var phi = 2.0f * 3.1415926 * xi.x  ;
        var cosTheta = sqrt( (1.0f - xi.y) / (1.0f + (alpha2 - 1.0f) * xi.y ));
        var sinTheta = sqrt( 1.0f - cosTheta*cosTheta );
        
        var h : vec3f ;
        h.x = sinTheta * cos( phi );
        h.y = sinTheta * sin( phi );
        h.z = cosTheta;
        
        var up = vec3f(1,0,0) ;
        if(abs(N.z) < 0.9999){
            up = vec3f(0,0,1) ;
        }

        var tangentX = normalize( cross( up, N ) );
        var tangentY = cross( N, tangentX );
        return (tangentX * h.x + tangentY * h.y + N * h.z);
    } 

    fn  specularD( roughness:f32,  NoH:f32) -> f32
    {
        var NoH2 = NoH * NoH;
        var r2 = roughness * roughness;
        return r2 / pow(NoH2 * (r2 - 1.0) + 1.0, 2.0);
    }
    
`;class kc extends Lr{constructor(){super();s(this,"cubeCamera");s(this,"gBuffer");s(this,"sizeW",0);s(this,"sizeH",0);s(this,"probeSize",64);s(this,"probeCount",32);s(this,"mipCount",8);s(this,"preFilteredEnvironmentCompute");s(this,"outTexture");s(this,"preFilteredEnvironmentUniform");s(this,"onChange",!0);s(this,"needUpdate",!0);this.passType=J.REFLECTION,this.cubeCamera=new kn(.01,5e3);let e=1;this.probeSize=m.setting.reflectionSetting.reflectionProbeSize,this.probeCount=m.setting.reflectionSetting.reflectionProbeMaxCount,this.sizeW=m.setting.reflectionSetting.width,this.sizeH=m.setting.reflectionSetting.height,this.gBuffer=fe.getGBufferFrame(fe.reflections_GBuffer,this.sizeW,this.sizeH,!1),this.setRenderStates(this.gBuffer),this.outTexture=new pe(this.probeSize*this.mipCount,this.sizeH,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING,1,0,e),this.outTexture.name="texture_AAA",this.preFilteredEnvironmentUniform=new Ct(4+this.probeCount*4),this.preFilteredEnvironmentUniform.setFloat("probeSize",this.probeSize),this.preFilteredEnvironmentUniform.setFloat("probeCount",this.probeCount),this.preFilteredEnvironmentUniform.setFloat("width",this.sizeW),this.preFilteredEnvironmentUniform.setFloat("height",this.sizeH),this.preFilteredEnvironmentUniform.apply(),this.preFilteredEnvironmentCompute=new ce(Fc),this.preFilteredEnvironmentCompute.setSamplerTexture("inputTex",this.gBuffer.getCompressGBufferTexture()),this.preFilteredEnvironmentCompute.setStorageTexture("outputTexture",this.outTexture),this.preFilteredEnvironmentCompute.setUniformBuffer("uniformData",this.preFilteredEnvironmentUniform)}forceUpdate(){this.onChange=!0}compute(e,r){if(this.needUpdate){this.needUpdate=!1;let i=re.getReflectionEntries(e.scene);i.reflectionMap=this.outTexture,this.preFilteredEnvironmentCompute.workerSizeX=Math.ceil(this.probeSize*this.mipCount/16),this.preFilteredEnvironmentCompute.workerSizeY=Math.ceil(this.sizeH/16),this.preFilteredEnvironmentCompute.workerSizeZ=this.mipCount*i.count;let a=S.beginCommandEncoder();S.computeCommand(a,[this.preFilteredEnvironmentCompute]),S.endCommandEncoder(a)}}render(e,r,i,a=!1,o=!1){this.renderContext.clean();let l=this.probeSize,h=this.probeSize,u=X.instance.getReflections(e.scene);for(let c=0;c<u.length;c++){let f=u[c];if(f.autoUpdate&&(f.needUpdate||this.onChange)||me.frame<10){f.needUpdate=!1,this.needUpdate=!0,this.renderContext.beginOpaqueRenderPass();let d=this.renderContext.encoder,p=c*h;u[c].transform.updateWorldMatrix();let A=u[c].transform.worldPosition;this.cubeCamera.x=A.x,this.cubeCamera.y=A.y,this.cubeCamera.z=A.z,this.cubeCamera.far=1e4,this.cubeCamera.transform.updateWorldMatrix(),d.setViewport(l*0,p,l,h,0,1),this.renderOnce(e,this.cubeCamera.right_camera,d,r,i,a),d.setViewport(l*1,p,l,h,0,1),this.renderOnce(e,this.cubeCamera.left_camera,d,r,i,a),d.setViewport(l*2,p,l,h,0,1),this.renderOnce(e,this.cubeCamera.up_camera,d,r,i,a),d.setViewport(l*3,p,l,h,0,1),this.renderOnce(e,this.cubeCamera.down_camera,d,r,i,a),d.setViewport(l*4,p,l,h,0,1),this.renderOnce(e,this.cubeCamera.front_camera,d,r,i,a),d.setViewport(l*5,p,l,h,0,1),this.renderOnce(e,this.cubeCamera.back_camera,d,r,i,a),this.renderContext.endRenderPass()}}this.onChange=!1}renderOnce(e,r,i,a,o,l=!1){let h=e.scene;r.transform.scene3D=h,this.rendererPassState.camera3D=r;let u=X.instance.getRenderNodes(h,r);{let c=i;re.updateCameraGroup(r),!l&&X.instance.sky&&(S.bindCamera(c,r),X.instance.sky.preInit(J.REFLECTION)||X.instance.sky.nodeUpdate(e,J.REFLECTION,this.rendererPassState,o),X.instance.sky.renderPass2(e,J.REFLECTION,this.rendererPassState,o,c)),u.opaqueList&&(S.bindCamera(c,r),this.drawNodes(e,this.renderContext,u.opaqueList,a,o)),!l&&u.transparentList&&(S.bindCamera(c,r),this.drawNodes(e,this.renderContext,u.transparentList,a,o))}}drawNodes(e,r,i,a,o){let l=X.instance.getRenderShaderCollect(e);if(l){for(const h of l){let u=h[1];for(const c of u){let f=c[1];if(!f.hasMask(ye.ReflectionDebug)&&!f.isDestroyed&&f.preInit(J.REFLECTION)){f.nodeUpdate(e,J.REFLECTION,this.rendererPassState,o);break}}}for(let h=0;h<i.length;h++){let u=i[h];u.hasMask(ye.ReflectionDebug)||u.transform.enable&&u.enable&&(u.isDestroyed||(u.preInit(J.REFLECTION)||u.nodeUpdate(e,J.REFLECTION,this.rendererPassState,o),u.renderPass(e,J.REFLECTION,this.renderContext)))}}}occlusionRenderNodeTest(e,r,i){return!0}}let zc=`
    #include 'BitUtil'
    struct FragmentOutput {
        @location(auto) o_Target: vec4<f32>
    };

    var<private> varying_uv: vec2<f32>;
    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d<f32>;
    // @group(1) @binding(2)
    // var gBuffer: texture_2d<f32>;

    struct MaterialUniform{
        u_texel: vec2<f32>,
        u_strength: f32,
    }

    @group(2) @binding(0)
    var<uniform> materialUniform: MaterialUniform;


    fn LinearToGammaSpace(linRGB0: vec3<f32>) -> vec3<f32> {
        var linRGB = max(linRGB0, vec3(0.0, 0.0, 0.0));
        linRGB.r = pow(linRGB.r,0.416666667);
        linRGB.g = pow(linRGB.g,0.416666667);
        linRGB.b = pow(linRGB.b,0.416666667);
        return max(1.055 * linRGB - 0.055, vec3(0.0, 0.0, 0.0));
    }

    fn texture2D( uv:vec2<f32> , offset:vec2<f32> ) -> vec4<f32> {
        let buffer = textureSample(baseMap, baseMapSampler, uv.xy + offset ).rgba ;
        return buffer ;
    }

    @fragment
    fn main(@location(auto) fragUV: vec2<f32>) -> FragmentOutput {
        var v_vTexcoord = fragUV ;
        // v_vTexcoord.x = 1.0 - v_vTexcoord.x ;
        v_vTexcoord.y = 1.0 - v_vTexcoord.y ;

        var reducemul = 1.0 / 8.0;
        var reducemin = 1.0 / 128.0;

        var basecol = texture2D(v_vTexcoord , vec2<f32>(0.0)).rgba;
        var baseNW = texture2D(v_vTexcoord , -materialUniform.u_texel).rgb;
        var baseNE = texture2D(v_vTexcoord , vec2<f32>(materialUniform.u_texel.x, -materialUniform.u_texel.y)).rgb;
        var baseSW = texture2D(v_vTexcoord , vec2<f32>(-materialUniform.u_texel.x, materialUniform.u_texel.y)).rgb;
        var baseSE = texture2D(v_vTexcoord , materialUniform.u_texel ).rgb;

        // var gray = vec3<f32>(0.299, 0.587, 0.114);
        var gray = vec3<f32>(0.213, 0.715, 0.072);
        var monocol = dot(basecol.rgb, gray);
        var monoNW = dot(baseNW, gray);
        var monoNE = dot(baseNE, gray);
        var monoSW = dot(baseSW, gray);
        var monoSE = dot(baseSE, gray);

        var monomin = min(monocol, min(min(monoNW, monoNE), min(monoSW, monoSE)));
        var monomax = max(monocol, max(max(monoNW, monoNE), max(monoSW, monoSE)));

        var dir = vec2<f32>(-((monoNW + monoNE) - (monoSW + monoSE)), ((monoNW + monoSW) - (monoNE + monoSE)));
        var dirreduce = max((monoNW + monoNE + monoSW + monoSE) * reducemul * 0.25, reducemin);
        var dirmin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirreduce);
        dir = min(vec2<f32>(materialUniform.u_strength), max(vec2<f32>(-materialUniform.u_strength), dir * dirmin)) * materialUniform.u_texel;

        var resultA = 0.5 * (texture2D(v_vTexcoord , dir * -0.166667).rgb  +
                            texture2D(v_vTexcoord , dir * 0.166667).rgb);
                            
        var resultB = resultA * 0.5 + 0.25 * (texture2D( v_vTexcoord , dir * -0.5).rgb +
                                            texture2D( v_vTexcoord , dir * 0.5).rgb);
        var monoB = dot(resultB.rgb, gray);
        
        var color:vec3<f32> ;
        if(monoB < monomin || monoB > monomax) {
            color = resultA ;//* v_vColour;
        } else {
            color = resultB ;//* v_vColour;
        }
        return FragmentOutput(vec4<f32>(color.rgb,basecol.a));
    }
`;class zn extends go{constructor(){super();s(this,"postQuad");s(this,"renderTexture");let[e,r]=E.presentationSize;H.register("FXAA_Shader",zc),this.renderTexture=this.createRTTexture("FXAAPost",e,r,j.rgba16float),this.postQuad=this.createViewQuad("fxaa","FXAA_Shader",this.renderTexture),this.postQuad.quadShader.setUniform("u_texel",new he(1/e,1/r)),this.postQuad.quadShader.setUniform("u_strength",4)}onResize(){let[e,r]=E.presentationSize;this.renderTexture.resize(e,r)}onAttach(e){m.setting.render.postProcessing.fxaa.enable=!0}onDetach(e){m.setting.render.postProcessing.fxaa.enable=!1}render(e,r){this.compute(e),this.rtViewQuad.forEach((i,a)=>{let o=S.lastRenderPassState.getLastRenderTexture();i.renderToViewQuad(e,i,r,o)})}}class Gc{constructor(t){s(this,"rendererMap");s(this,"shadowMapPassRenderer");s(this,"pointLightShadowRenderer");s(this,"ddgiProbeRenderer");s(this,"postRenderer");s(this,"clusterLightingRender");s(this,"reflectionRenderer");s(this,"occlusionSystem");s(this,"depthPassRenderer");s(this,"pauseRender",!1);s(this,"pickFire");s(this,"renderState",!1);s(this,"_view");this._view=t,this.rendererMap=new Oc,this.occlusionSystem=new fo,this.clusterLightingRender=this.addRenderer(Bc,t),this.reflectionRenderer=this.addRenderer(kc,t),m.setting.render.zPrePass&&(this.depthPassRenderer=this.addRenderer(Lc)),this.shadowMapPassRenderer=new Uc,this.pointLightShadowRenderer=new Pc,this.addPost(new zn)}get colorPassRenderer(){return this.rendererMap.getRenderer(J.COLOR)}addRenderer(t,e){let r;return e?r=new t(e):r=new t,this.rendererMap.addRenderer(r),r}get view(){return this._view}set view(t){this._view=t}start(){this.renderState=!0}stop(){}pause(){this.pauseRender=!0}resume(){this.pauseRender=!1}addPost(t){if(!this.postRenderer){let e=fe.getGBufferFrame("ColorPassGBuffer");this.postRenderer=this.addRenderer(Nc),this.postRenderer.setRenderStates(e)}return t instanceof go&&this.postRenderer.attachPost(this.view,t),t}removePost(t){if(t instanceof go)this.postRenderer.detachPost(this.view,t);else for(let e=0;e<t.length;e++)this.postRenderer.detachPost(this.view,t[e])}renderFrame(){let t=this._view;Fe.startView(t),re.getLightEntries(t.scene).update(t),re.getReflectionEntries(t.scene).update(t),this.occlusionSystem.update(t.camera,t.scene),this.clusterLightingRender.render(t,this.occlusionSystem),this.shadowMapPassRenderer&&(Kt.update(t),this.shadowMapPassRenderer.render(t,this.occlusionSystem)),this.pointLightShadowRenderer&&this.pointLightShadowRenderer.render(t,this.occlusionSystem),this.depthPassRenderer&&(this.depthPassRenderer.compute(t,this.occlusionSystem),this.depthPassRenderer.render(t,this.occlusionSystem)),m.setting.gi.enable&&this.ddgiProbeRenderer&&(this.ddgiProbeRenderer.compute(t,this.occlusionSystem),this.ddgiProbeRenderer.render(t,this.occlusionSystem));let e=this.rendererMap.getAllPassRenderer();for(let a=0;a<e.length;a++){const o=e[a];o.compute(t,this.occlusionSystem),o.render(t,this.occlusionSystem,this.clusterLightingRender.clusterLightingBuffer,!1)}this.postRenderer.render(t);let r=this.rendererMap.getRenderer(J.UI);r.compute(t,this.occlusionSystem),r.render(t,this.occlusionSystem,this.clusterLightingRender.clusterLightingBuffer,!1);let i=fe.getGUIBufferFrame().getColorTexture();this.postRenderer.presentContent(t,i)}debug(){}}class Qc extends Je{constructor(t,e,r=!0){super([],[]),this.crateGBuffer(t,e,r)}crateGBuffer(t,e,r){let i=this.renderTargets,a=this.rtDescriptors,o=new bt(t,e,j.rgba16float,!1,void 0,1,0,!0,r);o.name="positionMap";let l=new Me;l.loadOp="load";let h=new bt(t,e,j.rgba16float,!1,void 0,1,0,!0,r);h.name="normalMap";let u=new Me;u.loadOp="load";let c=new bt(t,e,j.rgba16float,!1,void 0,1,0,!0,r);c.name="colorMap";let f=new Me;f.loadOp="load";let d=new bt(t,e,j.depth24plus,!1,void 0,1,0,!0,r);d.name="depthTexture";let p=new Me;p.loadOp="load",i.push(o),i.push(h),i.push(c),a.push(l),a.push(u),a.push(f),this.depthTexture=d}}let Vc=`
#include "GenerayRandomDir"
#include "MathShader"
#include "IrradianceVolumeData_frag"
var<private> PI: f32 = 3.14159265359;

struct ProbeData{
  offsetX:f32,
  offsetY:f32,
  offsetZ:f32,
  frame:f32,
}

 struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

struct RayProbeBuffer{
  WPosition: vec3<f32>,
  WNormal:vec3<f32>,
  WRadiance:vec4<f32>,
}

struct CacheHitData{
  color:vec4<f32>,
  depth:vec4<f32>,
}

//  struct RayInfo{
//   rays:array<vec4<f32>,4096>
//  }

@group(0) @binding(0) var<storage, read> probes : array<ProbeData>;
@group(0) @binding(1) var<storage, read_write> irradianceBuffer : array<vec4<f32>>;
@group(0) @binding(2) var<storage, read_write> depthBuffer : array<vec4<f32>>;
@group(0) @binding(3) var<uniform> uniformData : IrradianceVolumeData ;
@group(0) @binding(4) var probeIrradianceMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(5) var probeDepthMap : texture_storage_2d<rgba16float, write>;
@group(0) @binding(6) var<storage, read_write> depthRaysBuffer : array<vec4<f32>>;

@group(1) @binding(0) var positionMap : texture_2d<f32>;
@group(1) @binding(1) var normalMap : texture_2d<f32>;
@group(1) @binding(2) var colorMap : texture_2d<f32>;

@group(2) @binding(0)
var<storage, read> models : Uniforms;

var<private> probeID: u32 ;
var<private> workgroup_idx: u32 ;
var<private> workgroup_idy: u32 ;
var<private> hysteresis: f32 = 0.98 ;
var<private> epsilon: f32 = 1e-6 ;
var<private> probeLocation:vec3<f32> = vec3<f32>(0.0);
var<private> energyConservation: f32 = 0.85 ;
var<private> resultIrradiance: vec4<f32> ;
var<private> resultDepth: vec4<f32> ;
var<private> RAYS_PER_PROBE: f32 = 144.0 ;
var<private> OCT_RT_SIZE: u32;
var<private> PROBE_OCT_RT_SIZE: u32;
var<private> OCT_SIDE_SIZE_u32: u32;
var<private> OCT_SIDE_SIZE_f32: f32;
var<private> OCT_RT_SIZE_f32: f32;
var<private> PROBE_SOURCESIZE: f32;
var<private> PROBEMAP_SOURCESIZE: f32;
var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);
var<private> randomMatrix:mat4x4<f32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   RAYS_PER_PROBE = f32(i32(uniformData.rayNumber));
   OCT_RT_SIZE = u32(uniformData.OctRTMaxSize);
   OCT_RT_SIZE_f32 = f32(uniformData.OctRTMaxSize);
   OCT_SIDE_SIZE_u32 = u32(uniformData.OctRTSideSize);
   OCT_SIDE_SIZE_f32 = f32(uniformData.OctRTSideSize);
   PROBE_SOURCESIZE = f32(uniformData.ProbeSize);
   PROBEMAP_SOURCESIZE = f32(uniformData.ProbeSourceTextureSize);
   hysteresis = uniformData.hysteresis;
    // probe index
    probeID = globalInvocation_id.z ;
    // pixel coord
    workgroup_idx = globalInvocation_id.x ;
    workgroup_idy = globalInvocation_id.y;

    probeLocation = calcProbePosition(probeID);

    resultIrradiance = vec4<f32>(0.0);
    resultDepth = vec4<f32>(0.0,0.0,0.0,0.0);

    var tdr = normalize(getCurrentDir());
    let orientationIndex = u32(uniformData.orientationIndex);
    randomMatrix = models.matrix[orientationIndex];

    var distancePprobeUV = getSampleProbeUV(tdr.xyz);
    var rayUv:vec2<i32> = vec2<i32>(distancePprobeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
    let rayHitPosition = textureLoad(positionMap, rayUv, 0).xyz ;
    
    for(var i:f32 = 0.0; i < RAYS_PER_PROBE ; i = i + 1.0 ){
      radianceProbeOnce(i, tdr);
    }

    if (resultIrradiance.w > epsilon) {
      var color = vec3<f32>(resultIrradiance.xyz/(2.0*resultIrradiance.w)) ;
      color = pow(color.rgb, vec3<f32>(1.0 / uniformData.ddgiGamma));
      resultIrradiance = vec4<f32>(color,1.0-hysteresis);
    }

    // if nonzero
    if (resultDepth.w > epsilon) {
      resultDepth = vec4<f32>(resultDepth.xyz/(2.0*resultDepth.w),1.0-hysteresis) ;
    }

   let pixelCoord = getWriteOctUVByID();

   var lerpDataResult:CacheHitData;

   lerpDataResult.color = resultIrradiance;

   lerpDataResult.depth = resultDepth;

   lerpDataResult = lerpHitData(lerpDataResult, pixelCoord);

   writeRayHitData(pixelCoord, lerpDataResult);

   storePixelAtCoord(probeIrradianceMap, pixelCoord , vec4<f32>(lerpDataResult.color.xyz, 1.0), true);

   storePixelAtCoord(probeDepthMap, pixelCoord , vec4<f32>(resultDepth.xy, 0.0, 1.0), false);
}

fn lerpHitData(data:CacheHitData, coord:vec2<i32>) -> CacheHitData{
   let frameIndex = probes[probeID].frame;
   var newData:CacheHitData = data;

   //if(frameIndex > 1.0){
      var oldData = readRayHitData(coord);
      newData.color = mix(oldData.color, newData.color, uniformData.lerpHysteresis);
      newData.depth = mix(oldData.depth, newData.depth, uniformData.lerpHysteresis);
   //}
   return newData;
}

fn square(v:vec3<f32>) -> vec3<f32>{
   var v3 = v;
   v3.x = v3.x * v3.x;
   v3.y = v3.y * v3.y;
   v3.z = v3.z * v3.z;
   return v3;
}

 fn testSample() ->vec4<f32>{
   var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
   var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
   var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
   var dir = octDecode(uv);
   var probeUV = getSampleProbeUV(dir.xyz);
   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   return rayProbeBuffer.WRadiance;
 }

 fn gridCoordToProbeIndex(grid:vec3<i32>) -> i32
 {
     return grid.x + grid.z * i32(uniformData.gridXCount) + grid.y * i32(uniformData.gridXCount * uniformData.gridZCount);
 }

fn storePixelAtCoord(texture:texture_storage_2d<rgba16float, write>, coord:vec2<i32>, color:vec4<f32>, isColor:bool){
   let sideCnt = i32(OCT_SIDE_SIZE_u32);
   let sideBorderCnt = sideCnt + 2;
   let indexXY = coord / sideCnt;
   let modeXY = coord % sideCnt;

   var newCoord = indexXY * sideBorderCnt + modeXY;
   textureStore(texture, newCoord + 1, color);

   var borderCoord = vec2<i32>(-1);
   //\u5DE6\u53F3
   if(modeXY.x % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.y = sideCnt - borderCoord.y;
     if(modeXY.x == sideCnt - 1){
       borderCoord.x = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u4E0A\u4E0B
   if(modeXY.y % (sideCnt - 1) == 0){
     borderCoord = modeXY;
     borderCoord.x = sideCnt - borderCoord.x;
     if(modeXY.y == sideCnt - 1){
         borderCoord.y = sideBorderCnt - 1;
     }
     borderCoord = indexXY * sideBorderCnt + borderCoord;
     textureStore(texture, borderCoord, color);
   }
   //\u8865\u89D2
   if(modeXY.x % (sideCnt - 1) == 0 && modeXY.y % (sideCnt - 1) == 0){
      var cornerCoord = modeXY;
      if(modeXY.x == 0){
         cornerCoord.x = sideBorderCnt - 1;
      }else{
         cornerCoord.x = 0;
      }
       if(modeXY.y == 0){
         cornerCoord.y = sideBorderCnt - 1;
      }else{
         cornerCoord.y = 0;
      }
      cornerCoord = indexXY * sideBorderCnt + cornerCoord;
      textureStore(texture, cornerCoord, color);
   }
}

fn calcProbePosition(id:u32) -> vec3<f32>{
   var probeLocation = vec3<f32>(0.0);
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var grid = vec3<u32>(0u);
   grid.x = (id % blockCount) % u32(uniformData.gridXCount);
   grid.y = id / blockCount;
   grid.z = (id % blockCount) / u32(uniformData.gridXCount);
   probeLocation.x = f32(grid.x) * uniformData.ProbeSpace + uniformData.startX;
   probeLocation.y = f32(grid.y) * uniformData.ProbeSpace + uniformData.startY;
   probeLocation.z = f32(grid.z) * uniformData.ProbeSpace + uniformData.startZ;
   return probeLocation;
}

fn getWriteOctUVByID() -> vec2<i32>
{
   var blockCount = u32(uniformData.gridXCount * uniformData.gridZCount) ;
   var offsetX = (probeID % blockCount) % u32(uniformData.gridXCount) ;
   var offsetY = u32(uniformData.gridZCount - 1.0) - (probeID % blockCount) / u32(uniformData.gridXCount) ;
   var offsetZ = probeID / blockCount ;
   var pixelCoord = vec2<i32>(i32(workgroup_idx), i32(workgroup_idy));
   pixelCoord.x = pixelCoord.x + i32(offsetX * OCT_SIDE_SIZE_u32);
   pixelCoord.y = pixelCoord.y + i32(offsetY * OCT_SIDE_SIZE_u32 + offsetZ * u32(uniformData.gridZCount) * OCT_SIDE_SIZE_u32);

   pixelCoord = offsetByCol(pixelCoord, OCT_SIDE_SIZE_f32, OCT_RT_SIZE, vec3<f32>(uniformData.gridXCount, uniformData.gridYCount, uniformData.gridZCount));
   return pixelCoord;
}

fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
{
 var pixelCoord = pixelCoord0;
 let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
 let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
 let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
 let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
 let col:i32 = pixelCoord.y / pixelCountYMax;

 pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
 pixelCoord.y = pixelCoord.y % pixelCountYMax;

 return pixelCoord;
}

fn radianceProbeOnce(rayID:f32, tdr:vec3<f32>){
   var texelDirection = sphericalFibonacci(rayID, RAYS_PER_PROBE ) ;
   var rayDirection = normalize( vec3<f32>((randomMatrix * vec4<f32>(texelDirection, 1.0)).xyz));
   var probeUV = getSampleProbeUV(rayDirection.xyz);
   var rayWriteUV = getWriteRayInfoUV();

   var rayProbeBuffer = getCurrentRayHitBuffer(probeUV);
   var rayHitLocation = rayProbeBuffer.WPosition + normalize(rayProbeBuffer.WNormal) * 0.01;

   var rayProbeDistance = length(probeLocation - rayHitLocation) ;
   // rayProbeDistance = min(uniformData.ProbeSpace * 4.0, rayProbeDistance) ;

   // if (dot(rayProbeBuffer.WNormal, rayProbeBuffer.WNormal) < epsilon) {
   //   rayProbeDistance = epsilon ;
   // }

   let rid = i32(probeID) * i32(RAYS_PER_PROBE) + i32(rayID) ;
   depthRaysBuffer[rid] = vec4<f32>(rayDirection.xyz,rayProbeDistance) ;

   // Detect misses and force depth
   var i_weight = max(0.0, dot(tdr,rayDirection) );
   var d_weight = pow(i_weight, uniformData.depthSharpness);
   
   if (i_weight >= epsilon) {
     //  var weightColor = pow(weight, (2.0 - uniformData.probeRoughness) * 2.0);
      resultIrradiance += vec4(rayProbeBuffer.WRadiance.rgb, i_weight );
     
   }
   if(d_weight>= epsilon){
       resultDepth += vec4(rayProbeDistance * d_weight, rayProbeDistance * rayProbeDistance * d_weight, 0.0 , i_weight);
   }
}

fn getCurrentRayHitBuffer(probeUV:vec2<f32>) -> RayProbeBuffer {
  var rayProbeBuffer : RayProbeBuffer ;
  var uv:vec2<i32> = vec2<i32>(probeUV.xy * f32(PROBEMAP_SOURCESIZE - 1.0));
  rayProbeBuffer.WPosition = textureLoad(positionMap, uv, 0).xyz ;
  rayProbeBuffer.WNormal = normalize(textureLoad(normalMap, uv, 0).xyz * 2.0 - 1.0);
  rayProbeBuffer.WRadiance = textureLoad(colorMap, uv, 0).xyzw * energyConservation;
  return rayProbeBuffer ;
}

fn getSampleProbeUV(dir0:vec3<f32>) -> vec2<f32> {
   var dir = applyQuaternion(dir0, quaternion);
   let faceId = dir_to_faceId(dir);
   var targetUV:vec2<f32> = convert_xyz_to_cube_uv(dir.x, dir.y, dir.z);
   targetUV.x = 1.0 - targetUV.x;
   let threshould = 0.5 / PROBE_SOURCESIZE;
   targetUV = clamp(targetUV, vec2<f32>(threshould), vec2<f32>(1.0 - threshould));

   targetUV.x = f32(faceId) + targetUV.x;

   let aspect:f32 = PROBE_SOURCESIZE / PROBEMAP_SOURCESIZE;
   targetUV = targetUV * aspect ;

   var fullCol = u32(PROBEMAP_SOURCESIZE) / u32(PROBE_SOURCESIZE);
   var offsetSampleUv = vec2<f32>( f32(probeID / fullCol) * 6.0 , f32(probeID % fullCol)) * aspect;
   return targetUV + offsetSampleUv;
}

fn getWriteRayInfoUV() -> vec2<i32> {
  var writeUV = vec2<i32>(i32(workgroup_idy),i32(probeID)) ;
  return writeUV ;
}

fn writeRayHitData( uv:vec2<i32> , data:CacheHitData){
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  irradianceBuffer[index] = data.color ;
  depthBuffer[index] = data.depth ;
}

fn readRayHitData( uv:vec2<i32> ) -> CacheHitData{
  var data:CacheHitData;
  let index = uv.y * i32(OCT_RT_SIZE) + uv.x ;
  data.color = irradianceBuffer[index] ;
  data.depth = depthBuffer[index] ;
  return data;
}

fn getCurrentDir() -> vec3<f32> {
  var ux = f32(workgroup_idx) / OCT_SIDE_SIZE_f32;
  var uy = f32(workgroup_idy) / OCT_SIDE_SIZE_f32;
  var uv = vec2<f32>(ux,uy) * 2.0 - 1.0 ;
  var dir = octDecode(uv) ;
  return normalize(dir) ;
}


`;class Yc{constructor(t){s(this,"irradianceBuffer");s(this,"depthBuffer");s(this,"probeIrradianceMap");s(this,"probeDepthMap");s(this,"volume");s(this,"computeShader");s(this,"depthRaysBuffer");this.volume=t,this.initPipeline()}initPipeline(){this.computeShader=new ce(Vc);let t=m.setting.gi,e=t.octRTMaxSize*t.octRTMaxSize;this.irradianceBuffer=new be(e*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("irradianceBuffer",this.irradianceBuffer),this.depthBuffer=new be(e*4,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST),this.computeShader.setStorageBuffer("depthBuffer",this.depthBuffer),this.depthRaysBuffer=new be(4096*4*2*2*2,GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC),this.computeShader.setStorageBuffer("depthRaysBuffer",this.depthRaysBuffer),this.computeShader.setStorageBuffer("probes",this.volume.probesBuffer),this.computeShader.setUniformBuffer("uniformData",this.volume.irradianceVolumeBuffer),this.computeShader.setStorageBuffer("models",re.modelMatrixBindGroup.matrixBufferDst)}setTextures(t,e,r){this.probeIrradianceMap=e,this.probeDepthMap=r;let i=t[0],a=t[1],o=t[2];this.computeShader.setStorageTexture("probeIrradianceMap",this.probeIrradianceMap),this.computeShader.setStorageTexture("probeDepthMap",this.probeDepthMap),this.computeShader.setSamplerTexture("positionMap",i),this.computeShader.setSamplerTexture("normalMap",a),this.computeShader.setSamplerTexture("colorMap",o)}readBuffer(){return this.depthRaysBuffer.readBuffer()}compute(t,e){let r=this.volume.setting,i=S.beginCommandEncoder(),a=X.instance.getProbes(t.scene);this.computeShader.workerSizeX=r.octRTSideSize/8,this.computeShader.workerSizeY=r.octRTSideSize/8,this.computeShader.workerSizeZ=a.length,S.computeCommand(i,[this.computeShader]),S.endCommandEncoder(i)}}let Hc=`
  #include "MathShader"
  #include "IrradianceVolumeData_frag"

  struct IrradianceField {
      probeStartPosition: vec4<f32>,
      probeCounts:vec4<f32>,
      probeStep:f32,
      irradianceTextureWidth:f32,
      irradianceTextureHeight:f32,
      irradianceProbeSideLength:f32,
  };

  @group(0) @binding(0) var outputBuffer : texture_storage_2d<rgba16float, write>;
  @group(0) @binding(1) var<uniform> uniformData : IrradianceVolumeData ;

  @group(1) @binding(0) var normalMapSampler : sampler;
  @group(1) @binding(1) var normalMap : texture_2d<f32>;

  @group(1) @binding(2) var colorMapSampler : sampler;
  @group(1) @binding(3) var colorMap : texture_2d<f32>;

  @group(1) @binding(4) var litMapSampler : sampler;
  @group(1) @binding(5) var litMap : texture_2d<f32>;

  @group(1) @binding(6) var irradianceMapSampler : sampler;
  @group(1) @binding(7) var irradianceMap : texture_2d<f32>;

  var<private> wsn:vec3<f32>;
  var<private> ulitColor:vec4<f32>;
  var<private> litColor:vec4<f32>;
  var<private> irradianceFieldSurface : IrradianceField ;
  var<private> probeID:u32;

  var<private> quaternion:vec4<f32> = vec4<f32>(0.0, -0.7071067811865475, 0.7071067811865475, 0.0);

  fn getIrradianceFieldSurface() -> IrradianceField{
    let data = uniformData;
    irradianceFieldSurface.probeStartPosition = vec4<f32>(data.startX, data.startY, data.startZ, 0.0);
    irradianceFieldSurface.probeCounts = vec4<f32>(data.gridXCount, data.gridYCount, data.gridZCount, 0.0);
    irradianceFieldSurface.probeStep = data.ProbeSpace;
    irradianceFieldSurface.irradianceTextureWidth = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceTextureHeight = data.OctRTMaxSize;
    irradianceFieldSurface.irradianceProbeSideLength = data.OctRTSideSize;
    return irradianceFieldSurface;
  }

  fn rotateDir(n:vec3<f32>) -> vec3<f32>{
     return normalize(applyQuaternion(-n, quaternion));
  }

  fn sampleLitColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(litMap, litMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(litMap, uv, 0);
      return oc;
  }

  fn sampleNormal(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(normalMap, normalMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(normalMap, uv, 0);
      return oc;
  }

  fn sampleColor(uv:vec2<i32>) -> vec4<f32>
  {
      var oc1:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, vec2<f32>(0.0), 0.0);
      var oc:vec4<f32> = textureLoad(colorMap, uv, 0);
      return oc;
  }

  fn sampleProbe(fragCoord:vec2<u32>){
    var uv = vec2<i32>(i32(fragCoord.x), i32(fragCoord.y)) ;

    litColor = sampleLitColor(uv);

    var normalMap = sampleNormal(uv);
    wsn = normalMap.xyz * 2.0 - 1.0;

    ulitColor = sampleColor(uv);
  }

  @compute @workgroup_size( 8 , 8 , 1 )
  fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
  {
    getIrradianceFieldSurface();
    var fragCoord = vec2<u32>( globalInvocation_id.x, globalInvocation_id.y);
    probeID = globalInvocation_id.z;
    fragCoord = fragCoord + getCoordOffset(probeID);

    sampleProbe(fragCoord);

    let irradiance = getIrradianceColor();
    let result = blendIrradianceColor(irradiance);
    textureStore(outputBuffer, vec2<i32>(fragCoord), result);
  }

  fn blendIrradianceColor(irradiance:vec4<f32>) -> vec4<f32>{
     var bounceColor = irradiance * ulitColor;
     let bounceIntensity = getBounceIntensity(uniformData.bounceIntensity);
     let conservation1 = 1.0 / sqrt((1.0 + bounceIntensity * 0.55));
     let conservation2 = 1.0 / sqrt((1.0 + bounceIntensity));
     var result = litColor * conservation2 + bounceColor * sqrt(bounceIntensity) * conservation1;
     return vec4<f32>(result.xyz, litColor.w);
  }

  fn getBounceIntensity(intensity:f32) -> f32 {
    var value = clamp(intensity, 0.0, 1.0) * 10.0;
    return value;
  }

  fn getCoordOffset(id:u32) -> vec2<u32>{
      var fullCol = u32(uniformData.ProbeSourceTextureSize / uniformData.ProbeSize);
      var offsetSampleUv = vec2<u32>( (id / fullCol) * 6u , id % fullCol) * u32(uniformData.ProbeSize);
      return offsetSampleUv;
  }

  fn getIrradianceColor() -> vec4<f32>{
     var probeIrradiance: vec4<f32> = vec4<f32>(0.0);
     if(length(wsn) > 0.01){
       probeIrradiance = getIrrdiaceIndex(i32(probeID), wsn);
     }
     return probeIrradiance;
  }

  fn getIrrdiaceIndex(index:i32, wsn:vec3<f32>) -> vec4<f32>{
    var wsN = rotateDir(wsn.xyz);
    var texCoord:vec2<f32> = textureCoordFromDirection(wsN,
      index,
      irradianceFieldSurface.irradianceTextureWidth,
      irradianceFieldSurface.irradianceTextureHeight,
      irradianceFieldSurface.irradianceProbeSideLength);

    var probeIrradiance: vec3<f32> = textureSampleLevel(irradianceMap, irradianceMapSampler, texCoord, 0.0).xyz;
    return vec4<f32>(probeIrradiance, 1.0);
  }

  fn textureCoordFromDirection(dir:vec3<f32>, probeIndex:i32, width:f32, height:f32, sideLength:f32) -> vec2<f32>
  {
      var uv = getWriteOctUVByID(dir, u32(probeIndex), sideLength) ;
      uv.x = uv.x / irradianceFieldSurface.irradianceTextureWidth;
      uv.y = uv.y / irradianceFieldSurface.irradianceTextureHeight;
      return uv ;
  }

  fn getWriteOctUVByID(dir:vec3<f32> , probeID:u32, size: f32) -> vec2<f32>
  {
      var blockCount = u32(irradianceFieldSurface.probeCounts.x * irradianceFieldSurface.probeCounts.z) ;
      var offsetX = (probeID % blockCount) % u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetY = u32(irradianceFieldSurface.probeCounts.z - 1.0) - (probeID % blockCount) / u32(irradianceFieldSurface.probeCounts.x) ;
      var offsetZ = probeID / blockCount ;

      var pixelCoord = (( octEncode(dir) + 1.0 ) * 0.5) * vec2<f32>(size,size) ;

      var blockOffset = vec2<f32>(0.0);
      blockOffset.x = f32(offsetX) * size;
      blockOffset.y = f32(offsetY) * size + f32(offsetZ) * f32(irradianceFieldSurface.probeCounts.z) * size;

      let mapHeight = u32(irradianceFieldSurface.irradianceTextureHeight);
      var probeCounts:vec3<f32> = vec3<f32>(irradianceFieldSurface.probeCounts.xyz);

      var gridOffsetFrom = vec2<i32>(blockOffset) + 1;
      var gridOffsetTo = offsetByCol(gridOffsetFrom, size, mapHeight, probeCounts);

      pixelCoord = pixelCoord + vec2<f32>(gridOffsetTo - 1) + vec2<f32>(vec2<i32>(vec2<f32>(gridOffsetTo) / size) * 2);

      return pixelCoord + 1.0 ;
  }

  fn offsetByCol(pixelCoord0:vec2<i32>, octSideSize:f32, mapHeight:u32, counts:vec3<f32>) -> vec2<i32>
  {
    var pixelCoord = pixelCoord0;
    let blockSize:vec2<i32> = vec2<i32>(i32(octSideSize * counts.x),  i32(octSideSize * counts.z));
    let blockSizeYBorder:i32 = i32((octSideSize + 2.0) * counts.z);
    let blockMaxRowBorder:i32 = i32(mapHeight) / blockSizeYBorder;
    let pixelCountYMax:i32 = blockMaxRowBorder * i32(octSideSize * counts.z);
    let col:i32 = pixelCoord.y / pixelCountYMax;

    pixelCoord.x = col * i32(octSideSize * counts.x) + pixelCoord.x;
    pixelCoord.y = pixelCoord.y % pixelCountYMax;

    return pixelCoord;
  }
`;class Xc{constructor(t){s(this,"blendTexture");s(this,"volume");s(this,"computerShader");this.volume=t,this.initPipeline()}initPipeline(){let t=m.setting.gi;this.blendTexture=new bt(t.probeSourceTextureSize,t.probeSourceTextureSize,j.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING),this.computerShader=new ce(Hc),this.computerShader.setStorageTexture("outputBuffer",this.blendTexture),this.computerShader.setUniformBuffer("uniformData",this.volume.irradianceVolumeBuffer)}setInputs(t){let e=t[0],r=t[1],i=t[2],a=t[3];this.computerShader.setSamplerTexture("normalMap",e),this.computerShader.setSamplerTexture("colorMap",r),this.computerShader.setSamplerTexture("litMap",i),this.computerShader.setSamplerTexture("irradianceMap",a)}compute(t,e){let r=S.beginCommandEncoder(),i=this.volume.setting,a=i.probeXCount*i.probeYCount*i.probeZCount,o=i.probeSize;this.computerShader.workerSizeX=o*6/8,this.computerShader.workerSizeY=o/8,this.computerShader.workerSizeZ=a,S.computeCommand(r,[this.computerShader]),S.endCommandEncoder(r)}}let Wc=`
var<private> PI: f32 = 3.14159265359;

#include "GlobalUniform"
#include "MathShader"
#include "FastMathShader"
#include "ColorUtil_frag"

struct ConstUniform{
   screenWidth:f32,
   screenHeight:f32
}

struct LightData {
     index:f32,
     lightType:i32,
     radius:f32,
     linear:f32,
     
     position:vec3<f32>,
     lightMatrixIndex:f32,

     direction:vec3<f32>,
     quadratic:f32,

     lightColor:vec3<f32>,
     intensity:f32,

     innerCutOff :f32,
     outerCutOff:f32,
     range :f32,
     castShadow:i32,

     lightTangent:vec3<f32>,
     ies:f32,
};

struct Uniforms {
     matrix : array<mat4x4<f32>>
 };

const PointLightType = 1;
const DirectLightType = 2;
const SpotLightType = 3;

@group(0) @binding(auto) var outputBuffer : texture_storage_2d<rgba16float, write>;
@group(0) @binding(auto) var prefilterMapSampler: sampler;
@group(0) @binding(auto) var prefilterMap: texture_cube<f32>;

@group(1) @binding(auto) var positionMapSampler : sampler;
@group(1) @binding(auto) var positionMap : texture_2d<f32>;

@group(1) @binding(auto) var normalMapSampler : sampler;
@group(1) @binding(auto) var normalMap : texture_2d<f32>;

@group(1) @binding(auto) var colorMapSampler : sampler;
@group(1) @binding(auto) var colorMap : texture_2d<f32>;

@group(1) @binding(auto) var shadowMapSampler : sampler_comparison;
@group(1) @binding(auto) var shadowMap : texture_depth_2d_array;
@group(1) @binding(auto) var pointShadowMapSampler: sampler;
@group(1) @binding(auto) var pointShadowMap: texture_depth_cube_array ;

@group(2) @binding(0)
var<storage,read> lightBuffer: array<LightData>;

@group(2) @binding(1)
var<storage, read> models : Uniforms;

struct ShadowStruct{
 directShadowVisibility:f32,
 pointShadows:array<f32,8>,
}

var<private> shadowStrut: ShadowStruct ;
var<private> ulitColor:vec3<f32>;
var<private> wPosition:vec3<f32>;
var<private> wNormal:vec3<f32>;

const LUMEN = 10.764;

fn samplePosition(uv:vec2<f32>) -> vec4<f32>
{
   return textureSampleLevel(positionMap, positionMapSampler,uv, 0.0);
}

fn sampleNormal(uv:vec2<f32>) -> vec4<f32>
{
  return textureSampleLevel(normalMap, normalMapSampler, uv, 0.0);
}

fn sampleColor(uv:vec2<f32>) -> vec4<f32>
{
   var oc:vec4<f32> = textureSampleLevel(colorMap, colorMapSampler, uv, 0.0);
   ulitColor = vec3(oc.xyz);
   return oc;
}

const csmCount:i32 = ${nr.Cascades} ;
fn directShadowMaping(P:vec3<f32>, N:vec3<f32>, shadowBias: f32)  {
  let enableCSM:bool = globalUniform.enableCSM > 0.5;
  var light = lightBuffer[0];
  var visibility = 1.0;
    var shadowIndex = i32(light.castShadow);
    if (shadowIndex >= 0 ) {
      var shadowMatrix:mat4x4<f32>;
      if(enableCSM && csmCount > 1){
        for(var csm:i32 = 0; csm < csmCount; csm ++){
          var csmShadowBias = globalUniform.csmShadowBias[csm];
          shadowMatrix = globalUniform.csmMatrix[csm];
          let csmShadowResult = directShadowMapingIndex(light, shadowMatrix, P, N, csm, csmShadowBias);
          if(csmShadowResult.y < 0.5){
            visibility = csmShadowResult.x;
            break;
          }
        }
      }else{
        shadowMatrix = globalUniform.shadowMatrix[shadowIndex];
        visibility = directShadowMapingIndex(light, shadowMatrix, P, N, shadowIndex, shadowBias).x;
      }
    }
  shadowStrut.directShadowVisibility = visibility;
}

fn directShadowMapingIndex(light:LightData, matrix:mat4x4<f32>, P:vec3<f32>, N:vec3<f32>, depthTexIndex:i32, shadowBias:f32) -> vec2<f32>
{
  var visibility = 1.0;
  var isOutSideArea:f32 = 1.0;
  var shadowPosTmp = matrix * vec4<f32>(P.xyz, 1.0);
  var shadowPos = shadowPosTmp.xyz / shadowPosTmp.w;
  var varying_shadowUV = shadowPos.xy * vec2<f32>(0.5, -0.5) + vec2<f32>(0.5, 0.5);
  if (varying_shadowUV.x <= 1.0
    && varying_shadowUV.x >= 0.0
    && varying_shadowUV.y <= 1.0
    && varying_shadowUV.y >= 0.0
    && shadowPosTmp.z <= 1.0
    && shadowPosTmp.z >= 0.0)
  {
    isOutSideArea = 0.0;
    var uvOnePixel = 1.0 / vec2<f32>(globalUniform.shadowMapSize);
    var NoL = abs(dot(N, normalize(light.direction)));
    var bias = shadowBias / max(NoL, 0.000001);
    visibility = textureSampleCompareLevel(shadowMap, shadowMapSampler, varying_shadowUV, depthTexIndex, shadowPos.z - bias);
    visibility += 0.001;
  }
  return vec2<f32>(visibility, isOutSideArea);
}

fn pointShadowMapCompare(shadowBias:f32){
   for(var i:i32 = i32(0) ; i < i32(8); i = i + 1 )
   { 
       var v = 1.0 ;
       let light = lightBuffer[i] ;
       if(light.castShadow < 0 ){
         shadowStrut.pointShadows[i] = v ;
         continue ;
       }

       let frgToLight = wPosition - light.position.xyz;
       var dir:vec3<f32> = normalize(frgToLight)  ;

       var len = length(frgToLight) ;
       var depth = textureSampleLevel(pointShadowMap,pointShadowMapSampler,dir.xyz,i,0); 
       depth *= globalUniform.far ;
       if((len - shadowBias) > depth){
          v = 0.0 ; 
       }
       shadowStrut.pointShadows[i] = v ;
   }
} 

fn directLighting( albedo:vec3<f32> , WP :vec3<f32>, N:vec3<f32> , V:vec3<f32> , light:LightData , shadowBias:f32  ) -> vec3<f32> {
 var L = -normalize(light.direction.xyz) ;
 var NoL = max(dot(N,L),0.0);
 let lightCC = pow( light.lightColor.rgb,vec3<f32>(2.2));
 var lightColor = getHDRColor( lightCC , light.linear ) ;
 var att = light.intensity / LUMEN ;
 if(light.castShadow>=0){
     lightColor *= shadowStrut.directShadowVisibility ;
 }
 let finalLight = (albedo / PI) * lightColor * NoL * att * 2.0 ;
 return finalLight ;
}

fn pointLighting( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir);
 var color = vec3<f32>(0.0) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 if( abs(dist) < light.range ){
     var L = dir ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.0001) ;

     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
 }

 return  color *0.0;
}

fn spotLight( albedo:vec3<f32>,WP:vec3<f32>, N:vec3<f32>, V:vec3<f32>, light:LightData ) -> vec3<f32> {
 let lightPos = models.matrix[u32(light.lightMatrixIndex)][3].xyz;
 var dir = lightPos.xyz - WP ;
 let dist = length(dir) ;

 if(dist != 0.0){
   dir *= 1.0 / dist ;
 }

 var color = vec3<f32>(0.0) ;
 if( abs(dist) < light.range * 2.0 ){
     var L = dir ;
     let theta = dot(-L, normalize(light.direction));
     let angle = acos(theta) ;
     var atten = 1.0 ;
     atten = 1.0 - smoothstep(0.0,light.range,dist) ;
     atten *= 1.0 / max(light.radius,0.1) ;
     if(angle < light.outerCutOff){
       if(angle > light.innerCutOff){
         atten *= 1.0 - smoothstep(light.innerCutOff, light.outerCutOff, angle) ;
       }
     }else{
       atten = 0.0 ;
     }
     var lightColor = light.lightColor.rgb  ;
     lightColor = getHDRColor(lightColor , light.linear ) * light.intensity / LUMEN * 2.0;
     color = (albedo / PI) * lightColor.rgb * atten ;
   }
 return  color ;
}

fn CalcUV_01(coord:vec2<i32>, texSize:vec2<u32>) -> vec2<f32>
{
  let u = (f32(coord.x) + 0.5) / f32(texSize.x);
  let v = (f32(coord.y) + 0.5) / f32(texSize.y);
  return vec2<f32>(u, v);
}

fn coordFun(fragCoord:vec2<i32>)-> vec4<f32>{
 let uv_01 = CalcUV_01(fragCoord, texSize);
 var pos = samplePosition(uv_01);

 var normalMap = sampleNormal(uv_01);
 var normal = normalize( normalMap.xyz * 2.0 - 1.0 );

 var color = sampleColor(uv_01);
 var emissive = vec4<f32>(pos.a,normalMap.a,color.a,0.0) * 1.0 ;
 if(pos.w + 1.0 > 10000.0){
   return vec4<f32>(color);
 }
 var V = normalize(pos.xyz - globalUniform.cameraWorldMatrix[3].xyz);
 var N = normal.xyz ;

 wPosition = pos.xyz;
 wNormal = N;

 directShadowMaping(wPosition, wNormal, globalUniform.shadowBias);
 pointShadowMapCompare(globalUniform.shadowBias);

 var lighting = vec3<f32>(0.0);
 let lightCount = 32 ;
 for(var i:i32 = 0 ; i < lightCount ; i = i + 1 )
 {
     let light = lightBuffer[i];
     switch (light.lightType) {
         case PointLightType: {
             lighting += pointLighting(color.rgb,pos.xyz,N,V,light);
         }
         case DirectLightType: {
             lighting += directLighting(color.rgb,pos.xyz,N,V,light,globalUniform.shadowBias);
         }
         case SpotLightType: {
             lighting += spotLight(color.rgb,pos.xyz,N,V,light);
         }
         default: {
         }
     }
 }

 // lighting = vec3<f32>(1.0) / (vec3<f32>(1.0) + lighting.rgb) * lighting.rgb;

 var skyLight: vec3<f32> = globalUniform.skyExposure * (textureSampleLevel(prefilterMap, prefilterMapSampler, N.xyz, 8.0 ).rgb);
 // skyLight = LinearToGammaSpace(skyLight);
 // skyLight = (color.rgb / 3.1415926 ) * skyLight;
 // skyLight = vec3<f32>(1.0) / (vec3<f32>(1.0) + skyLight.rgb) * skyLight.rgb;

 lighting = lighting.rgb ;//+ skyLight.rgb ;

 return vec4<f32>(lighting.rgb,color.w)+emissive;
}

// fn vertexToCoord(vertexPosition:vec3<f32>) -> vec4<f32>{
//   var worldPos = vec4<f32>(vertexPosition.xyz, 1.0);
//   var fragPosition = globalUniform.viewMat * worldPos ;
//   // var position = globalUniform.projMat * fragPosition ;
//   return fragPosition;
// }

var<private> texSize: vec2<u32>;

@compute @workgroup_size( 8 , 8 , 1 )
fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
{
   var fragCoord = vec2<i32>(globalInvocation_id.xy);
   texSize = textureDimensions(colorMap).xy;
   var color = coordFun(fragCoord);
   // color = vec4(pow(color.rgb,vec3<f32>(1.0/2.4)),1.0);
   textureStore(outputBuffer, fragCoord, color);
}

`;class Kc{constructor(){s(this,"computeShader");s(this,"worldPosMap");s(this,"worldNormalMap");s(this,"colorMap");s(this,"shadowMap");s(this,"pointShadowMap");s(this,"lightingTexture");let t=m.setting.gi;this.lightingTexture=new bt(t.probeSourceTextureSize,t.probeSourceTextureSize,j.rgba16float,!1,GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING)}create(t){let e=re.getLightEntries(t.scene);this.computeShader=new ce(Wc);let r=re.getCameraGroup(t.camera);this.computeShader.setUniformBuffer("globalUniform",r.uniformGPUBuffer),this.computeShader.setStorageTexture("outputBuffer",this.lightingTexture),this.computeShader.setStorageBuffer("lightBuffer",e.storageGPUBuffer),this.computeShader.setStorageBuffer("models",re.modelMatrixBindGroup.matrixBufferDst),this.computeShader.setSamplerTexture("positionMap",this.worldPosMap),this.computeShader.setSamplerTexture("normalMap",this.worldNormalMap),this.computeShader.setSamplerTexture("colorMap",this.colorMap),this.computeShader.setSamplerTexture("shadowMap",this.shadowMap),this.computeShader.setSamplerTexture("pointShadowMap",this.pointShadowMap),this.computeShader.setSamplerTexture("prefilterMap",m.res.defaultSky)}setInputs(t){this.worldPosMap=t[0],this.worldNormalMap=t[1],this.colorMap=t[2],this.shadowMap=t[3],this.pointShadowMap=t[4]}compute(t,e){this.computeShader||this.create(t);let r=S.beginCommandEncoder(),i=m.setting.gi;this.computeShader.workerSizeX=i.probeSourceTextureSize/8,this.computeShader.workerSizeY=i.probeSourceTextureSize/8,this.computeShader.workerSizeZ=1,S.computeCommand(r,[this.computeShader]),S.endCommandEncoder(r)}}let po=new lt("GIRenderStartEvent"),Gn=new lt("GIRenderCompleteEvent");class jc{constructor(){s(this,"count");s(this,"complete")}}class qc extends Lr{constructor(e){super();s(this,"cubeCamera");s(this,"volume");s(this,"probeCountPerFrame",1);s(this,"nextProbeIndex",-1);s(this,"tempProbeList",[]);s(this,"isRenderCloudGI");s(this,"probeRenderResult");s(this,"renderStatus","none");s(this,"positionMap");s(this,"normalMap");s(this,"colorMap");s(this,"probeNext",128);s(this,"sizeW");s(this,"sizeH");s(this,"lightingPass");s(this,"bouncePass");s(this,"irradianceComputePass");s(this,"irradianceDepthMap");s(this,"irradianceColorMap");this.passType=J.GI,this.volume=e;let r=e.setting;this.cubeCamera=new kn(.01,5e3),this.sizeW=r.probeSourceTextureSize,this.sizeH=r.probeSourceTextureSize,this.probeNext=r.probeSourceTextureSize/r.probeSize,this.initIrradianceMap(e),this.probeRenderResult=new jc;let i=new Qc(this.sizeW,this.sizeH,!1);this.positionMap=i.renderTargets[0],this.normalMap=i.renderTargets[1],this.colorMap=i.renderTargets[2],this.setRenderStates(i)}setInputTexture(e){this.lightingPass=new Kc,this.bouncePass=new Xc(this.volume),this.irradianceComputePass=new Yc(this.volume),this.lightingPass.setInputs([this.positionMap,this.normalMap,this.colorMap,e[0],e[1]]),this.bouncePass.setInputs([this.normalMap,this.colorMap,this.lightingPass.lightingTexture,this.irradianceColorMap]),this.irradianceComputePass.setTextures([this.positionMap,this.normalMap,this.bouncePass.blendTexture],this.irradianceColorMap,this.irradianceDepthMap)}setIrradianceData(e,r,i,a){if(i!=this.irradianceColorMap.width||a!=this.irradianceColorMap.height){console.error("irradiance image size not match !");return}this.writeToTexture(this.irradianceColorMap,e,i,a),this.writeToTexture(this.irradianceDepthMap,r,i,a)}updateProbe(e,r,i){let a=X.instance.getLights(e.scene),o=this.volume.setting.probeSize;r.drawCallFrame+=1,this.cubeCamera.x=r.x,this.cubeCamera.y=r.y,this.cubeCamera.z=r.z,this.volume.setting.debugCamera?(this.cubeCamera.x=e.camera.transform.x,this.cubeCamera.y=e.camera.transform.y,this.cubeCamera.z=e.camera.transform.z,this.cubeCamera.rotationX=e.camera.transform.rotationX,this.cubeCamera.rotationY=e.camera.transform.rotationY,this.cubeCamera.rotationZ=e.camera.transform.rotationZ):(this.cubeCamera.rotationX=r.rotationX,this.cubeCamera.rotationY=r.rotationY,this.cubeCamera.rotationZ=r.rotationZ);let l=this.cubeCamera,h=Math.floor(r.index/this.probeNext)*(o*6),u=Math.floor(r.index%this.probeNext)*o;i.setViewport(0+h,u,o,o,0,1),this.renderSceneOnce(e,l.right_camera,i,a),i.setViewport(o+h,u,o,o,0,1),this.renderSceneOnce(e,l.left_camera,i,a),i.setViewport(o*2+h,u,o,o,0,1),this.renderSceneOnce(e,l.up_camera,i,a),i.setViewport(o*3+h,u,o,o,0,1),this.renderSceneOnce(e,l.down_camera,i,a),i.setViewport(o*4+h,u,o,o,0,1),this.renderSceneOnce(e,l.front_camera,i,a),i.setViewport(o*5+h,u,o,o,0,1),this.renderSceneOnce(e,l.back_camera,i,a)}renderSceneOnce(e,r,i,a){this.volume.uploadBuffer();let o=X.instance.getRenderNodes(e.scene,r);S.bindCamera(i,r);let l=Math.max(0,m.setting.render.drawOpMin),h=Math.min(m.setting.render.drawOpMax,o.opaqueList.length),u=X.instance.getRenderShaderCollect(e);for(const c of u){let f=c[1];for(const d of f){let p=d[1];if(!p.isDestroyed&&p.preInit(this.passType)){p.nodeUpdate(e,this.passType,this.rendererPassState,null);break}}}for(let c=l;c<h;++c){let f=o.opaqueList[c];f.enable&&f.transform.enable&&!f.isDestroyed&&(f.preInit(this.passType)||f.nodeUpdate(e,this.passType,this.rendererPassState,null),f.renderPass2(e,this.passType,this.rendererPassState,null,i))}X.instance.sky&&(X.instance.sky.preInit(this.passType)||X.instance.sky.nodeUpdate(e,this.passType,this.rendererPassState,null),X.instance.sky.renderPass2(e,this.passType,this.rendererPassState,null,i)),l=Math.max(0,m.setting.render.drawTrMin),h=Math.min(m.setting.render.drawTrMax,o.transparentList.length);for(let c=l;c<h;++c){let f=o.transparentList[c];f.enable&&f.transform.enable&&!f.isDestroyed&&(f.preInit(this.passType)||f.nodeUpdate(e,this.passType,this.rendererPassState,null),f.renderPass2(e,this.passType,this.rendererPassState,null,i))}}render(e,r){if(!m.setting.gi.enable)return;this.volume.updateOrientation(),this.volume.isVolumeFrameChange=!1,this.volume.uploadBuffer(),this.rendProbe(e);let i=this.probeRenderResult.count>0;(X.instance.state.giLightingChange||i||m.setting.gi.realTimeGI)&&(X.instance.state.giLightingChange=!1,this.lightingPass.compute(e,this.rendererPassState),this.bouncePass.compute(e,this.rendererPassState),this.irradianceComputePass.compute(e,this.rendererPassState)),this.probeRenderResult.complete&&this.dispatchEvent(Gn)}startRenderGI(e=0){this.nextProbeIndex==-1&&e==0&&this.dispatchEvent(po),this.nextProbeIndex=e,this.renderStatus="rendering"}startRenderCloudGI(){this.dispatchEvent(po),this.nextProbeIndex=0,this.renderStatus="rendering",this.isRenderCloudGI=!0}rendProbe(e){let r=m.setting.gi.autoRenderProbe,i=!1;if(r?(this.nextProbeIndex==-1&&this.startRenderGI(),i=!0):i=this.renderStatus=="rendering",this.probeRenderResult.count=0,this.probeRenderResult.complete=!1,i){let a=X.instance.getProbes(e.scene);this.renderContext.clean(),this.renderContext.beginOpaqueRenderPass(),this.tempProbeList.length=0;let o=Math.min(this.probeCountPerFrame,a.length);for(this.probeRenderResult.count=o;o>0;){const h=a[this.nextProbeIndex];this.updateProbe(e,h,this.renderContext.encoder),o--,this.nextProbeIndex++,h.drawCallFrame<3&&this.tempProbeList.push(h)}this.tempProbeList.length>0&&this.volume.updateProbes(this.tempProbeList);let l=this.nextProbeIndex>=a.length;this.nextProbeIndex>=a.length&&this.isRenderCloudGI&&this.updateProbe(e,a[0],this.renderContext.encoder),this.renderContext.endRenderPass(),l&&(this.nextProbeIndex=-1,this.renderStatus="complete",this.probeRenderResult.complete=!0)}}initIrradianceMap(e){let r=e.setting,i=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.COPY_DST;this.irradianceDepthMap=new bt(r.octRTMaxSize,r.octRTMaxSize,j.rgba16float,!1,i),this.irradianceDepthMap.name="irradianceDepthMap",this.irradianceColorMap=new bt(r.octRTMaxSize,r.octRTMaxSize,j.rgba16float,!1,i),this.irradianceColorMap.name="irradianceColorMap"}writeToTexture(e,r,i,a){console.log(e.name);const o=E.device.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});E.device.queue.writeBuffer(o,0,r);const l=S.beginCommandEncoder();l.copyBufferToTexture({buffer:o,bytesPerRow:i*16},{texture:e.getGPUTexture()},{width:i,height:a,depthOrArrayLayers:1}),S.endCommandEncoder(l)}}class Jc extends Lr{constructor(){super(),this.passType=J.UI}compute(t,e){let r=S.beginCommandEncoder(),i=S.lastRenderPassState.getLastRenderTexture(),a=fe.getGUIBufferFrame().getColorTexture();S.copyTexture(r,i,a),S.endCommandEncoder(r)}render(t,e,r,i=!1){this.renderContext.clean();let a=t.scene,o=t.camera;re.updateCameraGroup(o),this.rendererPassState.camera3D=o;let l=X.instance.getRenderNodes(a,o);{this.renderContext.specialtRenderPass();let h=this.renderContext.encoder;l.opaqueList&&(S.bindCamera(h,o),this.drawNodes(t,this.renderContext,l.opaqueList,e,r))}{let h=this.renderContext.encoder;!i&&l.transparentList&&(S.bindCamera(h,o),this.drawNodes(t,this.renderContext,l.transparentList,e,r)),this.renderContext.endRenderPass()}}drawNodes(t,e,r,i,a){let o=X.instance.getRenderShaderCollect(t);if(o){for(const l of o){let h=l[1];for(const u of h){let c=u[1];if(!c.isDestroyed&&c.preInit(this._rendererType)){c.nodeUpdate(t,this._rendererType,this.rendererPassState,a);break}}}for(let l=m.setting.render.drawOpMin;l<Math.min(r.length,m.setting.render.drawOpMax);++l){let h=r[l];h.transform.enable&&h.enable&&(!h.hasMask(ye.UI)||h.isRecievePostEffectUI||h.isDestroyed||(h.preInit(this._rendererType)||h.nodeUpdate(t,this._rendererType,this.rendererPassState,a),h.renderPass(t,this.passType,this.renderContext)))}}}occlusionRenderNodeTest(t,e,r){return r.zDepthRenderNodeTest(e)>0}}class Zc extends Gc{constructor(t){super(t)}start(){super.start();{let t=new bc,e=fe.getGBufferFrame(fe.colorPass_GBuffer);if(m.setting.render.zPrePass&&(e.zPreTexture=this.depthPassRenderer.rendererPassState.depthTexture),t.setRenderStates(e),m.setting.gi.enable){let r=re.getLightEntries(this.view.scene);this.ddgiProbeRenderer=new qc(r.irradianceVolume),this.ddgiProbeRenderer.setInputTexture([this.shadowMapPassRenderer.depth2DArrayTexture,this.pointLightShadowRenderer.cubeArrayTexture]),t.setIrradiance(this.ddgiProbeRenderer.irradianceColorMap,this.ddgiProbeRenderer.irradianceDepthMap),this.rendererMap.addRenderer(this.ddgiProbeRenderer)}this.rendererMap.addRenderer(t)}{let t=fe.getGUIBufferFrame(),e=new Jc;e.setRenderStates(t),this.rendererMap.addRenderer(e)}m.setting.render.debug&&this.debug()}debug(){}}class $c{constructor(){s(this,"_factor");s(this,"_doubleFactor");this._factor=1,this._doubleFactor=2}get accelerateInterpolator(){return this._factor}set accelerateInterpolator(t){this._factor=t,this._doubleFactor=2*this._factor}getInterpolation(t){return this._factor==1?t*t:Math.pow(t,this._doubleFactor)}}class ef{constructor(){s(this,"_factor",1)}get decelerateInterpolator(){return this._factor}set decelerateInterpolator(t){this._factor=t}getInterpolation(t){let e;return this._factor==1?e=1-(1-t)*(1-t):e=1-Math.pow(1-t,2*this._factor),e}}class tf{constructor(){s(this,"_factor",1)}getInterpolation(t){return Math.cos((t+1)*Math.PI)/2+.5}}class rf{getInterpolation(t){return t}}class af{getInterpolation(t){return 4.9*t+4.9*t}}class Jt{constructor(){}static bounce(t){return t*t*9.8}getInterpolation(t){return t*=1.1226,t<.3535?Jt.bounce(t):t<.7408?Jt.bounce(t-.54719)+.7:t<.9644?Jt.bounce(t-.8526)+.9:Jt.bounce(t-1.0435)+.95}getBounceInterpolation(t){return t<.5?Jt.bounce(t):Jt.bounce(t-1)}geJumpUp(t,e){return e<.5?(e=e/.5,t*e-Jt.bounce(e)):e<.8?(e=(e-.5)/(.8-.5),(t*e-Jt.bounce(e))*.3):e<1?(e=(e-.8)/(1-.8),(t*e-Jt.bounce(e))*.15):t*e-Jt.bounce(e)}}class sf{constructor(){s(this,"_tension");this._tension=2}get anticipateInterpolator(){return this._tension}set anticipateInterpolator(t){this._tension=t}getInterpolation(t){return t*t*((this._tension+1)*t-this._tension)}}class As{constructor(){s(this,"_tension");this._tension=1*1.5}anticipateOvershootInterpolator(t){this._tension=t*1.5}anticipateOvershootInterpolator2(t,e){this._tension=t*e}getInterpolation(t){return t<.5?.5*As.a(t*2,this._tension):.5*(As.o(t*2-2,this._tension)+2)}static a(t,e){return t*t*((e+1)*t-e)}static o(t,e){return t*t*((e+1)*t+e)}}class of{constructor(t){s(this,"_cycles");this._cycles=t}getInterpolation(t){return Math.sin(2*this._cycles*Math.PI*t)}}class nf{constructor(){s(this,"_tension");this._tension=2}getInterpolation(t){return t-=1,t*t*((this._tension+1)*t+this._tension)+1}}var Qn=(n=>(n[n.AccelerateInterpolator=0]="AccelerateInterpolator",n[n.DecelerateInterpolator=1]="DecelerateInterpolator",n[n.AccelerateDecelerateInterpolator=2]="AccelerateDecelerateInterpolator",n[n.LinearInterpolator=3]="LinearInterpolator",n[n.BounceInterpolator=4]="BounceInterpolator",n[n.AnticipateInterpolator=5]="AnticipateInterpolator",n[n.AnticipateOvershootInterpolator=6]="AnticipateOvershootInterpolator",n[n.CycleInterpolator=7]="CycleInterpolator",n[n.OvershootInterpolator=8]="OvershootInterpolator",n[n.JumperInterpolator=9]="JumperInterpolator",n))(Qn||{});const oi=class oi{constructor(){s(this,"complete",!1);s(this,"onComplete");s(this,"onProgress");s(this,"target");s(this,"property");s(this,"targetProperty");s(this,"durtion");s(this,"interpolatorEnum");s(this,"delayTime",0);s(this,"_interpolator");s(this,"_ct",0);s(this,"_p",0)}static to(t,e,r,i=0){var a=new oi;return a.target=t,a.property=e,a.durtion=r,a.interpolatorEnum=i,a.start(),a.delayTime=e.delayTime?e.delayTime:0,e.onComplete&&(a.onComplete=e.onComplete),e.onProgress&&(a.onProgress=e.onProgress),this.interpolators.push(a),a}static tick(t){let e=oi.interpolators;for(let r of e)r.complete?oi.remove(r,!0):r.tick(t)}static remove(t,e){let r=oi.interpolators,i=r.indexOf(t);i!=-1&&r.splice(i,1),e&&t.dispose()}static removeList(t,e){t.forEach(r=>{this.remove(r,e)})}start(){window.AccelerateInterpolator=$c,window.DecelerateInterpolator=ef,window.AccelerateDecelerateInterpolator=tf,window.LinearInterpolator=rf,window.BounceInterpolator=Jt,window.AnticipateInterpolator=sf,window.AnticipateOvershootInterpolator=As,window.CycleInterpolator=of,window.OvershootInterpolator=nf,window.JumperInterpolator=af,this._interpolator=new window[Qn[this.interpolatorEnum]],this.targetProperty={};for(let t in this.property)this.targetProperty[t]=this.target[t]}tick(t){if(this.delayTime<=0){this._p=Math.min(this._ct/this.durtion,1);let e=this._interpolator.getInterpolation(this._p),r=this.property,i=this.target,a=this.targetProperty,o,l;for(let h in r)l=r[h],o=a[h],i[h]=o+(l-o)*e;this.onProgress!=null&&this.onProgress(this._p),this._ct>=this.durtion&&(this.complete=!0,this.onComplete!=null&&this.onComplete(this.target)),this._ct+=t}else this.delayTime-=t}dispose(){this.onComplete=null,this.onProgress=null,this.target=null,this.property=null,this.targetProperty=null,this.interpolatorEnum=null,this._interpolator=null,oi.remove(this)}};s(oi,"interpolators",[]);let mo=oi;class Tt{static hasString(t,e){for(var r=0;r<t.length;++r)if(t[r]==e)return r;return-1}static getEllipsis(t,e=4){let r=t;return r.length>e&&(r=r.slice(0,e)+"..."),r}static getURLName(t){var e;e=t.split("/");let r=e[e.length-1];return r=r.split(".")[0],r}static getFileFormat(t){var e=t.lastIndexOf(".");e++;var r=t.length;t.indexOf("?",e)!==-1&&(r=t.indexOf("?",e));var i=t.substr(e,r-e);return i=i.toLowerCase(),i}static readLineProperty(t,e){t.trim().split(" ").forEach((r,i)=>{let a=r.split("=");if(a.length>1){let o=a[0],l=a[1];Object.prototype.hasOwnProperty.call(e,o)&&(l.indexOf('"')==-1?e[o]=parseFloat(a[1]):e[o]=l.replace('"',"").replace('"',""))}})}static getPath(t){var e=t.lastIndexOf("/");return e++,t.substring(0,e)}static normalizePath(t){var e=t.replaceAll("//","/");return e=e.replaceAll("\\","/"),e}static getStringList(t,e=";"){return t.split(e)}static formatTime(t){let e=t/1e3/60,r=Math.floor(e),i=Math.floor(e-r);return[r.toString(),i.toString()]}static trim(t){return t.replace(/^\s+/g,"").replace(/\s+$/g,"")}static isEmpty(t){return!t||typeof t>"u"||t==null||typeof t=="string"&&this.trim(t)===""||t==="null"}static strCut(t,e){if(t.length*2<=e)return t;for(var r=0,i="",a=0;a<t.length;a++)if(i=i+t.charAt(a),t.charCodeAt(a)>128){if(r=r+2,r>=e)return i.substring(0,i.length-1)+"..."}else if(r=r+1,r>=e)return i.substring(0,i.length-2)+"...";return i}static toQueryPair(t,e,r=!1){return t+"="+(r?encodeURIComponent(e):e)}static stringFormat(t,...e){if(arguments.length===0)throw new Error("please give arg at least one !");if(arguments.length===2&&typeof arguments[1]=="object")for(let r in arguments[1]){let i=new RegExp("({"+r+"})","g");t=t.replace(i,arguments[1][r])}else for(let r=0;r<e.length;r++){if(e[r]==null)return t;{let i=new RegExp("({["+r+"]})","g");t=t.replace(i,e[r])}}return t}static parseJson2String(t,e){let r=null,i="",a=0,o="    ";return e=e||{},e.newlineAfterColonIfBeforeBraceOrBracket=e.newlineAfterColonIfBeforeBraceOrBracket===!0,e.spaceAfterColon=e.spaceAfterColon!==!1,typeof t!="string"||(t=JSON.parse(t)),t=JSON.stringify(t),r=/([\{\}])/g,t=t.replace(r,`\r
$1\r
`),r=/([\[\]])/g,t=t.replace(r,`\r
$1\r
`),r=/(\,)/g,t=t.replace(r,`$1\r
`),r=/(\r\n\r\n)/g,t=t.replace(r,`\r
`),r=/\r\n\,/g,t=t.replace(r,","),e.newlineAfterColonIfBeforeBraceOrBracket||(r=/\:\r\n\{/g,t=t.replace(r,":{"),r=/\:\r\n\[/g,t=t.replace(r,":[")),e.spaceAfterColon&&(r=/\:/g,t=t.replace(r,":")),t.split(`\r
`).forEach(function(l,h){let u=0,c=0,f="";for(l.match(/\{$/)||l.match(/\[$/)?c=1:l.match(/\}/)||l.match(/\]/)?a!==0&&(a-=1):c=0,u=0;u<a;u++)f+=o;i+=f+l+`\r
`,a+=c}),i}static compareVersion(t,e){t=t.split("."),e=e.split(".");let r=Math.max(t.length,e.length);for(;t.length<r;)t.push("0");for(;e.length<r;)e.push("0");for(let i=0;i<r;i++){let a=parseInt(t[i]),o=parseInt(e[i]);if(a>o)return 1;if(a<o)return-1}return 0}static buildRandomCode(){let t="abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789",e=t.length,r="";for(let i=0;i<26;i++){let a=Math.floor(Math.random()*e);r+=t.charAt(a)}return`${new Date().getTime()}-${r}`}static UUID(){return"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g,function(t){var e=Math.random()*16|0,r=t=="x"?e:e&3|8;return r.toString(16)})}static stringToHash(t){let e=0;if(t.length==0)return e;for(let r=0;r<t.length;r++){const i=t.charCodeAt(r);e=(e<<5)-e+i,e=e&e}return e}static parseUrl(t,e){return e.match(/^(blob|http|https):/)?e:t+e}}s(Tt,"_filterChar",[" ","  ",";",`
`,"\r","	",`
`,"\r","	"]);class ei extends It{constructor(e=!0){super();s(this,"_source");s(this,"premultiplyAlpha","none");s(this,"imageData");this.useMipmap=e,this.lodMinClamp=0,this.lodMaxClamp=4}get source(){return this._source}set source(e){this._source=e,this._source instanceof HTMLImageElement?this._source.decode().then(()=>V(this,null,function*(){if(this._source instanceof HTMLImageElement){const r=yield createImageBitmap(this._source,{imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});this.generate(r)}})):(this._source instanceof HTMLCanvasElement||this._source instanceof ImageBitmap)&&this.generate(this._source)}load(e,r){return V(this,null,function*(){if(this.name=Tt.getURLName(e),e.indexOf(";base64")!=-1){const i=document.createElement("img");let a=e.indexOf("data:image"),o=e.substring(a,e.length);i.src=o,yield i.decode(),i.width=Math.max(i.width,32),i.height=Math.max(i.height,32);const l=yield createImageBitmap(i,{resizeWidth:i.width,resizeHeight:i.height,imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});this.format=j.rgba8unorm,this.generate(l)}else return new Promise((i,a)=>{fetch(e,{headers:Object.assign({Accept:"image/avif,image/webp,*/*"},r==null?void 0:r.headers)}).then(o=>{Yi.read(e,o,r).then(l=>{let h=new Blob([l],{type:"image/jpeg"});l=null,this.loadFromBlob(h).then(()=>{i(!0)})})})});return!0})}loadFromBlob(e){return V(this,null,function*(){this.imageData=e;let r=yield createImageBitmap(e,{imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"});if(r.width<32||r.height<32){let i=Math.max(r.width,32),a=Math.max(r.height,32);r=yield createImageBitmap(r,{resizeWidth:i,resizeHeight:a,imageOrientation:this.flipY?"flipY":"from-image",premultiplyAlpha:"none"})}return this.format=j.rgba8unorm,this.generate(r),!0})}}class Yi{constructor(){s(this,"baseUrl","");s(this,"initUrl");s(this,"_progress",0)}loadBinData(t,e){return V(this,null,function*(){return this.baseUrl=Tt.getPath(t),this.initUrl=t,new Promise((r,i)=>V(this,null,function*(){fetch(t,{headers:e==null?void 0:e.headers}).then(a=>V(this,null,function*(){if(a.ok){let o=yield Yi.read(t,a,e),l=o.buffer;o=null,r(l)}else throw Error("request rejected with status "+a.status)})).catch(a=>{e.onError&&e.onError(a),i(a)})}))})}loadAsyncBitmapTexture(t,e){return V(this,null,function*(){this.baseUrl=Tt.getPath(t),this.initUrl=t;let r=new ei;return r.url=t,r.name=Tt.getURLName(t),yield r.load(t,e),m.res.addTexture(t,r),r})}loadJson(t,e){return V(this,null,function*(){return this.baseUrl=Tt.getPath(t),this.initUrl=t,new Promise((r,i)=>V(this,null,function*(){fetch(t,{headers:e==null?void 0:e.headers}).then(a=>V(this,null,function*(){if(a.ok){let o=yield Yi.read(t,a,e);const l=new TextDecoder("utf-8").decode(o);o=null,r(JSON.parse(l))}else throw Error("request rejected with status"+a.status)})).catch(a=>{e.onError&&e.onError(a),i(a)})}))})}loadTxt(t,e){return V(this,null,function*(){return this.baseUrl=Tt.getPath(t),new Promise((r,i)=>V(this,null,function*(){fetch(t).then(a=>V(this,null,function*(){if(a.ok){let o=yield Yi.read(t,a,e);const l=new TextDecoder("utf-8").decode(o);o=null,r({data:l})}else throw Error("request rejected with status"+a.status)})).catch(a=>{e.onError&&e.onError(a),i(a)})}))})}static read(t,e,r){return V(this,null,function*(){const i=e.body.getReader(),a=+e.headers.get("Content-Length");let o=0,l=[],h=[];for(;;){const{done:f,value:d}=yield i.read();if(f){a>0&&r&&r.onComplete&&r.onComplete.call(this,t);break}l.push(d),o+=d.length,a>0?r&&r.onProgress&&r.onProgress.call(this,o,a,t):h.push(d.length)}if(h.length>0)for(let f=0;f<l.length;f++)r&&r.onProgress&&r.onProgress.call(this,h[f],o,t),h[f]==o&&r&&r.onComplete&&r.onComplete.call(this,t);let u=new Uint8Array(o),c=0;for(let f of l)u.set(f,c),c+=f.length;return u})}}var at=(n=>(n[n.TEXT=0]="TEXT",n[n.BIN=1]="BIN",n[n.JSON=2]="JSON",n))(at||{});class Rt extends Yi{load(t,e,r,i){return V(this,null,function*(){switch(e.format){case at.BIN:return new Promise((a,o)=>V(this,null,function*(){this.loadBinData(t,r).then(l=>V(this,null,function*(){let h=new e;if(h.userData=i,h.baseUrl=this.baseUrl,h.initUrl=t,yield h.parseBuffer(l),h.verification())a(h);else throw new Error("parser error")})).catch(l=>{o(l)})}));case at.JSON:return new Promise((a,o)=>{this.loadJson(t,r).then(l=>V(this,null,function*(){let h=new e;h.userData=i,h.baseUrl=this.baseUrl,h.initUrl=t,h.loaderFunctions=r,yield h.parseJson(l),a(h)})).catch(l=>{o(l)})});case at.TEXT:return new Promise((a,o)=>{this.loadTxt(t,r).then(l=>V(this,null,function*(){let h=new e;h.userData=i,h.baseUrl=this.baseUrl,h.initUrl=t,h.loaderFunctions=r,l.data?(yield h.parseString(l.data),a(h)):o("text load is empty!")})).catch(l=>{o(l)})})}})}}class Et{constructor(){s(this,"baseUrl");s(this,"initUrl");s(this,"loaderFunctions");s(this,"userData");s(this,"data")}parseString(t){}parseJson(t){}parseBuffer(t){}parseTexture(t){throw this.parserError("Method not implemented.",-1)}parse(t){}verification(t){throw this.parserError("Method not implemented.",-1)}parserError(t,e){console.error(`error id:${e} ${t}`)}}s(Et,"format",at.BIN);class Ao{constructor(){s(this,"asset");s(this,"accessors");s(this,"buffers");s(this,"bufferViews");s(this,"materials");s(this,"meshes");s(this,"nodes");s(this,"scene",0);s(this,"scenes");s(this,"textures");s(this,"cameras");s(this,"skins");s(this,"resources");s(this,"images");s(this,"samplers");s(this,"animations");s(this,"extensions")}}class dA{constructor(){s(this,"nodes")}}class gA{constructor(){s(this,"name");s(this,"type");s(this,"color");s(this,"intensity");s(this,"range");s(this,"spot");s(this,"isParsed")}}class pA{constructor(){s(this,"name");s(this,"rotation");s(this,"scale");s(this,"translation");s(this,"children");s(this,"matrix");s(this,"mesh",-1);s(this,"isParsed");s(this,"dnode");s(this,"camera");s(this,"skin");s(this,"nodeId");s(this,"primitives");s(this,"extensions");s(this,"light")}}class mA{constructor(){s(this,"attributes");s(this,"indices");s(this,"material");s(this,"mode");s(this,"name");s(this,"targets");s(this,"extensions");s(this,"morphTargetsRelative")}}class AA{constructor(){s(this,"name");s(this,"primitives");s(this,"isParsed");s(this,"dprimitives");s(this,"weights");s(this,"extras")}}class vA{constructor(){s(this,"bufferView");s(this,"componentType");s(this,"count");s(this,"type");s(this,"max");s(this,"min");s(this,"isParsed");s(this,"daccessor");s(this,"normalized");s(this,"sparse");s(this,"byteOffset");s(this,"computeResult")}}const lf=window.SharedArrayBuffer?function(n){return n&&n.buffer&&(n.buffer instanceof ArrayBuffer||n.buffer instanceof window.SharedArrayBuffer)}:function(n){return n&&n.buffer&&n.buffer instanceof ArrayBuffer},vo=5120,vs=5121,xo=5122,Co=5123,_o=5124,yo=5125,So=5126,hf=32819,uf=32820,cf=33635,ff=5131,df=33640,gf=35899,pf=35902,mf=36269,Af=34042,Vn={};{const n=Vn;n[vo]=Int8Array,n[vs]=Uint8Array,n[xo]=Int16Array,n[Co]=Uint16Array,n[_o]=Int32Array,n[yo]=Uint32Array,n[So]=Float32Array,n[hf]=Uint16Array,n[uf]=Uint16Array,n[cf]=Uint16Array,n[ff]=Uint16Array,n[df]=Uint32Array,n[gf]=Uint32Array,n[pf]=Uint32Array,n[mf]=Uint32Array,n[Af]=Uint32Array}function xA(n){switch(n){case Int8Array:return vo;case Uint8Array:return vs;case Uint8ClampedArray:return vs;case Int16Array:return xo;case Uint16Array:return Co;case Int32Array:return _o;case Uint32Array:return yo;case Float32Array:return So;default:throw new Error("unsupported typed array type")}}function CA(n){if(n instanceof Int8Array)return vo;if(n instanceof Uint8Array||n instanceof Uint8ClampedArray)return vs;if(n instanceof Int16Array)return xo;if(n instanceof Uint16Array)return Co;if(n instanceof Int32Array)return _o;if(n instanceof Uint32Array)return yo;if(n instanceof Float32Array)return So;throw new Error("unsupported typed array type")}function Yn(n){const t=Vn[n];if(!t)throw new Error("unkonw gl type");return t}function _A(n,t=Float32Array){return lf(n)?n:new t(n)}class xs{static apply(t,e){return V(this,null,function*(){if(!e.extensions)return;const r=e.extensions.KHR_draco_mesh_compression;if(!r)return;let i=this._workers.get(t.gltf);i||(i=new Worker(yield this.initDecoder()),this._workers.set(t.gltf,i)),i.postMessage({type:"init",decoderConfig:{}});let a=t.parseBufferView(r.bufferView);if(!a.result){let o=yield new Promise((l,h)=>{i.onmessage=u=>{const c=u.data;c.type=="decode"?l(c.result):c.type=="error"&&h(c.error)},i.postMessage({type:"decoder",buffer:a,attributes:r.attributes},[a])});a.result=o}return a.result})}static unload(t){let e=this._workers.get(t);e&&(e.terminate(),this._workers.delete(t))}static initDecoder(){return V(this,null,function*(){if(!this._workerCode){let t=yield new Rt().loadTxt("https://cdn.orillusion.com/draco_decoder_gltf.js");const e=new Blob([t.data,"",`(${vf})()`],{type:"application/javascript"});this._workerCode=URL.createObjectURL(e)}return this._workerCode})}}s(xs,"_workerCode"),s(xs,"_workers",new Map);function vf(){let n,t;onmessage=e=>{const r=e.data;switch(r.type){case"init":n=r.decoderConfig,t=new Promise((o,l)=>{n.onModuleLoaded=h=>{o({draco:h})},DracoDecoderModule(n)});break;case"decoder":const i=r.buffer,a=r.attributes;t.then(o=>{const l=o.draco;let h=new l.Decoder,u=new l.DecoderBuffer;u.Init(new Int8Array(i),i.byteLength);let c,f;try{const d=h.GetEncodedGeometryType(u);d==l.TRIANGULAR_MESH?(f=new l.Mesh,c=h.DecodeBufferToMesh(u,f)):self.postMessage(new Error("INVALID_GEOMETRY_TYPE:"+d)),c.ok()||self.postMessage(new Error("DracoDecode:"+c.error_msg()));let p={};for(const A in a){let x=h.GetAttributeByUniqueId(f,a[A]);const C=x.num_components(),v=f.num_points()*C,y=v*Float32Array.BYTES_PER_ELEMENT,b=l.DT_FLOAT32,B=l._malloc(y);h.GetAttributeDataArrayForAllPoints(f,x,b,y,B);const I=new Float32Array(l.HEAPF32.buffer,B,v).slice();l._free(B),p[A]={data:I,numComponents:C,normalize:!1}}{const A=f.num_faces()*3,x=A*4,C=l._malloc(x);h.GetTrianglesUInt32Array(f,x,C);const v=new Uint32Array(l.HEAPF32.buffer,C,A).slice();l._free(C),p.indices={data:v,numComponents:1,normalize:!1}}self.postMessage({type:"decode",result:p})}catch(d){self.postMessage({type:"error",error:d.message})}finally{l.destroy(f),l.destroy(h),l.destroy(u)}});break}}}class xf{constructor(t){s(this,"gltf");this.gltf=t}parse(t){const e=this.gltf.cameras[t];if(!e)return this.errorMiss("camera",t);if(e.isParsed)return e.dcamera;e.isParsed=!0,e.dcamera=!1;const{name:r,type:i,perspective:a,orthographic:o}=e;if(i==="perspective"&&a){const{aspectRatio:l,yfov:h,zfar:u,znear:c}=a;e.dcamera=Object.assign({},{name:r,type:i,yfov:h,znear:c,aspectRatio:l,zfar:u})}else if(i==="orthographic"&&o){const{xmag:l,ymag:h,zfar:u,znear:c}=o;e.dcamera=Object.assign({},{name:r,type:i,xmag:l,ymag:h,zfar:u,znear:c})}return e.dcamera}errorMiss(t,e){throw new Error(t+e)}}const Zi=class Zi extends Et{constructor(){super(...arguments);s(this,"_gltf")}parseJson(e){return V(this,null,function*(){this._gltf=new Ao,this._gltf=Rr(Rr({},this._gltf),e),this._gltf.resources={},yield Promise.all([this.load_gltf_bin(),this.load_gltf_textures()]);let r=new wo,i=yield r.parse(this.initUrl,this._gltf,this._gltf.scene);return r.destroy(),r=null,i?(this.data=i.rootNode,i.rootNode):(this._gltf=null,null)})}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}static getMeshNameCounter(){return function(){return`GLTF_NO_NAME_PRIMITIVE_${Zi._counter++}`}}static getModelNameCounter(){let e=0;return function(){return`GLTF_NO_NAME_MESH_${e++}`}}static getTexCoordDefine(e){return`UV_NUM ${e}`}static getVertexColorDefine(e){return`HAS_VERTEXCOLOR ${e}`}static getBaseColorTextureDefine(){return"HAS_BASECOLORMAP"}static getMetalRoughnessDefine(){return"HAS_METALROUGHNESSMAP"}static getNormalMapDefine(){return"HAS_NORMALMAP"}static getEmissiveMapDefine(){return"HAS_EMISSIVEMAP"}static getOcclusionMapDefine(){return"HAS_OCCLUSIONMAP"}static getMorphTargetsDefine(e){return`MORPH_TARGET_NUM ${e}`}static getMorphtargetPositionDefine(){return"HAS_MORPH_POSITION"}static getMorphtargetNormalDefine(){return"HAS_MORPH_NORMAL"}static getMorphtargetTangentDefine(){return"HAS_MORPH_TANGENT"}static getJointsNumDefine(e){return`JOINTS_NUM ${e}`}static getJointVec8Define(){return"JOINT_VEC8"}static getHasNormalDefine(){return"HAS_NORMAL"}static getHasTangentDefine(){return"HAS_TANGENT"}static getHasNormalMapDefine(){return"HAS_NORMAL_MAP"}static getAlphaMaskDefine(){return"ALPHA_MASK"}static getAlphaBlendDefine(){return"ALPHA_BLEND"}load_gltf_bin(){return V(this,null,function*(){var e;if(this._gltf.buffers&&this._gltf.buffers.length>0){let r=[];for(let i=0;i<this._gltf.buffers.length;i++){const a=this._gltf.buffers[i];if(a.uri.substring(0,5)!=="data:"){let o=Tt.parseUrl(this.baseUrl,a.uri);(e=this.loaderFunctions)!=null&&e.onUrl&&(o=yield this.loaderFunctions.onUrl(o));let l=new Rt().loadBinData(o,this.loaderFunctions).then(h=>{this._gltf.resources[a.uri]=h});r.push(l)}}yield Promise.all(r)}})}load_gltf_textures(){return V(this,null,function*(){var e;if(this._gltf,this._gltf.images){let r=[];for(let i=0;i<this._gltf.images.length;i++){const a=this._gltf.images[i];if(a.uri){let o=Tt.parseUrl(this.baseUrl,a.uri);(e=this.loaderFunctions)!=null&&e.onUrl&&(o=yield this.loaderFunctions.onUrl(o));let l=new Rt().loadAsyncBitmapTexture(o,this.loaderFunctions).then(h=>{h.name=Tt.getURLName(a.uri),this._gltf.resources[h.name]=h});r.push(l)}}yield Promise.all(r)}})}};s(Zi,"format",at.JSON),s(Zi,"_counter",0),s(Zi,"defaultMaterial",{name:"GLTF_DEFAULT_MATERIAL",alphaCutoff:.33,alphaMode:"MASK",pbrMetallicRoughness:{name:"GLTF_DEFAULT_MATERIAL",defines:[],doubleSided:!1,baseColorFactor:[1,1,1,1],metallicFactor:1,roughnessFactor:1,emissiveFactor:[0,0,0]}});let Bt=Zi;class Cf{constructor(t){s(this,"gltf");s(this,"subParser");this.gltf=t.gltf,this.subParser=t}parse(t){return V(this,null,function*(){const e=this.gltf.meshes[t];if(!e)return this.errorMiss("mesh",t);if(e.isParsed)return e.dprimitives;const r=e.primitives,i=e.extras,a=[];for(let o=0;o<r.length;o++){const l=r[o],{attributes:h,indices:u,material:c,mode:f,name:d,targets:p,morphTargetsRelative:A,extensions:x}=l;let C=e.name;for(let D in h)C+=D;C+=`indices:${u}`,C+=`material:${c}`;const v={attribArrays:{indices:[]},weights:[],defines:[],material:null,drawMode:null,meshName:null,modelName:null,morphTargetsRelative:!1,targetNames:i?i.targetNames:null};let y=!1,b=0,B=!1,I;x&&x.KHR_draco_mesh_compression&&(I=yield xs.apply(this.subParser,l));for(const D in h){const L=I?I[D]:this.parseAccessor(h[D]);if(L){let M;switch(D){case"POSITION":M=O.position;break;case"NORMAL":M=O.normal,y=!0;break;case"TEXCOORD_0":M=O.uv,b++;break;case"JOINTS_0":M=O.joints0;break;case"JOINTS_1":M=O.joints1,B=!0;break;case"WEIGHTS_0":M=O.weights0;break;case"WEIGHTS_1":M=O.weights1;break;default:M=D}v.attribArrays[M]=L}}if(y&&v.defines.push(Bt.getHasNormalDefine()),b&&v.defines.push(Bt.getTexCoordDefine(b)),B&&v.defines.push(Bt.getJointVec8Define()),u!==void 0){const D=I?I.indices:this.parseAccessor(u);D&&(v.attribArrays.indices=D)}const w=yield this.parseMaterial(c);if(w&&(v.material=w,v.defines=v.defines.concat(w.defines)),v.drawMode=f===void 0?4:f,v.meshName=()=>C,v.modelName=e.name||Bt.getModelNameCounter(),p){v.defines.push(Bt.getMorphTargetsDefine(p.length)),v.morphTargetsRelative=!0;let D=!1,L=!1,M=!1;for(let G=0;G<p.length;G++){const N=p[G];Object.keys(N).forEach(q=>{const ie=this.parseAccessor(N[q]);if(ie){let ue;switch(q){case"POSITION":ue=Ce.MORPH_POSITION_PREFIX+G,D=!0;break;case"NORMAL":ue=Ce.MORPH_NORMAL_PREFIX+G,L=!0;break;case"TANGENT":ue=Ce.MORPH_TANGENT_PREFIX+G,M=!0;break;default:ue=!1}ue?v.attribArrays[ue]=ie:console.error(`glTF has unsupported morph target attribute ${q}`)}})}D&&v.defines.push(Bt.getMorphtargetPositionDefine()),L&&v.defines.push(Bt.getMorphtargetNormalDefine()),M&&v.defines.push(Bt.getMorphtargetTangentDefine()),v.weights=e.weights||new Array(p.length).fill(0)}a.push(v)}return e.dprimitives=a,e.isParsed=!0,e.dprimitives})}parseAccessor(t){return this.subParser.parseAccessor(t)}parseMaterial(t){return this.subParser.parseMaterial(t)}errorMiss(t,e){throw new Error(t+e)}}class _f{constructor(t){s(this,"gltf");s(this,"subParser");this.gltf=t.gltf,this.subParser=t}parse(t){return V(this,null,function*(){let e;if(t==null?e=Bt.defaultMaterial:e=this.gltf.materials[t],!e)return this.errorMiss("material",t);if(e.isParsed)return e.dmaterial;let{name:r,pbrMetallicRoughness:i,normalTexture:a,occlusionTexture:o,emissiveTexture:l,emissiveFactor:h,alphaMode:u,alphaCutoff:c,doubleSided:f,extensions:d}=e;const p={name:r,defines:[],doubleSided:!!f,baseColorFactor:[1,1,1,1],emissiveFactor:null,alphaCutoff:0,enableBlend:!1,baseColorTexture:null,metallicRoughnessTexture:null,normalTexture:null,occlusionTexture:null,emissiveTexture:null,extensions:null,baseMapOffsetSize:null,normalMapOffsetSize:null,emissiveMapOffsetSize:null,roughnessMapOffsetSize:null,metallicMapOffsetSize:null,aoMapOffsetSize:null,metallicFactor:0,roughnessFactor:1};if(i){const{baseColorFactor:A,metallicFactor:x,roughnessFactor:C,baseColorTexture:v,metallicRoughnessTexture:y}=i;if(Object.assign(p,{baseColorFactor:A||[1,1,1,1],metallicFactor:x===void 0?1:x,roughnessFactor:C===void 0?.5:C}),v){let b=v.extensions;if(b){let I=b.KHR_texture_transform;if(I){let w=new ae(I.offset?I.offset[0]:0,I.offset?I.offset[1]:0,I.scale?I.scale[0]:1,I.scale?I.scale[1]:1);p.baseMapOffsetSize=w}}const B=yield this.parseTexture(v.index);B?p.baseColorTexture=B:p.baseColorTexture=m.res.redTexture}if(a){let b=a.extensions;if(b){let I=b.KHR_texture_transform;if(I){let w=new ae(I.offset?I.offset[0]:0,I.offset?I.offset[1]:0,I.scale?I.scale[0]:1,I.scale?I.scale[1]:1);p.normalMapOffsetSize=w}}const B=yield this.parseTexture(a.index);B?p.normalTexture=B:p.normalTexture=m.res.normalTexture}if(y){let b=y.extensions;if(b){let I=b.KHR_texture_transform;if(I){let w=new ae(I.offset?I.offset[0]:0,I.offset?I.offset[1]:0,I.scale?I.scale[0]:1,I.scale?I.scale[1]:1);p.roughnessMapOffsetSize=w}}const B=yield this.parseTexture(y.index);B?p.metallicRoughnessTexture=B:p.metallicRoughnessTexture=m.res.blackTexture}}else Object.assign(p,{baseColorFactor:[1,1,1,1],metallicFactor:0,roughnessFactor:.5});if(p.baseColorFactor&&p.baseColorFactor[3]<1&&(u=u==="MASK"?"MASK":"BLEND"),u&&u!=="OPAQUE"&&(u==="MASK"&&(p.defines.push(Bt.getAlphaMaskDefine()),p.alphaCutoff=c===void 0?.5:c),u==="BLEND"&&(p.defines.push(Bt.getAlphaBlendDefine()),p.enableBlend=!0)),a){const A=yield this.parseTexture(a.index);A?p.normalTexture=A:p.normalTexture=m.res.normalTexture}if(o){const A=yield this.parseTexture(o.index);A&&(p.occlusionTexture=A)}if(h&&(p.emissiveFactor=h),l){const A=yield this.parseTexture(l.index);A?p.emissiveTexture=A:p.emissiveTexture=m.res.blackTexture}return d&&(p.extensions=d),e.isParsed=!0,e.dmaterial=p,p})}parseTexture(t){return V(this,null,function*(){return this.subParser.parseTexture(t)})}errorMiss(t,e){throw new Error(t+e)}}class yf{constructor(t){s(this,"gltf");s(this,"subParser");this.gltf=t.gltf,this.subParser=t}parse(t){const e=this.gltf.skins[t];if(!e)return this.errorMiss("skin",t);if(e.isParsed)return e.dskin;const{name:r,joints:i,inverseBindMatrices:a,skeleton:o}=e;if(!i)return this.errorMiss("skin.joints",t);e.isParsed=!0,e.dskin=!1;let l={name:r,skeleton:null,inverseBindMatrices:null,joints:i,defines:[Bt.getJointsNumDefine(i.length)]};if(o)l.skeleton=o;else{var h=-1;for(let u=0;u<this.gltf.nodes.length;u++)if(this.gltf.nodes[u].name=="root"){h=u;break}if(h==-1){let u=this.gltf.scenes[this.gltf.scene];h=u.nodes[u.nodes.length-1]}l.skeleton=h}if(l.inverseBindMatrices=Ce.IDENTITY_INVERSE_BIND_MATRICES,a!==void 0){const u=this.parseAccessor(a);if(u){const c=u.data,f=[];for(let d=0;d<c.length;d+=16)f.push(c.slice(d,d+16));l.inverseBindMatrices=f}else l=null}return e.dskin=l,e.dskin}parseAccessor(t){return this.subParser.parseAccessor(t)}errorMiss(t,e){throw new Error(t+e)}}class Sf{constructor(t=""){s(this,"name","");s(this,"index",0);s(this,"instanceID","");s(this,"parent",null);s(this,"scale",new g);s(this,"rotation",new Z);s(this,"translation",new g);this.name=t}}class Hn{constructor(t,e=!1){s(this,"index");s(this,"worldMatrix");this.index=t,this.worldMatrix=new Q(!e)}}class Cs{constructor(t,e=!1){s(this,"time");s(this,"_skeleton");s(this,"_jointsPose");s(this,"mJointMatrixIndexTable");this._skeleton=t,this._jointsPose=new Array(t.numJoint),this.mJointMatrixIndexTable=new Array(t.numJoint);for(let r=0;r<t.numJoint;r++){let i=new Hn(r,e);this._jointsPose[r]=i,this.mJointMatrixIndexTable[r]=i.worldMatrix.index}}buildSkeletonPose(t){let e=new g,r=new Z,i=new g,a=new Array(this._skeleton.numJoint);this.time=t[11]>0?t[11]:t[24];for(let o=0;o<this._skeleton.numJoint;o++){let l=12*o*4,h=new Float32Array(t.buffer,t.byteOffset+l,12),u=new Q;e.set(h[0],h[1],h[2]),r.set(h[4],h[5],h[6],h[7]),i.set(h[8],h[9],h[10]),Zs(r.getEulerAngles(),i,e,u),a[o]=u;let c=new Hn(o);const f=this._skeleton.getJointParentIndex(o);if(f<0)c.worldMatrix.copyFrom(u);else{let d=this._jointsPose[f];wu(d.worldMatrix,u,c.worldMatrix)}this._jointsPose[o]=c}}get numJoint(){return this._skeleton.numJoint}get joints(){return this._jointsPose}get jointMatrixIndexTable(){return this.mJointMatrixIndexTable}lerp(t,e,r){if(t&&e)for(let i=0;i<this._jointsPose.length;i++){let a=t._jointsPose[i],o=e._jointsPose[i];this._jointsPose[i].worldMatrix.lerp(a.worldMatrix,o.worldMatrix,r)}else for(let i=0;i<this._jointsPose.length;i++){let a=t._jointsPose[i];this._jointsPose[i].worldMatrix.copyFrom(a.worldMatrix)}}copyFrom(t){for(let e=0;e<this._jointsPose.length;e++)this._jointsPose[e].worldMatrix.copyFrom(t._jointsPose[e].worldMatrix)}reset(){for(let t=0;t<this._jointsPose.length;t++)this._jointsPose[t].worldMatrix.identity()}}class If extends lt{constructor(e,r){super();s(this,"skeletonAnimation");this.type=e,this.time=r}}class Io{constructor(t,e,r,i){s(this,"name","");s(this,"_skeleton");s(this,"_skeletonPoses");s(this,"_animationClipData");s(this,"_events");if(this.name=t,this._skeleton=e,this._animationClipData=i,r>0&&i){this._skeletonPoses=new Array(r);let a=12*e.numJoint;for(let o=0;o<r;o++){let l=a*o*4,h=new Float32Array(i.buffer,l,a),u=new Cs(e);u.buildSkeletonPose(h),this._skeletonPoses[o]=u}}}get totalTime(){return this._skeletonPoses[this._skeletonPoses.length-1].time}get frameRate(){return this.totalTime/this._skeletonPoses.length}get skeleton(){return this._skeleton}get numFrame(){return this._skeletonPoses.length-1}get animationClipData(){return this._animationClipData}getSkeletonPose(t){return this._skeletonPoses[t]}getLerpSkeletonPose(t,e,r,i){let a=this.getSkeletonPose(t),o=this.getSkeletonPose(e);return i.lerp(a,o,r),i}createSubClip(t,e,r){var i=new Io(t,this._skeleton,0,null);const a=Math.max(Math.floor(e/this.frameRate),0),o=Math.min(Math.floor(r/this.frameRate),this._skeletonPoses.length-1);i._skeletonPoses=this._skeletonPoses.slice(a,o);const l=12*this._skeleton.numJoint*4;return this._animationClipData=new Float32Array(this._animationClipData,a*l,(o-a)*l),i}addEvent(t,e){this._events||(this._events=new Array),this._events.push(new If(t,e))}removeEvent(t){this._events&&(this._events=this._events.filter(e=>e.type!=t))}getEvents(){return this._events}}class Xn{constructor(t){s(this,"gltf");s(this,"subParser");this.gltf=t.gltf,this.subParser=t}parse(t){let e=new Ul;return e.name="Id:"+t,e.count=0,e.boneData=[],e.boneMap=new Map,this.buildSkeleton(e,void 0,t),e}parseSkeletonAnimation(t,e){let r=new Xl;r.clipName=e.name,r.useSkeletonPos=!1,r.useSkeletonScale=!1;for(let i of e.channels){let a=e.samplers[i.sampler];const o=this.subParser.parseAccessor(a.input),l=this.subParser.parseAccessor(a.output);let h=i.target.node,u=i.target.path,c=this.gltf.nodes[h];if(!c||!t.boneMap.has(c.name))continue;let f=t.boneMap.get(c.name);switch(u){case"scale":{let d=new bi(l.numComponents);d.path="",d.attribute="",d.propertys=d.attribute.split("."),d.preInfinity=0,d.postInfinity=0,d.rotationOrder=0,r.useSkeletonScale=!0,r.scaleCurves.set(f.bonePath,d);for(let p=0;p<o.data.length;p++){const A=o.data[p],x=p*l.numComponents;let C=new Fs(0);C.time=A;const v=new g().set(l.data[x+0],l.data[x+1],l.data[x+2]);C.split(Y.vector3,v,"value"),d.addKeyFrame(C)}}break;case"rotation":{let d=new bi(l.numComponents);d.path="",d.attribute="",d.propertys=d.attribute.split("."),d.preInfinity=0,d.postInfinity=0,d.rotationOrder=0,r.rotationCurves.set(f.bonePath,d);for(let p=0;p<o.data.length;p++){const A=o.data[p],x=p*l.numComponents;let C=new Fs(0);C.time=A;const v=new Z().set(l.data[x+0],l.data[x+1],l.data[x+2],l.data[x+3]);C.split(Y.quaternion,v,"value"),d.addKeyFrame(C)}}break;case"translation":{let d=new bi(l.numComponents);d.path="",d.attribute="",d.propertys=d.attribute.split("."),d.preInfinity=0,d.postInfinity=0,d.rotationOrder=0,r.useSkeletonPos=!0,r.positionCurves.set(f.bonePath,d);for(let p=0;p<o.data.length;p++){const A=o.data[p],x=p*l.numComponents;let C=new Fs(0);C.time=A;const v=new g().set(l.data[x+0],l.data[x+1],l.data[x+2]);C.split(Y.vector3,v,"value"),d.addKeyFrame(C)}}break}}return r}parseSkeletonAnimationOld(t,e){let r=this.subParser.parseAccessor(e.samplers[0].input),i=r.data.length,a=r.data[1]-r.data[0];r.data[r.data.length-1];let o=12*t.numJoint,l=new Float32Array(o*i);for(var h=0;h<t.numJoint;h++)for(var u=0;u<i;u++){var c=o*u+12*h;l[c+0]=1,l[c+1]=1,l[c+2]=1,l[c+3]=1}for(let A of e.channels){let x=e.samplers[A.sampler];const C=this.subParser.parseAccessor(x.input),v=this.subParser.parseAccessor(x.output);let y=A.target.node,b=A.target.path,B=this.gltf.nodes[y];if(!B)continue;let I=t.getJointByName(B.name);if(I)switch(b){case"scale":if(i*v.numComponents==v.data.length)for(var u=0;u<i;u++){var f=u*v.numComponents,c=o*u+12*I.index;l[c+0]=v.data[f+0],l[c+1]=v.data[f+1],l[c+2]=v.data[f+2],l[c+3]=1}else if(C.data.length==2){let w=0;C.data[0];let D=C.data[1];var d=0*v.numComponents;g.HELP_0.set(v.data[d+0],v.data[d+1],v.data[d+2]);var p=1*v.numComponents;g.HELP_1.set(v.data[p+0],v.data[p+1],v.data[p+2]);for(var u=0;u<i;u++){let M=w/D;g.HELP_2.lerp(g.HELP_0,g.HELP_1,M);var c=o*u+12*I.index;l[c+0]=g.HELP_2.x,l[c+1]=g.HELP_2.y,l[c+2]=g.HELP_2.z,l[c+3]=1,w+=a}}else throw new Error("Unsupported animation sampler interpolation.");break;case"rotation":if(i*v.numComponents==v.data.length)for(var u=0;u<i;u++){var f=u*v.numComponents,c=o*u+12*I.index+4;l[c+0]=v.data[f+0],l[c+1]=v.data[f+1],l[c+2]=v.data[f+2],l[c+3]=v.data[f+3]}else if(C.data.length==2){let w=0;C.data[0];let D=C.data[1];var d=0*v.numComponents;g.HELP_0.set(v.data[d+0],v.data[d+1],v.data[d+2],v.data[d+3]);var p=1*v.numComponents;g.HELP_1.set(v.data[p+0],v.data[p+1],v.data[p+2],v.data[p+3]);for(var u=0;u<i;u++){let N=w/D;g.HELP_2.lerp(g.HELP_0,g.HELP_1,N);var c=o*u+12*I.index+4;l[c+0]=g.HELP_2.x,l[c+1]=g.HELP_2.y,l[c+2]=g.HELP_2.z,l[c+3]=g.HELP_2.w,w+=a}}else throw new Error("Unsupported animation sampler interpolation.");break;case"translation":if(i*v.numComponents==v.data.length)for(var u=0;u<i;u++){var f=u*v.numComponents,c=o*u+12*I.index+8;l[c+0]=v.data[f+0],l[c+1]=v.data[f+1],l[c+2]=v.data[f+2],l[c+3]=C.data[u*C.numComponents]}else if(C.data.length==2){let w=0;C.data[0];let D=C.data[1];var d=0*v.numComponents;g.HELP_0.set(v.data[d+0],v.data[d+1],v.data[d+2]);var p=1*v.numComponents;g.HELP_1.set(v.data[p+0],v.data[p+1],v.data[p+2]);for(var u=0;u<i;u++){let N=w/D;g.HELP_2.lerp(g.HELP_0,g.HELP_1,N);var c=o*u+12*I.index+8;l[c+0]=g.HELP_2.x,l[c+1]=g.HELP_2.y,l[c+2]=g.HELP_2.z,l[c+3]=w,w+=a}}else throw new Error("Unsupported animation sampler interpolation.");break}}return new Io(e.name,t,i,l)}buildSkeleton(t,e,r){let i=this.gltf.nodes[r];i.name||(i.name="Bone"+t.count);let a=new Rl;if(a.boneName=i.name,a.bonePath=e?e.bonePath+"/"+i.name:i.name,a.parentBoneName=e?e.boneName:"",a.boneID=t.count++,a.parentBoneID=e?e.boneID:-1,a.instanceID="",a.parentInstanceID="",a.s=new g(1,1,1),i.scale&&a.s.set(i.scale[0],i.scale[1],i.scale[2]),a.q=new Z,i.rotation&&a.q.set(i.rotation[0],i.rotation[1],i.rotation[2],i.rotation[3]),a.t=new g,i.translation&&a.t.set(i.translation[0],i.translation[1],i.translation[2]),t.boneData.push(a),t.boneMap.set(a.boneName,a),i.children)for(let o of i.children)this.buildSkeleton(t,a,o)}buildSkeletonOld(t,e,r,i=0){let a=this.gltf.nodes[r];a.name||(a.name="Node_"+r);let o=new Sf(a.name);if(o.parent=e,a.scale&&o.scale.set(a.scale[0],a.scale[1],a.scale[2]),a.rotation&&o.rotation.set(a.rotation[0],a.rotation[1],a.rotation[2],a.rotation[3]),a.translation&&o.translation.set(a.translation[0],a.translation[1],a.translation[2]),t.addJoint(o),a.children)for(let l of a.children)this.buildSkeletonOld(t,o,l,i+1)}}class bo{static add(t){this.list.indexOf(t)==-1&&this.list.push(t)}static remove(t){let e=this.list.indexOf(t);e!=-1&&this.list.splice(e,1)}}s(bo,"list",[]);class _s extends Qt{constructor(){super();s(this,"name");s(this,"size",1);s(this,"lightData");s(this,"dirFix",1);s(this,"bindOnChange");s(this,"needUpdateShadow",!0);s(this,"realTimeShadow",!0);s(this,"_castGI",!1);s(this,"_castShadow",!1);s(this,"_iesProfiles")}init(){this.transform.object3D.bound=new Oe(new g,new g),this.lightData=new ns,this.lightData.lightMatrixIndex=this.transform.worldMatrix.index}onChange(){this.bindOnChange&&this.bindOnChange(),this.transform.object3D.bound.setFromCenterAndSize(this.transform.worldPosition,new g(this.size,this.size,this.size)),this._castGI&&(X.instance.state.giLightingChange=!0),this._castShadow?(this.needUpdateShadow=!0,Kt.addShadowLight(this)):Kt.removeShadowLight(this),this.transform.view3D&&m.renderJobs&&m.renderJobs.get(this.transform.view3D).reflectionRenderer&&m.renderJobs.get(this.transform.view3D).reflectionRenderer.forceUpdate()}start(){this.transform.onPositionChange=()=>this.onPositionChange(),this.transform.onRotationChange=()=>this.onRotChange(),this.onPositionChange(),this.onRotChange()}onPositionChange(){this.lightData.lightPosition.copyFrom(this.transform.worldPosition),this.onChange()}onRotChange(){this.dirFix==1?this.lightData.direction.copyFrom(this.transform.forward):this.lightData.direction.copyFrom(this.transform.back),this.lightData.lightTangent.copyFrom(this.transform.up),this.onChange()}onScaleChange(){this.onChange()}onEnable(){this.onChange(),X.instance.addLight(this.transform.scene3D,this)}onDisable(){this.onChange(),X.instance.removeLight(this.transform.scene3D,this),Kt.removeShadowLight(this)}set iesProfiles(e){this._iesProfiles=e,this.lightData.iesIndex=e.index,ga.use=!0,this.onChange()}get iesProfile(){return this._iesProfiles}get r(){return this.lightData.lightColor.r}set r(e){this.lightData.lightColor.r=e,this.onChange()}get g(){return this.lightData.lightColor.g}set g(e){this.lightData.lightColor.g=e,this.onChange()}get b(){return this.lightData.lightColor.b}set b(e){this.lightData.lightColor.b=e,this.onChange()}get lightColor(){return this.lightData.lightColor}set lightColor(e){this.lightData.lightColor=e,this.onChange()}get color(){return this.lightData.lightColor}set color(e){this.lightData.lightColor=e,this.onChange()}get intensity(){return this.lightData.intensity}set intensity(e){this.lightData.intensity=e,this.onChange()}set castShadow(e){e!=this._castShadow&&(this._castShadow=e,this.onChange())}get castShadow(){return this._castShadow}get shadowIndex(){return this.lightData.castShadowIndex}get castGI(){return this._castGI}set castGI(e){e?bo.add(this):bo.remove(this),this._castGI=e,e&&this.onChange()}get direction(){return this.lightData.direction}destroy(e){this.bindOnChange=null,X.instance.removeLight(this.transform.scene3D,this),Kt.removeShadowLight(this),this.transform.eventDispatcher.removeEventListener(Cr.ROTATION_ONCHANGE,this.onRotChange,this),this.transform.eventDispatcher.removeEventListener(Cr.SCALE_ONCHANGE,this.onScaleChange,this),super.destroy(e)}}var bf=Object.defineProperty,wf=Object.getOwnPropertyDescriptor,Tf=(n,t,e,r)=>{for(var i=r>1?void 0:r?wf(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&bf(t,e,i),i};let Ca=class extends _s{constructor(){super();s(this,"shadowCamera")}init(){super.init(),this.object3D.name==""&&(this.object3D.name="DirectionLight_"+kt()),this.radius=Number.MAX_SAFE_INTEGER,this.lightData.lightType=tt.DirectionLight,this.lightData.linear=0,this.lightData.quadratic=.3}start(){super.start(),this.castGI=!0}get radius(){return this.lightData.range}set radius(t){this.lightData.range=t,this.onChange()}get indirect(){return this.lightData.quadratic}set indirect(t){this.lightData.quadratic=t,this.onChange()}debug(){}};Ca=Tf([or(Ca,"DirectLight")],Ca);var Ef=Object.defineProperty,Bf=Object.getOwnPropertyDescriptor,Df=(n,t,e,r)=>{for(var i=r>1?void 0:r?Bf(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Ef(t,e,i),i};let _a=class extends _s{constructor(){super()}init(){super.init(),this.lightData.lightType=tt.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+kt())}get range(){return this.lightData.range}set range(n){this.lightData.range=n,this.onChange()}get at(){return this.lightData.linear}set at(n){this.lightData.linear=n,this.onChange()}get radius(){return this.lightData.radius}set radius(n){this.lightData.radius=n,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(n){this.lightData.quadratic=n,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(n){}debug(){}debugDraw(n){}};_a=Df([or(_a,"PointLight")],_a);var Mf=Object.defineProperty,Pf=Object.getOwnPropertyDescriptor,Rf=(n,t,e,r)=>{for(var i=r>1?void 0:r?Pf(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Mf(t,e,i),i};let ys=class extends _s{constructor(){super()}init(){super.init(),this.lightData.lightType=tt.SpotLight,this.object3D.name==""&&(this.object3D.name="SpotLight"+kt())}get innerAngle(){return this.lightData.innerAngle/this.lightData.outerAngle*100}set innerAngle(n){this.lightData.innerAngle=se(n,0,100)/100*this.lightData.outerAngle,this.onChange()}get outerAngle(){return this.lightData.outerAngle*fa*2}set outerAngle(n){this.lightData.outerAngle=se(n,1,179)*ft*.5,this.onChange()}get radius(){return this.lightData.radius}set radius(n){this.lightData.radius=n,this.onChange()}get range(){return this.lightData.range}set range(n){this.lightData.range=n,this.onChange()}get at(){return this.lightData.linear}set at(n){this.lightData.linear=n,this.onChange()}start(){super.start(),this.lightData.lightType=tt.SpotLight}onUpdate(){}onGraphic(n){}debug(){}debugDraw(n){}};ys=Rf([or(ys,"SpotLight")],ys);class Uf{static apply(t,e,r){let i=e.extensions;if(i&&i.KHR_materials_clearcoat){r.shader.getDefaultColorShader().setDefine("USE_CLEARCOAT",!0);let a=i.KHR_materials_clearcoat;"clearcoatFactor"in a&&(e.clearcoatFactor=a.clearcoatFactor,r.clearcoatFactor=e.clearcoatFactor),"clearcoatRoughnessFactor"in a&&(e.clearcoatRoughnessFactor=a.clearcoatRoughnessFactor,r.clearcoatRoughnessFactor=e.clearcoatRoughnessFactor)}}}class Lf{static apply(t,e,r){let i=e.extensions;i&&i.KHR_materials_emissive_strength?(r.emissiveIntensity=i.KHR_materials_emissive_strength.emissiveStrength,r.emissiveMap==m.res.blackTexture&&(r.emissiveMap=m.res.whiteTexture)):r.emissiveIntensity=1}}class Of{static apply(t,e,r){let i=e.extensions;i&&i.KHR_materials_unlit?r.supportLight=!0:r.supportLight=!1}}class Nf{constructor(t){s(this,"gltf");s(this,"subParser");s(this,"_testCount",8);s(this,"_hasCastShadow",!1);this.gltf=t.gltf,this.subParser=t}convertNodeToObject3D(t,e){return V(this,null,function*(){const r=new ee;if(r.name=t.name,r[Ce.GLTF_NODE_INDEX_PROPERTY]=t.nodeId,t.nodeObj=r,t.matrix&&(t.translation=[0,0,0],t.rotation=[0,0,0,1],t.scale=[1,1,1]),t.translation&&(r.transform.x=t.translation[0],r.transform.y=t.translation[1],r.transform.z=t.translation[2]),t.rotation){let i=new Z;i.setFromArray(t.rotation),r.transform.localRotQuat=i}return t.scale&&(r.transform.scaleX=t.scale[0],r.transform.scaleY=t.scale[1],r.transform.scaleZ=t.scale[2]),e.addChild(r),t.light&&this.convertLight(t,r),t.primitives&&this.convertprimitives(t,r),t.skeleton&&this.convertSkeletonAnim(r,t.skeleton),r})}convertSkeletonAnim(t,e){let r=this.subParser.parseSkeleton(e.skeleton);m.res.addObj(r.name,r);let i=[];for(let o=0;o<this.gltf.animations.length;o++){let l=this.gltf.animations[o];l.name||(l.name=o.toString());let h=this.subParser.parseSkeletonAnimation(r,l);i.push(h)}let a=t.addComponent(ti);a.avatar=r.name,a.clips=i}convertLight(t,e){switch(t.light.type){case"directional":let r=e.addComponent(Ca);e.name=t.light.name,r.intensity=t.light.intensity*.1,r.radius=Number.MAX_SAFE_INTEGER,r.dirFix=-1,this._hasCastShadow||(this._hasCastShadow=!0,r.castShadow=this._hasCastShadow),r.lightColor=t.light.color?new K(t.light.color[0],t.light.color[1],t.light.color[2]):new K(1,1,1,1),r.debug();break;case"point":if(this._testCount>0){let a=e.addComponent(_a);a.name=t.light.name,a.intensity=t.light.intensity?t.light.intensity*8*2:1,a.radius=8,a.at=2,a.range=t.light.range?t.light.range:8,a.lightColor=t.light.color?new K(t.light.color[0],t.light.color[1],t.light.color[2]):new K(1,1,1,1)}this._testCount--;break;case"spot":let i=e.addComponent(ys);i.name=t.light.name,i.intensity=t.light.intensity*5,i.radius=1,i.dirFix=-1,i.at=2,i.range=t.light.range?t.light.range:8,i.outerAngle=t.light.spot.outerConeAngle*fa,i.lightColor=t.light.color?new K(t.light.color[0],t.light.color[1],t.light.color[2]):new K(1,1,1,1);break}}convertprimitives(t,e){var r;for(let i=0;i<t.primitives.length;i++){const a=t.primitives[i];a.modelName;let o=a.material;o.name==null&&(o.name=kt());let l,h=`matkey_${o.name}`;if(o&&this.gltf.resources[h])l=this.gltf.resources[h];else{let p=l=new Ir;this.gltf.resources[h]=p,p.name=o.name;let A=o;if(A){const{baseColorTexture:x,baseColorFactor:C,metallicFactor:v,roughnessFactor:y,doubleSided:b,metallicRoughnessTexture:B,normalTexture:I,occlusionTexture:w,emissiveTexture:D,emissiveFactor:L,enableBlend:M,alphaCutoff:G}=A;let N=p=this.applyMaterialExtensions(A,p);if("enableBlend"in A&&(A.enableBlend?((r=A.defines)!=null&&r.includes("ALPHA_BLEND")?N.blendMode=oe.ALPHA:N.blendMode=oe.NORMAL,N.castShadow=!1):N.blendMode=oe.NONE),"alphaCutoff"in A&&G>0&&G<1&&(N.setUniformFloat("alphaCutoff",G),N.blendMode=oe.NORMAL,N.transparent=!0),A.baseMapOffsetSize&&N.setUniformVector4("baseMapOffsetSize",A.baseMapOffsetSize),A.normalMapOffsetSize&&N.setUniformVector4("normalMapOffsetSize",A.normalMapOffsetSize),A.emissiveMapOffsetSize&&N.setUniformVector4("emissiveMapOffsetSize",A.emissiveMapOffsetSize),A.roughnessMapOffsetSize&&N.setUniformVector4("roughnessMapOffsetSize",A.roughnessMapOffsetSize),A.metallicMapOffsetSize&&N.setUniformVector4("metallicMapOffsetSize",A.metallicMapOffsetSize),A.aoMapOffsetSize&&N.setUniformVector4("aoMapOffsetSize",A.aoMapOffsetSize),N.setUniformColor("baseColor",new K(C[0],C[1],C[2],C[3])),N.setUniformFloat("roughness",y),N.setUniformFloat("metallic",v),N.setUniformFloat("ao",1),N.doubleSide=b,x&&N.setTexture("baseMap",x),I&&N.setTexture("normalMap",I),B&&N.setTexture("maskMap",B),D&&N.setTexture("emissiveMap",D),L&&(L[0]>0||L[1]>0||L[2]>0)){N.shader.getTexture("emissiveMap")||N.shader.setTexture("emissiveMap",m.res.whiteTexture),N.shader.setDefine("USE_EMISSIVEMAP",!0),N.setUniformColor("emissiveColor",new K(L[0],L[1],L[2],L[3])),N.blendMode!=oe.NONE&&(N.blendMode=oe.ADD);let q=l.getUniformFloat("emissiveIntensity");(!q||q<=0)&&l.setUniformFloat("emissiveIntensity",1)}}}const{attribArrays:u,modelName:c,drawMode:f}=a;let d;if(!u.indices.data){let p=[],A=u.position.data.length/3/3;for(let x=0;x<A;x++){let C=x*3;p.push(C+2),p.push(C+0),p.push(C+1)}u.indices={data:new Uint8Array(p),normalize:!1,numComponents:1}}if(!u.normal){let p=[],A=u.position.data.length/3;for(let x=0;x<A;x++)p.push(0),p.push(0),p.push(0);u.normal={data:new Float32Array(p),normalize:!1,numComponents:3}}if(u.indices.data&&u.indices.data.length>3){let p=a.meshName();this.gltf.resources[p]&&(d=this.gltf.resources[p]);const A=new ee;if(A.name=c+i,this.gltf.animations&&u[O.joints0]!=null){d||(d=this.createGeometryBase(c,u,a,t.skin)),this.gltf.resources[p]=d;let x=this.gltf.nodes[t.skin.skeleton];x.dnode&&x.dnode.nodeObj?this.convertSkeletonAnim(e,t.skin):x.dnode.skeleton=t.skin;let C=A.addComponent(yi);C.geometry=d,C.material=l}else{d||(d=this.createGeometryBase(c,u,a)),this.gltf.resources[p]=d,d.hasAttribute(O.joints0)&&d.vertexAttributeMap.delete(O.joints0);let x=A.addComponent($);x.castShadow=!0,x.castGI=!0,x.geometry=d,x.material=l}t.skin&&t.skin.defines,e.addChild(A)}}}createGeometryBase(t,e,r,i){"indices"in e&&(e.indices.data.length>65534?e.indices.data=new Uint32Array(e.indices.data):e.indices.data=new Uint16Array(e.indices.data));let a=new qt;if(a.name=t,"indices"in e&&(e.indices.data.length>65535?e.indices.data=new Uint32Array(e.indices.data):e.indices.data=new Uint16Array(e.indices.data)),r.morphTargetsRelative){let h=new kl,u=r.targetNames;if(u&&u.length>0){h.shapeNames=[],h.shapeIndexs=[];for(let c=0;c<u.length;c++)h.shapeNames.push(u[c]),h.shapeIndexs.push(c)}h.vertexCount=e.position.data.length/3,h.blendCount=h.shapeNames.length,h.blendShapePropertyDatas=[],h.blendShapeMap=new Map;for(let c=0;c<h.blendCount;c++){let f=new Fl;f.shapeName=h.shapeNames[c],f.shapeIndex=h.shapeIndexs[c],f.frameCount=1,f.blendPositionList=e[Ce.MORPH_POSITION_PREFIX+c].data,f.blendNormalList=e[Ce.MORPH_NORMAL_PREFIX+c].data,h.blendShapePropertyDatas.push(f),h.blendShapeMap.set(f.shapeName,f)}a.blendShapeData=h}a.morphTargetsRelative=r.morphTargetsRelative;let o=r.targetNames;if(o&&o.length>0){let h=a.morphTargetDictionary={};for(let u=0;u<o.length;u++)h[o[u]]=u}if(a.morphTargetDictionary){let h=e.position.data.length/3,u=new Float32Array(h);for(let c=0;c<h;c++)u[c]=c;e.vIndex={data:u,normalize:!1,numComponents:1}}for(const h in e){let u=e[h];a.setAttribute(h,u.data)}if(i){a.skinNames=new Array(i.joints.length);for(let h=0;h<i.joints.length;h++){const u=i.joints[h],c=this.gltf.nodes[u];a.skinNames[h]=c.name}a.bindPose=new Array(i.inverseBindMatrices.length);for(let h=0;h<i.inverseBindMatrices.length;h++){const u=i.inverseBindMatrices[h];let c=new Q;c.rawData.set(u),a.bindPose[h]=c}}let l=a.getAttribute(O.indices);return a.addSubGeometry({indexStart:0,indexCount:l.data.length,vertexStart:0,index:0,vertexCount:0,firstStart:0,topology:0}),a}applyMaterialExtensions(t,e){return t.extensions&&(Uf.apply(this.gltf,t,e),Of.apply(this.gltf,t,e),Lf.apply(this.gltf,t,e)),e}parseSkinJoints(t){let e=[];for(let r of t.joints){let i=this.gltf.nodes[r];e.push(i.name)}return e}}class wo{constructor(){s(this,"currentSceneName");s(this,"gltf");s(this,"initUrl");s(this,"_generator");s(this,"_version");s(this,"_BASE64_MARKER",";base64,");s(this,"_cameraParser",null);s(this,"_meshParser",null);s(this,"_materialParser",null);s(this,"_skinParser",null);s(this,"_skeletonParser",null);s(this,"_converter",null)}get version(){return this.version?this.version:this.gltf?this.gltf.asset?(this._version=this.gltf.asset.version,this.gltf.asset.minVersion&&(this._version+=`\r minVersion${this.gltf.asset.minVersion}`),this.version):this.errorMiss("asset"):(console.warn("glTF not loaded."),null)}parse(t,e,r){return V(this,null,function*(){this.gltf=e,this.initUrl=t;const{version:i,generator:a}=this.gltf.asset;if(this._generator=a,i!=="2.0")return console.error(`GLTFParser only support glTF 2.0 for now! Received glTF version: ${this.version}`),!1;const o={nodes:yield this.parseScene(r),animations:this.parseAnimations(),name:this.currentSceneName};return yield this.convertToNode(o)})}destroy(){xs.unload(this.gltf),this.gltf=null}parseScene(t){return V(this,null,function*(){const e=t||this.gltf.scene||0,r=this.gltf.scenes[e];if(typeof r>"u")return this.errorMiss("scene",e);this.currentSceneName=r.name||"GLTF_NO_NAME_SCENE";const i=[],a=r.nodes;for(let o=0;o<a.length;o++){const l=yield this.parseNode(a[o]);l&&i.push(l)}return i})}parseNode(t){return V(this,null,function*(){const e=this.gltf.nodes[t];if(!e)return this.errorMiss("node",t);if(e.isParsed)return e.dnode;const{name:r,matrix:i,translation:a,rotation:o,scale:l}=e,h={name:r,matrix:i,translation:a,rotation:o,scale:l,nodeId:t,camera:null,primitives:null,skin:null,children:null,light:null};if(e.camera!==void 0&&(h.camera=this.parseCamera(e.camera)),e.mesh!==void 0&&(h.primitives=yield this.parseMesh(e.mesh)),e.extensions!==void 0&&this.applyNodeExtensions(e,h),e.skin!==void 0){const u=this.parseSkin(e.skin);u&&(h.skin=u)}if(h.children=[],e.children)for(let u=0;u<e.children.length;u++)h.children.push(yield this.parseNode(e.children[u]));return e.dnode=h,e.isParsed=!0,e.dnode})}errorMiss(t,e){throw new Error(t+e)}parseCamera(t){return this._cameraParser||(this._cameraParser=new xf(this.gltf)),this._cameraParser.parse(t)}parseMesh(t){return V(this,null,function*(){return this._meshParser||(this._meshParser=new Cf(this)),this._meshParser.parse(t)})}parseTexture(t){return V(this,null,function*(){let e=this.gltf.textures[t];if(e&&!e.dtexture){if(e&&e.source!=null){let r=this.gltf.images[e.source];if(r.uri){let i=r.uri;i=Tt.getURLName(i),e.dtexture=this.gltf.resources[i]}else if(r.bufferView){let i=this.parseBufferView(r.bufferView),a=new ei,o=new Blob([i],{type:r.mimeType});yield a.loadFromBlob(o),e.dtexture=a}else e.dtexture=this.gltf.resources[r.name]}else if(e.name){let r=Tt.getURLName(e.name);e.dtexture=this.gltf.resources[r]}}return e.dtexture||console.log("miss texture , please check texture!",t,e),e.dtexture})}parseMaterial(t){return V(this,null,function*(){return this._materialParser||(this._materialParser=new _f(this)),this._materialParser.parse(t)})}parseAnimations(){return[]}parseObject3D(t,e){return V(this,null,function*(){return this._converter||(this._converter=new Nf(this)),this._converter.convertNodeToObject3D(t,e)})}parseSkeleton(t){return this._skeletonParser||(this._skeletonParser=new Xn(this)),this._skeletonParser.parse(t)}parseSkeletonAnimation(t,e){return this._skeletonParser||(this._skeletonParser=new Xn(this)),this._skeletonParser.parseSkeletonAnimation(t,e)}traverse(t,e){return V(this,null,function*(){for(let r=0;r<e.length;r++){const i=yield this.parseObject3D(e[r],t);yield this.traverse(i,e[r].children)}})}convertToNode(t){return V(this,null,function*(){const e=new ee;e.name=t.name;const r=t.nodes;t.animations;const i=[],a=[];return yield this.traverse(e,r),{rootNode:e,textures:i,animations:void 0,cameras:a}})}parseSkin(t){return this._skinParser||(this._skinParser=new yf(this)),this._skinParser.parse(t)}parseAccessor(t){const e=this.gltf.accessors[t];if(!e)return this.errorMiss("accessor",t);if(e.isParsed)return e.daccessor;e.isParsed=!0,e.daccessor=!1;const r=!!e.normalized,i=this.gltf.bufferViews[e.bufferView],a=i&&i.byteStride,o=Yn(e.componentType);let l=1;switch(e.type){case"SCALAR":l=1;break;case"VEC2":l=2;break;case"VEC3":l=3;break;case"VEC4":case"MAT2":l=4;break;case"MAT3":l=9;break;case"MAT4":l=16;break;default:l=0;break}if(l===0)return console.error(`glTF has unknown data type in accessor: ${e.type}`),!1;const h=l*o.BYTES_PER_ELEMENT;let u;if(i!==void 0){if(u=this.parseBufferView(e.bufferView),!u)return e.daccessor}else u=new Uint8Array(h*e.count).buffer;let c=this.getTypedArrayFromArrayBuffer(u,a,e.byteOffset||0,o,l,e.count);if(e.sparse){const{count:f,indices:d,values:p}=e.sparse;c=new o(c);const A=d.byteOffset||0,x=this.gltf.bufferViews[d.bufferView],C=Yn(d.componentType),v=this.parseBufferView(d.bufferView),y=this.getTypedArrayFromArrayBuffer(v,x.byteStride,A,C,1,f),b=p.byteOffset||0,B=this.gltf.bufferViews[p.bufferView],I=this.parseBufferView(p.bufferView),w=this.getTypedArrayFromArrayBuffer(I,B.byteStride,b,o,l,f);for(let D=0;D<y.length;D++)c.set(w.slice(D*l,D*l+l),y[D]*l)}return e.computeResult={typedArray:c,arrayType:o,numComponents:l},e.daccessor={data:c,numComponents:l,normalize:r},e.daccessor}getTypedArrayFromArrayBuffer(t,e,r,i,a,o){let l;const h=a*i.BYTES_PER_ELEMENT;if(e&&h!==e){const u=a*o;l=new i(u);for(let c=0;c<o;c++){const f=new i(t,r+c*e,a);for(let d=0;d<a;d++)l[c*a+d]=f[d]}}else l=new i(t,r,o*a);return l}parseBufferView(t){const e=this.gltf.bufferViews[t];if(!e)return this.errorMiss("bufferView",t);if(e.isParsed)return e.dbufferView;e.isParsed=!0,e.dbufferView=!1;const r=this.parseBuffer(e.buffer);if(r){const{byteOffset:i,byteLength:a}=e,o=new Uint8Array(r,i||0,a);e.dbufferView=new Uint8Array(o).buffer}return e.dbufferView}parseBuffer(t){const e=this.gltf.buffers[t];if(!e)return this.errorMiss("buffer",t);if(e.isParsed)return e.dbuffer;if(e.isParsed=!0,e.dbuffer=!1,e.uri.substring(0,5)!=="data:"){const r=e.uri,i=this.gltf.resources[r];i?i.byteLength===e.byteLength?e.dbuffer=this.gltf.resources[r]:console.error(`load gltf resource "${r}" at buffers[${t} failed, ArrayBuffer.byteLength not equals buffer's byteLength]`):console.error(`load gltf resource "${r}" at buffers[${t}] failed`)}else{const r=e.uri.indexOf(this._BASE64_MARKER)+this._BASE64_MARKER.length,i=window.atob(e.uri.substring(r)),a=new Uint8Array(i.length);for(let o=0;o<i.length;o++)a[o]=i.charCodeAt(o);e.dbuffer=a.buffer}return e.dbuffer}getLight(t){return this.gltf.extensions.KHR_lights_punctual.lights[t]}applyNodeExtensions(t,e){let r=t.extensions;r.KHR_lights_punctual&&this.gltf.extensions.KHR_lights_punctual&&(e.light=this.getLight(r.KHR_lights_punctual.light))}}class Ff{constructor(){s(this,"magic");s(this,"version");s(this,"length")}}class kf{constructor(){s(this,"chunkLength");s(this,"chunkType");s(this,"chunkData")}}class To extends Et{constructor(){super(...arguments);s(this,"_gltf")}parseBuffer(e){return V(this,null,function*(){let r=new Uint8Array(e);r.pos=0;const i=this.parseHeader(r);if(i.magic!=1179937895)return console.error("invalid GLB file"),!1;if(i.version!==2)return console.error(`GLBParser only support glTF 2.0 for now! Received glTF version: ${i.version}`),!1;let a=[];for(;r.pos<r.length;){let f=this.parseChunk(r);a.push(f)}if(a[0].chunkType!=1313821514)return console.error("invalid GLBChunk"),!1;let o="",l=65535,h=a[0].chunkData;for(let f=0;f<h.length;f+=l){let d=h.length-f;d=Math.min(d,l);let p=h.subarray(f,f+d);o+=String.fromCharCode(...p)}let u=JSON.parse(o);this._gltf=new Ao,this._gltf=Rr(Rr({},this._gltf),u),this._gltf.resources={};for(let f=0;f<this._gltf.buffers.length;f++){let d=this._gltf.buffers[f];d.isParsed=!0,d.dbuffer=a[f+1].chunkData.buffer}if(this._gltf.images)for(let f=0;f<this._gltf.images.length;f++){let d=this._gltf.images[f];d.name=d.name||"bufferView_"+d.bufferView.toString();const p=this._gltf.bufferViews[d.bufferView],A=this._gltf.buffers[p.buffer];let x=new Uint8Array(A.dbuffer,p.byteOffset,p.byteLength),C=new Blob([x],{type:d.mimeType}),v=new ei;yield v.loadFromBlob(C),v.name=d.name,this._gltf.resources[d.name]=v}let c=yield new wo().parse(this.initUrl,this._gltf,this._gltf.scene);return c?(this.data=c.rootNode,c.rootNode):null})}parseJsonAndBuffer(e,r){return V(this,null,function*(){this._gltf=new Ao,this._gltf=Rr(Rr({},this._gltf),e),this._gltf.resources={};let i=this._gltf.buffers[0];if(i.isParsed=!0,i.dbuffer=r,this._gltf.images)for(let o=0;o<this._gltf.images.length;o++){let l=this._gltf.images[o];l.name=l.name||"bufferView_"+l.bufferView.toString();const h=this._gltf.bufferViews[l.bufferView],u=this._gltf.buffers[h.buffer];let c=new Uint8Array(u.dbuffer,h.byteOffset,h.byteLength),f=new Blob([c],{type:l.mimeType}),d=new ei;yield d.loadFromBlob(f),d.name=l.name,this._gltf.resources[l.name]=d}let a=yield new wo().parse(this.initUrl,this._gltf,this._gltf.scene);return a?(this.data=a.rootNode,a.rootNode):null})}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}parseHeader(e){let r=e.pos,i=new Ff,a=new Uint32Array(e.buffer,r,3);return e.pos+=a.byteLength,i.magic=a[0],i.version=a[1],i.length=a[2],i}parseChunk(e){let r=e.pos,i=new kf,a=new Uint32Array(e.buffer,r,2);r=e.pos+=a.byteLength,i.chunkLength=a[0],i.chunkType=a[1],i.chunkData=new Uint8Array(e.buffer,r,i.chunkLength);const o=new Uint8Array(i.chunkLength);for(let l=0;l<i.chunkLength;l++)o[l]=i.chunkData[l];return i.chunkData=o,e.pos+=i.chunkLength,i}}s(To,"format",at.BIN);class zf extends gt{constructor(){super();let t=new Le("PBRLItShader","PBRLItShader");t.setShaderEntry("VertMain","FragMain"),t.passType=J.COLOR,this.addRenderPass(t);let e=t.shaderState;e.acceptShadow=!0,e.castShadow=!0,e.receiveEnv=!0,e.acceptGI=!0,e.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformColor("baseColor",new K(.75,.75,.75,1)),this.setUniformColor("emissiveColor",new K(0,0,0)),this.setUniformVector4("materialF0",new ae(.04,.04,.04,1)),this.setUniformColor("specularColor",new K(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",1),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new K(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this.setUniformFloat("clearcoatIor",1.5),this.setUniformVector4("baseMapOffsetSize",new ae(0,0,1,1)),this.setUniformVector4("normalMapOffsetSize",new ae(0,0,1,1)),this.setUniformVector4("emissiveMapOffsetSize",new ae(0,0,1,1)),this.setUniformVector4("roughnessMapOffsetSize",new ae(0,0,1,1)),this.setUniformVector4("metallicMapOffsetSize",new ae(0,0,1,1)),this.setUniformVector4("aoMapOffsetSize",new ae(0,0,1,1)),this.baseMap=m.res.whiteTexture,this.normalMap=m.res.normalTexture,this.maskMap=m.res.maskTexture}get baseMap(){return this.getDefaultColorShader().getTexture("baseMap")}set baseMap(t){this.getDefaultColorShader().setTexture("baseMap",t)}get baseColor(){return this.getDefaultColorShader().getUniform("baseColor")}set baseColor(t){this.getDefaultColorShader().setUniformColor("baseColor",t)}get normalMap(){return this.getDefaultColorShader().getTexture("normalMap")}set normalMap(t){this.getDefaultColorShader().setTexture("normalMap",t)}get doubleSide(){return this.getDefaultColorShader().doubleSide}set doubleSide(t){this.getDefaultColorShader().doubleSide=t}get alphaCutoff(){return this.getDefaultColorShader().shaderState.alphaCutoff}set alphaCutoff(t){this.getDefaultColorShader().setDefine("USE_ALPHACUT",!0),this.getDefaultColorShader().shaderState.alphaCutoff=t,this.getDefaultColorShader().setUniform("alphaCutoff",t)}get emissiveColor(){return this.getDefaultColorShader().getUniform("emissiveColor")}set emissiveColor(t){this.getDefaultColorShader().setUniform("emissiveColor",t)}get emissiveIntensity(){return this.getDefaultColorShader().getUniform("emissiveIntensity")}set emissiveIntensity(t){this.getDefaultColorShader().setUniform("emissiveIntensity",t)}get transformUV1(){return this.getDefaultColorShader().uniforms.transformUV1.vector4}set transformUV1(t){this.getDefaultColorShader().setUniform("transformUV1",t)}get uvTransform_2(){return this.getDefaultColorShader().uniforms.transformUV2.vector4}set uvTransform_2(t){this.getDefaultColorShader().setUniform("transformUV2",t)}get depthWriteEnabled(){return this.getDefaultColorShader().shaderState.depthWriteEnabled}set depthWriteEnabled(t){this.getDefaultColorShader().shaderState.depthWriteEnabled=t}get materialF0(){return this.getDefaultColorShader().uniforms.materialF0.vector4}set materialF0(t){this.getDefaultColorShader().setUniform("materialF0",t)}get specularColor(){return this.getDefaultColorShader().uniforms.specularColor.color}set specularColor(t){this.getDefaultColorShader().setUniform("specularColor",t)}get roughness(){return this.getDefaultColorShader().uniforms.roughness.value}set roughness(t){this.getDefaultColorShader().setUniform("roughness",t)}get metallic(){return this.getDefaultColorShader().uniforms.metallic.value}set metallic(t){this.getDefaultColorShader().setUniform("metallic",t)}get ao(){return this.getDefaultColorShader().uniforms.ao.value}set ao(t){this.getDefaultColorShader().setUniform("ao",t)}get metallic_min(){return this.getDefaultColorShader().uniforms.metallic_min.value}set metallic_min(t){this.getDefaultColorShader().setUniform("metallic_min",t)}get metallic_max(){return this.getDefaultColorShader().uniforms.metallic_max.value}set metallic_max(t){this.getDefaultColorShader().setUniform("metallic_max",t)}get roughness_min(){return this.getDefaultColorShader().uniforms.roughness_min.value}set roughness_min(t){this.getDefaultColorShader().setUniform("roughness_min",t)}get roughness_max(){return this.getDefaultColorShader().uniforms.roughness_max.value}set roughness_max(t){this.getDefaultColorShader().setUniform("roughness_max",t)}get normalScale(){return this.getDefaultColorShader().uniforms.normalScale.value}set normalScale(t){this.getDefaultColorShader().setUniform("normalScale",t)}get maskMap(){return this.getDefaultColorShader().textures.maskMap}set maskMap(t){this.getDefaultColorShader().setDefine("USE_MR",!0),this.getDefaultColorShader().setTexture("maskMap",t)}set aoMap(t){t&&(this.getDefaultColorShader().setTexture("aoMap",t),t!=m.res.whiteTexture&&this.getDefaultColorShader().setDefine("USE_AOTEX",!0))}get aoMap(){return this.getDefaultColorShader().textures.aoMap}set clearCoatRoughnessMap(t){t&&(console.log("USE_CLEARCOAT_ROUGHNESS"),this.getDefaultColorShader().setTexture("clearCoatRoughnessMap",t),this.getDefaultColorShader().setDefine("USE_CLEARCOAT_ROUGHNESS",!0))}get clearCoatRoughnessMap(){return this.getDefaultColorShader().textures.clearCoatRoughnessMap}get brdfLUT(){return this.getDefaultColorShader().textures.brdfLUT}set brdfLUT(t){this.getDefaultColorShader().setTexture("brdfLUT",t),this.getDefaultColorShader().setTexture("brdflutMap",t)}get emissiveMap(){return this.getDefaultColorShader().textures.emissiveMap}set emissiveMap(t){this.getDefaultColorShader().setTexture("emissiveMap",t)}set envIntensity(t){this.getDefaultColorShader().setUniformFloat("envIntensity",t)}get envIntensity(){return this.getDefaultColorShader().uniforms.envIntensity.value}set ior(t){this.getDefaultColorShader().setUniformFloat("ior",t)}get ior(){return this.getDefaultColorShader().uniforms.ior.value}useCleanCoat(){this.getDefaultColorShader().setDefine("USE_CLEARCOAT",!0)}set clearcoatFactor(t){this.getDefaultColorShader().setUniformFloat("clearcoatFactor",t),this.useCleanCoat()}get clearcoatFactor(){return this.getDefaultColorShader().uniforms.clearcoatFactor.value}set clearcoatRoughnessFactor(t){this.getDefaultColorShader().setUniformFloat("clearcoatRoughnessFactor",t),this.useCleanCoat()}get clearcoatRoughnessFactor(){return this.getDefaultColorShader().uniforms.clearcoatRoughnessFactor.value}set clearcoatWeight(t){this.getDefaultColorShader().setUniformFloat("clearcoatWeight",t),this.useCleanCoat()}get clearcoatWeight(){return this.getDefaultColorShader().uniforms.clearcoatWeight.value}set clearcoatColor(t){this.getDefaultColorShader().setUniformColor("clearcoatColor",t),this.useCleanCoat()}get clearcoatColor(){return this.getDefaultColorShader().uniforms.clearcoatColor.color}}class Ir extends $r{constructor(){super();let t=new zf;this.shader=t}clone(){let t=new Ir,e=t.shader.getDefaultColorShader(),r=this.shader.getDefaultColorShader();return e.defineValue=Rr({},r.defineValue),e.setUniform("shadowBias",r.getUniform("shadowBias")),e.setUniform("baseColor",r.getUniform("baseColor")),e.setUniform("specularColor",r.getUniform("specularColor")),e.setUniform("emissiveColor",r.getUniform("emissiveColor")),e.setUniform("materialF0",r.getUniform("materialF0")),e.setUniform("envIntensity",r.getUniform("envIntensity")),e.setUniform("normalScale",r.getUniform("normalScale")),e.setUniform("roughness",r.getUniform("roughness")),e.setUniform("metallic",r.getUniform("metallic")),e.setUniform("ao",r.getUniform("ao")),e.setUniform("roughness_min",r.getUniform("roughness_min")),e.setUniform("roughness_max",r.getUniform("roughness_max")),e.setUniform("metallic_min",r.getUniform("metallic_min")),e.setUniform("metallic_max",r.getUniform("metallic_max")),e.setUniform("emissiveIntensity",r.getUniform("emissiveIntensity")),e.setUniform("alphaCutoff",r.getUniform("alphaCutoff")),e.setUniform("ior",r.getUniform("ior")),e.setUniform("clearcoatFactor",r.getUniform("clearcoatFactor")),e.setUniform("clearcoatRoughnessFactor",r.getUniform("clearcoatRoughnessFactor")),e.setUniform("clearcoatColor",r.getUniform("clearcoatColor")),e.setUniform("clearcoatWeight",r.getUniform("clearcoatWeight")),e.setUniform("clearcoatIor",r.getUniform("clearcoatIor")),e.setTexture("baseMap",r.getTexture("baseMap")),e.setTexture("normalMap",r.getTexture("normalMap")),e.setTexture("emissiveMap",r.getTexture("emissiveMap")),e.setTexture("aoMap",r.getTexture("aoMap")),e.setTexture("maskMap",r.getTexture("maskMap")),e.setTexture("empty",r.getTexture("empty")),e.setUniform("baseMapOffsetSize",r.getUniform("baseMapOffsetSize")),e.setUniform("normalMapOffsetSize",r.getUniform("normalMapOffsetSize")),e.setUniform("emissiveMapOffsetSize",r.getUniform("emissiveMapOffsetSize")),e.setUniform("roughnessMapOffsetSize",r.getUniform("roughnessMapOffsetSize")),e.setUniform("metallicMapOffsetSize",r.getUniform("metallicMapOffsetSize")),e.setUniform("aoMapOffsetSize",r.getUniform("aoMapOffsetSize")),t}set baseMap(t){this.shader.setTexture("baseMap",t)}get baseMap(){return this.shader.getTexture("baseMap")}set maskMap(t){this.shader.setTexture("maskMap",t)}get maskMap(){return this.shader.getTexture("maskMap")}set normalMap(t){this.shader.setTexture("normalMap",t)}get normalMap(){return this.shader.getTexture("normalMap")}set emissiveMap(t){this.shader.setTexture("emissiveMap",t)}get emissiveMap(){return this.shader.getTexture("emissiveMap")}set aoMap(t){this.shader.setTexture("aoMap",t)}get aoMap(){return this.shader.getTexture("aoMap")}set clearCoatRoughnessMap(t){this.shader.setTexture("clearCoatRoughnessMap",t),this.shader.setDefine("USE_CLEARCOAT",!0),this.shader.setDefine("USE_CLEARCOAT_ROUGHNESS",!0)}get clearCoatRoughnessMap(){return this.shader.getTexture("clearCoatRoughnessMap")}set clearcoatColor(t){this.shader.setUniformColor("clearcoatColor",t),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatColor(){return this.shader.getUniformColor("clearcoatColor")}set clearcoatWeight(t){this.shader.setUniformFloat("clearcoatWeight",t),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatWeight(){return this.shader.getUniformFloat("clearcoatWeight")}set clearcoatFactor(t){this.shader.setUniformFloat("clearcoatFactor",t),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatFactor(){return this.shader.getUniformFloat("clearcoatFactor")}set clearcoatRoughnessFactor(t){this.shader.setUniformFloat("clearcoatRoughnessFactor",t),this.shader.setDefine("USE_CLEARCOAT",!0)}get clearcoatRoughnessFactor(){return this.shader.getUniformFloat("clearcoatRoughnessFactor")}set ior(t){this.shader.setUniformFloat("clearcoatIor",t)}get ior(){return this.shader.getUniformFloat("clearcoatIor")}set alphaCutoff(t){this.shader.setUniform("alphaCutoff",t)}get alphaCutoff(){return this.shader.getUniform("alphaCutoff")}set baseColor(t){this.shader.setUniformColor("baseColor",t)}get baseColor(){return this.shader.getUniformColor("baseColor")}get roughness(){return this.shader.getUniformFloat("roughness")}set roughness(t){this.shader.setUniformFloat("roughness",t)}get metallic(){return this.shader.getUniformFloat("metallic")}set metallic(t){this.shader.setUniformFloat("metallic",t)}get emissiveColor(){return this.shader.getUniformColor("emissiveColor")}set emissiveColor(t){this.shader.setUniformColor("emissiveColor",t)}get emissiveIntensity(){return this.shader.getUniformFloat("emissiveIntensity")}set emissiveIntensity(t){this.shader.setUniformFloat("emissiveIntensity",t)}get ao(){return this.shader.getUniform("ao")}set ao(t){this.shader.setUniform("ao",t)}}class Wn extends Et{constructor(){super(...arguments);s(this,"textData","");s(this,"source_vertices");s(this,"source_normals");s(this,"source_tangents");s(this,"source_textureCoords");s(this,"matLibs");s(this,"geometrys");s(this,"activeGeo");s(this,"facesMaterialsIndex");s(this,"mtl");s(this,"mtlUrl")}parseString(e){return V(this,null,function*(){return this.source_vertices=[],this.source_normals=[],this.source_tangents=[],this.source_textureCoords=[],this.matLibs={},this.geometrys={},this.textData=e,yield Promise.all([this.parserOBJ(),this.loadMTL()]),this.parser_mesh(),"null"})}applyVector2(e,r,i){r[e]&&r[e].length>0?(i.push(r[e][0]),i.push(r[e][1])):(i.push(0),i.push(0))}applyVector3(e,r,i){i.push(r[e][0]),i.push(r[e][1]),i.push(r[e][2])}applyVector4(e,r,i){i.push(r[e][0]),i.push(r[e][1]),i.push(r[e][2]),i.push(r[e][3])}loadMTL(){return V(this,null,function*(){let e=yield new Rt().loadTxt(this.baseUrl+this.mtlUrl),r=e.data,i,a=r.split(`\r
`);for(let h=0;h<a.length;h++){let u=a[h];var o=u.indexOf("#");o!=-1&&(u=u.substring(0,o)),u=u.trim();var l=u.split(/\s+/);l[0]==="newmtl"?(i={name:l[1]},this.matLibs[l[1]]=i):l[0].indexOf("map_")!=-1?(i[l[0]]=l[1],i.textures||(i.textures=[l[l.length-1]]),i.textures.push(l[l.length-1])):l.length==2?i[l[0]]=Number(l[1]):l.length==3?i[l[0]]=[Number(l[1]),Number(l[2])]:l.length==4&&(i[l[0]]=[Number(l[1]),Number(l[2]),Number(l[3])])}for(const h in this.matLibs){const u=this.matLibs[h];if(u.textures&&u.textures.length>0)for(let c=0;c<u.textures.length;c++){const f=Tt.normalizePath(this.baseUrl+u.textures[c]);yield m.res.loadTexture(f)}}return e=null,!0})}load_textures(){return V(this,null,function*(){})}parserLine(e){var r=e.indexOf("#");if(r!=-1){if(e.indexOf("# object")!=-1){var i=e.split(/\s+/);let p=i[1],A=i[2];this.activeGeo={type:p,name:A[1],source_mat:"",source_faces:[]},this.geometrys[A]=this.activeGeo}e=e.substring(0,r)}e=e.trim();var i=e.split(/\s+/);if(i[0]==="v"){var a=[Number(i[1]),Number(i[2]),Number(i[3]),i[4]?1:Number(i[4])];this.source_vertices.push(a)}else if(i[0]==="vt"){var o=[Number(i[1]),Number(i[2]),i[3]?1:Number(i[3])];this.source_textureCoords.push(o)}else if(i[0]==="vn"){var l=[Number(i[1]),Number(i[2]),Number(i[3])];this.source_normals.push(l)}else if(i[0]==="f"){for(var h={indices:[],texture:[],normal:[]},u=1;u<i.length;++u){var c=i[u].indexOf("//"),f=i[u].split(/\W+/);c>0?(h.indices.push(f[0]),h.normal.push(f[1])):f.length===1?h.indices.push(f[0]):f.length===2?(h.indices.push(f[0]),h.texture.push(f[1])):f.length===3&&(h.indices.push(f[0]),h.texture.push(f[1]),h.normal.push(f[2]))}this.activeGeo.source_faces.push(h)}else i[0]==="usemtl"?this.activeGeo.source_mat=i[1]:i[0]==="mtllib"&&(this.mtlUrl=i[1])}parserOBJ(){return V(this,null,function*(){let e=this.textData.split(`\r
`);for(let r=0;r<e.length;r++){const i=e[r];this.parserLine(i)}return this.textData="",!0})}parser_mesh(){return V(this,null,function*(){let e=new ee;for(const r in this.geometrys){const i=this.geometrys[r];i.vertex_arr=[],i.normal_arr=[],i.uv_arr=[],i.indeice_arr=[];let a=0;for(let f=0;f<i.source_faces.length;f++){const d=i.source_faces[f];let p=parseInt(d.indices[0])-1,A=parseInt(d.indices[1])-1,x=parseInt(d.indices[2])-1,C=parseInt(d.normal[0])-1,v=parseInt(d.normal[1])-1,y=parseInt(d.normal[2])-1,b=parseInt(d.texture[0])-1,B=parseInt(d.texture[1])-1,I=parseInt(d.texture[2])-1;if(this.applyVector3(p,this.source_vertices,i.vertex_arr),this.applyVector3(C,this.source_normals,i.normal_arr),this.applyVector2(b,this.source_textureCoords,i.uv_arr),i.indeice_arr[a]=a++,this.applyVector3(A,this.source_vertices,i.vertex_arr),this.applyVector3(v,this.source_normals,i.normal_arr),this.applyVector2(B,this.source_textureCoords,i.uv_arr),i.indeice_arr[a]=a++,this.applyVector3(x,this.source_vertices,i.vertex_arr),this.applyVector3(y,this.source_normals,i.normal_arr),this.applyVector2(I,this.source_textureCoords,i.uv_arr),i.indeice_arr[a]=a++,d.indices.length>3){let w=parseInt(d.indices[3])-1,D=parseInt(d.normal[3])-1,L=parseInt(d.texture[3])-1;this.applyVector3(p,this.source_vertices,i.vertex_arr),this.applyVector3(C,this.source_normals,i.normal_arr),this.applyVector2(b,this.source_textureCoords,i.uv_arr),i.indeice_arr[a]=a++,this.applyVector3(x,this.source_vertices,i.vertex_arr),this.applyVector3(y,this.source_normals,i.normal_arr),this.applyVector2(I,this.source_textureCoords,i.uv_arr),i.indeice_arr[a]=a++,this.applyVector3(w,this.source_vertices,i.vertex_arr),this.applyVector3(D,this.source_normals,i.normal_arr),this.applyVector2(L,this.source_textureCoords,i.uv_arr),i.indeice_arr[a]=a++}}let o=new qt;o.setIndices(new Uint32Array(i.indeice_arr)),o.setAttribute(O.position,new Float32Array(i.vertex_arr)),o.setAttribute(O.normal,new Float32Array(i.normal_arr)),o.setAttribute(O.uv,new Float32Array(i.uv_arr)),o.setAttribute(O.TEXCOORD_1,new Float32Array(i.uv_arr)),o.addSubGeometry({indexStart:0,indexCount:i.indeice_arr.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0});let l=new Ir,h=this.matLibs[i.source_mat];l.baseMap=m.res.getTexture(Tt.normalizePath(this.baseUrl+h.map_Kd));let u=new ee,c=u.addComponent($);c.geometry=o,c.material=l,e.addChild(u)}this.data=e})}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}s(Wn,"format",at.TEXT);let Gf=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        var srcId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x * 2u), i32(GlobalInvocationID.y * 2u));
        textureStore(outputTexture, dstId, textureLoad(inputTexture, srcId, 0));
    }
`,Qf=`
    struct ImageSize {
        srcWidth: i32,
            srcHeight : i32,
                dstWidth : i32,
                    dstHeight : i32,
    };

    @group(0) @binding(0) var<uniform>size : ImageSize;
    @group(0) @binding(1) var inputTexture: texture_2d<f32>;
    @group(0) @binding(2) var outputTexture: texture_storage_2d<rgba8unorm, write>;

    fn repeat_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = max + id;
        }
        if (id >= max) {
            ret = id - max;
        }
        return ret;
    }

    fn clamp_i32(id: i32, max: i32) -> i32 {
        var ret = id;
        if (id < 0) {
            ret = 0;
        }
        if (id >= max) {
            ret = max - 1;
        }
        return ret;
    }

    fn blur(idx: u32) -> vec4 < f32 > {
        var id: vec2<i32>;
        id.y = i32(idx) / size.srcWidth;
        id.x = i32(idx) - i32(id.y) * size.srcWidth;
        var _BlurSpread: i32 = 1;
        var result = vec4<f32>(0.0, 0.0, 0.0, 0.0);
        let g: array < f32, 3u > = array<f32, 3u > (0.4026, 0.2442, 0.0545);
        var uv: vec2<i32>;
        for(var h: i32 = 0; h< 5; h = h + 1) {
        let offsetU: i32 = (h - 2) * _BlurSpread;
        uv.x = id.x + offsetU;
        uv.x = clamp_i32(uv.x, size.srcWidth);
        for (var v: i32 = 0; v < 5; v = v + 1) {
            let offsetV: i32 = (v - 2) * _BlurSpread;
            uv.y = id.y + offsetV;
            uv.y = clamp(uv.y, 0, size.srcHeight);
            let weightU: i32 = abs(h - 2);
            let weightV: i32 = abs(v - 2);
            let resultWeight: f32 = g[weightU] * g[weightV];
            var colorf32: vec4<f32> = textureLoad(inputTexture, uv, 0);
            let sampleColor: vec4<f32> = vec4<f32>(colorf32 * resultWeight);
            result = result + sampleColor;
        }
    }

    return result;
    }

    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        var uv: vec2<f32> = vec2<f32>(f32(GlobalInvocationID.x) / f32(size.dstWidth), f32(GlobalInvocationID.y) / f32(size.dstHeight));
        uv = uv * vec2<f32>(f32(size.srcWidth), f32(size.srcHeight));
        let srcIdx = i32(uv.y) * size.srcWidth + i32(uv.x);
        var dstId: vec2<i32> = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
        textureStore(outputTexture, dstId, blur(u32(srcIdx)));
    }
`;class Vf{static blurImageFromTexture(t,e,r,i){const a=E.device;let o=i?Qf:Gf;const l=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:o}),entryPoint:"main"}}),h=4*4,u=a.createBuffer({size:h,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});a.queue.writeBuffer(u,0,new Uint32Array([t.width,t.height,e,r]));const c=a.createTexture({size:[e,r,1],mipLevelCount:1,format:"rgba8unorm",usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.RENDER_ATTACHMENT,label:"blurImageFromTexture"});let f=[{binding:0,resource:{buffer:u,size:4*4}},{binding:1,resource:t.gpuTexture.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})},{binding:2,resource:c.createView({format:"rgba8unorm",dimension:"2d",baseMipLevel:0,mipLevelCount:1})}];const d=a.createBindGroup({layout:l.getBindGroupLayout(0),entries:f}),p=S.beginCommandEncoder(),A=p.beginComputePass();return A.setPipeline(l),A.setBindGroup(0,d),A.dispatchWorkgroups(Math.floor(e/8),Math.floor(r/8)),A.end(),S.endCommandEncoder(p),u.destroy(),c}}class Eo extends It{constructor(){super(4,4);s(this,"width",4);s(this,"height",4);s(this,"depthOrArrayLayers",6);s(this,"visibility",GPUShaderStage.FRAGMENT);s(this,"textureBindingLayout",{viewDimension:"cube",multisampled:!1});s(this,"samplerBindingLayout",{type:"filtering"});this.addressModeU=Wt.clamp_to_edge,this.addressModeV=Wt.clamp_to_edge,this.addressModeW=Wt.clamp_to_edge,this.magFilter=this.minFilter="linear",this.mipmapFilter="linear",this.visibility=GPUShaderStage.FRAGMENT}createTextureDescriptor(e,r,i,a,o=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT,l=1){this.width=e,this.height=r,this.format=a,this.usage=o,this.textureDescriptor={size:{width:e,height:r,depthOrArrayLayers:6},mipLevelCount:i,format:a,usage:o,dimension:"2d"},l>1?this.viewDescriptor={dimension:"cube-array"}:this.viewDescriptor={dimension:this.textureBindingLayout.viewDimension}}}const Ti=class Ti{static createFace(t,e,r,i){const a=E.device;this.pipeline==null&&(this.pipeline=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:Ti.createCube}),entryPoint:"main"}}));const o=this.pipeline,l=4*4;this.configBuffer||(this.configBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.configBuffer,0,new Uint32Array([t,0,0,0])),this.blurSettingBuffer||(this.blurSettingBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([0,0,0,0]));let h=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:r.getGPUView()},{binding:2,resource:i.getGPUView()}];const u=a.createBindGroup({layout:o.getBindGroupLayout(0),entries:h}),c=S.beginCommandEncoder(),f=c.beginComputePass();f.setPipeline(o),f.setBindGroup(0,u),f.dispatchWorkgroups(e/8,e/8),f.end(),S.endCommandEncoder(c)}};s(Ti,"createCube",`

struct SettingUniform {
  faceIndex : i32,
  srcHeight : i32,
  dstWidth : i32,
  dstHeight : i32
};

@group(0) @binding(0) var<uniform> settingUniform : SettingUniform;
@group(0) @binding(1) var inputTex : texture_2d<f32>;
@group(0) @binding(2) var outTex : texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
  let coord = vec2<i32>(GlobalInvocationID.xy);
  
  let outTexSize = textureDimensions(outTex).xy;
  let outTexel = 1.0 / vec2<f32>(outTexSize - 1);
  
  let uv_0 = vec2<f32>(coord) * outTexel;
  var oc = samplePixel(settingUniform.faceIndex, uv_0);
  textureStore(outTex, coord, oc);
}

fn samplePixel(face:i32, uv01:vec2<f32>) -> vec4<f32> {
    let rectangle_v2_f32 = round(vec2<f32>(0.25, 0.33333) * vec2<f32>(textureDimensions(inputTex).xy));
    let rectangle = vec2<i32>(rectangle_v2_f32);
    
    var offsetIndex = vec2<i32>(0);
    if(face == 0){
        offsetIndex.x = 2;
        offsetIndex.y = 1;
    }else if(face == 1){
        offsetIndex.x = 0;
        offsetIndex.y = 1;
    }else if(face == 2){
        offsetIndex.x = 1;
        offsetIndex.y = 0;
    }else if(face == 3){
        offsetIndex.x = 1;
        offsetIndex.y = 2;
    }else if(face == 4){
        offsetIndex.x = 1;
        offsetIndex.y = 1;
    }else if(face == 5){
        offsetIndex.x = 3;
        offsetIndex.y = 1;
    }
    
    let coordOffset = rectangle * offsetIndex;
    let coordIndex = vec2<i32>(vec2<f32>(rectangle - 1) * uv01);
    var oc = textureLoad(inputTex, coordOffset + coordIndex, 0);
    return oc;
}
`),s(Ti,"configBuffer",null),s(Ti,"blurSettingBuffer",null),s(Ti,"pipeline");let Bo=Ti;class Kn extends Eo{constructor(){super();s(this,"_images");s(this,"_url");this.useMipmap=!0}generateImages(e){let r=E.device;this.width=this.height=32,"width"in e[0]&&(this.width=this.height=e[0].width);let i=Math.min(this.width,this.height);for(this.mipmapCount=1;i>16;)i/=2,this.mipmapCount++;this.textureBindingLayout.viewDimension="cube",this.samplerBindingLayout.type="filtering",this.createTextureDescriptor(this.width,this.height,this.mipmapCount,this.format),this.textureDescriptor.size={width:this.width,height:this.height,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuTexture=this.getGPUTexture();let a=[],o=a,l=this.width,h=this.height;if(e[0]instanceof It){for(let u=0;u<6;u++){let c=e[u];a[u]=c.getGPUTexture()}this.uploadMipmapGPUTexture(0,this.width,this.width,a)}else{this.uploadBaseImages(this.width,e);for(let u=0;u<6;u++){let c=new ei(!1);c.format=this.format,c.source=e[u],a[u]=c.getGPUTexture()}}for(let u=1;u<this.mipmapCount;u++){o=a,a=[];let c={width:l,height:h,gpuTexture:null};l=l/2,h=h/2;for(let f=0;f<6;f++)c.gpuTexture=o[f],a[f]=Vf.blurImageFromTexture(c,l,h,!1);this.uploadMipmapGPUTexture(u,l,h,a)}this.gpuSampler=r.createSampler(this)}uploadBaseImages(e,r){let i=E.device;const a=S.beginCommandEncoder();for(let o=0;o<6;o++)i.queue.copyExternalImageToTexture({source:r[o]},{texture:this.gpuTexture,mipLevel:0,origin:{x:0,y:0,z:o}},{width:e,height:e,depthOrArrayLayers:1});S.endCommandEncoder(a)}uploadMipmapGPUTexture(e,r,i,a){const o=S.beginCommandEncoder();for(let l=0;l<6;l++)o.copyTextureToTexture({texture:a[l],mipLevel:0,origin:{x:0,y:0,z:0}},{texture:this.gpuTexture,mipLevel:e,origin:{x:0,y:0,z:l}},{width:r,height:i,depthOrArrayLayers:1});S.endCommandEncoder(o)}get images(){return this._images}set images(e){if(this._images=e,this._images[0]instanceof HTMLImageElement){let r=function(l,h){h.decode().then(()=>V(this,null,function*(){i[l]=yield createImageBitmap(h),a--,a==0&&o.generateImages(i)}))},i=[],a=6,o=this;for(let l=0;l<6;l++)r(l,this._images[l])}else(this._images instanceof HTMLCanvasElement||this._images instanceof ImageBitmap)&&this.generateImages(this._images)}load(e){return V(this,null,function*(){this._url=e;let r=6,i=[];this.format=j.rgba8unorm;let a=this;function o(l,h){return V(this,null,function*(){const u=document.createElement("img");if(u.src=h,u.setAttribute("crossOrigin",""),yield u.decode(),i[l]=yield createImageBitmap(u),r--,r==0)return a.generateImages(i),!0})}for(let l=0;l<6;l++)yield o(l,e[l]);return!0})}loadStd(e){return V(this,null,function*(){this._url=e,this.format=j.rgba8unorm;const r=document.createElement("img");r.src=e,r.setAttribute("crossOrigin",""),yield r.decode();let i=new ei(!1);i.name=Tt.getURLName(e),i.format="rgba8unorm",i.source=yield createImageBitmap(r);let a=Math.round(Math.log2(i.width/4));a=Math.pow(2,a),this.width=this.height=a;let o=[];for(let l=0;l<6;l++){let h=new pe(a,a,this.format,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING);h.name="face "+l,o.push(h),Bo.createFace(l,this.width,i,h)}return this.generateImages(o),!0})}}var Yf=(n=>(n[n.Left=0]="Left",n[n.Right=1]="Right",n[n.Bottom=2]="Bottom",n[n.Top=3]="Top",n[n.Back=4]="Back",n[n.Front=5]="Front",n))(Yf||{});class jn{static getRotationToFace(t){let e=Z.identity().clone(),r=new g,i=new Q().identity(),a=new g;switch(t){case 3:r.set(0,-1,0),a.set(0,0,-1);break;case 2:r.set(0,1,0),a.set(0,0,1);break;case 1:r.set(1,0,0),a.set(0,1,0);break;case 0:r.set(-1,0,0),a.set(0,1,0);break;case 4:r.set(0,0,-1),a.set(0,1,0);break;case 5:return Z.identity()}return i.lookAt(new g,r,a),e.setFromRotationMatrix(i),e}}let Hf=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
  @group(0) @binding(2) var inputTexSampler : sampler;
  @group(0) @binding(3) var inputTex : texture_2d<f32>;

  @group(1) @binding(0) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;

  fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
      var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
      //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
      uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
      uv = uv + vec2<f32>(0.5);
      uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
      return uv;
  }


  fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
      let x:f32 = position.x;
      let y:f32 = position.y;
      let z:f32 = position.z;

      let qx:f32 = q.x;
      let qy:f32 = q.y;
      let qz:f32 = q.z;
      let qw:f32 = q.w;

      let ix:f32 = qw * x + qy * z - qz * y;
      let iy:f32 = qw * y + qz * x - qx * z;
      let iz:f32 = qw * z + qx * y - qy * x;
      let iw:f32 = -qx * x - qy * y - qz * z;

      var ret: vec3<f32>;
      ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
      ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
      ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;

      return ret;
  }

  fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
      var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
      var halfSize:f32 = f32(size.dstWidth / 2) - 0.5;
      var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
      worldDirection = normalize(worldDirection);
      worldDirection = applyQuaternion(worldDirection, quaternion);
      return worldDirection;
  }

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let coord = vec2<i32>(GlobalInvocationID.xy);
    let quaternion = faceRotation[GlobalInvocationID.z];
    var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
    let uv_f32:vec2<f32> = SampleSphericalMap(worldDirection);
    let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
    textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
  }
`,Xf=`
  struct ImageSize {
    srcWidth : i32,
    srcHeight : i32,
    dstWidth : i32,
    dstHeight : i32
  };

  @group(0) @binding(0) var<uniform> size : ImageSize;
  @group(0) @binding(1) var<storage, read> tex_in: array<vec4<f32>>;
  @group(0) @binding(2) var outputBuffer : texture_storage_2d<rgba16float, write>;

  @compute @workgroup_size(8, 8, 1)
  fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
    let fragCoord = vec2<i32>(i32(GlobalInvocationID.x), i32(GlobalInvocationID.y));
    var oc:vec4<f32> = tex_in[fragCoord.y * size.srcWidth + fragCoord.x] / 256.0;
    var e = pow(2.0, oc.w * 255.0 - 128.0);
    oc = oc * e;
    oc = scaleByThreshold(oc, 40.0);
    textureStore(outputBuffer, fragCoord , vec4<f32>(oc.xyz, 1.0) );
  }

  fn scaleByThreshold(color:vec4<f32>, threshold:f32) -> vec4<f32>{
    var oc = color;
    let brightness = length(vec3<f32>(oc.xyz));
    var scale = brightness / threshold;
    if(scale > 1.0){
        scale = 1.0 / pow(scale, 0.7);
        oc = oc * scale;
    }
    oc.a = 1.0;
    return oc;
  }
`;const st=class st{static convertRGBE2RGBA(t,e){const r=E.device,i=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:Xf}),entryPoint:"main"}}),a=r.createBuffer({size:4*4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST});r.queue.writeBuffer(a,0,new Uint32Array([t.width,t.height,t.width,t.height]));const o=r.createBuffer({size:e.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});r.queue.writeBuffer(o,0,e);let l=[{binding:0,resource:{buffer:a,size:4*4}},{binding:1,resource:{buffer:o,size:e.byteLength}},{binding:2,resource:t.getGPUView()}];const h=r.createBindGroup({layout:i.getBindGroupLayout(0),entries:l}),u=S.beginCommandEncoder(),c=u.beginComputePass();c.setPipeline(i),c.setBindGroup(0,h),c.dispatchWorkgroups(Math.floor(t.width/8),Math.floor(t.height/8)),c.end(),S.endCommandEncoder(u),a.destroy()}static makeTextureCube(t,e,r){const i=E.device;st.makeFaceTexturePipeline||(st.makeFaceTexturePipeline=i.createComputePipeline({layout:"auto",compute:{module:i.createShaderModule({code:Hf}),entryPoint:"main"}}));const a=st.makeFaceTexturePipeline,o=4*4;st.configBuffer||(st.configBuffer=i.createBuffer({size:o,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),i.queue.writeBuffer(st.configBuffer,0,new Uint32Array([t.width,t.height,e,e]));const l=4*6;if(!st.quaternionBuffer){st.quaternionBuffer=i.createBuffer({size:l*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let A=new Float32Array(4*6);for(let x=0;x<6;x++){let C=jn.getRotationToFace(x);A[x*4+0]=C.x,A[x*4+1]=C.y,A[x*4+2]=C.z,A[x*4+3]=C.w}i.queue.writeBuffer(st.quaternionBuffer,0,A)}let h=[{binding:0,resource:{buffer:st.configBuffer,size:4*4}},{binding:1,resource:{buffer:st.quaternionBuffer,size:l*4}},{binding:2,resource:t.gpuSampler},{binding:3,resource:t.getGPUView()}],u=[{binding:0,resource:r}];const c=i.createBindGroup({layout:a.getBindGroupLayout(0),entries:h}),f=i.createBindGroup({layout:a.getBindGroupLayout(1),entries:u}),d=S.beginCommandEncoder(),p=d.beginComputePass();p.setPipeline(a),p.setBindGroup(0,c),p.setBindGroup(1,f),p.dispatchWorkgroups(e/8,e/8,6),p.end(),S.endCommandEncoder(d)}};s(st,"makeFaceTexturePipeline"),s(st,"configBuffer"),s(st,"quaternionBuffer");let ya=st;class qn extends It{constructor(){super(32,32,null),this.isHDRTexture=!0}create(t=32,e=32,r=null,i=!0){this.width=t,this.height=e;let a=E.device;const o=t*4*2;let l=r;this.format=j.rgba16float,this.useMipmap=i,this.updateTextureDescription(),this.updateGPUTexture();const h=a.createBuffer({size:l.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(h,0,l);const u=S.beginCommandEncoder();return u.copyBufferToTexture({buffer:h,bytesPerRow:o},{texture:this.getGPUTexture()},{width:t,height:e,depthOrArrayLayers:1}),S.endCommandEncoder(u),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),this.gpuSampler=a.createSampler(this),this}load(t,e){return V(this,null,function*(){return(yield new Rt().load(t,$n,e)).getHDRTexture()})}}const Jn=new Float32Array(1),Wf=new Int32Array(Jn.buffer);let Sa=function(n){Jn[0]=n;const t=Wf[0];let e=t>>16&32768,r=t>>12&2047;const i=t>>23&255;return i<103?e:i>142?(e|=31744,e|=(i==255?1:0)&&t&8388607,e):i<114?(r|=2048,e|=(r>>114-i)+(r>>113-i&1),e):(e|=i-112<<10|r>>1,e+=r&1,e)};var Kf=(n=>(n[n.RGBE_RETURN_FAILURE=-1]="RGBE_RETURN_FAILURE",n[n.rgbe_read_error=1]="rgbe_read_error",n[n.rgbe_write_error=2]="rgbe_write_error",n[n.rgbe_format_error=3]="rgbe_format_error",n[n.rgbe_memory_error=4]="rgbe_memory_error",n))(Kf||{});class Zn{constructor(){s(this,"valid");s(this,"string");s(this,"comments");s(this,"programtype");s(this,"format");s(this,"gamma");s(this,"exposure");s(this,"width");s(this,"height")}}class $n extends Et{constructor(){super(...arguments);s(this,"_rgbeArray");s(this,"_width");s(this,"_height");s(this,"_RGBE_RETURN_FAILURE",-1);s(this,"_parserType",j.rgba8uint)}parseBuffer(e){let r,i=new Uint8Array(e);i.pos=0;const a=this.paserHeader(i);if(a instanceof Zn){const o=this._width=a.width,l=this._height=a.height;let h=this.parserPixel(i.subarray(i.pos),o,l);if(h instanceof Uint8Array){switch(this._rgbeArray=h,this._parserType){}return this.data=r,r}}return null}verification(){if(this.data&&this.data instanceof It||this._rgbeArray)return!0;throw new Error("Method not implemented.")}getTexture(){return this.data}getCubeTexture(){let e=this._width/4;return new Do().createFromHDRData(e,{width:this._width,height:this._height,array:this._rgbeArray})}getHDRTexture(){return new qn().create(this._width,this._height,this._rgbeArray)}parseError(e,r){switch(e){case 1:console.error("Read Error: "+(r||""));break;case 2:console.error("Write Error: "+(r||""));break;case 3:console.error("Bad File Format: "+(r||""));break;default:case 4:console.error("Error: "+(r||""))}return-1}parserBlock(e,r,i){r=r||1024;let a=e.pos,o=-1,l=0,h="",u=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));const c=`
`;for(;0>(o=u.indexOf(c))&&l<r&&a<e.byteLength;)h+=u,l+=u.length,a+=128,u+=String.fromCharCode.apply(null,new Uint16Array(e.subarray(a,a+128)));return-1<o?(i!==!1&&(e.pos+=l+o+1),h+u.slice(0,o)):!1}paserHeader(e){const r=/^#\?(\S+)/,i=/^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,a=/^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,o=/^\s*FORMAT=(\S+)\s*$/,l=/^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,h=new Zn;let u,c;if(e.pos>=e.byteLength||!(u=this.parserBlock(e)))return this.parseError(1,"no header found");if(!(c=u.match(r)))return this.parseError(3,"bad initial token");const f=1,d=2,p=4;for(h.valid|=f,h.programtype=c[1],h.string+=u+`
`;u=this.parserBlock(e),u!==!1;){if(h.string+=u+`
`,u.charAt(0)==="#"){h.comments+=u+`
`;continue}if((c=u.match(i))&&(h.gamma=Math.floor(parseFloat(c[1])*10)/10),(c=u.match(a))&&(h.exposure=Math.floor(parseFloat(c[1])*10)/10),(c=u.match(o))&&(h.valid|=d,h.format=c[1]),(c=u.match(l))&&(h.valid|=p,h.height=parseInt(c[1],10),h.width=parseInt(c[2],10)),h.valid&d&&h.valid&p)break}return h.valid&d?h.valid&p?h:(this.parseError(3,"missing image size specifier"),null):(this.parseError(3,"missing format specifier"),null)}parserPixel(e,r,i){const a=r;if(a<8||a>32767||e[0]!==2||e[1]!==2||e[2]&128)return new Uint8Array(e);if(a!==(e[2]<<8|e[3]))return this.parseError(3,"wrong scanline width");const o=new Uint8Array(4*r*i);if(!o.length)return this.parseError(4,"unable to allocate buffer space");let l=0,h=0;const u=4*a,c=new Uint8Array(4),f=new Uint8Array(u);let d=i;for(;d>0&&h<e.byteLength;){if(h+4>e.byteLength)return this.parseError(1,"");if(c[0]=e[h++],c[1]=e[h++],c[2]=e[h++],c[3]=e[h++],c[0]!=2||c[1]!=2||(c[2]<<8|c[3])!=a)return this.parseError(3,"bad rgbe scanline format");let p=0,A;for(;p<u&&h<e.byteLength;){A=e[h++];const C=A>128;if(C&&(A-=128),A===0||p+A>u)return this.parseError(3,"bad scanline data");if(C){const v=e[h++];for(let y=0;y<A;y++)f[p++]=v}else f.set(e.subarray(h,h+A),p),p+=A,h+=A}const x=a;for(let C=0;C<x;C++){let v=0;o[l]=f[C+v],v+=a,o[l+1]=f[C+v],v+=a,o[l+2]=f[C+v],v+=a,o[l+3]=f[C+v],l+=4}d--}return o}rbgeToFloat(e,r,i,a){const o=e[r+3],l=Math.pow(2,o-128)/255;i[a+0]=e[r+0]*l,i[a+1]=e[r+1]*l,i[a+2]=e[r+2]*l,i[a+3]=1}rbgeToHalfFloat(e,r,i,a){const o=e[r+3],l=Math.pow(2,o-128)/255;i[a+0]=Sa(e[r+0]*l),i[a+1]=Sa(e[r+1]*l),i[a+2]=Sa(e[r+2]*l),i[a+3]=Sa(1)}}let jf=`
    struct ImageSize {
        srcWidth : i32,
        srcHeight : i32,
        dstWidth : i32,
        dstHeight : i32
    };
    
    @group(0) @binding(0) var<uniform> size : ImageSize;
    @group(0) @binding(1) var<storage,read_write> faceRotation: array<vec4<f32>>;
    @group(0) @binding(2) var inputTexSampler : sampler;
    @group(0) @binding(3) var inputTex : texture_2d<f32>;
    
    @group(1) @binding(0) var<uniform> blurSetting : vec4<f32>;
    @group(1) @binding(1) var outputBuffer0 : texture_storage_2d_array<rgba16float, write>;
    
    var<private> PI: f32 = 3.14159265359;
    
    fn applyQuaternion(position:vec3<f32>, q:vec4<f32>) -> vec3<f32>{
        let x:f32 = position.x;
        let y:f32 = position.y;
        let z:f32 = position.z;
    
        let qx:f32 = q.x;
        let qy:f32 = q.y;
        let qz:f32 = q.z;
        let qw:f32 = q.w;
    
        let ix:f32 = qw * x + qy * z - qz * y;
        let iy:f32 = qw * y + qz * x - qx * z;
        let iz:f32 = qw * z + qx * y - qy * x;
        let iw:f32 = -qx * x - qy * y - qz * z;
    
        var ret: vec3<f32>;
        ret.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;
        ret.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;
        ret.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;
    
        return ret;
    }
    
    fn convertIdToDir3(uv_i32:vec2<i32>, quaternion:vec4<f32>) -> vec3<f32>{
        var uv_f32:vec2<f32> = vec2<f32>(uv_i32.xy);
        var halfSize:f32 = f32(size.dstWidth / 2);
        var worldDirection:vec3<f32> = vec3<f32>(uv_f32.x - halfSize, uv_f32.y - halfSize, -halfSize);
        worldDirection = normalize(worldDirection);
        worldDirection = applyQuaternion(worldDirection, quaternion);
        return worldDirection;
    }
    
    fn VanDerCorpus(n0:u32, base0:u32) -> f32
    {
        var n = n0;
        var base = base0;
        var invBase:f32 = 1.0 / f32(base);
        var denom:f32   = 1.0;
        var result:f32  = 0.0;
    
        for(var i:u32 = 0u; i < 32u; i = i + 1u)
        {
            if(n > 0u)
            {
                denom   = f32(n) % 2.0;
                result = result + denom * invBase;
                invBase = invBase / 2.0;
                n       = u32(f32(n) / 2.0);
            }
        }
    
        return result;
    }
    
    fn HammersleyNoBitOps(i:u32, N:u32) -> vec2<f32>
    {
        return vec2(f32(i)/f32(N), VanDerCorpus(i, 2u));
    }
    
    fn hammersley( i : u32 ,  N : u32 ) -> vec2<f32>
    {
        // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
        var bits = (i << 16u) | (i >> 16u);
        bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
        bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
        bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
        bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
        var rdi = f32(bits) * 2.3283064365386963e-10;
        return vec2<f32>(f32(i) /f32(N), rdi);
    }
    
    fn ImportanceSampleGGX( Xi:vec2<f32>, N:vec3<f32>, roughness:f32) ->vec3<f32>
    {
        var a = roughness*roughness;
    
        var phi = 2.0 * PI * Xi.x;
        var cosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a*a - 1.0) * Xi.y));
        var sinTheta = sqrt(1.0 - cosTheta*cosTheta);
    
        // from spherical coordinates to cartesian coordinates
        var H:vec3<f32>;
        H.x = cos(phi) * sinTheta;
        H.y = sin(phi) * sinTheta;
        H.z = cosTheta;
    
        // from tangent-space vector to world-space sample vector
        var up:vec3<f32>;
        if(abs(N.z) < 0.999)
        {
            up = vec3<f32>(0.0, 0.0, 1.0);
        }
        else
        {
            up = vec3<f32>(1.0, 0.0, 0.0);
        }
        var tangent:vec3<f32>  = normalize(cross(up, N));
        var bitangent:vec3<f32> = cross(N, tangent);
        var sampleVec:vec3<f32> = tangent * H.x + bitangent * H.y + N * H.z;
        return normalize(sampleVec);
    }
    
    fn multiSample(normal:vec3<f32>, roughness:f32) -> vec4<f32>
    {
        var N: vec3<f32> = normalize(normal);
        var R: vec3<f32> = N;
        var V: vec3<f32> = R;
    
        let SAMPLE_COUNT:u32 = 1024u;
        var totalWeight:f32 = 0.0;
        var prefilteredColor:vec3<f32> = vec3<f32>(0.0, 0.0, 0.0);
        for(var i:u32 = 0u; i < SAMPLE_COUNT; i = i + 1u)
        {
            var Xi:vec2<f32> = hammersley(i, SAMPLE_COUNT);
            var H :vec3<f32> = ImportanceSampleGGX(Xi, N, roughness);
            var L :vec3<f32> = normalize(2.0 * dot(V, H) * H - V);
    
            var NdotL:f32 = max(dot(N, L), 0.0);
            if(NdotL > 0.0)
            {
                var att = 1.0 ;//( f32(SAMPLE_COUNT - i) / f32(SAMPLE_COUNT)) ;
    
                prefilteredColor = prefilteredColor + sampleColor(L).rgb * NdotL;
                prefilteredColor = prefilteredColor * att ;
                totalWeight      = totalWeight + NdotL;
            }
        }
        prefilteredColor = prefilteredColor / totalWeight;
    
        return vec4<f32>(prefilteredColor, 1.0);
    }
    
    fn SampleSphericalMap(v: vec3<f32>) -> vec2<f32> {
        var uv:vec2<f32> = vec2<f32>(atan2(v.z, v.x), asin(v.y));
        //uv = (uv * (vec2<f32>(0.1590999960899353, 0.3183000087738037) + vec2<f32>(0.0010000000474974513)));
        uv = uv * vec2<f32>(0.1590999960899353, 0.3183000087738037);
        uv = uv + vec2<f32>(0.5);
        uv = clamp(uv, vec2<f32>(0.0), vec2<f32>(1.0));
        return uv;
    }
    
    fn sampleColor(d:vec3<f32>) -> vec4<f32>
    {
        let uv_f32:vec2<f32> = SampleSphericalMap(d);
        let oc = textureSampleLevel(inputTex, inputTexSampler, uv_f32 , 0.0);
        //let dir = vec3<f32>(-d.x, -d.y, d.z);
        //var oc:vec4<f32> = textureSampleLevel(cubeMap, cubeMapSampler, dir, 0.0);
        return oc;
    }
    
    @compute @workgroup_size(8, 8, 1)
    fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3<u32>) {
        let coord = vec2<i32>(GlobalInvocationID.xy);
        let quaternion = faceRotation[GlobalInvocationID.z];
        var worldDirection:vec3<f32> = convertIdToDir3(coord, quaternion);
        var oc:vec4<f32> = multiSample(worldDirection, blurSetting.x);
        textureStore(outputBuffer0, coord, i32(GlobalInvocationID.z), oc);
    }

`;class Ia{static importantSample(t,e,r,i){const a=E.device;this.pipeline==null&&(this.pipeline=a.createComputePipeline({layout:"auto",compute:{module:a.createShaderModule({code:jf}),entryPoint:"main"}}));const o=this.pipeline,l=4*4;this.configBuffer||(this.configBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.configBuffer,0,new Uint32Array([t.width,t.height,e,e]));const h=4*6;if(!this.quaternionBuffer){this.quaternionBuffer=a.createBuffer({size:h*4*6,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST});let C=new Float32Array(4*6);for(let v=0;v<6;v++){let y=jn.getRotationToFace(v);C[v*4+0]=y.x,C[v*4+1]=y.y,C[v*4+2]=y.z,C[v*4+3]=y.w}a.queue.writeBuffer(this.quaternionBuffer,0,C)}this.blurSettingBuffer||(this.blurSettingBuffer=a.createBuffer({size:l,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST})),a.queue.writeBuffer(this.blurSettingBuffer,0,new Float32Array([r,0,0,0]));const u=t.erpTexture;let c=[{binding:0,resource:{buffer:this.configBuffer,size:4*4}},{binding:1,resource:{buffer:this.quaternionBuffer,size:h*4}},{binding:2,resource:u.gpuSampler},{binding:3,resource:u.getGPUView()}],f=[{binding:0,resource:{buffer:this.blurSettingBuffer,size:4*4}},{binding:1,resource:i}];const d=a.createBindGroup({layout:o.getBindGroupLayout(0),entries:c}),p=a.createBindGroup({layout:o.getBindGroupLayout(1),entries:f}),A=S.beginCommandEncoder(),x=A.beginComputePass();x.setPipeline(o),x.setBindGroup(0,d),x.setBindGroup(1,p),x.dispatchWorkgroups(e/8,e/8,6),x.end(),S.endCommandEncoder(A)}}s(Ia,"configBuffer",null),s(Ia,"quaternionBuffer",null),s(Ia,"blurSettingBuffer",null),s(Ia,"pipeline");class el{constructor(t){s(this,"faceTextureRef");s(this,"_texture");this._texture=t,this.faceTextureRef={}}uploadTexture(t,e){let r=this.getGpuSource(t);return ya.makeTextureCube(e,this._texture.width,r.v),this}uploadErpTexture(t){let e=this.getGpuSource(0);return ya.makeTextureCube(t,this._texture.width,e.v),this.generateMipmap(t),this}getGpuSource(t){let e=this.faceTextureRef[t];return e||(e={t:this._texture.getGPUTexture(),v:this._texture.getGPUTexture().createView({format:this._texture.format,dimension:"2d-array",baseMipLevel:t,mipLevelCount:1,arrayLayerCount:6})},this.faceTextureRef[t]=e),e}generateMipmap(t){let e=1;for(;e<this._texture.mipmapCount;)this.generateMipmapAtLevel(e,t),e++}generateMipmapAtLevel(t,e,r=3){let i=this._texture.width/Math.pow(2,t),a={width:i,height:i,erpTexture:e},o=(t+1)/this._texture.mipmapCount;o=Math.pow(o,r);let l=this.getGpuSource(t);Ia.importantSample(a,i,o,l.v)}}class Do extends Eo{constructor(){super();s(this,"_url");s(this,"_faceData");this.useMipmap=!0,this.format=j.rgba16float,this.isHDRTexture=!0,this._faceData=new el(this)}createFromHDRData(e,r){let i=new pe(r.width,r.height,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),a=new Float32Array(r.array);return ya.convertRGBE2RGBA(i,a),this.createFromTexture(e,i),this}createFromTexture(e,r){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let i=this.width;for(this.mipmapCount=1;i>16;)i/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=E.device.createSampler(this),this._faceData.uploadErpTexture(r),this}load(e,r){return V(this,null,function*(){return this._url=e,(yield new Rt().load(e,$n,r)).getCubeTexture()})}}function qf(n){return new TextDecoder().decode(n)}class Mo{constructor(t,e,r,i){s(this,"buffer");s(this,"binOffset");s(this,"binLength");s(this,"header");this.buffer=t,this.binOffset=e+r,this.binLength=i;let a=null;if(r!==0){const o=new Uint8Array(t,e,r);a=JSON.parse(qf(o))}else a={};this.header=a}getKeys(){return Object.keys(this.header)}getData(t,e,r=null,i=null){const a=this.header;if(!(t in a))return null;const o=a[t];if(o instanceof Object){if(Array.isArray(o))return o;{const{buffer:l,binOffset:h,binLength:u}=this,c=o.byteOffset||0,f=o.type||i,d=o.componentType||r;if("type"in o&&i&&o.type!==i)throw new Error("FeatureTable: Specified type does not match expected type.");let p;switch(f){case"SCALAR":p=1;break;case"VEC2":p=2;break;case"VEC3":p=3;break;case"VEC4":p=4;break;default:throw new Error(`FeatureTable : Feature type not provided for "${t}".`)}let A;const x=h+c,C=e*p;switch(d){case"BYTE":A=new Int8Array(l,x,C);break;case"UNSIGNED_BYTE":A=new Uint8Array(l,x,C);break;case"SHORT":A=new Int16Array(l,x,C);break;case"UNSIGNED_SHORT":A=new Uint16Array(l,x,C);break;case"INT":A=new Int32Array(l,x,C);break;case"UNSIGNED_INT":A=new Uint32Array(l,x,C);break;case"FLOAT":A=new Float32Array(l,x,C);break;case"DOUBLE":A=new Float64Array(l,x,C);break;default:throw new Error(`FeatureTable : Feature component type not provided for "${t}".`)}if(x+C*A.BYTES_PER_ELEMENT>h+u)throw new Error("FeatureTable: Feature data read outside binary body length.");return A}}else return o}}class tl extends Mo{constructor(e,r,i,a,o){super(e,i,a,o);s(this,"batchSize");this.batchSize=r}getData(e,r=null,i=null){return super.getData(e,this.batchSize,r,i)}}function rl(n){let t;if(n instanceof DataView?t=n:t=new DataView(n),String.fromCharCode(t.getUint8(0))==="{")return null;let e="";for(let r=0;r<4;r++)e+=String.fromCharCode(t.getUint8(r));return e}class Jf{parse(t){return V(this,null,function*(){const e=new DataView(t),r=rl(e);console.assert(r==="b3dm");const i=e.getUint32(4,!0);console.assert(i===1);const a=e.getUint32(8,!0);console.assert(a===t.byteLength);const o=e.getUint32(12,!0),l=e.getUint32(16,!0),h=e.getUint32(20,!0),u=e.getUint32(24,!0),c=28,f=new Mo(t,c,o,l),d=c+o+l,p=new tl(t,f.getData("BATCH_LENGTH"),d,h,u),A=d+h+u,x=new Uint8Array(t,A,a-A);return{version:i,featureTable:f,batchTable:p,glbBytes:x}})}}const ni=class ni extends Jf{constructor(){super();s(this,"adjustmentTransform");s(this,"gltfBuffer");this.adjustmentTransform=new Q().identity(),ni.tempMatrix||(ni.tempMatrix=new Q().identity())}parse(e){return V(this,null,function*(){const r=yield cn(ni.prototype,this,"parse").call(this,e);this.gltfBuffer=r.glbBytes.slice().buffer;let i=yield new ol().parseBinary(this.gltfBuffer),{batchTable:a,featureTable:o}=r;const l=o.getData("RTC_CENTER");l&&(i.x+=l[0],i.y+=l[1],i.z+=l[2]);let h=i.getComponent(Cr);h.updateWorldMatrix();let u=ni.tempMatrix;u.compose(h.localPosition,h.localRotQuat,h.localScale),u.multiply(this.adjustmentTransform);let c=u.decompose(Gt.QUATERNION);return h.localRotQuat.copyFrom(c[1]),h.localRotQuat=h.localRotQuat,h.localPosition.copyFrom(c[0]),h.localPosition=h.localPosition,h.localScale.copyFrom(c[2]),h.localScale=h.localScale,h.updateWorldMatrix(),i.batchTable=a,i.featureTable=o,i})}static decodeText(e){if(typeof TextDecoder<"u")return new TextDecoder().decode(e);let r="";for(let i=0,a=e.length;i<a;i++)r+=String.fromCharCode(e[i]);try{return decodeURIComponent(escape(r))}catch(i){return r}}};s(ni,"tempMatrix");let vi=ni;class il extends Et{parseBuffer(t){return V(this,null,function*(){let e=new vi;e.adjustmentTransform=this.userData,this.data=yield e.parse(t)})}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}s(il,"format",at.JSON);const al="glTF",ba=12,sl={JSON:1313821514,BIN:5130562},Po={KHR_BINARY_GLTF:"KHR_binary_glTF",KHR_DRACO_MESH_COMPRESSION:"KHR_draco_mesh_compression",KHR_LIGHTS_PUNCTUAL:"KHR_lights_punctual",KHR_MATERIALS_CLEARCOAT:"KHR_materials_clearcoat",KHR_MATERIALS_IOR:"KHR_materials_ior",KHR_MATERIALS_PBR_SPECULAR_GLOSSINESS:"KHR_materials_pbrSpecularGlossiness",KHR_MATERIALS_SHEEN:"KHR_materials_sheen",KHR_MATERIALS_SPECULAR:"KHR_materials_specular",KHR_MATERIALS_TRANSMISSION:"KHR_materials_transmission",KHR_MATERIALS_UNLIT:"KHR_materials_unlit",KHR_MATERIALS_VOLUME:"KHR_materials_volume",KHR_TEXTURE_BASISU:"KHR_texture_basisu",KHR_TEXTURE_TRANSFORM:"KHR_texture_transform",KHR_MESH_QUANTIZATION:"KHR_mesh_quantization",EXT_TEXTURE_WEBP:"EXT_texture_webp",EXT_MESHOPT_COMPRESSION:"EXT_meshopt_compression"};class Zf{constructor(t){s(this,"name");s(this,"content");s(this,"body");s(this,"header");this.name=Po.KHR_BINARY_GLTF,this.content=null,this.body=null;const e=new DataView(t,0,ba);if(this.header={magic:vi.decodeText(new Uint8Array(t.slice(0,4))),version:e.getUint32(4,!0),length:e.getUint32(8,!0)},this.header.magic!==al)throw new Error("GLTFLoader: Unsupported glTF-Binary header.");if(this.header.version<2)throw new Error("GLTFLoader: Legacy binary file detected.");const r=this.header.length-ba,i=new DataView(t,ba);let a=0;for(;a<r;){const o=i.getUint32(a,!0);a+=4;const l=i.getUint32(a,!0);if(a+=4,l===sl.JSON){const h=new Uint8Array(t,ba+a,o);this.content=vi.decodeText(h)}else if(l===sl.BIN){const h=ba+a;this.body=t.slice(h,h+o)}a+=o}if(this.content===null)throw new Error("GLTFLoader: JSON content not found.")}}class ol{constructor(){s(this,"_binary")}parseBinary(t){return V(this,null,function*(){this._binary=t;const e=vi.decodeText(new Uint8Array(this._binary,0,4)),r={};let i,a;if(e===al){try{a=r[Po.KHR_BINARY_GLTF]=new Zf(this._binary)}catch(l){return}i=r[Po.KHR_BINARY_GLTF].content}else i=vi.decodeText(new Uint8Array(this._binary));const o=JSON.parse(i);return yield this.parseGLB(o,a.body)})}parseGLB(t,e){return V(this,null,function*(){return yield new To().parseJsonAndBuffer(t,e)})}}class $f{parse(t){return V(this,null,function*(){const e=new DataView(t),r=rl(e);console.assert(r==="i3dm");const i=e.getUint32(4,!0);console.assert(i===1);const a=e.getUint32(8,!0);console.assert(a===t.byteLength);const o=e.getUint32(12,!0),l=e.getUint32(16,!0),h=e.getUint32(20,!0),u=e.getUint32(24,!0);e.getUint32(28,!0);const c=32,f=new Mo(t,c,o,l),d=c+o+l,p=new tl(t,f.getData("INSTANCES_LENGTH"),d,h,u),A=d+h+u,x=new Uint8Array(t,A,a-A);return{version:i,featureTable:f,batchTable:p,glbBytes:x}})}}class ed extends ee{constructor(e,r,i){super();s(this,"_geometry");s(this,"_material");s(this,"_instanceList");this._geometry=e,this._material=r,this._instanceList=[];for(let a=0;a<i;a++){let o,l=new ee;o=l.addComponent($),o.geometry=this._geometry,o.material=this._material,this.addChild(l),this._instanceList.push(l)}}setMatrixAt(e,r){let i=this._instanceList[e],a=r.decompose(Gt.QUATERNION),o=i.transform;return o.localRotQuat.copyFrom(a[1]),o.localRotQuat=o.localRotQuat,o.localPosition.copyFrom(a[0]),o.localPosition=o.localPosition,o.localScale.copyFrom(a[2]),o.localScale=o.localScale,this}}const ve=class ve extends $f{constructor(){super();s(this,"adjustmentTransform");s(this,"_gltfBuffer");ve.tempFwd||(ve.tempFwd=new g),ve.tempUp||(ve.tempUp=new g),ve.tempRight||(ve.tempRight=new g),ve.tempPos||(ve.tempPos=new g),ve.tempQuat||(ve.tempQuat=new Z),ve.tempSca||(ve.tempSca=new g),ve.tempMat||(ve.tempMat=new Q),this.adjustmentTransform=new Q().identity()}parse(e){return V(this,null,function*(){const r=yield cn(ve.prototype,this,"parse").call(this,e);this._gltfBuffer=r.glbBytes.slice().buffer;let i=yield new ol().parseBinary(this._gltfBuffer),{batchTable:a,featureTable:o}=r;const l=this.adjustmentTransform,h=o.getData("INSTANCES_LENGTH"),u=o.getData("POSITION",h,"FLOAT","VEC3"),c=o.getData("NORMAL_UP",h,"FLOAT","VEC3"),f=o.getData("NORMAL_RIGHT",h,"FLOAT","VEC3"),d=o.getData("SCALE_NON_UNIFORM",h,"FLOAT","VEC3"),p=o.getData("SCALE",h,"FLOAT","SCALAR"),A=new Map,x=[];i.traverse(y=>{let b;if(b=y?y.getComponent($):null,b){const{geometry:B,material:I}=b,w=new ed(B,I,h);w.localPosition=w.localPosition.copy(y.localPosition),w.localRotation=w.localRotation.copy(y.localRotation),w.localScale=w.localScale.copy(y.localScale),x.push(w),A.set(y,w)}});const C=new g;for(let y=0;y<h;y++)C.x+=u[y*3+0]/h,C.y+=u[y*3+1]/h,C.z+=u[y*3+2]/h;A.forEach((y,b)=>{const B=b.parent?b.parentObject:null;B&&(B.removeChild(b),B.addChild(y),y.transform.updateWorldMatrix(),y.transform.worldMatrix.transformVector4(C,y.localPosition))});const v=ve;for(let y=0;y<h;y++){v.tempMat.identity(),v.tempPos.set(u[y*3+0]-C.x,u[y*3+1]-C.y,u[y*3+2]-C.z),c?(v.tempUp.set(c[y*3+0],c[y*3+1],c[y*3+2]),v.tempRight.set(f[y*3+0],f[y*3+1],f[y*3+2]),v.tempRight.crossProduct(v.tempUp,v.tempFwd).normalize(),v.tempMat.makeBasis(v.tempRight,v.tempUp,v.tempFwd),v.tempQuat.setFromRotationMatrix(v.tempMat)):v.tempQuat.set(0,0,0,1),p?v.tempSca.setScalar(p[y]):d?v.tempSca.set(d[y*3+0],d[y*3+1],d[y*3+2]):v.tempSca.set(1,1,1),v.tempMat.compose(v.tempPos,v.tempQuat,v.tempSca),v.tempMat.multiplyMatrices(v.tempMat,l);for(let b=0,B=x.length;b<B;b++)x[b].setMatrixAt(y,v.tempMat)}return i.batchTable=a,i.featureTable=o,i})}};s(ve,"tempFwd"),s(ve,"tempUp"),s(ve,"tempRight"),s(ve,"tempPos"),s(ve,"tempQuat"),s(ve,"tempSca"),s(ve,"tempMat");let Ro=ve;class nl extends Et{parseBuffer(t){return V(this,null,function*(){let e=new Ro;e.adjustmentTransform=this.userData,this.data=yield e.parse(t)})}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}}s(nl,"format",at.BIN);class ll extends Eo{constructor(){super();s(this,"_faceData");s(this,"_url");this.useMipmap=!0,this.format=j.rgba16float,this._faceData=new el(this)}get ldrImageUrl(){return this._url}load(e,r){return V(this,null,function*(){this._url=e;let i=new ei(!1);return yield i.load(e,r),this.createFromLDRTexture(i),this})}createFromLDRTexture(e){let r=Math.log2(e.width/4);return r=Math.pow(2,Math.round(r)),this.createFromTexture(r,e),this}createFromTexture(e,r){this.width=this.height=e,this.textureBindingLayout.viewDimension="cube";let i=this.width;for(this.mipmapCount=1;i>16;)i/=2,this.mipmapCount++;return this.createTextureDescriptor(e,e,this.mipmapCount,this.format),this.textureDescriptor.size={width:e,height:e,depthOrArrayLayers:6},this.textureDescriptor.dimension="2d",this.gpuSampler=E.device.createSampler(this),this._faceData.uploadErpTexture(r),this}}let td=`
var<private>PI: f32 = 3.141592653589793;

// fn saturate( x : f32 ) -> f32 {
//     return clamp(x, 0.0, 1.0);
// }

fn hammersley(i : u32, N : u32) -> vec2<f32>
{
    // Radical inverse based on http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html
    var bits = (i << 16u) | (i >> 16u);
    bits = ((bits & 0x55555555u) << 1u) | ((bits & 0xAAAAAAAAu) >> 1u);
    bits = ((bits & 0x33333333u) << 2u) | ((bits & 0xCCCCCCCCu) >> 2u);
    bits = ((bits & 0x0F0F0F0Fu) << 4u) | ((bits & 0xF0F0F0F0u) >> 4u);
    bits = ((bits & 0x00FF00FFu) << 8u) | ((bits & 0xFF00FF00u) >> 8u);
    var rdi = f32(bits) * 2.3283064365386963e-10;
    return vec2<f32>(f32(i) / f32(N), rdi);
}

fn G_Smith(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var k = (roughness * roughness) / 2.0;
    var GGXL = NoL / (NoL * (1.0 - k) + k);
    var GGXV = NoV / (NoV * (1.0 - k) + k);
    return GGXL * GGXV;
}

fn V_SmithGGXCorrelated(NoV: f32, NoL : f32, roughness : f32) -> f32
{
    var a2 = pow(roughness, 4.0);
    var GGXV = NoL * sqrt(NoV * NoV * (1.0 - a2) + a2);
    var GGXL = NoV * sqrt(NoL * NoL * (1.0 - a2) + a2);
    return 0.5 / (GGXV + GGXL);
}


// Based on Karis 2014
fn importanceSampleGGX(Xi: vec2<f32>, roughness: f32, N: vec3<f32>) -> vec3<f32>
{
    var a = roughness * roughness;
    // Sample in spherical coordinates
    var Phi = 2.0 * PI * Xi.x;
    var CosTheta = sqrt((1.0 - Xi.y) / (1.0 + (a * a - 1.0) * Xi.y));
    var SinTheta = sqrt(1.0 - CosTheta * CosTheta);
    // Construct tangent space vector
    var H: vec3<f32>;
    H.x = SinTheta * cos(Phi);
    H.y = SinTheta * sin(Phi);
    H.z = CosTheta;

    // Tangent to world space
    var UpVector = vec3<f32>(1.0, 0.0, 0.0);
    if (abs(N.z) < 0.999) {
        UpVector = vec3<f32>(0.0, 0.0, 1.0);
    }
    var TangentX = normalize(cross(UpVector, N));
    var TangentY = cross(N, TangentX);
    return TangentX * H.x + TangentY * H.y + N * H.z;
}


// Karis 2014
fn integrateBRDF(roughness: f32, NoV: f32) -> vec2<f32>
{
    var V: vec3<f32>;
    V.x = sqrt(1.0 - NoV * NoV); // sin
    V.y = 0.0;
    V.z = NoV; // cos

    // N points straight upwards for this integration
    var N = vec3<f32>(0.0, 0.0, 1.0);

    var A = 0.0;
    var B = 0.0;
    var numSamples = 1024u;

    for (var i = 0u; i < numSamples; i += 1u) {
        var Xi = hammersley(i, numSamples);
        // Sample microfacet direction
        var H = importanceSampleGGX(Xi, roughness, N);

        // Get the light direction
        var L = 2.0 * dot(V, H) * H - V;

        var NoL = saturate(dot(N, L));
        var NoH = saturate(dot(N, H));
        var VoH = saturate(dot(V, H));

        if (NoL > 0.0) {
            var V_pdf = V_SmithGGXCorrelated(NoV, NoL, roughness) * VoH * NoL / NoH;
            var Fc = pow(1.0 - VoH, 5.0);
            A += (1.0 - Fc) * V_pdf;
            B += Fc * V_pdf;
        }
    }

    return 4.0 * vec2<f32>(A, B) / f32(numSamples);
}

@group(0) @binding(0) var brdflutTexture: texture_storage_2d<rgba8unorm, write>;
@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(0.0);
    // Output to screen
    var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    textureStore(brdflutTexture, vec2<i32>(fragCoord.xy), fragColor);
}
`;class rd{constructor(){s(this,"compute");this.compute=new ce(td)}generateBRDFLUTTexture(){let t=new pe(256,256,j.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);this.compute.setStorageTexture("brdflutTexture",t),this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let e=S.beginCommandEncoder();return S.computeCommand(e,[this.compute]),S.endCommandEncoder(e),t}}class id extends It{constructor(){super(...arguments);s(this,"_dataBuffer")}create(e,r,i,a=!1){let o=E.device;const l=Math.ceil(e*4/256)*256;this.format=j.rgba8unorm,this.mipmapCount=Math.floor(a?Math.log2(e):1),this.createTextureDescriptor(e,r,this.mipmapCount,this.format);const h=this._dataBuffer=o.createBuffer({size:i.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});o.queue.writeBuffer(h,0,i);const u=S.beginCommandEncoder();return u.copyBufferToTexture({buffer:h,bytesPerRow:l},{texture:this.getGPUTexture()},{width:e,height:r,depthOrArrayLayers:1}),S.endCommandEncoder(u),a&&jr.webGPUGenerateMipmap(this),this}updateTexture(e,r,i){let a=E.device;const o=Math.ceil(e*4/256)*256;this.mipmapCount=Math.floor(Math.log2(e)),this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null;const l=this._dataBuffer=a.createBuffer({size:i.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,i);const h=S.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:o},{texture:this.getGPUTexture()},{width:e,height:r,depthOrArrayLayers:1}),S.endCommandEncoder(h),this.gpuSampler=a.createSampler(this),this.mipmapCount>1&&jr.webGPUGenerateMipmap(this)}}class wa{constructor(t){s(this,"id");s(this,"guiTexture");s(this,"uvRec",new ae(0,0,1,1));s(this,"uvBorder",new ae(0,0,0,0));s(this,"offsetSize",new ae(0,0,4,4));s(this,"borderSize",new ae(0,0,0,0));s(this,"trimSize",new he);s(this,"isSliced",!1);s(this,"height",4);s(this,"width",4);s(this,"xadvance",0);s(this,"xoffset",0);s(this,"yoffset",0);this.guiTexture=t||m.res.defaultGUITexture}}const Ga=class Ga{constructor(t){s(this,"_staticId",-1);s(this,"dynamicId",-1);s(this,"texture");s(this,"width",1);s(this,"height",1);t||(t=m.res.whiteTexture),t.addressModeU="clamp-to-edge",t.addressModeV="clamp-to-edge",this.texture=t,Ga._maxUid++,this._staticId=Ga._maxUid,this.init()}get staticId(){return this._staticId}init(){this.dynamicId=-1,this.width=this.texture.width,this.height=this.texture.height}};s(Ga,"_maxUid",-1);let Hi=Ga;class ad{constructor(){s(this,"fntCache",{});s(this,"fntData",{})}addFontData(t,e,r){this.fntData[`${t}${e}`]=r}getFontData(t,e){return this.fntData[`${t}${e}`]}addFnt(t,e,r,i){let a=`${t}${e}`;this.fntCache[a]||(this.fntCache[a]={}),this.fntCache[a][r]=i}getFnt(t,e,r){let i=`${t}${e}`,a=this.fntCache[i];return a?a[r]:this.fntCache[" "]}}let Ta=new ad;class sd{constructor(){s(this,"face","");s(this,"size",0);s(this,"bold",!1);s(this,"italic",!1);s(this,"stretchH",0);s(this,"spacing","");s(this,"outline",0);s(this,"lineHeight",0);s(this,"base",0);s(this,"scaleW",0);s(this,"scaleH",0);s(this,"pages",0);s(this,"packed",0);s(this,"alphaChnl",0);s(this,"redChnl",0);s(this,"greenChnl",0);s(this,"blueChnl",0);s(this,"count",0);s(this,"fontPage",[]);s(this,"fontChar",{})}}class od{constructor(){s(this,"id",0);s(this,"file","")}}class nd{constructor(){s(this,"id",-1);s(this,"x",0);s(this,"y",0);s(this,"width",0);s(this,"height",0);s(this,"xoffset",0);s(this,"yoffset",0);s(this,"xadvance",0);s(this,"page",0);s(this,"chnl",0)}}const Yr=class Yr extends Et{static parseSprite(t,e){for(const r in e.fontChar)if(Object.prototype.hasOwnProperty.call(e.fontChar,r)){const i=e.fontChar[r];let a=new wa;a.id=i.id.toString(),a.offsetSize.set(0,0,i.width,i.height),a.trimSize.set(i.width,i.height),a.width=i.width,a.height=i.height,a.xadvance=i.xadvance,a.xoffset=i.xoffset,a.yoffset=i.yoffset,a.guiTexture=t[i.page],a.uvRec.set(i.x/e.scaleW,(e.scaleH-(i.y+i.height))/e.scaleH,i.width/e.scaleW,i.height/e.scaleH),Ta.addFnt(e.face,e.size,a.id,a)}}verification(){if(this.data)return!0;throw new Error("Method not implemented.")}parseString(t){return V(this,null,function*(){let e=this.getNewLine(t),r=t,i=new sd;r.trim().split(e).forEach((a,o)=>{if(o<2)Yr.readLineProperty(a,i);else if(o<i.pages+2){let l=new od;Yr.readLineProperty(a,l),i.fontPage.push(l)}else if(o<i.pages+3)Yr.readLineProperty(a,i);else if(i.count>0){let l=new nd;Yr.readLineProperty(a,l),i.fontChar[l.id]=l,i.count--}}),r="",this.data=i,yield this.loadFontTextures()})}getNewLine(t){return t.indexOf(`\r
`)!=-1?`\r
`:t.indexOf("\r")!=-1?"\r":`
`}loadFontTextures(){return V(this,null,function*(){let t=[],e=this.data;for(const r of e.fontPage){let i=this.baseUrl+r.file;yield m.res.loadTexture(i,null,!0);let a=m.res.getTexture(i),o=new Hi(a);t.push(o)}Yr.parseSprite(t,e),e.fontChar[" "]||Yr.insertSpaceChar(e,t[0])})}static insertSpaceChar(t,e){let r=new wa,i=t.size*.5,a=t.lineHeight*.5;r.id=" ",r.offsetSize.set(0,0,t.size,t.size),r.trimSize.set(i,a),r.width=i,r.height=a,r.xadvance=0,r.xoffset=0,r.yoffset=0,r.guiTexture=e,r.uvRec.set(0,0,1e-6,1e-6),Ta.addFnt(t.face,t.size,r.id,r)}static readLineProperty(t,e){t.trim().split(" ").forEach((r,i)=>{let a=r.split("=");if(a.length>1){let o=a[0],l=a[1];Object.prototype.hasOwnProperty.call(e,o)&&(l.indexOf('"')==-1?e[o]=parseFloat(a[1]):e[o]=l.replace('"',"").replace('"',""))}})}};s(Yr,"format",at.TEXT);let Uo=Yr;function yA(n,t){let e=new wa;return e.id=n,e.offsetSize.set(0,0,t.width,t.height),e.trimSize.set(t.width,t.height),e.width=t.width,e.height=t.height,e.xadvance=0,e.xoffset=0,e.yoffset=0,e.guiTexture=new Hi(t),e.uvRec.set(0,0,1,1),t.isVideoTexture||(t.flipY=!0),e}function ld(n,t,e){let r=new wa;r.guiTexture=n,r.id=t,r.uvRec.copyFrom(e.textureRect),r.trimSize.x=e.textureRect.z,r.trimSize.y=e.textureRect.w,r.offsetSize.x=e.textureRectOffset.x,r.offsetSize.y=e.textureRectOffset.y,r.offsetSize.z=e.size.x,r.offsetSize.w=e.size.y,r.width=e.size.x,r.height=e.size.y;let i=1/n.width,a=1/n.height;r.uvRec.set(r.uvRec.x*i,r.uvRec.y*a,r.uvRec.z*i,r.uvRec.w*a);let o=.1;return e.border.x<=o&&e.border.y<=o&&e.border.z<=o&&e.border.x<=o?r.isSliced=!1:(r.borderSize.copyFrom(e.border),r.uvBorder.copyFrom(e.border),r.uvBorder.x-=e.textureRectOffset.x,r.uvBorder.y-=e.textureRectOffset.y,r.uvBorder.z=e.border.z-(e.size.x-e.textureRect.z-e.textureRectOffset.x),r.uvBorder.w=e.border.w-(e.size.y-e.textureRect.w-e.textureRectOffset.y),r.uvBorder.x/=e.textureRect.z,r.uvBorder.z/=e.textureRect.z,r.uvBorder.y/=e.textureRect.w,r.uvBorder.w/=e.textureRect.w,r.isSliced=!0),r}class hd{constructor(t){s(this,"_spriteMap",new Map);s(this,"_spriteList",[]);s(this,"textureSize",new he);s(this,"name");this.textureSize.set(t.x,t.y)}setTexture(t,e,r){let i=ld(t,e,r);return this._spriteMap.set(i.id,i),this._spriteList.push(i),i}getSprite(t){return this._spriteMap.get(t)}get spriteList(){return this._spriteList}}class hl extends Et{constructor(){super(...arguments);s(this,"_json");s(this,"_texture")}parseString(e){return V(this,null,function*(){this._json=JSON.parse(e);let r=this.userData.replace(".json",".png");this._texture=yield m.res.loadTexture(r,null,!0),this.data={json:this._json,texture:this._texture},this.parseAtlas()})}verification(){if(this.data)return!0;throw new Error("verify failed.")}parseAtlas(){let e=new hd(this._json.size),r=new Hi(this._texture),i=this._json.atlas;for(const a in i)e.setTexture(r,a,i[a]);m.res.addAtlas(this.baseUrl,e),this.data=e}}s(hl,"format",at.TEXT);class ud{constructor(){s(this,"_texturePool");s(this,"_materialPool");s(this,"_prefabPool");s(this,"_gltfPool");s(this,"_geometryPool");s(this,"_atlasList");s(this,"_obj");s(this,"normalTexture");s(this,"maskTexture");s(this,"whiteTexture");s(this,"blackTexture");s(this,"redTexture");s(this,"blueTexture");s(this,"greenTexture");s(this,"yellowTexture");s(this,"grayTexture");s(this,"defaultSky");s(this,"defaultGUITexture");s(this,"defaultGUISprite");s(this,"defaultMaterial");this._texturePool=new Map,this._materialPool=new Map,this._prefabPool=new Map,this._geometryPool=new Map,this._gltfPool=new Map,this._atlasList=new Map,this._obj=new Map}getGltf(t){return this._gltfPool.get(t)}addObj(t,e){this._obj.set(t,e)}getObj(t){return this._obj.get(t)}addTexture(t,e){this._texturePool.set(t,e)}getTexture(t){return this._texturePool.get(t)}addGeometry(t,e){this._geometryPool.set(t,e)}getGeometry(t){return this._geometryPool.get(t)}addMat(t,e){return this._materialPool.set(t,e)}getMat(t){return this._materialPool.get(t)}addPrefab(t,e){this._prefabPool.set(t,e)}getPrefab(t){return this._prefabPool.get(t).instantiate()}addAtlas(t,e){e.name=t,this._atlasList.set(t,e)}getAtlas(t){return this._atlasList.get(t)}getGUISprite(t){for(let e of this._atlasList.values()){let r=e.getSprite(t);if(r)return r}return null}load(t,e,r){return V(this,null,function*(){return(yield new Rt().load(t,e,r)).data})}loadGltf(t,e){return V(this,null,function*(){if(this._prefabPool.has(t))return this._prefabPool.get(t);let r,i=t.substring(t.lastIndexOf(".")).toLowerCase(),a=new Rt;i==".gltf"?r=yield a.load(t,Bt,e):r=yield a.load(t,To,e);let o=r.data;return this._prefabPool.set(t,o),this._gltfPool.set(t,r.gltf),o})}loadObj(t,e){return V(this,null,function*(){if(this._prefabPool.has(t))return this._prefabPool.get(t);let r,i=t.substring(t.lastIndexOf(".")).toLowerCase(),a=new Rt;i==".obj"&&(r=yield a.load(t,Wn,e));let o=r.data;return this._prefabPool.set(t,o),o})}loadB3DM(t,e,r){return V(this,null,function*(){if(this._prefabPool.has(t))return this._prefabPool.get(t);let i=(yield new Rt().load(t,il,e,r)).data;return this._prefabPool.set(t,i),i})}loadI3DM(t,e,r){return V(this,null,function*(){if(this._prefabPool.has(t))return this._prefabPool.get(t);let i=(yield new Rt().load(t,nl,e,r)).data;return this._prefabPool.set(t,i),i})}loadTexture(t,e,r){return V(this,null,function*(){if(this._texturePool.has(t))return this._texturePool.get(t);let i=new ei;return i.flipY=r,yield i.load(t,e),this._texturePool.set(t,i),i})}loadTextureCount(t,e,r,i){return V(this,null,function*(){return new Promise((a,o)=>V(this,null,function*(){let l=0,h=[];e==0&&a(h);for(let u=0;u<e;u++){const c=t.shift();this.loadTexture(c,r,i).then(f=>{h.push(f),l++,l==e&&a(h)})}}))})}loadBitmapTextures(t,e=5,r,i){return V(this,null,function*(){let a=[],o=Math.floor(t.length/e)+1,l=Math.floor(t.length%e);for(let h=0;h<o;h++){let u=yield this.loadTextureCount(t,h==o-1?l:e,r,i);a.push(...u)}return a})}loadHDRTexture(t,e){return V(this,null,function*(){if(this._texturePool.has(t))return this._texturePool.get(t);let r=new qn;return r=yield r.load(t,e),this._texturePool.set(t,r),r})}loadHDRTextureCube(t,e){return V(this,null,function*(){if(this._texturePool.has(t))return this._texturePool.get(t);let r=new Do;return r=yield r.load(t,e),this._texturePool.set(t,r),r})}loadLDRTextureCube(t,e){return V(this,null,function*(){if(this._texturePool.has(t))return this._texturePool.get(t);let r=new ll;return r=yield r.load(t,e),this._texturePool.set(t,r),r})}loadTextureCubeMaps(t){return V(this,null,function*(){let e=t[0];if(this._texturePool.has(e))return this._texturePool.get(e);let r=new Kn;return yield r.load(t),this._texturePool.set(t[0],r),r})}loadTextureCubeStd(t,e){return V(this,null,function*(){if(this._texturePool.has(t))return this._texturePool.get(t);let r=new Kn;return yield r.loadStd(t),r})}loadJSON(t,e){return V(this,null,function*(){return yield new Rt().loadJson(t,e).then(r=>V(this,null,function*(){return r})).catch(r=>{console.log(r)})})}loadFont(t,e,r){return V(this,null,function*(){let i=yield new Rt().load(t,Uo,e,r),a=i.data;return Ta.addFontData(a.face,a.size,a),i.data})}loadAtlas(t,e){return V(this,null,function*(){return(yield new Rt().load(t,hl,e,t)).data})}createTexture(t,e,r,i,a,o,l){let h=32,u=32,c=new Uint8Array(h*u*4);this.fillColor(c,t,e,r,i,a,o);let f=new id;return f.name=l,f.create(16,16,c,!0),l&&this.addTexture(l,f),f}fillColor(t,e,r,i,a,o,l){for(let h=0;h<e;h++)for(let u=0;u<r;u++){let c=u*e+h;t[c*4+0]=i,t[c*4+1]=a,t[c*4+2]=o,t[c*4+3]=l}}initDefault(){this.normalTexture=this.createTexture(32,32,255*.5,255*.5,255,255,"default-normalTexture"),this.maskTexture=this.createTexture(32,32,255,255*.5,255,255,"default-maskTexture"),this.whiteTexture=this.createTexture(32,32,255,255,255,255,"default-whiteTexture"),this.blackTexture=this.createTexture(32,32,0,0,0,255,"default-blackTexture"),this.redTexture=this.createTexture(32,32,255,0,0,255,"default-redTexture"),this.blueTexture=this.createTexture(32,32,0,0,255,255,"default-blueTexture"),this.greenTexture=this.createTexture(32,32,0,255,0,255,"default-greenTexture"),this.yellowTexture=this.createTexture(32,32,0,255,255,255,"default-yellowTexture"),this.grayTexture=this.createTexture(32,32,128,128,128,255,"default-grayTexture");let t=new rd().generateBRDFLUTTexture(),e=t.name="BRDFLUT";this.addTexture(e,t),this.defaultSky=new Do,this.defaultSky.createFromTexture(128,this.blackTexture),Ae.getInstance().attached(this.defaultSky,this),Ae.getInstance().attached(t,this),Ae.getInstance().attached(this.normalTexture,this),Ae.getInstance().attached(this.maskTexture,this),Ae.getInstance().attached(this.whiteTexture,this),Ae.getInstance().attached(this.blackTexture,this),Ae.getInstance().attached(this.redTexture,this),Ae.getInstance().attached(this.blueTexture,this),Ae.getInstance().attached(this.greenTexture,this),Ae.getInstance().attached(this.yellowTexture,this),Ae.getInstance().attached(this.grayTexture,this),this.defaultGUITexture=new Hi(this.whiteTexture),this.defaultGUISprite=new wa(this.defaultGUITexture),this.defaultGUISprite.trimSize.set(4,4),this.defaultMaterial=new Ir}}class cd extends Qt{constructor(){super(...arguments);s(this,"_postList")}init(e){this._postList=new Map}start(){}stop(){}onEnable(){this.activePost()}onDisable(){this.unActivePost()}activePost(){let e=this.transform.view3D,r=m.getRenderJob(e);this._postList.forEach(i=>{r.addPost(i)})}unActivePost(){let e=this.transform.view3D,r=m.getRenderJob(e);this._postList.forEach(i=>{r.removePost(i)})}addPost(e){if(this._postList.has(e))return;let r=new e;return this._postList.set(e,r),this._enable&&this.activePost(),r}removePost(e){if(!this._postList.has(e))return;let r=this._postList.get(e);this._postList.delete(e);let i=this.transform.view3D;m.getRenderJob(i).removePost(r)}getPost(e){return this._postList.has(e)?this._postList.get(e):null}}class m{static get frameRate(){return this._frameRate}static set frameRate(t){this._frameRate=t,this._frameRateValue=1e3/t,t>=360&&(this._frameRateValue=0)}static get size(){return E.presentationSize}static get aspect(){return E.aspect}static get width(){return E.windowWidth}static get height(){return E.windowHeight}static init(){return V(this,arguments,function*(t={}){console.log("Engine Version",nh),window.isSecureContext||console.warn("WebGPU is only supported in secure contexts (HTTPS or localhost)"),this.setting=Rr(Rr({},this.setting),t.engineSetting),yield Se.init(Q.allocCount,this.setting.doublePrecision),yield E.init(t.canvasConfig),this.setting.reflectionSetting.width=this.setting.reflectionSetting.reflectionProbeSize*6,this.setting.reflectionSetting.height=this.setting.reflectionSetting.reflectionProbeSize*this.setting.reflectionSetting.reflectionProbeMaxCount,fe.getGBufferFrame(fe.reflections_GBuffer,this.setting.reflectionSetting.width,this.setting.reflectionSetting.height,!1),H.init(),Sr.init(),re.init(),Vt.init(),Kt.init(),this.res=new ud,this.res.initDefault(),this._beforeRender=t.beforeRender,this._renderLoop=t.renderLoop,this._lateRender=t.lateRender,this.inputSystem=new oh,this.inputSystem.initCanvas(E.canvas)})}static startRenderJob(t){let e=new Zc(t);return this.renderJobs.set(t,e),this.setting.pick.mode=="pixel"&&t.scene.getOrAddComponent(cd).addPost(zn),(this.setting.pick.mode=="pixel"||this.setting.pick.mode=="bound")&&(t.enablePick=!0),e}static startRenderView(t){this.renderJobs||(this.renderJobs=new Map),this.views=[t];let e=this.startRenderJob(t);return this.resume(),e}static startRenderViews(t){this.renderJobs||(this.renderJobs=new Map),this.views=t;for(let e=0;e<t.length;e++)this.startRenderJob(t[e]);this.resume()}static getRenderJob(t){return this.renderJobs.get(t)}static pause(){this._requestAnimationFrameID!==0&&(cancelAnimationFrame(this._requestAnimationFrameID),this._requestAnimationFrameID=0)}static resume(){this._requestAnimationFrameID===0&&(this._requestAnimationFrameID=requestAnimationFrame(t=>this.render(t)))}static render(t){return V(this,null,function*(){if(this._frameRateValue>0){let e=t-this._time;if(e<this._frameRateValue){let r=performance.now();yield new Promise(i=>{setTimeout(()=>{t+=performance.now()-r,i(!0)},this._frameRateValue-e)})}this._time=t}yield this.updateFrame(t),this._requestAnimationFrameID=0,this.resume()})}static updateFrame(t){return V(this,null,function*(){me.delta=t-me.time,me.time=t,me.frame+=1,mo.tick(me.delta);let e=this.views,r=0;for(r=0;r<e.length;r++){const a=e[r];a.scene.waitUpdate();let[o,l]=E.presentationSize;a.camera.viewPort.setTo(0,0,o,l)}this._beforeRender&&(yield this._beforeRender());for(const a of Te.componentsBeforeUpdateList){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];u.enable&&c(o)}}let i=E.device.createCommandEncoder();for(const a of Te.componentsComputeList){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];u.enable&&c(o,i)}}E.device.queue.submit([i.finish()]);for(const a of Te.componentsUpdateList){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];u.enable&&c(o)}}for(const a of Te.graphicComponent){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];o&&u.enable&&c(o)}}this._renderLoop&&(yield this._renderLoop()),Se.updateAllContinueTransform(0,Q.useCount,16),re.modelMatrixBindGroup.writeBuffer(Q.useCount*16),this.renderJobs.forEach((a,o)=>{a.renderState||a.start(),a.renderFrame()});for(const a of Te.componentsLateUpdateList){let o=a[0],l=a[1];for(const h of l){let u=h[0],c=h[1];u.enable&&c(o)}}this._lateRender&&(yield this._lateRender())})}}s(m,"res"),s(m,"inputSystem"),s(m,"views"),s(m,"_frameRateValue",0),s(m,"_frameRate",360),s(m,"_time",0),s(m,"_beforeRender"),s(m,"_renderLoop"),s(m,"_lateRender"),s(m,"_requestAnimationFrameID",0),s(m,"setting",{doublePrecision:!1,occlusionQuery:{enable:!0,debug:!1},pick:{enable:!0,mode:"bound",detail:"mesh"},render:{debug:!1,renderPassState:4,renderState_left:5,renderState_right:5,renderState_split:.5,quadScale:1,hdrExposure:1.5,debugQuad:-1,maxPointLight:1e3,maxDirectLight:4,maxSportLight:1e3,drawOpMin:0,drawOpMax:Number.MAX_SAFE_INTEGER,drawTrMin:0,drawTrMax:Number.MAX_SAFE_INTEGER,zPrePass:!1,useLogDepth:!1,useCompressGBuffer:!1,gi:!1,postProcessing:{bloom:{downSampleStep:3,downSampleBlurSize:9,downSampleBlurSigma:1,upSampleBlurSize:9,upSampleBlurSigma:1,luminanceThreshole:1,bloomIntensity:1,hdr:1},globalFog:{debug:!1,enable:!1,fogType:0,fogHeightScale:.1,start:400,end:10,density:.02,ins:.5,skyFactor:.5,skyRoughness:.4,overrideSkyFactor:.8,fogColor:new K(96/255,117/255,133/255,1),falloff:.7,rayLength:200,scatteringExponent:2.7,dirHeightLine:10},godRay:{blendColor:!0,rayMarchCount:16,scatteringExponent:5,intensity:.5},ssao:{enable:!1,radius:.15,bias:-.1,aoPower:2,debug:!0},outline:{enable:!1,strength:1,groupCount:4,outlinePixel:2,fadeOutlinePixel:4,textureScale:1,useAddMode:!1,debug:!0},taa:{enable:!1,jitterSeedCount:8,blendFactor:.1,sharpFactor:.6,sharpPreBlurFactor:.5,temporalJitterScale:.13,debug:!0},gtao:{enable:!1,darkFactor:1,maxDistance:5,maxPixel:50,rayMarchSegment:6,multiBounce:!1,usePosFloat32:!0,blendColor:!0,debug:!0},ssr:{enable:!1,pixelRatio:1,fadeEdgeRatio:.2,rayMarchRatio:.5,fadeDistanceMin:600,fadeDistanceMax:2e3,roughnessThreshold:.5,powDotRN:.2,mixThreshold:.1,debug:!0},fxaa:{enable:!1},depthOfView:{enable:!1,iterationCount:3,pixelOffset:1,near:150,far:300}}},shadow:{enable:!0,type:"HARD",pointShadowBias:5e-4,shadowSize:2048,pointShadowSize:1024,shadowSoft:.005,shadowBound:100,shadowBias:.05,needUpdate:!0,autoUpdate:!0,updateFrameRate:2,csmMargin:.1,csmScatteringExp:.7,csmAreaScale:.4,debug:!1},gi:{enable:!1,offsetX:0,offsetY:0,offsetZ:0,probeSpace:64,probeXCount:4,probeYCount:2,probeZCount:4,probeSize:32,probeSourceTextureSize:2048,octRTMaxSize:2048,octRTSideSize:16,maxDistance:64*1.73,normalBias:.25,depthSharpness:1,hysteresis:.98,lerpHysteresis:.01,irradianceChebyshevBias:.01,rayNumber:144,irradianceDistanceBias:32,indirectIntensity:1,ddgiGamma:2.2,bounceIntensity:.025,probeRoughness:1,realTimeGI:!1,debug:!1,autoRenderProbe:!1},sky:{type:"HDRSKY",sky:null,skyExposure:1,defaultFar:65536,defaultNear:1},light:{maxLight:4096},material:{materialChannelDebug:!1,materialDebug:!1},loader:{numConcurrent:20},reflectionSetting:{reflectionProbeMaxCount:8,reflectionProbeSize:256,width:256*6,height:8*256,enable:!0}}),s(m,"renderJobs");let SA=null,IA=null,bA=null,wA=null,TA=function(n,t,e){var r=`

  fn ${n}(uv:vec2<f32>, n:i32, stride:vec2<f32>, sigma:f32) -> vec3<f32>
  {
      var color = vec3<f32>(0.0);
      let r:i32 = n / 2;
      var weight:f32 = 0.0;
  
      for(var i:i32=-r; i<=r; i+=1)
      {
          for(var j=-r; j<=r; j+=1)
          {
              let w = GaussWeight2D(f32(i), f32(j), sigma);
              var coord:vec2<f32> = uv + vec2<f32>(f32(i), f32(j)) * stride ;
              color += textureSampleLevel(${t}, ${e}, coord, 0.0).xyz * w;
              weight += w;
          }
      }
  
      color /= weight;
      return color;
  }`;return r},fd=null,dd=null,ul=null,gd=null,pd=null,md=null,Ad=null,vd=null,xd=null,Cd=null,_d=null,yd=`

    #include "GlobalUniform"
    #include "GBufferStand"

    struct PickResult{
        pick_meshID:f32,
        pick_meshID2:f32,
        pick_UV:vec2<f32>,

        pick_Position:vec4<f32>,
        pick_Normal:vec4<f32>,
        pick_Tangent:vec4<f32>,

        v4:vec4<f32>,
        v5:vec4<f32>,
        v6:vec4<f32>,
        v7:vec4<f32>
    }

    @group(0) @binding(2) var<storage,read_write> outBuffer: PickResult;
    const PI = 3.1415926 ;

    @compute @workgroup_size( 1 )
    fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
    {
    var result:PickResult ;
    let texSize = textureDimensions(gBufferTexture).xy;
    let screenPoint = vec2<f32>(globalUniform.mouseX/globalUniform.windowWidth,globalUniform.mouseY/globalUniform.windowHeight);

    let mouseUV = screenPoint * vec2<f32>(texSize.xy);
    let fragCoord =  vec2<i32>(i32(mouseUV.x), i32(mouseUV.y));
    var gBuffer = getGBuffer( fragCoord ) ;
    let pick_meshID = getIDFromGBuffer_i32(gBuffer);
    outBuffer.pick_meshID = f32(pick_meshID) ;
    outBuffer.pick_meshID2 = f32(pick_meshID) ;
    outBuffer.pick_Tangent = vec4<f32>(2.0,2.0,2.0,2.0) ;
    outBuffer.pick_UV = vec2<f32>(globalUniform.mouseX,globalUniform.mouseY) ;
    let wPosition = getWorldPositionFromGBuffer(gBuffer,screenPoint);
    let wNormal = getWorldNormalFromGBuffer(gBuffer);
    outBuffer.pick_Position = vec4<f32>(wPosition, 1.0) ;
    outBuffer.pick_Normal = vec4<f32>(wNormal, 1.0) ;
    }
`,EA=null,Sd=`
var<private>PI: f32 = 3.141592653589793;

fn Scatter( r:f32) -> vec3f
{
    return Gaussian(0.0064 * 1.414, r) * vec3f(0.233, 0.455, 0.649)
           + Gaussian(0.0484 * 1.414, r) * vec3f(0.100, 0.336, 0.344)
           + Gaussian(0.1870 * 1.414, r) * vec3f(0.118, 0.198, 0.000)
           + Gaussian(0.5670 * 1.414, r) * vec3f(0.113, 0.007, 0.007)
           + Gaussian(1.9900 * 1.414, r) * vec3f(0.358, 0.004, 0.00001)
           + Gaussian(7.4100 * 1.414, r) * vec3f(0.078, 0.00001, 0.00001);
}

fn Gaussian( v:f32 , r:f32 ) -> f32
{
    return 1.0 / sqrt(2.0 * PI * v) * exp(-(r * r) / (2.0 * v));
}

fn Integrate( cosTheta : f32 ,  skinRadius: f32 ) -> vec3f
{
    var theta = acos(cosTheta);  // theta -> the angle from lighting direction
    var totalWeights = vec3f(0.0);
    var totalLight = vec3f(0.0);

    var a = -(PI / 2.0);
    let inc = 0.05;

    while ( a <= (PI / 2.0) ) {
        var sampleAngle = theta + a;
        var diffuse = clamp(cos(sampleAngle),0.0,1.0);

        // calc distance
        var sampleDist = abs(2.0 * skinRadius * sin(a * 0.5));

        // estimated by Gaussian pdf
        var weights = Scatter(sampleDist);

        totalWeights += weights;
        totalLight += diffuse * weights;
        a += inc;
    }

    var result = vec3f(totalLight.x / totalWeights.x, totalLight.y / totalWeights.y, totalLight.z / totalWeights.z);
    return result;
}

@group(0) @binding(0) var sssMap: texture_storage_2d<rgba8unorm, write>;

@compute @workgroup_size(8, 8, 1)
// fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(local_invocation_id) local_invocation_id : vec3<u32> ){
fn CsMain(@builtin(global_invocation_id) global_invocation_id : vec3<u32>){
    var fragCoord = vec2<u32>(global_invocation_id.x, global_invocation_id.y);

    var fragColor = vec4<f32>(1.0,1.0,0.0,1.0);
    // // Output to screen
    // var res = integrateBRDF(f32(fragCoord.y + 1u) / 256.0, f32(fragCoord.x + 1u) / 256.0);
    // fragColor = vec4<f32>(res.x, res.y, 0.0, 1.0);

    var NDotL = mix(-1.0, 1.0, f32(fragCoord.x) / 256.0) ; 
    var oneOverR = 2.0 * 1.0 / (f32((fragCoord.y + 1u)) / 256.0);  

    //Integrate Diffuse Scattering
    var diff = Integrate(NDotL, oneOverR);
    // fragColor = vec4f(diff,1.0);
    fragColor = vec4f(vec3f(diff),1.0);
    textureStore(sssMap, vec2<i32>(fragCoord.xy), fragColor);
}
`,BA=null,Id=null,bd=null,wd=null,Td=null,Ed=null,Bd=null,Dd=null,Md=null,Pd=null,Rd=null,Ud=(n,t,e,r,i,a=1)=>{let o=0,l="",h="";h+=`
        fn acesFilm( x:vec3f) -> vec3f {
            return clamp((x*(2.51*x+vec3f(0.03)))/(x*(2.43*x+vec3f(0.59))+vec3f(0.14)),vec3f(0.0),vec3f(1.0));
        }
    `;for(let p=0;p<t.length;p++){t[p];let A=`source${p}Map`,x=`source${p}MapSampler`;l+=`
            @group(0) @binding(${(o+p)*2+0}) var ${A} : texture_2d<f32>;

            @group(0) @binding(${(o+p)*2+1}) var ${x} : sampler;
        `,h+=cl(`GaussBlur_${A}_1`,A,x),h+=cl(`GaussBlur_${A}_0`,A,x)}o+=t.length;let u="";for(let p=0;p<e.length;p++)u+=`@group(0) @binding(${(o+p)*2+0}) var dest${p}Map : texture_storage_2d<rgba16float, write>;
`;let c="";n&&(o+=e.length,l+=`@group(0) @binding(${o*2+0}) var colorMap : texture_2d<f32>;

       
        `,c+=`
            mainColor = textureLoad( colorMap ,fragCoord, 0) ;
        `);let f=`@compute @workgroup_size(${r}, ${i},${a})`,d=Ld(t.length,!!n);return`
        ${Fd}
        ${Nd}
        ${l}
        ${u}
        ${h}
        
        var<private> fragCoord: vec2<i32>;
        var<private> texSize: vec2<u32>;

        var<private> mainColor: vec4f;

        ${f}
        fn CsMain(@builtin(global_invocation_id) globalInvocation_id : vec3<u32>){
            fragCoord = vec2<i32>( globalInvocation_id.xy );
            texSize = textureDimensions(dest0Map).xy;
            if(fragCoord.x >= i32(texSize.x) || fragCoord.y >= i32(texSize.y)){
                return;
            }
            
            ${c}

            ${d}
        }
    `},Ld=(n,t)=>{let e="";for(let r=0;r<n;r++)e+=Od(`GaussBlur_source${r}Map`,`dest${r}Map`,t);return e},Od=(n,t,e)=>`
        var color = vec4<f32>(0.0, 0.0, 0.0, 1.0);
        var uv = CalcUV_01(fragCoord, texSize);
        
        // half stride
        let prev_stride = vec2<f32>(0.5) / vec2<f32>(f32(texSize.x), f32(texSize.y));
        let curr_stride = vec2<f32>(1.0) / vec2<f32>(f32(texSize.x), f32(texSize.y));

        let rgb1 = ${n}_1(uv, i32(1), prev_stride, 1.0);
        let rgb2 = ${n}_0(uv, i32(1), curr_stride, 1.0);
        color = vec4<f32>((rgb1 + rgb2) * 0.5 , color.w) ;
        // color *= 3.1415926 ;
        color = vec4f(pow(acesFilm(max(vec3f(0.),color.xyz)),vec3f(0.45)),1.) * 0.5  ;   
        ${e?"color = (color + mainColor) ;":""}
        // color = color / (1.0+color) * 2.0 ;
        textureStore(${t}, fragCoord, color );
    `,Nd=null,Fd=null,cl=function(n,t,e){var r=`
  
  fn ${n}(uv:vec2<f32>, n:i32, stride:vec2<f32>, sigma:f32) -> vec3<f32>
  {
      var color = vec3<f32>(0.0);
      let r:i32 = n / 2;
      var weight:f32 = 0.0;
  
      for(var i:i32=-r; i<=r; i+=1)
      {
          for(var j=-r; j<=r; j+=1)
          {
              let w = GaussWeight2D(f32(i), f32(j), sigma);
              var coord:vec2<f32> = uv + vec2<f32>(f32(i), f32(j)) * stride;
              // color += tex2D(tex, coord).rgb * w;
              color += textureSampleLevel(${t}, ${e}, coord, 0.0).xyz * w;
              weight += w;
          }
      }
  
      color /= weight;
      return color;
  }`;return r},DA=null,MA=null,kd=null,PA=null,zd=`
    #include "WorldMatrixUniform"
    struct VertexAttributes{
        @builtin(instance_index) index : u32,

        @location(auto) position: vec3<f32>,
        @location(auto) normal: vec3<f32>,
        @location(auto) uv: vec2<f32>,
        @location(auto) TEXCOORD_1: vec2<f32>,
        @location(auto) vIndex: f32,
        @location(auto) index2: f32,
        
    }

    struct VertexOutput {
        @location(auto) index: f32,
        @location(auto) varying_UV0: vec2<f32>,
        @location(auto) varying_UV1: vec2<f32>,
        @location(auto) varying_ViewPos: vec4<f32>,
        @location(auto) varying_Clip: vec4<f32>,
        @location(auto) varying_WPos: vec4<f32>,
        @location(auto) varying_WNormal: vec3<f32>,
        @location(auto) varying_Color: vec4<f32>,
        #if USE_SHADOWMAPING
            @location(auto) varying_ShadowPos: vec4<f32>,
        #endif
        @builtin(position) member: vec4<f32>
    };

    struct TransformVertex{
        position:vec3<f32>,
        normal:vec3<f32>,
    }

    struct GraphicNodeStruct{
        matrixIndex:f32,
        texIndex:f32,
        tex2Index:f32,
        tex3Index:f32,

        fillRotation:f32,
        empty0:f32,
        empty1:f32,
        empty2:f32,

        baseColor:vec4f,
        lineColor:vec4f,
        emissiveColor:vec4f,
        uvRect:vec4f,
        uvRect2:vec4f,
        uvSpeed:vec4f,
    }

    var<private> ORI_VertexOut: VertexOutput ;
    var<private> worldMatrix: mat4x4<f32> ;
    var<private> graphicNode: GraphicNodeStruct ;

    fn ORI_Vert(vertex:VertexAttributes){
        var vertexPosition = vertex.position;
        var vertexNormal = vertex.normal;

        ORI_VertexOut.index = f32(vertex.vIndex) ;
        graphicNode = graphicBuffer[u32(round(vertex.vIndex))];
        let node_Matrix_M = models.matrix[u32(round(graphicNode.matrixIndex))];

        #if USE_TANGENT
            ORI_VertexOut.varying_Tangent = vertex.TANGENT ;
        #endif

        ORI_MATRIX_M = node_Matrix_M * ORI_MATRIX_M ;

        #if USE_BILLBOARD
            let billboardMatrix: mat3x3<f32> = calculateBillboardMatrix2(globalUniform.CameraPos.xyz,ORI_MATRIX_M[3].xyz,globalUniform.cameraWorldMatrix[1].xyz);
            vertexPosition = billboardMatrix * vertexPosition.xyz;
        #endif

        worldMatrix = ORI_MATRIX_M ;

        let nMat = mat3x3<f32>(ORI_MATRIX_M[0].xyz,ORI_MATRIX_M[1].xyz,ORI_MATRIX_M[2].xyz) ;
        ORI_NORMALMATRIX = transpose(inverse( nMat ));

        var worldPos = (ORI_MATRIX_M * vec4<f32>(vertexPosition.xyz, 1.0));

        #if TRANSFORMVERTEX
            var transformVertex = transformVertex(worldPos.xyz,vertexNormal,vertex);
            worldPos = vec4<f32>(transformVertex.position ,worldPos.w);
            vertexNormal = transformVertex.normal ;
        #endif

        var viewPosition = ORI_MATRIX_V * worldPos;
        var clipPosition = ORI_MATRIX_P * viewPosition ;

        ORI_VertexOut.varying_UV0 = vertex.uv.xy ;
        ORI_VertexOut.varying_UV1 = vertex.TEXCOORD_1.xy;
        ORI_VertexOut.varying_ViewPos = viewPosition ;
        ORI_VertexOut.varying_Clip = clipPosition;
        ORI_VertexOut.varying_WPos = worldPos;
        ORI_VertexOut.varying_WNormal = normalize( vertexNormal.xyz);
        ORI_VertexOut.member = clipPosition ;
    }
`,RA=null,UA=null,LA=null,Gd=null,Qd=null,Vd=null,Yd=`
    #include "Common_vert"
    #include "Common_frag"
    #include "Hair_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var idMapSampler: sampler;
    @group(1) @binding(auto)
    var idMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var depthMapSampler: sampler;
    @group(1) @binding(auto)
    var depthMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var rootMapSampler: sampler;
    @group(1) @binding(auto)
    var rootMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var alphaMapSampler: sampler;
    @group(1) @binding(auto)
    var alphaMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
    struct MaterialUniform {
      transformUV1:vec4<f32>,
      transformUV2:vec4<f32>,

      baseColor0: vec4<f32>,
      baseColor1: vec4<f32>,
      emissiveColor: vec4<f32>,
      materialF0: vec4<f32>,
      specularColor: vec4<f32>,
      envIntensity: f32,
      normalScale: f32,
      roughness: f32,
      metallic: f32,

      ao: f32,
      roughness_min: f32,
      roughness_max: f32,
      metallic_min: f32,

      metallic_max: f32,
      emissiveIntensity: f32,
      alphaCutoff: f32,
      ior: f32,

      backlit: f32,
      area: f32,
    };
#endif
    
    var<private> debugOut : vec4f = vec4f(0.0) ;
    var<private> uv : vec2f = vec2f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;
        uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        ORI_ShadingInput.Roughness = materialUniform.roughness;
        ORI_ShadingInput.Metallic = materialUniform.metallic;
        

        #if USE_HAIRCOLOR
            let root = textureSample(rootMap, rootMapSampler, uv ).r ;
            ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
        #else
            #if USE_SRGB_ALBEDO
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #else 
                ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            #endif
        #endif

        fragData.Alpha = 1.0 ;
        #if USE_ALPHA_A
        // fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
            // let shake = (globalUniform.frame % 5.0) / 5.0 * 2.0 ;
            fragData.Alpha =  textureSample(alphaMap, alphaMapSampler, uv ).r ;
        #endif

        #if USE_ALPHACUT 
            if( (fragData.Alpha - materialUniform.alphaCutoff) < 0.0 ){
                #if USEGBUFFER
                    ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                    ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                #endif
                discard;
            }
        #endif

        useShadow();

        ORI_ShadingInput.Specular = 1.0 ;

        let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
        var hairNormal = HairNormal(idMap.r).rgb ;
        hairNormal = transformHairNormal( hairNormal) ;  
        ORI_ShadingInput.HairNormal = hairNormal ;

        ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

        ORI_ShadingInput.BaseColor.a = fragData.Alpha;
        
        BSSSRDFShading();
    }
`,Hd=`
#include "Common_vert"
#include "Common_frag"
#include "Hair_frag"

@group(1) @binding(auto)
var baseMapSampler: sampler;
@group(1) @binding(auto)
var baseMap: texture_2d<f32>;

@group(1) @binding(auto)
var idMapSampler: sampler;
@group(1) @binding(auto)
var idMap: texture_2d<f32>;

@group(1) @binding(auto)
var depthMapSampler: sampler;
@group(1) @binding(auto)
var depthMap: texture_2d<f32>;

@group(1) @binding(auto)
var rootMapSampler: sampler;
@group(1) @binding(auto)
var rootMap: texture_2d<f32>;

@group(1) @binding(auto)
var alphaMapSampler: sampler;
@group(1) @binding(auto)
var alphaMap: texture_2d<f32>;

#if USE_CUSTOMUNIFORM
struct MaterialUniform {
  transformUV1:vec4<f32>,
  transformUV2:vec4<f32>,

  baseColor0: vec4<f32>,
  baseColor1: vec4<f32>,
  emissiveColor: vec4<f32>,
  materialF0: vec4<f32>,
  specularColor: vec4<f32>,
  envIntensity: f32,
  normalScale: f32,
  roughness: f32,
  metallic: f32,

  ao: f32,
  roughness_min: f32,
  roughness_max: f32,
  metallic_min: f32,

  metallic_max: f32,
  emissiveIntensity: f32,
  alphaCutoff: f32,
  ior: f32,

  backlit: f32,
  area: f32,
};
#endif

var<private> debugOut : vec4f = vec4f(0.0) ;
var<private> uv : vec2f = vec2f(0.0) ;

fn vert(inputData:VertexAttributes) -> VertexOutput {
    ORI_Vert(inputData) ;
    return ORI_VertexOut ;
}

fn frag(){
    var transformUV1 = materialUniform.transformUV1;
    var transformUV2 = materialUniform.transformUV2;
    uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

    ORI_ShadingInput.Roughness = materialUniform.roughness;
    ORI_ShadingInput.Metallic = materialUniform.metallic;

    #if USE_HAIRCOLOR
        let root = textureSample(rootMap, rootMapSampler, uv ).r ;
        ORI_ShadingInput.BaseColor = mix(materialUniform.baseColor0,materialUniform.baseColor1,root)  ;
    #else
        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #else 
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
        #endif
    #endif

    fragData.Alpha = 1.0 ;
    #if USE_ALPHA_A
        fragData.Alpha =  textureSampleLevel(alphaMap, alphaMapSampler, uv , 0.0 ).r ;
    #endif

    #if USE_ALPHACUT 
        if( (((1.0 - fragData.Alpha) - (1.0 - materialUniform.alphaCutoff))) < 0.0 ){
            #if USEGBUFFER
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
            #endif
            discard;
        }
    #endif

    #if USE_SHADOWMAPING
        useShadow();
    #endif

    ORI_ShadingInput.Specular = 1.0 ;

    let idMap = textureSampleLevel(idMap, idMapSampler, uv , 0.0 );
    var hairNormal = HairNormal(idMap.r).rgb ;
    hairNormal = transformHairNormal( hairNormal) ;  
    ORI_ShadingInput.HairNormal = hairNormal ;

    ORI_ShadingInput.Normal = unPackRGNormal(vec3f(0.5,0.5,1.0),1.0,1.0) ;

    ORI_ShadingInput.BaseColor.a = fragData.Alpha;
    
    BSSSRDFShading();
}
`,OA=null,Xd=`
    #include "Common_vert"
    #include "Common_frag"
    #include "BsDF_frag"

    @group(1) @binding(auto)
    var baseMapSampler: sampler;
    @group(1) @binding(auto)
    var baseMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var normalMapSampler: sampler;
    @group(1) @binding(auto)
    var normalMap: texture_2d<f32>;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
          transformUV1:vec4<f32>,
          transformUV2:vec4<f32>,

          baseColor: vec4<f32>,
          emissiveColor: vec4<f32>,
          materialF0: vec4<f32>,
          specularColor: vec4<f32>,
          envIntensity: f32,
          normalScale: f32,
          roughness: f32,
          metallic: f32,

          ao: f32,
          roughness_min: f32,
          roughness_max: f32,
          metallic_min: f32,

          metallic_max: f32,
          emissiveIntensity: f32,
          alphaCutoff: f32,
          ior: f32,

          clearcoatColor: vec4<f32>,

          clearcoatWeight: f32,
          clearcoatFactor: f32,
          clearcoatRoughnessFactor: f32,
          skinPower: f32,
          
          skinColor: vec4<f32>,
          skinColorIns: f32,
          curveFactor: f32,
        };
    #endif
    // #if USE_ARMC
        // @group(1) @binding(auto)
        // var maskMapSampler: sampler;
        // @group(1) @binding(auto)
        // var maskMap: texture_2d<f32>;
    // #endif

    // #if USE_MR
        @group(1) @binding(auto)
        var maskMapSampler: sampler;
        @group(1) @binding(auto)
        var maskMap: texture_2d<f32>;
    // #endif

    #if USE_AOTEX
        @group(1) @binding(auto)
        var aoMapSampler: sampler;
        @group(1) @binding(auto)
        var aoMap: texture_2d<f32>;
    #endif

    @group(1) @binding(auto)
    var emissiveMapSampler: sampler;
    @group(1) @binding(auto)
    var emissiveMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var sssMapSampler: sampler;
    @group(1) @binding(auto)
    var sssMap: texture_2d<f32>;

    @group(1) @binding(auto)
    var lutMapSampler: sampler;
    @group(1) @binding(auto)
    var lutMap: texture_2d<f32>;

    var<private> debugOut : vec4f = vec4f(0.0) ;

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy; 

        #if USE_SRGB_ALBEDO
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #else
            ORI_ShadingInput.BaseColor = textureSample(baseMap, baseMapSampler, uv )  ;
            ORI_ShadingInput.BaseColor = vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a)  ;
            ORI_ShadingInput.BaseColor = vec4<f32>(gammaToLiner(ORI_ShadingInput.BaseColor.rgb) * materialUniform.baseColor.rgb, ORI_ShadingInput.BaseColor.w * materialUniform.baseColor.a)  ;
        #endif

        var maskTex = textureSample(maskMap, maskMapSampler, uv ) ;
       
        #if USE_ALPHA_A
            ORI_ShadingInput.BaseColor.a =  ORI_ShadingInput.BaseColor.a * (maskTex.a) ;
            ORI_ShadingInput.BaseColor =  vec4f(ORI_ShadingInput.BaseColor.rgb/ORI_ShadingInput.BaseColor.a,ORI_ShadingInput.BaseColor.a) ;
        #endif

        #if USE_ALPHACUT 
            if( (ORI_ShadingInput.BaseColor.a - materialUniform.alphaCutoff) <= 0.0 ){
                ORI_FragmentOutput.color = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldPos = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.worldNormal = vec4<f32>(0.0,0.0,0.0,1.0);
                ORI_FragmentOutput.material = vec4<f32>(0.0,0.0,0.0,1.0);
                discard;
            }
        #endif

        useShadow();

        // maskTex =vec4f( gammaToLiner(maskTex.rgb), maskTex.a );

        var roughnessChannel:f32 = 1.0 ;
        #if USE_ROUGHNESS_A
            roughnessChannel = maskTex.a ;
        #else if USE_ROUGHNESS_R
            roughnessChannel = maskTex.r ;
        #else if USE_ROUGHNESS_G
            roughnessChannel = maskTex.g ;
        #else if USE_ROUGHNESS_B
            roughnessChannel = maskTex.b ;
        #else if USE_ALBEDO_A
            roughnessChannel = ORI_ShadingInput.BaseColor.a ;
        #endif  

        #if USE_SMOOTH
            var roughness = ( 1.0 - roughnessChannel ) * materialUniform.roughness;
            ORI_ShadingInput.Roughness = clamp(roughness , 0.0001 , 1.0);
        #else
            ORI_ShadingInput.Roughness = clamp(roughnessChannel * materialUniform.roughness ,0.0001,1.0);
        #endif 

        var metallicChannel:f32 = 1.0 ;
        #if USE_METALLIC_A
            metallicChannel = maskTex.a ;
        #else if USE_METALLIC_R
            metallicChannel = maskTex.r ;
        #else if USE_METALLIC_G
            metallicChannel = maskTex.g ;
        #else if USE_METALLIC_B
            metallicChannel = maskTex.b ;
        #endif    
        ORI_ShadingInput.Metallic = metallicChannel * metallicChannel * materialUniform.metallic ;
   
        var aoChannel:f32 = 1.0 ;
        #if USE_AOTEX
            var aoMap = textureSample(aoMap, aoMapSampler, uv );
            aoChannel = aoMap.g ;
        #else
            #if USE_AO_A
                aoChannel = maskTex.a ;
            #else if USE_AO_R
                aoChannel = maskTex.r ;
            #else if USE_AO_G
                aoChannel = maskTex.g ;
            #else if USE_AO_B
                aoChannel = maskTex.b ;
            #endif  
        #endif

        // ORI_ShadingInput.BaseColor.a = maskTex.a ;

        ORI_ShadingInput.AmbientOcclusion = aoChannel ;

        ORI_ShadingInput.Specular = 1.0 ;

        var emissiveColor = textureSample(emissiveMap, emissiveMapSampler , ORI_VertexVarying.fragUV0.xy) ;

        emissiveColor = vec4<f32>(gammaToLiner(emissiveColor.rgb),emissiveColor.w);

        ORI_ShadingInput.EmissiveColor = vec4<f32>(materialUniform.emissiveColor.rgb * emissiveColor.rgb * materialUniform.emissiveIntensity,1.0);

     

        var Normal = textureSample(normalMap,normalMapSampler,uv).rgb ;

        let normal = unPackRGNormal(Normal,1.0,1.0) ;  
        
        ORI_ShadingInput.Normal = normal ;

        var sssColor = vec3f(pow(textureSample(sssMap, sssMapSampler, uv ).r,materialUniform.skinPower)) * materialUniform.skinColor.rgb ;
        let sunLight = lightBuffer[0] ;
        let sunLightIntensity = (sunLight.intensity )  ;
        let ndl = 1.0 - clamp(dot(normalize(normal),-normalize(sunLight.direction)),0.0,1.0) * 0.5 + 0.5 ;//1.0 - saturate( dot(normalize(normal),normalize(sunLight.direction)) ) * 0.5 + 0.5 ;
        ORI_ShadingInput.SSS += 0.5 * vec3f(sssColor * sunLightIntensity * materialUniform.skinColorIns * ndl * sunLight.lightColor.rgb ) ;
     
        var curve = clamp(materialUniform.curveFactor * (length(fwidth(ORI_ShadingInput.Normal.xyz)) / length(fwidth(ORI_VertexVarying.vWorldPos.xyz*100.0))),0.0,1.0);
        var NDotL = dot(ORI_ShadingInput.Normal, -sunLight.direction );
        var sssColor2 = textureSample(lutMap, lutMapSampler ,vec2f(NDotL * 0.5 + 0.5, materialUniform.curveFactor * sssColor.r)).rgb * sunLight.lightColor.rgb * sunLightIntensity ;
        ORI_ShadingInput.SSS = sssColor2.rgb * ORI_ShadingInput.BaseColor.rgb ;
     
        BsDFShading();

        // ORI_FragmentOutput.color = vec4f(vec3f(0.5*ORI_ShadingInput.SSS),1.0)  ;
    }
`,NA=null,FA=null,Wd=`
    // #include "Common_vert"
    #include "Common_frag"
    #include "UnLit_frag"
    #include "UnLitMaterialUniform_frag"

    #include "WorldMatrixUniform"
    #include "VertexAttributeIndexShader"
    #include "GlobalUniform"
    #include "Inline_vert"
    #include "EnvMap_frag"
    #include "ColorUtil_frag"

    const DEGREES_TO_RADIANS : f32 = 3.1415926 / 180.0 ;
    const PI : f32 = 3.1415926 ;

    #if USE_CUSTOMUNIFORM
        struct MaterialUniform {
            transformUV1:vec4<f32>,
            transformUV2:vec4<f32>,
            baseColor: vec4<f32>,
            alphaCutoff: f32,
        };
    #endif

    @group(1) @binding(0)
    var baseMapSampler: sampler;
    @group(1) @binding(1)
    var baseMap: texture_2d_array<f32>;

    @group(2) @binding(5)
    var<storage,read> graphicBuffer : array<GraphicNodeStruct>;
    
    @vertex
    fn VertMain( vertex:VertexAttributes ) -> VertexOutput {
        vertex_inline(vertex);
        vert(vertex);
        return ORI_VertexOut ;
    }

    fn vert(inputData:VertexAttributes) -> VertexOutput {
        ORI_Vert(inputData) ;
        return ORI_VertexOut ;
    }

    fn frag(){
        var transformUV1 = materialUniform.transformUV1;
        var transformUV2 = materialUniform.transformUV2;

        // var irradiance = vec3<f32>(0.0) ;
        // let MAX_REFLECTION_LOD  = f32(textureNumLevels(prefilterMap)) ;
        // irradiance += (globalUniform.skyExposure * textureSampleLevel(prefilterMap, prefilterMapSampler, ORI_VertexVarying.vWorldNormal.xyz, 0.8 * (MAX_REFLECTION_LOD) ).rgb);

        graphicNode = graphicBuffer[u32(round(ORI_VertexVarying.index))];
        
        var uv = transformUV1.zw * ORI_VertexVarying.fragUV0 + transformUV1.xy;
        //The fragUV1.x is 1.0 when the vertex belongs to line.
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            uv = graphicNode.uvRect2.zw * uv.xy + graphicNode.uvRect2.xy;
            uv += graphicNode.uvSpeed.zw * globalUniform.time;
        }else{
            uv = graphicNode.uvRect.zw * uv.xy + graphicNode.uvRect.xy;
            uv += graphicNode.uvSpeed.xy * globalUniform.time;
            let rad = graphicNode.fillRotation;
            if(rad != 0.0){
                let zrot = mat3x3<f32>(
                    cos(rad),-sin(rad),0.0,
                    sin(rad), cos(rad),0.0,
                    0.0,0.0,1.0
                );
                uv = (zrot * vec3f(uv, 0.0)).xy;
            }
        }
        var graphicTextureID = graphicNode.texIndex;
        var graphicNodeColor = graphicNode.baseColor;
        if(ORI_VertexVarying.fragUV1.x > 0.5){
            graphicTextureID = graphicNode.tex2Index;
            graphicNodeColor = graphicNode.lineColor;
        }
        var color = textureSample(baseMap,baseMapSampler,uv, u32(round(graphicTextureID)) ) * materialUniform.baseColor * graphicNodeColor ;
        // let color = textureSample(baseMap,baseMapSampler,uv, u32(round(ORI_VertexVarying.index)));

        // ORI_ViewDir = normalize( globalUniform.CameraPos.xyz - ORI_VertexVarying.vWorldPos.xyz);
        // let att = dot( ORI_ViewDir , ORI_VertexVarying.vWorldNormal.xyz );

        // irradiance = LinearToGammaSpace(irradiance.rgb) * color.rgb ;//* att ;

        color += graphicNode.emissiveColor ;
        if(color.w < materialUniform.alphaCutoff){
            discard ;
        }

        // let outColor = vec4f( color.rgb * (att * 0.5 + 0.5 ) , 1.0 ) * materialUniform.baseColor ;
        let outColor = vec4f( color.rgb , 1.0 ) * materialUniform.baseColor ;
        
        // ORI_ShadingInput.BaseColor = color  ;
        ORI_ShadingInput.BaseColor = vec4f(outColor.xyz,1.0)  ;
        UnLit();
    }
`,kA=null,fl=null;class dl{}s(dl,"cs",`
    #include 'ColorUtil_frag'
    struct UniformData {
        width: f32,
        height: f32,
        sunU: f32,
        sunV: f32,
        eyePos: f32,
        sunRadius: f32,         // = 500.0;
        sunRadiance: f32,       // = 20.0;
        mieG: f32,              // = 0.76;
        mieHeight: f32,         // = 1200;
        sunBrightness: f32,     // = 1.0;
        displaySun: f32,        // > 0.5: true
        skyColor: vec4<f32>,        // sky color
      };

      @group(0) @binding(0) var<uniform> uniformBuffer: UniformData;
      @group(0) @binding(1) var outTexture : texture_storage_2d<rgba16float, write>;

      var<private> uv01: vec2<f32>;
      var<private> fragCoord: vec2<i32>;
      var<private> texSizeF32: vec2<f32>;

      var<private> PI:f32 = 3.1415926535;
      var<private> PI_2:f32 = 0.0;
      var<private> EPSILON:f32 = 0.0000001;
      var<private> SAMPLES_NUMS:i32 = 16;

      var<private> transmittance:vec3<f32>;
      var<private> insctrMie:vec3<f32>;
      var<private> insctrRayleigh:vec3<f32>;

      @compute @workgroup_size( 8 , 8 , 1 )
      fn CsMain( @builtin(workgroup_id) workgroup_id : vec3<u32> , @builtin(global_invocation_id) globalInvocation_id : vec3<u32>)
      {
        fragCoord = vec2<i32>(globalInvocation_id.xy);
        texSizeF32 = vec2<f32>( uniformBuffer.width, uniformBuffer.height);
        uv01 = vec2<f32>(globalInvocation_id.xy) / texSizeF32;
        uv01.y = 1.0 - uv01.y - EPSILON;
        PI_2 = PI * 2.0;
        textureStore(outTexture, fragCoord , mainImage(uv01));//vec4(uv01, 0.0, 1.0));
      }

      struct ScatteringParams
      {
        sunRadius:f32,
        sunRadiance:f32,

        mieG:f32,
        mieHeight:f32,

        rayleighHeight:f32,

        waveLambdaMie:vec3<f32>,
        waveLambdaOzone:vec3<f32>,
        waveLambdaRayleigh:vec3<f32>,

        earthRadius:f32,
        earthAtmTopRadius:f32,
        earthCenter:vec3<f32>,
      }

      fn ComputeSphereNormal(coord:vec2<f32>, phiStart:f32, phiLength:f32, thetaStart:f32, thetaLength:f32) -> vec3<f32>
      {
        var normal:vec3<f32>;
        normal.x = -sin(thetaStart + coord.y * thetaLength) * sin(phiStart + coord.x * phiLength);
        normal.y = -cos(thetaStart + coord.y * thetaLength);
        normal.z = -sin(thetaStart + coord.y * thetaLength) * cos(phiStart + coord.x * phiLength);
        return normalize(normal);
      }

      fn ComputeRaySphereIntersection(position:vec3<f32>, dir:vec3<f32>, center:vec3<f32>, radius:f32) -> vec2<f32>
      {
        var origin:vec3<f32> = position - center;
        var B = dot(origin, dir);
        var C = dot(origin, origin) - radius * radius;
        var D = B * B - C;

        var minimaxIntersections:vec2<f32>;
        if (D < 0.0)
        {
          minimaxIntersections = vec2<f32>(-1.0, -1.0);
        }
        else
        {
          D = sqrt(D);
          minimaxIntersections = vec2<f32>(-B - D, -B + D);
        }

        return minimaxIntersections;
      }

      fn ComputeWaveLambdaRayleigh(lambda: vec3<f32>) -> vec3<f32>
      {
        var n:f32 = 1.0003;
        var N:f32 = 2.545E25;
        var pn:f32 = 0.035;
        var n2:f32 = n * n;
        var pi3:f32 = PI * PI * PI;
        var rayleighConst:f32 = (8.0 * pi3 * pow(n2 - 1.0,2.0)) / (3.0 * N) * ((6.0 + 3.0 * pn) / (6.0 - 7.0 * pn));
        return vec3<f32>(rayleighConst) / (lambda * lambda * lambda * lambda);
      }

      fn ComputePhaseMie(theta: f32, g:f32) -> f32
      {
        var g2 = g * g;
        return (1.0 - g2) / pow(1.0 + g2 - 2.0 * g * saturate(theta), 1.5) / (4.0 * PI);
      }

      fn ComputePhaseRayleigh(theta: f32) -> f32
      {
        var theta2 = theta * theta;
        return (theta2 * 0.75 + 0.75) / (4.0 * PI);
      }

      fn ChapmanApproximation(X: f32, h: f32, cosZenith: f32) -> f32
      {
        var c = sqrt(X + h);
        var c_exp_h = c * exp(-h);

        if (cosZenith >= 0.0)
        {
          return c_exp_h / (c * cosZenith + 1.0);
        }
        else
        {
          var x0 = sqrt(1.0 - cosZenith * cosZenith) * (X + h);
          var c0 = sqrt(x0);

          return 2.0 * c0 * exp(X - x0) - c_exp_h / (1.0 - c * cosZenith);
        }
      }

      fn GetOpticalDepthSchueler(h: f32, H: f32, earthRadius: f32, cosZenith: f32) -> f32
      {
        return H * ChapmanApproximation(earthRadius / H, h / H, cosZenith);
      }

      fn GetTransmittance(setting: ScatteringParams, L:vec3<f32>, V: vec3<f32>) -> vec3<f32>
      {
        var ch = GetOpticalDepthSchueler(L.y, setting.rayleighHeight, setting.earthRadius, V.y);
        return exp(-(setting.waveLambdaMie + setting.waveLambdaRayleigh) * ch);
      }

      fn ComputeOpticalDepth(setting: ScatteringParams, samplePoint: vec3<f32>, V: vec3<f32>, L: vec3<f32>, neg: f32) -> vec2<f32>
      {
        var rl = length(samplePoint);
        var h = rl - setting.earthRadius;
        var r: vec3<f32> = samplePoint / rl;

        var cos_chi_sun = dot(r, L);
        var cos_chi_ray = dot(r, V * neg);

        var opticalDepthSun = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_sun);
        var opticalDepthCamera = GetOpticalDepthSchueler(h, setting.rayleighHeight, setting.earthRadius, cos_chi_ray) * neg;

        return vec2<f32>(opticalDepthSun, opticalDepthCamera);
      }

      fn AerialPerspective(setting:ScatteringParams, start: vec3<f32>, end: vec3<f32>, V: vec3<f32>, L: vec3<f32>, infinite:i32)
      {
        var inf_neg:f32 = 1.0;
        if( infinite == 0){
          inf_neg = -1.0;
        }

        var sampleStep: vec3<f32> = (end - start) / f32(SAMPLES_NUMS);
        var samplePoint: vec3<f32> = end - sampleStep;
        var sampleLambda: vec3<f32> = setting.waveLambdaMie + setting.waveLambdaRayleigh + setting.waveLambdaOzone;

        var sampleLength:f32 = length(sampleStep);

        var scattering:vec3<f32> = vec3<f32>(0.0);
        var lastOpticalDepth:vec2<f32> = ComputeOpticalDepth(setting, end, V, L, inf_neg);

        for (var i:i32 = 1; i < SAMPLES_NUMS; i = i + 1)
        {
          var opticalDepth: vec2<f32> = ComputeOpticalDepth(setting, samplePoint, V, L, inf_neg);

          var segment_s: vec3<f32> = exp(-sampleLambda * (opticalDepth.x + lastOpticalDepth.x));
          var segment_t: vec3<f32> = exp(-sampleLambda * (opticalDepth.y - lastOpticalDepth.y));

          transmittance *= segment_t;

          scattering = scattering * segment_t;
          scattering += exp(-(length(samplePoint) - setting.earthRadius) / setting.rayleighHeight) * segment_s;

          lastOpticalDepth = opticalDepth;
          samplePoint = samplePoint - sampleStep;
        }

        insctrMie = scattering * setting.waveLambdaMie * sampleLength;
        insctrRayleigh = scattering * setting.waveLambdaRayleigh * sampleLength;
      }

      fn ComputeSkyboxChapman(setting: ScatteringParams, eye:vec3<f32>, V:vec3<f32>, L:vec3<f32>) -> f32
      {
        var neg:i32 = 1;
        var outerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthAtmTopRadius);
        if (outerIntersections.y < 0.0){
          return 0.0;
        }
        var innerIntersections: vec2<f32> = ComputeRaySphereIntersection(eye, V, setting.earthCenter, setting.earthRadius);
        if (innerIntersections.x > 0.0)
        {
          neg = 0;
          outerIntersections.y = innerIntersections.x;
        }

        let eye0 = eye - setting.earthCenter;

        var start : vec3<f32> = eye0 + V * max(0.0, outerIntersections.x);
        var end : vec3<f32>= eye0 + V * outerIntersections.y;

        AerialPerspective(setting, start, end, V, L, neg);

        //bool intersectionTest = innerIntersections.x < 0.0 && innerIntersections.y < 0.0;
        //return intersectionTest ? 1.0 : 0.0;

        if(innerIntersections.x < 0.0 && innerIntersections.y < 0.0){
          return 1.0;
        }
        return 0.0;
      }

      fn ComputeSkyInscattering(setting: ScatteringParams, eye: vec3<f32>, V: vec3<f32>, L: vec3<f32>) -> vec4<f32>
      {
        transmittance = vec3<f32>(1.0);
        insctrMie = vec3<f32>(0.0);
        insctrRayleigh = vec3<f32>(0.0);
        var intersectionTest:f32 = ComputeSkyboxChapman(setting, eye, V, L);

        var phaseTheta = dot(V, L);
        var phaseMie = ComputePhaseMie(phaseTheta, setting.mieG);
        var phaseRayleigh = ComputePhaseRayleigh(phaseTheta);
        var phaseNight = 1.0 - saturate(transmittance.x * EPSILON);

        var insctrTotalMie: vec3<f32> = insctrMie * phaseMie;
        var insctrTotalRayleigh: vec3<f32> = insctrRayleigh * phaseRayleigh;

        var sky: vec3<f32> = (insctrTotalMie + insctrTotalRayleigh) * setting.sunRadiance;
        if(uniformBuffer.displaySun > 0.5){
          var angle:f32 = clamp((1.0 - phaseTheta) * setting.sunRadius, 0.0000001, 0.9999999);
          var cosAngle:f32 = cos(angle * PI * 0.5);
          var edge:f32 = 0.0;
          if(angle >= 0.9){
            edge = smoothstep(0.9, 1.0, angle);
          }

          var limbDarkening: vec3<f32> = GetTransmittance(setting, -L, V);
          limbDarkening *= pow(vec3<f32>(cosAngle), vec3<f32>(0.420, 0.503, 0.652)) * mix(vec3<f32>(1.0), vec3<f32>(1.2,0.9,0.5), edge) * intersectionTest;
          sky += limbDarkening * uniformBuffer.sunBrightness; 
        }
        return vec4<f32>(sky, phaseNight * intersectionTest);
      }

      fn TonemapACES(x: vec3<f32>) -> vec3<f32>
      {
        var A:f32 = 2.51f;
        var B:f32 = 0.03f;
        var C:f32 = 2.43f;
        var D:f32 = 0.59f;
        var E:f32 = 0.14f;
        return (x * (A * x + B)) / (x * (C * x + D) + E);
      }

      fn noise(uv:vec2<f32>) -> f32
      {
        return fract(dot(sin(vec3<f32>(uv.xyx) * vec3<f32>(uv.xyy) * 1024.0), vec3<f32>(341896.483, 891618.637, 602649.7031)));
      }

      fn mainImage( uv:vec2<f32> ) -> vec4<f32>
      {
        let eyePosition = uniformBuffer.eyePos;
        var sun = vec2<f32>(uniformBuffer.sunU, uniformBuffer.sunV);
        var V: vec3<f32> = ComputeSphereNormal(uv, 0.0, PI_2, 0.0, PI);
        var L: vec3<f32> = ComputeSphereNormal(vec2<f32>(sun.x, sun.y), 0.0, PI_2, 0.0, PI);

        var setting: ScatteringParams;
        setting.sunRadius = uniformBuffer.sunRadius;//500.0;
        setting.sunRadiance = uniformBuffer.sunRadiance;//20.0;
        setting.mieG = uniformBuffer.mieG;//0.76;
        setting.mieHeight = uniformBuffer.mieHeight;// 1200.0;
        setting.rayleighHeight = 8000.0;
        setting.earthRadius = 6360000.0;
        setting.earthAtmTopRadius = 6420000.0;
        setting.earthCenter = vec3<f32>(0, -setting.earthRadius, 0);
        setting.waveLambdaMie = vec3<f32>(0.0000002);

        // wavelength with 680nm, 550nm, 450nm
        setting.waveLambdaRayleigh = ComputeWaveLambdaRayleigh(vec3<f32>(0.000000680, 0.000000550, 0.000000450));

        // see https://www.shadertoy.com/view/MllBR2
        setting.waveLambdaOzone = vec3<f32>(1.36820899679147, 3.31405330400124, 0.13601728252538)* 0.0000006 * 2.504;

        var eye:vec3<f32> = vec3<f32>(0,eyePosition,0);
        var sky0:vec4<f32> = ComputeSkyInscattering(setting, eye, V, L);
        var sky = vec3<f32>(sky0.rgb);

        sky = TonemapACES(sky.rgb * 2.0);
        sky = pow(sky.rgb, vec3<f32>(1.0/1.2)); // gamma

        var fragColor:vec4<f32> = vec4<f32>((sky.rgb), 1.0);
        return fragColor;
      }
    `);class Kd{constructor(){s(this,"sunRadius",500);s(this,"sunRadiance",11);s(this,"mieG",.76);s(this,"mieHeight",1200);s(this,"eyePos",1500);s(this,"sunX",.71);s(this,"sunY",.56);s(this,"sunBrightness",1);s(this,"displaySun",!0);s(this,"defaultTextureCubeSize",512);s(this,"defaultTexture2DSize",1024);s(this,"skyColor",new K(1,1,1,1))}}class jd extends ll{constructor(e){super();s(this,"_internalTexture");s(this,"_cubeSize");s(this,"setting");return this.setting=e,this._cubeSize=e.defaultTextureCubeSize,this._internalTexture=new qd(e.defaultTexture2DSize,e.defaultTexture2DSize*.5),this._internalTexture.update(this.setting),this.createFromTexture(this._cubeSize,this._internalTexture),this}get texture2D(){return this._internalTexture}apply(){return this._internalTexture.update(this.setting),this._faceData.uploadErpTexture(this._internalTexture),this}}class qd extends pe{constructor(e,r){super(e,r,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);s(this,"_computeShader");s(this,"_uniformBuffer");this.initCompute(e,r)}initCompute(e,r){this._uniformBuffer=new Ct(16*4),this._uniformBuffer.apply(),this._computeShader=new ce(dl.cs),this._computeShader.setUniformBuffer("uniformBuffer",this._uniformBuffer),this._computeShader.setStorageTexture("outTexture",this),this._computeShader.workerSizeX=e/8,this._computeShader.workerSizeY=r/8}update(e){this._uniformBuffer.setFloat("width",this.width),this._uniformBuffer.setFloat("height",this.height),this._uniformBuffer.setFloat("sunU",e.sunX),this._uniformBuffer.setFloat("sunV",e.sunY),this._uniformBuffer.setFloat("eyePos",e.eyePos),this._uniformBuffer.setFloat("sunRadius",e.sunRadius),this._uniformBuffer.setFloat("sunRadiance",e.sunRadiance),this._uniformBuffer.setFloat("mieG",e.mieG),this._uniformBuffer.setFloat("mieHeight",e.mieHeight),this._uniformBuffer.setFloat("sunBrightness",e.sunBrightness),this._uniformBuffer.setFloat("displaySun",e.displaySun?1:0),this._uniformBuffer.setColor("skyColor",e.skyColor),this._uniformBuffer.apply();let r=S.beginCommandEncoder();return S.computeCommand(r,[this._computeShader]),S.endCommandEncoder(r),this}}var Jd=Object.defineProperty,Zd=Object.getOwnPropertyDescriptor,$d=(n,t,e,r)=>{for(var i=r>1?void 0:r?Zd(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Jd(t,e,i),i};let Lo=class extends gt{constructor(){super();let n=new Le("sky_vs_frag_wgsl","sky_fs_frag_wgsl");this.addRenderPass(n),n.setUniformVector3("eyesPos",new g),n.setUniformFloat("exposure",1),n.setUniformFloat("roughness",0);let t=n.shaderState;t.frontFace="ccw",t.cullMode=Pt.front,t.depthWriteEnabled=!1,t.depthCompare=ct.less_equal}};Lo=$d([ci],Lo);class eg extends $r{constructor(){super(),this.shader=new Lo,this.shader.setUniformVector3("eyesPos",new g),this.shader.setUniformFloat("exposure",1),this.shader.setUniformFloat("roughness",0)}set baseMap(t){this.setTexture("baseMap",t);const e="IS_HDR_SKY";this._shader.getDefaultShaders()[0].defineValue[e]!=(t==null?void 0:t.isHDRTexture)&&this._shader.setDefine(e,!!(t!=null&&t.isHDRTexture))}get baseMap(){return this._shader.getDefaultColorShader().getTexture("baseMap")}set envMap(t){}set shadowMap(t){}get exposure(){return m.setting.sky.skyExposure}set exposure(t){m.setting.sky.skyExposure=t}get roughness(){return this._shader.getDefaultColorShader().uniforms.roughness.value}set roughness(t){let e=this._shader.getDefaultColorShader();"roughness"in e.uniforms&&(e.uniforms.roughness.value=t)}}class Ea extends qt{constructor(e,r,i,a,o,l,h){super();s(this,"shape_vertices",[]);s(this,"shape_indices",[]);s(this,"radius");s(this,"widthSegments");s(this,"heightSegments");s(this,"phiStart");s(this,"phiLength");s(this,"thetaStart");s(this,"thetaLength");this.radius=e,this.widthSegments=r,this.heightSegments=i,this.phiStart=a,this.phiLength=o,this.thetaStart=l,this.thetaLength=h,this.buildGeometry()}buildGeometry(){var e,r,i=0;let a=this.heightSegments,o=this.widthSegments,l=this.radius;var h=(a+1)*(o+1);let u=new Float32Array(h*3),c=new Float32Array(h*3),f=new Float32Array(h*2),d=new Uint16Array(o*a*2*3),p=0,A=0,x=0;for(r=0;r<=a;++r){var C=Math.PI*r/a,v=l*Math.cos(C),y=l*Math.sin(C);for(e=0;e<=o;++e){var b=2*Math.PI*e/o,B=y*Math.cos(b),I=y*Math.sin(b),w=1/Math.sqrt(B*B+v*v+I*I);if(u[p++]=B,u[p++]=v,u[p++]=I,c[A++]=B*w,c[A++]=v*w,c[A++]=I*w,f[x++]=e/o,f[x++]=r/a,e>0&&r>0){var D=(o+1)*r+e,L=(o+1)*r+e-1,M=(o+1)*(r-1)+e-1,G=(o+1)*(r-1)+e;r==a?(d[i++]=D,d[i++]=M,d[i++]=G):r==1?(d[i++]=D,d[i++]=L,d[i++]=M):(d[i++]=D,d[i++]=L,d[i++]=M,d[i++]=D,d[i++]=M,d[i++]=G)}}}this.setIndices(d),this.setAttribute(O.position,u),this.setAttribute(O.normal,c),this.setAttribute(O.uv,f),this.setAttribute(O.TEXCOORD_1,f),this.addSubGeometry({indexStart:0,indexCount:d.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0}),this.bounds=new Oe(g.ZERO,new g(this.radius*2,this.radius*2,this.radius*2))}}class tg extends Aa{constructor(){super(...arguments);s(this,"gid",0);s(this,"needUpdate",!0);s(this,"autoUpdate",!1);s(this,"radius",500)}init(){super.init(),this.addRendererMask(ye.Reflection),this.alwaysRender=!0,this.object3D.bound=new Oe(g.ZERO.clone(),g.MAX),qs(this.transform.onPositionChange,()=>{this.needUpdate=!0})}onEnable(){X.instance.addRenderNode(this.transform.scene3D,this)}onDisable(){X.instance.removeRenderNode(this.transform.scene3D,this)}renderPass2(e,r,i,a,o,l=!1){super.renderPass2(e,r,i,a,o,l)}}class rg extends gt{constructor(){super();let t=new Le("ReflectionShader_shader","ReflectionShader_shader");t.setShaderEntry("VertMain","FragMain"),this.addRenderPass(t);let e=t.shaderState;e.acceptShadow=!1,e.castShadow=!1,e.receiveEnv=!1,e.acceptGI=!1,e.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new ae(0,0,1,1)),this.setUniformVector4("transformUV2",new ae(0,0,1,1)),this.setUniformColor("baseColor",new K),this.setUniformFloat("alphaCutoff",0)}set _MainTex(t){this.setTexture("baseMap",t)}set _BumpMap(t){this.setTexture("normalMap",t)}set _MaskTex(t){this.setTexture("maskMap",t)}set _UVTransform(t){this.setUniformVector4("transformUV1",t)}set _Metallic(t){this.setUniformFloat("metallic",t)}set _Roughness(t){this.setUniformFloat("roughness",t)}set _MainColor(t){this.setUniformColor("baseColor",t)}set _AlphaCutoff(t){this.setUniformFloat("alphaCutoff",t)}set _DoubleSidedEnable(t){let e=this.getDefaultColorShader();e.shaderState.cullMode=t?Pt.none:e.shaderState.cullMode}set _SurfaceType(t){let e=this.getDefaultColorShader();t==0?e.blendMode=oe.NONE:e.blendMode=oe.ALPHA}set _AlphaCutoffEnable(t){t==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}}class ig extends $r{constructor(){super(),this.shader=new rg,this.baseMap=m.res.whiteTexture,this.setDefine("USE_CUSTOMUNIFORM",!0),this.reflectionIndex=0}set baseMap(t){this.shader.setTexture("baseMap",t)}get baseMap(){return this.shader.getTexture("baseMap")}set baseColor(t){this.shader.setUniformColor("baseColor",t)}set reflectionIndex(t){this.shader.setUniformFloat("reflectionIndex",t)}get baseColor(){return this.shader.getUniformColor("baseColor")}set envMap(t){}set shadowMap(t){}}class Ss{constructor(t,e){s(this,"center",new g);s(this,"extents");s(this,"max");s(this,"min");s(this,"size");s(this,"tmpVecA",new g);s(this,"tmpVecB",new g);s(this,"tmpVecC",new g);s(this,"tmpVecD",new g);s(this,"radius",0);s(this,"diffBetweenPoints",new g);s(this,"owner");s(this,"forward",new g(0,0,1));s(this,"worldCenter");s(this,"worldSize");s(this,"_center",new g);this.center=t||new g(0,0,0),this.radius=e===void 0?.5:e}updateBound(){throw new Error("Method not implemented.")}containsPoint(t){var e=this.tmpVecA.subtract(t,this.center).lengthSquared,r=this.radius;return e<r*r}intersectsRay(t,e){var r=this.tmpVecA.copyFrom(t.origin).subtract(this.center),i=r.dotProduct(this.tmpVecB.copyFrom(t.direction).normalize()),a=r.dotProduct(r)-this.radius*this.radius;if(a>0&&i>0)return null;var o=i*i-a;if(o<0)return!1;var l=Math.abs(-i-Math.sqrt(o));return e&&e.copyFrom(t.direction).scaleBy(l).add(t.origin),!0}intersectsBoundingSphere(t){this.tmpVecA.subtract(t.center,this.center);var e=t.radius+this.radius;return this.tmpVecA.lengthSquared<=e*e}calculateTransform(t){this.update(t)}inFrustum(t,e){return e.containsSphere(t)}clone(){return new Ss(this.center.clone(),this.radius)}update(t){this.owner=t,this._center.add(t.transform.worldMatrix.position,this.center),this.forward=t.transform.forward}merge(t){throw new Error("BoundingSphere merge is not ready!")}setFromCenterAndSize(t,e){this.center.copy(t),this.radius=e}}class ag extends tg{init(){super.init(),this.castShadow=!1,this.castGI=!1,this.addRendererMask(ye.Reflection),this.alwaysRender=!0,this.object3D.bound=new Ss(g.ZERO.clone(),this.radius)}debug(t,e=1){let r=new ee,i=r.addComponent($);i.addMask(ye.ReflectionDebug),i.geometry=new Ea(25,30,30);let a=m.setting.reflectionSetting,o=fe.getGBufferFrame(fe.reflections_GBuffer,a.width,a.height),l=new ig;l.reflectionIndex=t,l.baseMap=o.getCompressGBufferTexture(),i.material=l,this.object3D.addChild(r),r.scaleX=e,r.scaleY=e,r.scaleZ=e}onEnable(){super.onEnable()}onDisable(){super.onDisable()}renderPass2(t,e,r,i,a,o=!1){super.renderPass2(t,e,r,i,a,o)}}class Oo extends ${constructor(){super(...arguments);s(this,"skyMaterial")}init(){super.init(),this.castShadow=!1,this.castGI=!0,this.addRendererMask(ye.Sky),this.alwaysRender=!0,this.object3D.bound=new Oe(g.ZERO.clone(),g.MAX),this.geometry=new Ea(m.setting.sky.defaultFar,20,20),this.skyMaterial||(this.skyMaterial=new eg)}onEnable(){this._readyPipeline?(this.castNeedPass(),!this._inRenderer&&this.transform.scene3D&&(X.instance.sky=this,this._inRenderer=!0)):this.initPipeline()}onDisable(){this._inRenderer&&this.transform.scene3D&&(this._inRenderer=!1,X.instance.sky=null),super.onDisable()}nodeUpdate(e,r,i,a){super.nodeUpdate(e,r,i,a)}renderPass2(e,r,i,a,o,l=!1){super.renderPass2(e,r,i,a,o,l)}set map(e){this.skyMaterial.baseMap=e,this.skyMaterial.name==null&&(this.skyMaterial.name="skyMaterial"),this.material=this.skyMaterial}get map(){return this.skyMaterial.baseMap}get exposure(){return this.skyMaterial.exposure}set exposure(e){this.skyMaterial&&(this.skyMaterial.exposure=e)}get roughness(){return this.skyMaterial.roughness}set roughness(e){this.skyMaterial&&(this.skyMaterial.roughness=e)}useSkyReflection(){let e=new ee,r=e.addComponent(ag);r.autoUpdate=!1,e.x=0,e.y=300,e.z=0,this.object3D.addChild(e)}}class sg{constructor(){s(this,"rotateX");s(this,"rotateY");s(this,"sunX");s(this,"sunY");this.reset()}reset(){return this.rotateX=this.rotateY=this.sunX=this.sunY=Number.MAX_VALUE,this}isRotateChange(t,e){return Math.abs(this.rotateX-t)>=.001||Math.abs(this.rotateY-e)>=.001}isSkyChange(t,e){return Math.abs(this.sunX-t)>=.001||Math.abs(this.sunY-e)>=.001}save(t,e,r,i){return this.sunX=t,this.sunY=e,this.rotateX=r,this.rotateY=i,this}}class og extends Oo{constructor(){super(...arguments);s(this,"_atmosphericScatteringSky");s(this,"_onChange",!0);s(this,"_relatedTransform");s(this,"_historyData")}get sunX(){return this._atmosphericScatteringSky.setting.sunX}set sunX(e){this._atmosphericScatteringSky.setting.sunX!=e&&(this._atmosphericScatteringSky.setting.sunX=e,this._onChange=!0)}get sunY(){return this._atmosphericScatteringSky.setting.sunY}set sunY(e){this._atmosphericScatteringSky.setting.sunY!=e&&(this._atmosphericScatteringSky.setting.sunY=e,this._onChange=!0)}get eyePos(){return this._atmosphericScatteringSky.setting.eyePos}set eyePos(e){this._atmosphericScatteringSky.setting.eyePos!=e&&(this._atmosphericScatteringSky.setting.eyePos=e,this._onChange=!0)}get sunRadius(){return this._atmosphericScatteringSky.setting.sunRadius}set sunRadius(e){this._atmosphericScatteringSky.setting.sunRadius!=e&&(this._atmosphericScatteringSky.setting.sunRadius=e,this._onChange=!0)}get sunRadiance(){return this._atmosphericScatteringSky.setting.sunRadiance}set sunRadiance(e){this._atmosphericScatteringSky.setting.sunRadiance!=e&&(this._atmosphericScatteringSky.setting.sunRadiance=e,this._onChange=!0)}get sunBrightness(){return this._atmosphericScatteringSky.setting.sunBrightness}set sunBrightness(e){this._atmosphericScatteringSky.setting.sunBrightness!=e&&(this._atmosphericScatteringSky.setting.sunBrightness=e,this._onChange=!0)}get displaySun(){return this._atmosphericScatteringSky.setting.displaySun}set displaySun(e){this._atmosphericScatteringSky.setting.displaySun!=e&&(this._atmosphericScatteringSky.setting.displaySun=e,this._onChange=!0)}init(){super.init(),this._historyData=new sg,this._atmosphericScatteringSky=new jd(new Kd);let e=this.transform.view3D,r=this.transform.scene3D;this.map=this._atmosphericScatteringSky,r.envMap=this._atmosphericScatteringSky,this.onUpdate(e)}start(e){let r=this.transform.scene3D;this.map=this._atmosphericScatteringSky,r.envMap=this._atmosphericScatteringSky,super.start()}get relativeTransform(){return this._relatedTransform}set relativeTransform(e){this._relatedTransform=e,this._historyData.reset()}onUpdate(e){this._relatedTransform&&(this._relatedTransform.rotationZ=0,this._historyData.isRotateChange(this._relatedTransform.rotationX,this._relatedTransform.rotationY)?(this.sunX=(this._relatedTransform.rotationY+90)/360,this.sunY=this._relatedTransform.rotationX/180+.5):this._historyData.isSkyChange(this.sunX,this.sunY)&&(this._relatedTransform.rotationY=this.sunX*360-90,this._relatedTransform.rotationX=(this.sunY-.5)*180),this._historyData.save(this.sunX,this.sunY,this._relatedTransform.rotationX,this._relatedTransform.rotationY)),this._onChange&&(this._onChange=!1,this._atmosphericScatteringSky.apply())}destroy(e){super.destroy(e),this._atmosphericScatteringSky.destroy(),this._atmosphericScatteringSky=null,this._onChange=null}}class Zt{}s(Zt,"panelRatio",1),s(Zt,"quadMaxCountForWorld",256),s(Zt,"quadMaxCountForView",2048),s(Zt,"SortOrderStartWorld",7e3),s(Zt,"SortOrderStartView",8e3),s(Zt,"SortOrderCanvasSpan",1e4);var lr=(n=>(n[n.View=0]="View",n[n.World=2]="World",n))(lr||{}),Ba=(n=>(n[n.Simple=0]="Simple",n[n.Sliced=1]="Sliced",n[n.Tiled=2]="Tiled",n[n.Filled=3]="Filled",n))(Ba||{}),xi=(n=>(n[n.None=0]="None",n[n.BillboardY=9]="BillboardY",n[n.BillboardXYZ=10]="BillboardXYZ",n))(xi||{});class Is extends Qt{constructor(){super();s(this,"type");s(this,"camera");s(this,"_cameraPosition");this._cameraPosition=new g}onUpdate(){this.enable&&this.transform.view3D.camera&&this.updateBillboardMatrix()}updateBillboardMatrix(){let e=this.transform.view3D.camera;this._cameraPosition.copyFrom(e.transform.back),this.type==xi.BillboardXYZ||this.type==xi.BillboardY&&(this._cameraPosition.y=0),this._cameraPosition.normalize(),this._cameraPosition.add(this.object3D.localPosition,this._cameraPosition),this.transform.lookAt(this.object3D.localPosition,this._cameraPosition,e.transform.up)}cloneTo(e){let r=e.addComponent(Is);r.type=this.type}}var Da=(n=>(n[n.None=0]="None",n[n.Box=1]="Box",n[n.Capsule=2]="Capsule",n[n.Sphere=3]="Sphere",n[n.Mesh=4]="Mesh",n))(Da||{});const Ot=class Ot{constructor(){s(this,"_center");s(this,"_size");s(this,"_halfSize");s(this,"_shapeType",0);Ot.v3_help_0||(Ot.v3_help_0=new g),Ot.helpMatrix||(Ot.helpMatrix=new Q),Ot.helpRay||(Ot.helpRay=new mi),this._center=new g,this._size=new g,this._halfSize=new g}get shapeType(){return this._shapeType}setFromCenterAndSize(t,e){return t&&this._center.copy(t),e&&this._size.copy(e),this}get center(){return this._center}set center(t){this._center.copy(t)}get size(){return this._size}set size(t){this._size.copy(t),this._halfSize.copy(t).multiplyScalar(.5)}get halfSize(){return this._halfSize}rayPick(t,e){return null}};s(Ot,"v3_help_0"),s(Ot,"helpMatrix"),s(Ot,"helpRay");let $t=Ot;class Ma extends null{constructor(){super();s(this,"_pickRet");s(this,"box");this._shapeType=Da.Box,this.box=new Oe(new g,new g)}rayPick(e,r){this.box.setFromCenterAndSize(this.center,this.size);let i=$t.helpMatrix;i.copyFrom(r).invert();let a=$t.helpRay.copy(e);a.applyMatrix(i);let o=a.intersectBox(this.box,$t.v3_help_0);return o?(this._pickRet||(this._pickRet={intersectPoint:new g,distance:0}),this._pickRet.intersectPoint=o,this._pickRet.distance=g.distance(a.origin,$t.v3_help_0),this._pickRet):null}}class hr extends null{constructor(){super();s(this,"_shape");this._shape=new Ma}start(){m.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.set(this.transform.worldMatrix.index,this)}onEnable(e){Te.bindEnablePick(e,this,null)}onDisable(e){Te.unBindEnablePick(e,this)}get shape(){return this._shape}set shape(e){this._shape=e}rayPick(e){return this._enable?this._shape.rayPick(e,this.transform.worldMatrix):null}beforeDestroy(e){m.setting.pick.mode=="pixel"&&this.transform.scene3D.view.pickFire.mouseEnableMap.delete(this.transform.worldMatrix.index),super.beforeDestroy(e)}}class ng{constructor(t){s(this,"loop",!0);s(this,"speed",1);s(this,"t",0);s(this,"time",0);s(this,"weight",0);s(this,"currFrame",0);s(this,"lastFrame",-1);s(this,"nextFrame",0);s(this,"clip");s(this,"animation");s(this,"_isEnd",!1);s(this,"_currSkeletonPose");this.clip=t,this._currSkeletonPose=new Cs(this.clip.skeleton)}reset(){this.time=0,this.weight=0,this._isEnd=!1}get name(){return this.clip.name}get currSkeletonPose(){return this._currSkeletonPose}update(t){this.time=(this.time+t*this.speed)%this.clip.totalTime;let e=this.time/this.clip.frameRate;if(this.currFrame=Math.trunc(e),this.t=e-this.currFrame,this.currFrame<0&&(this.currFrame=this.clip.numFrame+this.currFrame),this.time>=0?this.nextFrame=(this.currFrame+1)%this.clip.numFrame:(this.nextFrame=this.currFrame-1,this.nextFrame<0&&(this.nextFrame=this.clip.numFrame+this.nextFrame),this.t=1-this.t),this._isEnd)this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1;else if(this.currFrame!=this.lastFrame){let a=this.speed<0?0:this.clip.numFrame;this.currFrame==a&&(this.loop?(this.currFrame=0,this.nextFrame=1,this.time=this.t=0):(this.currFrame=this.nextFrame=this.speed<0?0:this.clip.numFrame-1,this._isEnd=!0));var r=this.clip.getEvents();if(r)for(let o of r){var i=Math.floor(o.time/this.clip.frameRate);if(i=Math.min(i,this.clip.numFrame),i=Math.max(i,0),i==this.currFrame){o.skeletonAnimation=this.animation,this.animation.eventDispatcher.dispatchEvent(o);break}}this.lastFrame=this.currFrame}this.clip.getLerpSkeletonPose(this.currFrame,this.nextFrame,this.t,this._currSkeletonPose)}}var lg=Object.defineProperty,hg=Object.getOwnPropertyDescriptor,ug=(n,t,e,r)=>{for(var i=r>1?void 0:r?hg(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&lg(t,e,i),i};let Ci=class extends Qt{constructor(){super();s(this,"isPlaying",!0);s(this,"timeScale",1);s(this,"_skeleton");s(this,"_clips",[]);s(this,"_clipStates",new Map);s(this,"_mixSkeletonPose");s(this,"_mixTempSkeletonPose");s(this,"_currentClipState");s(this,"_bindList",[]);s(this,"_jointMatrixIndexTableBuffer");s(this,"_crossFadeState")}start(){}get currName(){return this._currentClipState?this._currentClipState.name:""}set skeleton(t){this._skeleton=t,this._mixSkeletonPose=new Cs(this._skeleton,!0),this._mixTempSkeletonPose=new Cs(this._skeleton);const e=new Float32Array(this._mixSkeletonPose.jointMatrixIndexTable);this._jointMatrixIndexTableBuffer=new be(this._skeleton.numJoint*4,0,e)}get skeleton(){return this._skeleton}get finalSkeletonPose(){return this._mixSkeletonPose}get jointMatrixIndexTableBuffer(){return this._jointMatrixIndexTableBuffer}getJointIndexTable(t){let e=new Array;for(let r=0;r<t.length;r++){const i=t[r];let a=this._skeleton.getJointByName(i);e[r]=a?a.index:-1}return e}addAnimationClip(t){if(!this._clipStates.has(t.name)){this._clips.push(t);let e=new ng(t);e.animation=this,this._clipStates.set(t.name,e),this._currentClipState||this.setCurrentClipState(e)}}getAnimationClip(t){var e=this.getAnimationClipState(t);return e?e.clip:null}getAnimationClips(){return this._clips}getAnimationClipState(t){return this._clipStates.has(t)?this._clipStates.get(t):null}getAnimationClipStates(){return this._clipStates}pause(){this.isPlaying=!1}resume(){this.isPlaying=!0}play(t,e=1,r=!1){if(this._currentClipState&&this._currentClipState.name==t)return r&&this._currentClipState.reset(),!1;let i=this.getAnimationClipState(t);return i?(i.speed=e,i.reset(),this._clipStates.forEach((a,o)=>{a.weight=0}),this.setCurrentClipState(i),!0):!1}crossFade(t,e){if(e<.01){this.play(t);return}if(this._currentClipState.name==t)return;let r=this.getAnimationClipState(t);r&&(r.reset(),this._crossFadeState?(this._crossFadeState.inClip&&(this._crossFadeState.inClip.weight=0),this._crossFadeState.outClip&&(this._crossFadeState.outClip.weight=0),this._crossFadeState.reset(r,this._currentClipState,e)):this._crossFadeState=new cg(r,this._currentClipState,e),this._currentClipState=r)}setAnimIsLoop(t,e){this._clipStates.has(t)&&(this._clipStates.get(t).loop=e)}addJointBind(t,e){this._bindList.push({jointName:t,obj:e})}removeJointBind(t){for(let e=0;e<this._bindList.length;e++)if(this._bindList[e].obj==t){this._bindList.splice(e,1);break}}onUpdate(){if(!this.isPlaying)return;let t=me.delta*.001*this.timeScale;this._crossFadeState&&this._crossFadeState.update(t);var e=0,r=[];if(this._clipStates.forEach((a,o)=>{a.weight>0&&(a.update(t),e+=a.weight,r.push(a))}),r.length>0){this._mixSkeletonPose.copyFrom(r[0].currSkeletonPose);for(var i=1;i<r.length;++i){const a=r[i];this._mixTempSkeletonPose.lerp(this._mixSkeletonPose,a.currSkeletonPose,a.weight/e),this._mixSkeletonPose.copyFrom(this._mixTempSkeletonPose)}}}cloneTo(t){let e=t.addComponent(Ci);e.skeleton=this.skeleton;for(var r=0;r<this._clips.length;++r)e.addAnimationClip(this._clips[r])}setCurrentClipState(t){this._currentClipState!=t&&(this._currentClipState=t,this._currentClipState.weight=1)}};Ci=ug([or(Ci,"SkeletonAnimationComponent")],Ci);class cg{constructor(t,e,r){s(this,"inClip");s(this,"outClip");s(this,"currentTime");s(this,"crossFadeTime");this.reset(t,e,r)}reset(t,e,r){this.inClip=t,this.outClip=e,this.currentTime=0,this.crossFadeTime=r}update(t){!this.inClip||!this.outClip||(this.currentTime+=t,this.inClip.weight=Math.min(Math.abs(this.currentTime%this.crossFadeTime)/this.crossFadeTime,1),this.outClip.weight=1-this.inClip.weight,Math.abs(this.currentTime)>=this.crossFadeTime&&(this.inClip.weight=1,this.outClip.weight=0,this.inClip=null,this.outClip=null))}}var fg=Object.defineProperty,dg=Object.getOwnPropertyDescriptor,gg=(n,t,e,r)=>{for(var i=r>1?void 0:r?dg(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&fg(t,e,i),i};let ti=class extends Qt{constructor(){super(...arguments);s(this,"timeScale",1);s(this,"jointMatrixIndexTableBuffer");s(this,"playBlendShapeLoop",!1);s(this,"inverseBindMatrices");s(this,"_avatar");s(this,"_rendererList");s(this,"propertyCache");s(this,"_clips");s(this,"_clipsState");s(this,"_clipsMap");s(this,"_currentSkeletonClip");s(this,"_currentBlendAnimClip");s(this,"_skeletonTime",0);s(this,"_blendShapeTime",0);s(this,"_skeletonSpeed",1);s(this,"_blendShapeSpeed",1);s(this,"_skeletonStart",!0);s(this,"_blendShapeStart",!0);s(this,"root");s(this,"_avatarName");s(this,"_bonePos",new g);s(this,"_boneScale",new g);s(this,"_boneRot",new Z);s(this,"_crossFadeState");s(this,"skeltonPoseObject3D",{});s(this,"skeltonTPoseObject3D",{})}init(t){this.propertyCache=new Map,this._clipsMap=new Map,this._clips=[],this._clipsState=[],this._rendererList=this.object3D.getComponentsInChild(yi);let e=this.object3D.getComponentsInChild($);for(let r of e){let i=r;i.blendShape=r.morphData,this._rendererList.push(i)}for(const r of this._rendererList)sr.hasMask(r.rendererMask,ye.MorphTarget)&&r.selfCloneMaterials("MORPH_TARGET_UUID")}start(){}debug(){}playAnim(t,e=0,r=1){let i=this.getAnimationClipState(t);i?(this._currentSkeletonClip&&(this._currentSkeletonClip.weight=0),this._currentSkeletonClip=i,this._currentSkeletonClip.weight=1,this._skeletonTime=e,this._skeletonSpeed=r,this._skeletonStart=!0):console.warn(`not has anim ${t}`)}crossFade(t,e){let r=this.getAnimationClipState(t);if(!r){console.warn(`not has anim ${t}`);return}if(e<.01||!this._currentSkeletonClip){this.playAnim(t);return}if(this._currentSkeletonClip&&this._currentSkeletonClip.clip.clipName===t)return;let i=r,a=this._currentSkeletonClip;this._crossFadeState?(this._crossFadeState.inClip&&(this._crossFadeState.inClip.weight=0),this._crossFadeState.outClip&&(this._crossFadeState.outClip.weight=0),this._crossFadeState.reset(i,a,e)):this._crossFadeState=new mg(i,a,e),this._currentSkeletonClip=i}playBlendShape(t,e=0,r=1){this._clipsMap.has(t)?(this._currentBlendAnimClip=this._clipsMap.get(t),this._blendShapeTime=e,this._blendShapeSpeed=r,this._blendShapeStart=!0):console.warn(`not has blendShape ${t}`)}set avatar(t){this._avatarName=t,this.inverseBindMatrices=[],this._avatar=m.res.getObj(t);let e=this.buildSkeletonPose();const r=new Float32Array(e);this.jointMatrixIndexTableBuffer=new be(this._avatar.count,0,r)}get numJoint(){return this._avatar.count}getJointIndexTable(t){let e=new Array;for(let r=0;r<t.length;r++){let i=this._avatar.boneMap.get(t[r]);e[r]=i?i.boneID:-1}return e}buildSkeletonPose(){let t=[];for(const e of this._avatar.boneData){let r=new ee;Q.getEuler(g.HELP_6,e.q,!0,"ZYX"),r.localPosition=e.t.clone(),r.localRotation=g.HELP_6.clone(),r.localScale=g.ONE,e.s.clone(),this.skeltonPoseObject3D[e.boneName]=r,this.skeltonTPoseObject3D[e.bonePath]=r.clone(),e.parentBoneName&&e.parentBoneName!=""?this.skeltonPoseObject3D[e.parentBoneName].addChild(r):(this.object3D.transform.scene3D&&this.object3D.transform.scene3D.addChild(r),this.root=r),t.push(r.transform.worldMatrix.index);let i=new Q;i.copyFrom(r.transform.worldMatrix),i.invert(),this.inverseBindMatrices.push(i.rawData)}return t}set clips(t){this._clips=t;for(const e of t)this._clipsMap.set(e.clipName,e);this._clipsState=[];for(const e of t)this._clipsState.push(new pg(e));this._currentSkeletonClip||this.playAnim(t[0].clipName)}get clips(){return this._clips}get clipsState(){return this._clipsState}cloneTo(t){let e=t.addComponent(ti);e.avatar=this._avatarName,e.clips=this._clips}updateTime(){const t=me.delta*.001;this._skeletonStart&&(this._skeletonTime+=t*this._skeletonSpeed*this.timeScale,this._currentSkeletonClip&&this._currentSkeletonClip.clip.loopTime&&(this._skeletonTime=this._skeletonTime%this._currentSkeletonClip.clip.stopTime)),this._blendShapeStart&&(this._blendShapeTime+=t*this._blendShapeSpeed,this._currentBlendAnimClip&&(this._currentBlendAnimClip.loopTime&&this.playBlendShapeLoop?this._blendShapeTime=this._blendShapeTime%this._currentBlendAnimClip.stopTime:this._blendShapeTime=Math.min(this._blendShapeTime,this._currentBlendAnimClip.stopTime)-1e-4)),this._crossFadeState&&this._crossFadeState.update(t)}onUpdate(t){this.updateTime();let e=[];for(let r of this._clipsState)r.weight>0&&e.push(r);e.length>0?this.updateSkeletonAnimMix(e):this.updateSkeletonAnim(),this.updateMorphAnim()}updateSkeletonAnim(){if(this._currentSkeletonClip){let t=this._avatar.boneData,e=0,r=t.length;for(e=0;e<r;e++){const i=t[e];let a=this.skeltonPoseObject3D[i.boneName];if(this._currentSkeletonClip.clip.useSkeletonPos){let l=this.getPosition(i.bonePath,this._skeletonTime);a.transform.localPosition=l}let o=this.getRotation(i.bonePath,this._skeletonTime);if(a.transform.localRotQuat=o,this._currentSkeletonClip.clip.useSkeletonScale){let l=this.getScale(i.bonePath,this._skeletonTime);a.transform.localScale=l}}}}updateMorphAnim(){if(this._currentBlendAnimClip&&this._currentBlendAnimClip.floatCurves&&this._currentBlendAnimClip.floatCurves.size>0&&this._rendererList)for(const t of this._currentBlendAnimClip.floatCurves){let e=t[0],r=t[1].propertys,i=this._currentBlendAnimClip.floatCurves.get(e).getValue(this._blendShapeTime)/100;this.updateBlendShape(r,e,i)}}updateBlendShape(t,e,r){for(const i of this._rendererList)if(i.blendShape){let a=this.propertyCache.get(i);if(a&&e in a)a[e](r);else{a=i;for(const o of t){if(!a[o]){a=null;break}a=a[o]}if(!a||a==i)continue;this.propertyCache.get(i)||this.propertyCache.set(i,{}),this.propertyCache.get(i)[e]=a,a(r)}}}updateSkeletonAnimMix(t){let e=0;for(let r of t)e+=r.weight;if(t.length>0){let r=this._avatar.boneData,i=r.length;for(let a=0;a<i;a++){const o=r[a];let l=this.skeltonPoseObject3D[o.boneName];if(t[0].clip.useSkeletonPos){this._bonePos.copyFrom(this.getPosition(o.bonePath,this._skeletonTime,t[0].clip));for(let h=1;h<t.length;h++){const u=t[h];if(u.clip.useSkeletonPos){let c=this.getPosition(o.bonePath,this._skeletonTime,u.clip);g.HELP_0.lerp(this._bonePos,c,u.weight/e),this._bonePos.copyFrom(g.HELP_0)}}l.transform.localPosition=this._bonePos}this._boneRot.copyFrom(this.getRotation(o.bonePath,this._skeletonTime,t[0].clip));for(let h=1;h<t.length;h++){const u=t[h];let c=this.getRotation(o.bonePath,this._skeletonTime,u.clip);Z.HELP_2.slerp(this._boneRot,c,u.weight/e),this._boneRot.copyFrom(Z.HELP_2)}if(l.transform.localRotQuat=this._boneRot,t[0].clip.useSkeletonScale){this._boneScale.copyFrom(this.getScale(o.bonePath,this._skeletonTime,t[0].clip));for(let h=1;h<t.length;h++){const u=t[h];if(u.clip.useSkeletonScale){let c=this.getScale(o.bonePath,this._skeletonTime,u.clip);g.HELP_0.lerp(this._boneScale,c,u.weight/e),this._boneScale.copyFrom(g.HELP_0)}}l.transform.localScale=this._boneScale}}}}getPosition(t,e,r=this._currentSkeletonClip.clip){return r.positionCurves.has(t)?r.positionCurves.get(t).getValue(e):this.skeltonTPoseObject3D[t].localPosition}getRotation(t,e,r=this._currentSkeletonClip.clip){if(r.rotationCurves.has(t)){let i=r.rotationCurves.get(t).getValue(e);return Z.HELP_0.set(i.x,i.y,i.z,i.w),Z.HELP_0}return this.skeltonTPoseObject3D[t].localQuaternion}getScale(t,e,r=this._currentSkeletonClip.clip){return r.scaleCurves.has(t)?r.scaleCurves.get(t).getValue(e):this.skeltonTPoseObject3D[t].localScale}getAnimationClipState(t){for(let e of this._clipsState)if(e.clip.clipName===t)return e;return null}cloneMorphRenderers(){let t={};for(const e of this._rendererList)for(const r in e.geometry.morphTargetDictionary){let i=t[r]||[];i.push(e),t[r]=i}return t}};ti=gg([or(ti,"AnimatorComponent")],ti);class pg{constructor(t){s(this,"clip");s(this,"weight",0);this.clip=t}get totalTime(){return this.clip.stopTime-this.clip.startTime}}class mg{constructor(t,e,r){s(this,"inClip");s(this,"outClip");s(this,"currentTime");s(this,"crossFadeTime");this.reset(t,e,r)}reset(t,e,r){this.inClip=t,this.outClip=e,this.currentTime=0,this.crossFadeTime=r}update(t){!this.inClip||!this.outClip||(this.currentTime+=t,this.inClip.weight=Math.min(Math.abs(this.currentTime%this.crossFadeTime)/this.crossFadeTime,1),this.outClip.weight=1-this.inClip.weight,Math.abs(this.currentTime)>=this.crossFadeTime&&(this.inClip.weight=1,this.outClip.weight=0,this.inClip=null,this.outClip=null))}}class gl{constructor(){s(this,"index");s(this,"time");s(this,"timeEnd");s(this,"coeff",[])}}var _i=(n=>(n[n.PingPong=0]="PingPong",n[n.Repeat=1]="Repeat",n[n.Clamp=2]="Clamp",n))(_i||{});class No{constructor(t=0,e=0){s(this,"serializedVersion","2");s(this,"time");s(this,"value");s(this,"inSlope",0);s(this,"outSlope",0);s(this,"tangentMode",0);s(this,"weightedMode",0);s(this,"inWeight");s(this,"outWeight");this.time=t,this.value=e}unSerialized(t){this.serializedVersion=t.serializedVersion,this.time=t.time,this.value=t.value,this.tangentMode=t.tangentMode,this.inSlope=t.inSlope=="Infinity"?NaN:t.inSlope,this.outSlope=t.outSlope=="Infinity"?NaN:t.outSlope}unSerialized2(t){this.serializedVersion=t.serializedVersion,this.time=t.time,this.value=t.value,this.tangentMode=t.tangentMode,this.inSlope=t.inTangent=="Infinity"?NaN:t.inTangent,this.outSlope=t.outTangent=="Infinity"?NaN:t.outTangent}}class Fo{constructor(t,e=_i.Repeat,r=_i.Repeat){s(this,"_totalTime",1);s(this,"_cache",new gl);s(this,"_cacheOut",{lhsIndex:0,rhsIndex:0});s(this,"_InvalidateCache",!1);s(this,"curve",[]);s(this,"serializedVersion");s(this,"preWarpMode");s(this,"postWarpMode");s(this,"rotationOrder");if(t)for(let i=0;i<t.length;i++){const a=t[i];this.addKeyFrame(a)}this.preWarpMode=e,this.postWarpMode=r}get cacheOut(){return this._cacheOut}get totalTime(){return this._totalTime}get first(){return this.curve[0]}get last(){return this.curve[this.curve.length-1]}addKeyFrame(t){this.curve.indexOf(t)==-1&&this.curve.push(t),this.calcTotalTime()}removeKeyFrame(t){let e=this.curve.indexOf(t);e!=-1&&this.curve.splice(e,1),this.calcTotalTime()}calculateCacheData(t,e,r,i=0){let a=this.curve,o=a[e],l=a[r];t.index=e,t.time=o.time+i,t.timeEnd=l.time+i,t.index=e;let h,u,c,f,d,p,A;h=l.time-o.time,h=Math.max(h,1e-4),c=l.value-o.value,u=1/(h*h),f=o.outSlope,d=l.inSlope,p=f*h,A=d*h,t.coeff[0]=(p+A-c-c)*u/h,t.coeff[1]=(c+c+c-p-p-A)*u,t.coeff[2]=f,t.coeff[3]=o.value,this.setupStepped(t.coeff,o,l)}getValue(t){return t=this.wrapTime(t),this.findCurve(t,this._cacheOut),this.calculateCacheData(this._cache,this._cacheOut.lhsIndex,this._cacheOut.rhsIndex,0),this.evaluateCache(this._cache,t)}getCurveFramesExtent(t){return t=this.wrapTime(t),this.findCurve(t,this._cacheOut),{lhsIndex:this._cacheOut.lhsIndex,rhsIndex:this._cacheOut.rhsIndex,time:t}}getKeyCount(){return this.curve.length}getKey(t){return this.curve[t]}unSerialized(t){this.preWarpMode=t.m_PreInfinity,this.postWarpMode=t.m_PostInfinity,this.rotationOrder=t.m_RotationOrder;let e=t.m_Curve.length;for(let r=0;r<e;r++)this.curve[r]=new No,this.curve[r].unSerialized(t.m_Curve[r.toString()]);return this.calcTotalTime(),this}unSerialized2(t){this.preWarpMode=t.preWrapMode,this.postWarpMode=t.postWrapMode;let e=t.keyFrames||t.keys,r=e.length;for(let i=0;i<r;i++)this.curve[i]=new No,this.curve[i].unSerialized2(e[i.toString()]);return this.calcTotalTime(),this}wrapTime(t){let e=this.curve,r=e[0].time,i=e[e.length-1].time;return t<r?this.preWarpMode==_i.Clamp?t=r:this.preWarpMode==_i.PingPong?t=Sn(t,r,i):t=In(t,r,i):t>i&&(this.postWarpMode==_i.Clamp?t=i:this.postWarpMode==_i.PingPong?t=Sn(t,r,i):t=In(t,r,i)),t}evaluateCache(t,e){let r=e-t.time;return r*(r*(r*t.coeff[0]+t.coeff[1])+t.coeff[2])+t.coeff[3]}findCurve(t,e){let r=this.curve;for(let i=1;i<r.length;i++){let a=r[i-1],o=r[i];a.time<=t&&o.time>t&&(e.lhsIndex=i-1,e.rhsIndex=i)}}setupStepped(t,e,r){(isNaN(e.outSlope)||isNaN(r.inSlope))&&(t[0]=0,t[1]=0,t[2]=0,t[3]=e.value)}invalidateCache(){this._InvalidateCache=!0}calcTotalTime(){let t=0;for(let e of this.curve)e?t=Math.max(t,e.time):console.error(e);this._totalTime=t}static scaleCurveValue(t,e){if(!t._InvalidateCache)for(let r=0;r<t.curve.length;r++){let i=t.curve[r];i.value*=e,i.inSlope*=e,i.outSlope*=e}t.invalidateCache()}}class Ag extends null{constructor(){super();s(this,"attribute","");s(this,"propertyList");s(this,"path")}unSerialized(e){let{attribute:r,path:i}=e;return this.attribute=r,this.path=i,this.propertyList=r.split("."),super.unSerialized(e.curve),this}}class vg{constructor(){s(this,"curve",{})}}var Pa=(n=>(n[n.Default=0]="Default",n[n.Clamp=1]="Clamp",n[n.Once=1]="Once",n[n.Loop=2]="Loop",n[n.PingPong=4]="PingPong",n[n.ClampForever=8]="ClampForever",n))(Pa||{});class zA{constructor(){s(this,"name");s(this,"objAnimClip");s(this,"totalTime",0);s(this,"time",0);s(this,"_stopTime",0);s(this,"_loopTime");s(this,"_wrapMode");s(this,"_sampleRate")}get wrapMode(){return this._wrapMode||(this._wrapMode=0),this._wrapMode}set wrapMode(t){this._wrapMode=t}parse(t){this.objAnimClip={};let e=t.AnimationClip,{m_Name:r,m_AnimationClipSettings:i,m_WrapMode:a,m_SampleRate:o}=e;this.name=r,this._wrapMode=a,this._sampleRate=o,this._loopTime=i.m_LoopTime;for(const l in e.m_EditorCurves)if(Object.prototype.hasOwnProperty.call(e.m_EditorCurves,l)){const h=e.m_EditorCurves[l];let u=h.attribute,c=new Ag;c.unSerialized(h),this.totalTime=Math.max(this.totalTime,c.totalTime);let f=this.objAnimClip[h.path];f||(f=new vg,this.objAnimClip[h.path]=f),f.curve[u]=c}}}class xg{constructor(){s(this,"transform");s(this,"quaternion");s(this,"materialColor")}}class Or{static updatePropertyTag(t,e){t.quaternion||(t.quaternion=this.tag_quaternion[e]),t.transform||(t.transform=this.tag_transform[e]),t.materialColor||(t.materialColor=this.tag_materialColor[e])}}s(Or,"Property",{"m_LocalPosition.x":"localPosition.x","m_LocalPosition.y":"localPosition.y","m_LocalPosition.z":"localPosition.z","m_LocalRotation.x":"localQuaternion.x","m_LocalRotation.y":"localQuaternion.y","m_LocalRotation.z":"localQuaternion.z","m_LocalRotation.w":"localQuaternion.w","localEulerAnglesRaw.x":"localRotation.x","localEulerAnglesRaw.y":"localRotation.y","localEulerAnglesRaw.z":"localRotation.z","m_LocalEulerAngles.x":"localRotation.x","m_LocalEulerAngles.y":"localRotation.y","m_LocalEulerAngles.z":"localRotation.z","m_LocalScale.x":"localScale.x","m_LocalScale.y":"localScale.y","m_LocalScale.z":"localScale.z","m_Color.r":"materialColor.r","m_Color.g":"materialColor.g","m_Color.b":"materialColor.b","m_Color.a":"materialColor.a","material._Color.r":"materialColor.r","material._Color.g":"materialColor.g","material._Color.b":"materialColor.b","material._Color.a":"materialColor.a","material._UnlitColor.r":"materialColor.r","material._UnlitColor.g":"materialColor.g","material._UnlitColor.b":"materialColor.b","material._UnlitColor.a":"materialColor.a","field of view":"camera3D.fov",m_IsActive:"active",m_Sprite:"sprite",m_FlipX:"flipX",m_FlipY:"flipY"}),s(Or,"Scale",{"m_LocalPosition.x":1,"m_LocalPosition.y":1,"m_LocalPosition.z":-1,"localEulerAnglesRaw.x":-1,"localEulerAnglesRaw.y":1,"localEulerAnglesRaw.z":1,"m_LocalEulerAngles.x":-1,"m_LocalEulerAngles.y":1,"m_LocalEulerAngles.z":1,"m_LocalRotation.x":1,"m_LocalRotation.y":1,"m_LocalRotation.z":-1,"m_LocalRotation.w":-1,"field of view":1,m_IsActive:1,m_Sprite:1}),s(Or,"tag_quaternion",{"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0}),s(Or,"tag_materialColor",{"material._Color.r":!0,"material._Color.g":!0,"material._Color.b":!0,"material._Color.a":!0,"material._UnlitColor.r":!0,"material._UnlitColor.g":!0,"material._UnlitColor.b":!0,"material._UnlitColor.a":!0}),s(Or,"tag_transform",{"m_LocalPosition.x":!0,"m_LocalPosition.y":!0,"m_LocalPosition.z":!0,"m_LocalRotation.x":!0,"m_LocalRotation.y":!0,"m_LocalRotation.z":!0,"m_LocalRotation.w":!0,"localEulerAnglesRaw.x":!0,"localEulerAnglesRaw.y":!0,"localEulerAnglesRaw.z":!0,"m_LocalEulerAngles.x":!0,"m_LocalEulerAngles.y":!0,"m_LocalEulerAngles.z":!0,"m_LocalScale.x":!0,"m_LocalScale.y":!0,"m_LocalScale.z":!0});const $i=class $i{constructor(t){s(this,"_rootObject3D");s(this,"_animation");s(this,"_propertyCache");s(this,"_currentClip");s(this,"_frame",0);s(this,"_time",0);s(this,"_isPlaying",!0);s(this,"speed",1);s(this,"_propertyTagDic");this._rootObject3D=t.object3D,this._animation=t,this._propertyTagDic=new Map,this.reset()}reset(){this._propertyCache={},this._propertyTagDic.clear()}get time(){return this._time}get currentClip(){return this._currentClip}play(t,e=!0){this._isPlaying=!0,e&&(this._time=0),t!=this._currentClip&&t&&this.parseAnimClip(t),this._currentClip=t,this.validProperty()}parseAnimClip(t){var e;this.reset();for(const r in t.objAnimClip){let i=t.objAnimClip[r],a=this._rootObject3D,o={};if(r==""?a=this._rootObject3D:a=this._rootObject3D.getObjectByName(r),!a)continue;let l=new xg;this._propertyTagDic.set(a,l);let h=i.curve;for(const u in h){Or.updatePropertyTag(l,u);let c=(e=this._propertyCache)[r]||(e[r]={}),f=Or.Property[u].split("."),d=f[0];if(f.length>1){let p=o[d];p||(p=o[d]=a[d]),c[u]={value:p,property:f[1]}}else c[u]={value:a,property:f[0]}}}return this}stop(){return this._isPlaying=!1,this}toggle(){return this._isPlaying=!this._isPlaying,this}get isPlaying(){return this._isPlaying}update(t,e){if(t=t*.001,e=e*.001,!this._currentClip||this._frame==t||!this._isPlaying)return;this._frame=t;let r=this._time;this._time=this.calcTime(r+e*this.speed),this.validProperty(),this._currentClip.wrapMode!=Pa.Loop&&this._currentClip.wrapMode!=Pa.Default&&(this.speed>0?this._time>=this._currentClip.totalTime:this._time<=0)&&(this._isPlaying=!1,this._animation.statusCall($i.Complete,r,this._time)),this._animation.statusCall($i.Seek,r,this._time)}seek(t){return this._time=this.calcTime(t),this._rootObject3D&&this.validProperty(),this}calcTime(t){return this._currentClip.wrapMode==Pa.Loop||this._currentClip.wrapMode==Pa.Default?t=Bn(t,this._currentClip.totalTime):t=se(t,0,this._currentClip.totalTime),t}validProperty(){for(const t in this._currentClip.objAnimClip){let e=this._currentClip.objAnimClip[t].curve;for(const r in e){const i=e[r];let a=this._propertyCache[t][r],o=i.getValue(this._time);r in Or.Scale&&(o*=Or.Scale[r]),a.value[a.property]=o}}this._propertyTagDic.forEach((t,e)=>{this.applyProperty(t,e)})}applyProperty(t,e){t.quaternion&&Q.getEuler(e.transform.localRotation,e.transform.localRotQuat,!0,"ZYX"),t.transform&&(e.transform.localPosition=e.transform.localPosition,e.transform.localRotation=e.transform.localRotation,e.transform.localScale=e.transform.localScale);let r=e;t.materialColor&&r.notifyMaterialColorChange(0,"baseColor")}};s($i,"Complete",null),s($i,"Seek",null);let Ra=$i;class GA{constructor(){s(this,"clipName");s(this,"data");s(this,"time")}}class Xi extends null{constructor(e,r){super(r);s(this,"animation");s(this,"frame");this.animation=e}}s(Xi,"SEEK",null),s(Xi,"COMPLETE",null);class pl extends null{constructor(){super();s(this,"_animator");s(this,"_clips",[]);s(this,"defaultClip");s(this,"autoPlay");s(this,"_seekEvent");s(this,"_completeEvent");s(this,"_keyFrameList");this._seekEvent=new Xi(this,Xi.SEEK),this._completeEvent=new Xi(this,Xi.COMPLETE),this._keyFrameList={}}registerEventKeyFrame(e){let r=this._keyFrameList[e.clipName];r==null&&(this._keyFrameList[e.clipName]=r=[]),r.push(e)}init(){this._animator=new Ra(this)}onUpdate(){this.enable&&this._animator.update(me.time,me.delta)}appendClip(e){this._clips.push(e),this.play(e.name)}statusCall(e,r,i){if(e==Ra.Complete)this.eventDispatcher.dispatchEvent(this._completeEvent);else if(e==Ra.Seek&&r!=i){let a=this._keyFrameList[this.currentClip.name];if(a)for(let o of a)o.time>r&&o.time<=i&&(this._seekEvent.data=this._seekEvent.frame=o,this.eventDispatcher.dispatchEvent(this._seekEvent))}}set speed(e){this._animator.speed=e}get speed(){return this._animator.speed}stop(){this._animator.stop()}toggle(){this._animator.toggle()}getClip(e){let r;for(let i of this._clips)if(i.name==e){r=i;break}return r}get currentClip(){return this._animator.currentClip}get time(){return this._animator.time}seek(e){this._animator.seek(e)}play(e,r=!0){let i=this.getClip(e);return i?(this._animator.play(i,r),i):null}start(){this.autoPlay&&this.play(this.defaultClip)}copyComponent(e){this.autoPlay=e.autoPlay,this.defaultClip=e.defaultClip;let r=e._clips;for(let i=0,a=r.length;i<a;i++)this.appendClip(r[i]);return this}cloneTo(e){e.addComponent(pl).copyComponent(this)}}var Cg=Object.defineProperty,_g=Object.getOwnPropertyDescriptor,yg=(n,t,e,r)=>{for(var i=r>1?void 0:r?_g(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Cg(t,e,i),i};let yi=class extends ${constructor(){super();s(this,"skinJointsName");s(this,"mInverseBindMatrixData");s(this,"mInverseBindMatrixBuffer");s(this,"mSkeletonAnimation");s(this,"mJointIndexTableBuffer");this.addRendererMask(ye.SkinnedMesh)}get geometry(){return this._geometry}set geometry(t){this.skinJointsName=t.skinNames;let e=[];for(let r=0;r<t.bindPose.length;r++)e.push(new Float32Array(t.bindPose[r].rawData.slice(0,16)));this.skinInverseBindMatrices=e,super.geometry=t}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(ti),!this.skeletonAnimation){let t=this.object3D.parentObject.parentObject.getComponentsInChild(ti);t.length>0&&(this.skeletonAnimation=t[0]);let e=this.object3D;for(;!this.skeletonAnimation&&e;)this.skeletonAnimation=e.getComponentFromParent(ti),e.parent&&(e=e.parent.object3D)}}get blendShape(){return this.morphData}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(t){if(this.mSkeletonAnimation=t,!!t&&!this.mJointIndexTableBuffer){let e=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new be(e.length,0,new Float32Array(e)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(t){this.mInverseBindMatrixData=t;var e=new Float32Array(t.length*16);for(let r=0;r<t.length;r++){let i=r*16,a=t[r];e.set(a,i)}this.mInverseBindMatrixBuffer=new be(e.byteLength,0,e),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(t){let e=t.addComponent(yi),r=[];for(const i of this.materials)r.push(i.clone());e.materials=r,e.geometry=this.geometry,e.castShadow=this.castShadow,e.castGI=this.castGI,e.receiveShadow=this.receiveShadow,e.rendererMask=this.rendererMask,e.skinJointsName=this.skinJointsName,e.skinInverseBindMatrices=this.skinInverseBindMatrices,e.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(t,e,r,i){for(let a=0;a<this.materials.length;a++){let o=this.materials[a].getPass(e);if(o)for(let l=0;l<o.length;l++){const h=o[l];!h.pipeline&&this.mSkeletonAnimation&&(h.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),h.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),h.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(t,e,r,i)}};yi=yg([or(yi,"SkinnedMeshRenderer2")],yi);class QA extends null{constructor(){super(...arguments);s(this,"_targetRenderers",{});s(this,"_vec3",new g);s(this,"_matrix4",new Q);s(this,"_quaternion",new Z)}init(e){let r=this.fetchMorphRenderers(this.object3D,yi),i=this.fetchMorphRenderers(this.object3D,$);r.push(...i);for(const a of r){sr.hasMask(a.rendererMask,ye.MorphTarget)&&a.selfCloneMaterials("MORPH_TARGET_UUID");for(const o in a.geometry.morphTargetDictionary){let l=this._targetRenderers[o]||[];l.push(a),this._targetRenderers[o]=l}}}getMorphRenderersByKey(e){return this._targetRenderers[e]}cloneMorphRenderers(){let e={};for(let r in this._targetRenderers)e[r]=this._targetRenderers[r];return e}applyBlendShape(e,r,i=1){if(!e){console.warn("blendShape is null");return}this._vec3.setFromArray(e.transform.transform[3]),this._vec3.multiplyScalar(i),this.object3D.transform.localPosition=this._vec3,this._vec3.setFromArray(e.transform.transform[2]),this._matrix4.copyColFrom(2,this._vec3),this._vec3.setFromArray(e.transform.transform[1]),this._matrix4.copyColFrom(1,this._vec3),this._vec3.setFromArray(e.transform.transform[0]),this._matrix4.copyColFrom(0,this._vec3),this._matrix4.transpose(),this._quaternion.fromMatrix(this._matrix4),this.object3D.localQuaternion=this._quaternion;for(let a in r){let o=this._targetRenderers[a],l=r[a],h=e.texture[l];this.applyMorphTargetInfluence(a,h,o)}}applyMorphTargetInfluence(e,r,i){for(let a of i)a.setMorphInfluence(e,r)}fetchMorphRenderers(e,r){let i=e.getComponentsInChild(r),a=[];for(let o of i)o.hasMask(ye.MorphTarget)&&a.push(o);return a}}class VA{constructor(){s(this,"texture");s(this,"transform")}}var Sg=(n=>(n.mouthRollLower="mouthRollLower",n.browOuterUp_L="browOuterUpLeft",n.mouthSmile_L="mouthSmileLeft",n.jawRight="jawRight",n.eyeLookOut_L="eyeLookOutLeft",n.mouthFunnel="mouthFunnel",n.mouthUpperUp_R="mouthUpperUpRight",n.browDown_L="browDownLeft",n.jawLeft="jawLeft",n.mouthLowerDown_L="mouthLowerDownLeft",n.noseSneer_R="noseSneerRight",n.jawForward="jawForward",n.mouthLowerDown_R="mouthLowerDownRight",n.browInnerUp="browInnerUp",n.mouthRollUpper="mouthRollUpper",n.mouthStretch_R="mouthStretchRight",n.mouthPucker="mouthPucker",n.eyeBlink_L="eyeBlinkLeft",n.mouthUpperUp_L="mouthUpperUpLeft",n.mouthShrugUpper="mouthShrugUpper",n.eyeLookIn_R="eyeLookInRight",n.noseSneer_L="noseSneerLeft",n.mouthFrown_L="mouthFrownLeft",n.cheekSquint_L="cheekSquintLeft",n.eyeLookDown_L="eyeLookDownLeft",n.mouthDimple_L="mouthDimpleLeft",n.mouthFrown_R="mouthFrownRight",n.eyeLookIn_L="eyeLookInLeft",n.eyeLookOut_R="eyeLookOutRight",n.mouthLeft="mouthLeft",n.mouthStretch_L="mouthStretchLeft",n.mouthPress_L="mouthPressLeft",n.mouthDimple_R="mouthDimpleRight",n.eyeWide_R="eyeWideRight",n.browDown_R="browDownRight",n.eyeLookUp_R="eyeLookUpRight",n.eyeBlink_R="eyeBlinkRight",n.cheekSquint_R="cheekSquintRight",n.mouthRight="mouthDimpleRight",n.eyeLookDown_R="eyeLookDownRight",n.eyeLookUp_L="eyeLookUpLeft",n.eyeSquint_L="eyeSquintLeft",n.jawOpen="jawOpen",n.browOuterUp_R="browOuterUpRight",n.mouthClose="mouthClose",n.mouthShrugLower="mouthShrugLower",n.eyeWide_L="eyeWideLeft",n.tongueOut="tongueOut",n.eyeSquint_R="eyeSquintRight",n.cheekPuff="cheekPuff",n.mouthPress_R="mouthPressRight",n.mouthSmile_R="mouthSmileRight",n))(Sg||{});class YA{constructor(t=[]){s(this,"joints");this.joints=t}get numJoint(){return this.joints.length}addJoint(t){t.index=this.joints.push(t)-1}getJointName(t){return this.joints[t].name}getJointParentIndex(t){let e=this.joints[t];return e.parent?e.parent.index:-1}getJointByName(t){for(let e of this.joints)if(e.name==t)return e;return null}}class HA{constructor(t,e){s(this,"_computePipeline");s(this,"_computeBindGroup");let r=E.device;this._computePipeline=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:t}),entryPoint:"CsMain"}}),this._computeBindGroup=r.createBindGroup({layout:this._computePipeline.getBindGroupLayout(0),entries:e})}compute(t,e,r,i){let a=t.beginComputePass();return a.setPipeline(this._computePipeline),a.setBindGroup(0,this._computeBindGroup),a.dispatchWorkgroups(e,r,i),a.end(),this}}class XA extends null{constructor(){super();s(this,"numJoint");s(this,"numState");s(this,"time");s(this,"weight");s(this,"argumentsData");s(this,"_isDirty",!1);s(this,"_argumentsBuffer");s(this,"_argumentsBufferEntries");this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numState",data:[0]},{name:"retain1",data:[0]},{name:"retain2",data:[0]},{name:"time",data:[0,0]},{name:"weight",data:[0,0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){return this._isDirty&&(this._isDirty=!1,E.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer)),this}allocationMemorySet(e){this.argumentsData={};let r=0;for(let a=0;a<e.length;a++){const o=e[a];r+=o.data.length}this.allocation(r*4);let i=this;for(let a=0;a<e.length;a++){const o=e[a],l=o.name;this.argumentsData[l]=this.allocation_node(o.data.length*4),i[l]=this.argumentsData[l]}}generateGPUBuffer(){let e=E.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}class WA extends null{constructor(){super();s(this,"numJoint");s(this,"numFrame");s(this,"retain0");s(this,"retain1");s(this,"argumentsData");s(this,"_isDirty",!1);s(this,"_argumentsBuffer");s(this,"_argumentsBufferEntries");this.allocationMemorySet([{name:"numJoint",data:[0]},{name:"numFrame",data:[0]},{name:"retain0",data:[0]},{name:"retain1",data:[0]}]),this.generateGPUBuffer()}getGPUBuffer(){return this._argumentsBuffer}getGPUBindGroupEntry(){return this._argumentsBufferEntries}updateGPUBuffer(){this._isDirty&&(this._isDirty=!1,E.device.queue.writeBuffer(this._argumentsBuffer,0,this.shareDataBuffer))}allocationMemorySet(e){this.argumentsData={};let r=0;for(let a=0;a<e.length;a++){const o=e[a];r+=o.data.length}this.allocation(r*4);let i=this;for(let a=0;a<e.length;a++){const o=e[a],l=o.name;this.argumentsData[l]=this.allocation_node(o.data.length*4),i[l]=this.argumentsData[l]}}generateGPUBuffer(){let e=E.device;this._argumentsBuffer=e.createBuffer({size:this.shareDataBuffer.byteLength,usage:GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,mappedAtCreation:!1}),this._argumentsBufferEntries={binding:0,resource:{buffer:this._argumentsBuffer,offset:0,size:this.shareDataBuffer.byteLength}}}}let KA=null,jA=null;class qA{constructor(t=null,e=null){s(this,"_autoUpdate",!0);s(this,"_target");s(this,"_lookAtObject");s(this,"_origin",new g(0,0,0));s(this,"_speed",300);this._target=t,this._lookAtObject=e}get target(){return this._target}set target(t){this._target!=t&&(this._target=t)}get lookAtObject(){return this._lookAtObject}set lookAtObject(t){this._lookAtObject!=t&&(this._lookAtObject=t)}get speed(){return this._speed}set speed(t){this._speed=t}update(){}}class JA extends null{constructor(){super();s(this,"focus");s(this,"distance",5);s(this,"_camera")}start(){if(this._camera=this.object3D.getOrAddComponent(Fi),!this._camera){console.error("FirstPersonCameraController need camera");return}if(!this.focus){console.error("FirstPersonCameraController need target");return}m.inputSystem.addEventListener(F.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.addEventListener(F.POINTER_UP,this.mouseUp,this),m.inputSystem.addEventListener(F.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){m.inputSystem.addEventListener(F.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){m.inputSystem.removeEventListener(F.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){let r=this.transform.localRotation;r.y+=e.movementX*.01,r.x+=e.movementY*.01,this.transform.localRotation=r}mouseWheel(e){this.distance+=m.inputSystem.wheelDelta*.1}onUpdate(){let e=new g;this._camera.transform.forward.scaleToRef(this.distance,e);var r=this.focus.transform.worldPosition;this._camera.transform.localPosition=r}destroy(e){m.inputSystem.removeEventListener(F.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.removeEventListener(F.POINTER_UP,this.mouseUp,this),m.inputSystem.removeEventListener(F.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var ze=(n=>(n[n.Key_BackSpace=8]="Key_BackSpace",n[n.Key_Tab=9]="Key_Tab",n[n.Key_Clear=12]="Key_Clear",n[n.Key_Enter=13]="Key_Enter",n[n.Key_Shift_L=16]="Key_Shift_L",n[n.Key_Control_L=17]="Key_Control_L",n[n.Key_Alt_L=18]="Key_Alt_L",n[n.Key_Pause=19]="Key_Pause",n[n.Key_CapsLock=20]="Key_CapsLock",n[n.Key_Escape=21]="Key_Escape",n[n.Key_Esc=27]="Key_Esc",n[n.Key_Space=32]="Key_Space",n[n.Key_Prior=33]="Key_Prior",n[n.Key_Next=34]="Key_Next",n[n.Key_End=35]="Key_End",n[n.Key_Home=36]="Key_Home",n[n.Key_Left=37]="Key_Left",n[n.Key_Up=38]="Key_Up",n[n.Key_Right=39]="Key_Right",n[n.Key_Down=40]="Key_Down",n[n.Key_Select=41]="Key_Select",n[n.Key_Print=42]="Key_Print",n[n.Key_Execute=43]="Key_Execute",n[n.Key_Insert=45]="Key_Insert",n[n.Key_Delete=46]="Key_Delete",n[n.Key_Help=47]="Key_Help",n[n.Key_0=48]="Key_0",n[n.Key_1=49]="Key_1",n[n.Key_2=50]="Key_2",n[n.Key_3=51]="Key_3",n[n.Key_4=52]="Key_4",n[n.Key_5=53]="Key_5",n[n.Key_6=54]="Key_6",n[n.Key_7=55]="Key_7",n[n.Key_8=56]="Key_8",n[n.Key_9=57]="Key_9",n[n.Key_A=65]="Key_A",n[n.Key_B=66]="Key_B",n[n.Key_C=67]="Key_C",n[n.Key_D=68]="Key_D",n[n.Key_E=69]="Key_E",n[n.Key_F=70]="Key_F",n[n.Key_G=71]="Key_G",n[n.Key_H=72]="Key_H",n[n.Key_I=73]="Key_I",n[n.Key_J=74]="Key_J",n[n.Key_K=75]="Key_K",n[n.Key_L=76]="Key_L",n[n.Key_M=77]="Key_M",n[n.Key_N=78]="Key_N",n[n.Key_O=79]="Key_O",n[n.Key_P=80]="Key_P",n[n.Key_Q=81]="Key_Q",n[n.Key_R=82]="Key_R",n[n.Key_S=83]="Key_S",n[n.Key_T=84]="Key_T",n[n.Key_U=85]="Key_U",n[n.Key_V=86]="Key_V",n[n.Key_W=87]="Key_W",n[n.Key_X=88]="Key_X",n[n.Key_Y=89]="Key_Y",n[n.Key_Z=90]="Key_Z",n[n.Key_KP_0=96]="Key_KP_0",n[n.Key_KP_1=97]="Key_KP_1",n[n.Key_KP_2=98]="Key_KP_2",n[n.Key_KP_3=99]="Key_KP_3",n[n.Key_KP_4=100]="Key_KP_4",n[n.Key_KP_5=101]="Key_KP_5",n[n.Key_KP_6=102]="Key_KP_6",n[n.Key_KP_7=103]="Key_KP_7",n[n.Key_KP_8=104]="Key_KP_8",n[n.Key_KP_9=105]="Key_KP_9",n[n.Key_Multiply=106]="Key_Multiply",n[n.Key_Add=107]="Key_Add",n[n.Key_Separator=108]="Key_Separator",n[n.Key_Subtract=109]="Key_Subtract",n[n.Key_Decimal=110]="Key_Decimal",n[n.Key_Divide=111]="Key_Divide",n[n.Key_F1=112]="Key_F1",n[n.Key_F2=113]="Key_F2",n[n.Key_F3=114]="Key_F3",n[n.Key_F4=115]="Key_F4",n[n.Key_F5=116]="Key_F5",n[n.Key_F6=117]="Key_F6",n[n.Key_F7=118]="Key_F7",n[n.Key_F8=119]="Key_F8",n[n.Key_F9=120]="Key_F9",n[n.Key_F10=121]="Key_F10",n[n.Key_F11=122]="Key_F11",n[n.Key_F12=123]="Key_F12",n[n.Key_F13=124]="Key_F13",n[n.Key_F14=125]="Key_F14",n[n.Key_F15=126]="Key_F15",n[n.Key_F16=127]="Key_F16",n[n.Key_F17=128]="Key_F17",n[n.Key_F18=129]="Key_F18",n[n.Key_F19=130]="Key_F19",n[n.Key_F20=131]="Key_F20",n[n.Key_F21=132]="Key_F21",n[n.Key_F22=133]="Key_F22",n[n.Key_F23=134]="Key_F23",n[n.Key_F24=135]="Key_F24",n[n.Key_Num_Lock=136]="Key_Num_Lock",n[n.Key_Scroll_Lock=137]="Key_Scroll_Lock",n))(ze||{});class ZA extends null{constructor(){super();s(this,"moveSpeed",2);s(this,"targetPos",new g(0,0,10));s(this,"lookAtPos",new g(0,0,0));s(this,"config",{shiftMoveScale:20});s(this,"_moveScale",1);s(this,"_dir");s(this,"_mouseFactory",25);s(this,"_factory",1.5);s(this,"_mouseDown",!1);s(this,"_lastPos");s(this,"_keyState");this._lastPos=new g,this._keyState={front:!1,back:!1,left:!1,right:!1,q:!1,e:!1},this.setCamera(new g(0,0,100),new g(0,0,0))}setCamera(e,r){this.targetPos.copyFrom(e),this.lookAtPos.copyFrom(r),this.Reset()}start(){m.inputSystem.addEventListener(F.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.addEventListener(F.POINTER_UP,this.mouseUp,this),m.inputSystem.addEventListener(F.POINTER_DOWN,this.mouseDown,this),m.inputSystem.addEventListener(ar.KEY_UP,this.keyUp,this),m.inputSystem.addEventListener(ar.KEY_DOWN,this.keyDown,this),this.transform.lookAt(this.targetPos,this.lookAtPos)}mouseWheel(e){}keyUp(e){switch(e.keyCode){case ze.Key_W:this._keyState.front=!1;break;case ze.Key_S:this._keyState.back=!1;break;case ze.Key_A:this._keyState.left=!1;break;case ze.Key_D:this._keyState.right=!1;break;case ze.Key_Shift_L:this._moveScale=1;break;case ze.Key_Q:this._keyState.q=!1;break;case ze.Key_E:this._keyState.e=!1;break;case ze.Key_F:this.transform.lookAt(this.targetPos,this.lookAtPos);break}}keyDown(e){switch(e.keyCode){case ze.Key_W:this._keyState.front=!0;break;case ze.Key_S:this._keyState.back=!0;break;case ze.Key_A:this._keyState.left=!0;break;case ze.Key_D:this._keyState.right=!0;break;case ze.Key_Q:this._keyState.q=!0;break;case ze.Key_E:this._keyState.e=!0;break;case ze.Key_Shift_L:this._moveScale=this.config.shiftMoveScale}}Reset(){this._lastPos.x=m.inputSystem.mouseLastX,this._lastPos.y=m.inputSystem.mouseLastY}mouseDown(e){this.Reset(),this._mouseDown=!0}mouseUp(e){this.Reset(),this._mouseDown=!1}get factory(){return this._factory}set factory(e){this._factory=e}get mouseFactory(){return this._mouseFactory}set mouseFactory(e){this._mouseFactory=e}internal(e,r,i){return(r-e)*i}onUpdate(){let e=this.transform,r=se(me.delta,0,.016);if(this._mouseDown&&(e.rotationY-=this.internal(e.rotationY+(m.inputSystem.mouseLastX-this._lastPos.x)*.25,e.rotationY,r*this._mouseFactory),e.rotationX-=this.internal(e.rotationX+(m.inputSystem.mouseLastY-this._lastPos.y)*.25,e.rotationX,r*this._mouseFactory),this.Reset()),this._keyState.front){let i=e.forward;e.x-=this.internal(e.x+i.x*this.moveSpeed*this._moveScale,e.x,r*this._factory),e.y-=this.internal(e.y+i.y*this.moveSpeed*this._moveScale,e.y,r*this._factory),e.z-=this.internal(e.z+i.z*this.moveSpeed*this._moveScale,e.z,r*this._factory)}if(this._keyState.back){let i=e.forward;e.x+=this.internal(e.x+i.x*this.moveSpeed*this._moveScale,e.x,r*this._factory),e.y+=this.internal(e.y+i.y*this.moveSpeed*this._moveScale,e.y,r*this._factory),e.z+=this.internal(e.z+i.z*this.moveSpeed*this._moveScale,e.z,r*this._factory)}if(this._keyState.left){let i=e.left;e.x+=this.internal(e.x+i.x*this.moveSpeed*this._moveScale,e.x,r*this._factory),e.y+=this.internal(e.y+i.y*this.moveSpeed*this._moveScale,e.y,r*this._factory),e.z+=this.internal(e.z+i.z*this.moveSpeed*this._moveScale,e.z,r*this._factory)}if(this._keyState.right){let i=e.left;e.x-=this.internal(e.x+i.x*this.moveSpeed*this._moveScale,e.x,r*this._factory),e.y-=this.internal(e.y+i.y*this.moveSpeed*this._moveScale,e.y,r*this._factory),e.z-=this.internal(e.z+i.z*this.moveSpeed*this._moveScale,e.z,r*this._factory)}this._keyState.q&&(e.y=Ni(e.y,e.y-this.moveSpeed*this._moveScale,r*this._factory)),this._keyState.e&&(e.y=Ni(e.y,e.y+this.moveSpeed*this._moveScale,r*this._factory))}destroy(e){m.inputSystem.removeEventListener(F.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.removeEventListener(F.POINTER_UP,this.mouseUp,this),m.inputSystem.removeEventListener(F.POINTER_DOWN,this.mouseDown,this),m.inputSystem.removeEventListener(ar.KEY_UP,this.keyUp,this),m.inputSystem.removeEventListener(ar.KEY_DOWN,this.keyDown,this),super.destroy(e)}}class bs{static add(t,e,r){return r||(r=new g),r.x=t.x+e.x,r.y=t.y+e.y,r.z=t.z+e.z,r}static sub(t,e,r){return r||(r=new g),r.x=t.x-e.x,r.y=t.y-e.y,r.z=t.z-e.z,r}static mul(t,e,r){return r||(r=new g),r.x=t.x*e.x,r.y=t.y*e.y,r.z=t.z*e.z,r}static mulScale(t,e,r){return r||(r=new g),r.x=t.x*e,r.y=t.y*e,r.z=t.z*e,r}static div(t,e,r){return r||(r=new g),r.x=t.x/e.x,r.y=t.y/e.y,r.z=t.z/e.z,r}static normalize(t){return t.clone().normalize()}static dot(t,e){let r=g.HELP_0;return r.copyFrom(t),r.dotProduct(e)}static calculateVectorAngle_xz(t,e){return Math.acos((t.x*e.x+t.y*e.y)/Math.sqrt((t.x*t.x+t.y*t.y)*(e.x*e.x+e.y*e.y)))}static distance(t,e){return g.distance(t,e)}static getRandomXYZ(t=-100,e=100){return new g(Math.random()*(e-t)+t,Math.random()*(e-t)+t,Math.random()*(e-t)+t)}static getRandomV3(t=-100,e=100,r,i){return new g(Math.random()*e+t,Math.random()*i+r,Math.random()*e+t)}static sphere(t){let e=t*Math.random(),r=new g(Math.random()*1-.5,Math.random()*1-.5,Math.random()*1-.5);return r.normalize(),r.scaleBy(e),r}static sphereXYZ(t,e,r=1,i=1,a=1){let o=t+(e-t)*Math.random(),l=new g(Math.random()*r-r*.5,Math.random()*i-i*.5,Math.random()*a-a*.5);return l.normalize(),l.scaleBy(o),l}}class Ig extends Qt{constructor(){super();s(this,"camera");s(this,"minDistance",.1);s(this,"maxDistance",500);s(this,"rollSmooth",15);s(this,"dragSmooth",20);s(this,"wheelSmooth",10);s(this,"wheelStep",.002);s(this,"mouseRightFactor",.25);s(this,"mouseLeftFactor",20);s(this,"smooth",!0);s(this,"_wheelStep",.002);s(this,"_distance",0);s(this,"distance",10);s(this,"_roll",0);s(this,"roll",0);s(this,"_pitch",0);s(this,"pitch",0);s(this,"_currentPos");s(this,"_targetPos");s(this,"_flowTarget");s(this,"_flowOffset");s(this,"_mouseLeftDown",!1);s(this,"_mouseRightDown",!1);s(this,"_bottomClamp",89.99);s(this,"_topClamp",-89.99);s(this,"_tempDir",new g);s(this,"_tempPos",new g);this._currentPos=new ee,this._targetPos=new ee}get bottomClamp(){return this._bottomClamp}set bottomClamp(e){this._bottomClamp=e>89.99?89.99:e}get topClamp(){return this._topClamp}set topClamp(e){this._topClamp=e<-89.99?-89.99:e}start(){this.camera=this.object3D.getOrAddComponent(Fi),m.inputSystem.addEventListener(F.POINTER_DOWN,this.onMouseDown,this),m.inputSystem.addEventListener(F.POINTER_MOVE,this.onMouseMove,this,null,10),m.inputSystem.addEventListener(F.POINTER_UP,this.onMouseUp,this,null,10),m.inputSystem.addEventListener(F.POINTER_WHEEL,this.onMouseWheel,this)}flowTarget(e,r=g.ZERO){this._flowTarget=e,this._flowOffset||(this._flowOffset=new g),this._flowOffset.copyFrom(r)}getFlowTarget(){return this._flowTarget}setCamera(e,r,i,a){this.roll=e,this.pitch=r,this.distance=i,this.maxDistance<i*1.5&&(this.maxDistance=i*1.5),a&&this._targetPos.transform.localPosition.copy(a)}focusByBounds(e){let r=hs.genMeshBounds(e);this.target=r.center}set target(e){this._targetPos.transform.localPosition.copy(e)}get target(){return this._targetPos.transform.localPosition}onMouseWheel(e){this.enable&&(this._wheelStep=this.wheelStep*bs.distance(this._currentPos.transform.worldPosition,this.camera.transform.worldPosition)/10,this.distance-=m.inputSystem.wheelDelta*this._wheelStep,this.distance=se(this.distance,this.minDistance,this.maxDistance))}onMouseDown(e){if(this.enable)switch(e.mouseCode){case 0:this._mouseLeftDown=!0;break;case 1:break;case 2:this._mouseRightDown=!0;break}}onMouseUp(e){this._mouseLeftDown=!1,this._mouseRightDown=!1}onMouseMove(e){this.enable&&(this._mouseRightDown&&(g.HELP_1.x=-1*e.movementX*Math.cos(this._roll*Math.PI/180)-e.movementY*Math.sin(this._roll*Math.PI/180),g.HELP_1.z=-1*e.movementY*Math.cos(this._roll*Math.PI/180)+e.movementX*Math.sin(this._roll*Math.PI/180),this._targetPos.x+=g.HELP_1.x*this.mouseRightFactor,this._targetPos.z+=g.HELP_1.z*this.mouseRightFactor),this._mouseLeftDown&&(this.roll-=e.movementX*me.delta*.001*this.mouseLeftFactor,this.pitch-=e.movementY*me.delta*.001*this.mouseLeftFactor,this.pitch=se(this.pitch,this._topClamp,this._bottomClamp)))}onBeforeUpdate(e){if(!this.enable)return;this._flowTarget&&(g.HELP_0.copyFrom(this._flowTarget.transform.worldPosition),g.HELP_0.add(this._flowOffset,g.HELP_0),this.target=g.HELP_0);let r=se(me.delta,0,.016);this.smooth?(this._currentPos.x+=(this._targetPos.x-this._currentPos.x)*r*this.dragSmooth,this._currentPos.y+=(this._targetPos.y-this._currentPos.y)*r*this.dragSmooth,this._currentPos.z+=(this._targetPos.z-this._currentPos.z)*r*this.dragSmooth,this._distance+=(this.distance-this._distance)*r*this.wheelSmooth,this._roll+=(this.roll-this._roll)*r*this.rollSmooth,this._pitch+=(this.pitch-this._pitch)*r*this.rollSmooth):(this._currentPos.x=this._targetPos.x,this._currentPos.y=this._targetPos.y,this._currentPos.z=this._targetPos.z,this._distance=this.distance,this._roll=this.roll,this._pitch=this.pitch),this._tempDir.set(0,0,1);let i=Z.HELP_0;i.fromEulerAngles(this._pitch,this._roll,0),this._tempDir.applyQuaternion(i),this._tempPos=bs.mulScale(this._tempDir,this._distance,this._tempPos),this._tempPos.add(this._currentPos.transform.localPosition,this._tempPos),this.camera.lookAt(this._tempPos,this._currentPos.transform.localPosition,g.UP)}destroy(e){m.inputSystem.removeEventListener(F.POINTER_DOWN,this.onMouseDown,this),m.inputSystem.removeEventListener(F.POINTER_MOVE,this.onMouseMove,this),m.inputSystem.removeEventListener(F.POINTER_UP,this.onMouseUp,this),m.inputSystem.removeEventListener(F.POINTER_WHEEL,this.onMouseWheel,this),super.destroy(e),this.camera=null,this._flowTarget=null}}class $A extends null{constructor(){super();s(this,"_camera");s(this,"autoRotate",!1);s(this,"autoRotateSpeed",.1);s(this,"rotateFactor",.5);s(this,"zoomFactor",.1);s(this,"panFactor",.25);s(this,"_smooth",5);s(this,"_minDistance",1);s(this,"_maxDistance",1e5);s(this,"_maxPolarAngle",90);s(this,"_minPolarAngle",-90);s(this,"_target",new g(0,0,0));s(this,"_cTarget",new g(0,0,0));s(this,"_position",new g(0,0,0));s(this,"_cPosition",new g(0,0,0));s(this,"_spherical",new bg);s(this,"_isMouseDown",!1);s(this,"_lastMouseX",-1);s(this,"_lastMouseY",-1);s(this,"_isPanning",!1)}get target(){return this._target}set target(e){this._target=e}get smooth(){return this._smooth}set smooth(e){this._smooth=Math.max(e,1)}get minDistance(){return this._minDistance}set minDistance(e){this._minDistance=se(e,2e-6,this._maxDistance)}get maxDistance(){return this._maxDistance}set maxDistance(e){this._maxDistance=se(e,this._minDistance,1/0)}get minPolarAngle(){return this._minPolarAngle}set minPolarAngle(e){this._minPolarAngle=se(e,-90,this._maxPolarAngle)}get maxPolarAngle(){return this._maxPolarAngle}set maxPolarAngle(e){this._maxPolarAngle=se(e,this._minPolarAngle,90)}get spherical(){return this._spherical}start(){this._camera=this.object3D.getComponent(Fi),this._position=this.object3D.transform.localPosition.clone(),this._cPosition=this._position.clone(),this._target=this._camera.lookTarget.clone(),this._cTarget=this._target.clone(),this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z),this._camera.lookAt(this._cPosition,this._cTarget,g.UP),this.addEventListener()}onEnable(){this.addEventListener()}onDisable(){this.removeEventListener()}onUpdate(){let e=this._isPanning?1:this.smooth,r=!1;this._cPosition.equals(this.object3D.transform.localPosition)||(this._position.copyFrom(this.object3D.transform.localPosition),e=1,r=!0),this._cTarget.equals(this._target)||(this._cTarget.copyFrom(this._target),e=1,r=!0),r?(this._spherical.setCoords(this._position.x-this._target.x,this._position.y-this._target.y,this._position.z-this._target.z),this.updateCamera()):!this._isMouseDown&&this.autoRotate&&(this._spherical.theta-=this.autoRotateSpeed*Math.PI/180,this.updateCamera());let i=(this._position.x-this._cPosition.x)/e,a=(this._position.y-this._cPosition.y)/e,o=(this._position.z-this._cPosition.z)/e;this._cPosition.x=Math.abs(i)>1e-10?this._cPosition.x+i:this._position.x,this._cPosition.y=Math.abs(a)>1e-10?this._cPosition.y+a:this._position.y,this._cPosition.z=Math.abs(o)>1e-10?this._cPosition.z+o:this._position.z,this._camera.lookAt(this._cPosition,this._cTarget,g.UP)}onWheel(e){let r=se(e.deltaY,-this._spherical.radius,this._spherical.radius);this._spherical.radius+=r*this.zoomFactor,this._spherical.radius=se(this._spherical.radius,this.minDistance,this.maxDistance),this.updateCamera(),this._camera.type===qe.ortho&&(this._camera.frustumSize+=e.deltaY*this.zoomFactor,this._camera.frustumSize<this._minDistance?this._camera.frustumSize=this._minDistance:this._camera.frustumSize>this._maxDistance&&(this._camera.frustumSize=this._maxDistance),this._camera.updateProjection())}onPointerDown(e){this._isMouseDown=!0,this._lastMouseX=e.mouseX,this._lastMouseY=e.mouseY,e.mouseCode===2&&(this._isPanning=!0)}onPointerMove(e){if(!this._isMouseDown||!this.enable)return;let r=e.mouseX,i=e.mouseY;if(e.mouseCode===0&&this._lastMouseX>0&&this._lastMouseY>0){const a=-(r-this._lastMouseX)*this.rotateFactor,o=(i-this._lastMouseY)*this.rotateFactor;this._spherical.theta+=a*Math.PI/180,this._spherical.phi-=o*Math.PI/180,this._spherical.phi=se(this._spherical.phi,this.minPolarAngle,this.maxPolarAngle),this.updateCamera()}else e.mouseCode===2&&(bs.mulScale(this.object3D.transform.up,e.movementY*this.panFactor*this._camera.aspect,g.HELP_1),e.ctrlKey||e.metaKey?this._target.y+=g.HELP_1.y:(this._target.x+=g.HELP_1.x,this._target.z+=g.HELP_1.z),bs.mulScale(this.object3D.transform.right,-e.movementX*this.panFactor,g.HELP_1),this._target.x-=g.HELP_1.x,this._target.z-=g.HELP_1.z,this._cTarget.copyFrom(this._target),this.updateCamera());this._lastMouseX=r,this._lastMouseY=i}onPointerUp(e){this._isMouseDown=!1,e.mouseCode===2&&(this._isPanning=!1)}updateCamera(){this._spherical.makeSafe();let e=this._spherical.getCoords();this._position.set(e.x+this._target.x,e.y+this._target.y,e.z+this._target.z)}addEventListener(){m.inputSystem.addEventListener(F.POINTER_WHEEL,this.onWheel,this),m.inputSystem.addEventListener(F.POINTER_DOWN,this.onPointerDown,this),m.inputSystem.addEventListener(F.POINTER_MOVE,this.onPointerMove,this),m.inputSystem.addEventListener(F.POINTER_UP,this.onPointerUp,this)}removeEventListener(){m.inputSystem.removeEventListener(F.POINTER_WHEEL,this.onWheel,this),m.inputSystem.removeEventListener(F.POINTER_DOWN,this.onPointerDown,this),m.inputSystem.removeEventListener(F.POINTER_MOVE,this.onPointerMove,this),m.inputSystem.removeEventListener(F.POINTER_UP,this.onPointerUp,this)}}const ml=Math.PI/180/100;class bg{constructor(t=1,e=0,r=0){s(this,"radius");s(this,"phi");s(this,"theta");s(this,"coords");return this.radius=t,this.phi=e,this.theta=r,this.coords=new g,this}set(t,e,r){return this.radius=t,this.phi=e,this.theta=r,this}makeSafe(){return this.phi=Math.max(ml,Math.min(Math.PI-ml,this.phi)),this}setFromVector3(t){return this.setCoords(t.x,t.y,t.z)}setCoords(t,e,r){return this.radius=Math.sqrt(t*t+e*e+r*r),this.radius===0?(this.theta=0,this.phi=0):(this.theta=Math.atan2(t,r),this.phi=Math.acos(se(e/this.radius,-1,1))),this}getCoords(){const t=Math.sin(this.phi)*this.radius;return this.coords.x=t*Math.sin(this.theta),this.coords.y=Math.cos(this.phi)*this.radius,this.coords.z=t*Math.cos(this.theta),this.coords}}class e0 extends null{constructor(){super();s(this,"focus");s(this,"_rotation",new g(45,0,0));s(this,"distance",5);s(this,"_camera")}start(){if(this._camera=this.object3D.getOrAddComponent(Fi),!this._camera){console.error("ThirdPersonCameraController need camera");return}if(!this.focus){console.error("ThirdPersonCameraController need target");return}m.inputSystem.addEventListener(F.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.addEventListener(F.POINTER_UP,this.mouseUp,this),m.inputSystem.addEventListener(F.POINTER_DOWN,this.mouseDown,this)}mouseDown(e){m.inputSystem.addEventListener(F.POINTER_MOVE,this.mouseMove,this)}mouseUp(e){m.inputSystem.removeEventListener(F.POINTER_MOVE,this.mouseMove,this)}mouseMove(e){this._rotation.y+=e.movementX*.01,this._rotation.x+=e.movementY*.01}mouseWheel(e){this.distance+=m.inputSystem.wheelDelta*.1}onUpdate(){let e=new g;this._camera.transform.forward.scaleToRef(this.distance,e);var r=this.focus.transform.worldPosition;this._camera.transform.localPosition=r.subtract(e)}destroy(e){m.inputSystem.removeEventListener(F.POINTER_WHEEL,this.mouseWheel,this),m.inputSystem.removeEventListener(F.POINTER_UP,this.mouseUp,this),m.inputSystem.removeEventListener(F.POINTER_DOWN,this.mouseDown,this),super.destroy(e)}}var Ge=(n=>(n[n.NORMAL=0]="NORMAL",n[n.DOWN=1]="DOWN",n[n.OVER=2]="OVER",n[n.DISABLE=3]="DISABLE",n))(Ge||{});let wg=Math.PI,Al=wg*2;class Wi{constructor(t=1,e=0,r=0,i=1,a=0,o=0){s(this,"a");s(this,"b");s(this,"c");s(this,"d");s(this,"tx");s(this,"ty");this.a=t,this.b=e,this.c=r,this.d=i,this.tx=a,this.ty=o}clone(){return new Wi(this.a,this.b,this.c,this.d,this.tx,this.ty)}concat(t){let e=this.a,r=this.c,i=this.tx;this.a=e*t.a+this.b*t.c,this.b=e*t.b+this.b*t.d,this.c=r*t.a+this.d*t.c,this.d=r*t.b+this.d*t.d,this.tx=i*t.a+this.ty*t.c+t.tx,this.ty=i*t.b+this.ty*t.d+t.ty}copyFrom(t){return this.a=t.a,this.b=t.b,this.c=t.c,this.d=t.d,this.tx=t.tx,this.ty=t.ty,this}identity(){return this.a=this.d=1,this.b=this.c=this.tx=this.ty=0,this}invert(){this._invertInto(this)}rotate(t){if(t=+t,t!==0){t=t*ft;let e=Math.cos(t),r=Math.sin(t),i=this.a,a=this.b,o=this.c,l=this.d,h=this.tx,u=this.ty;this.a=i*e-a*r,this.b=i*r+a*e,this.c=o*e-l*r,this.d=o*r+l*e,this.tx=h*e-u*r,this.ty=h*r+u*e}}scale(t,e){t!==1&&(this.a*=t,this.c*=t,this.tx*=t),e!==1&&(this.b*=e,this.d*=e,this.ty*=e)}setTo(t,e,r,i,a,o){return this.a=t,this.b=e,this.c=r,this.d=i,this.tx=a,this.ty=o,this}transformPoint(t,e,r){let i=this.a*t+this.c*e+this.tx,a=this.b*t+this.d*e+this.ty;return r?(r.setTo(i,a,0,1),r):new g(i,a,0,1)}setTranslate(t,e){this.tx=t,this.ty=e}translate(t,e){this.tx+=t,this.ty+=e}mul(t){let e=this,r=t,i=e.a,a=e.b,o=e.c,l=e.d,h=e.tx,u=e.ty,c=r.a,f=r.b,d=r.c,p=r.d,A=r.tx,x=r.ty;f!==0||d!==0?(this.a=i*c+a*d,this.b=i*f+a*p,this.c=o*c+l*d,this.d=o*f+l*p,this.tx=c*h+d*u+A,this.ty=f*h+p*u+x):(this.a=i*c,this.b=a*p,this.c=o*c,this.d=l*p,this.tx=c*h+A,this.ty=p*u+x)}equals(t){return this.a==t.a&&this.b==t.b&&this.c==t.c&&this.d==t.d&&this.tx==t.tx&&this.ty==t.ty}prepend(t,e,r,i,a,o){let l=this.tx;if(t!=1||e!=0||r!=0||i!=1){let h=this.a,u=this.c;this.a=h*t+this.b*r,this.b=h*e+this.b*i,this.c=u*t+this.d*r,this.d=u*e+this.d*i}return this.tx=l*t+this.ty*r+a,this.ty=l*e+this.ty*i+o,this}append(t){let e=this.a,r=this.b,i=this.c,a=this.d;return(t.a!=1||t.b!=0||t.c!=0||t.d!=1)&&(this.a=t.a*e+t.b*i,this.b=t.a*r+t.b*a,this.c=t.c*e+t.d*i,this.d=t.c*r+t.d*a),this.tx=t.tx*e+t.ty*i+this.tx,this.ty=t.tx*r+t.ty*a+this.ty,this}deltaTransformPoint(t){let e=this,r=e.a*t.x+e.c*t.y,i=e.b*t.x+e.d*t.y;return new g(r,i)}toString(){return"(a="+this.a+", b="+this.b+", c="+this.c+", d="+this.d+", tx="+this.tx+", ty="+this.ty+")"}createBox(t,e,r=0,i=0,a=0){let o=this;if(r!==0){r=r*ft;let l=Math.cos(r),h=Math.sin(r);o.a=l*t,o.b=h*e,o.c=-h*t,o.d=l*e}else o.a=t,o.b=0,o.c=0,o.d=e;o.tx=i,o.ty=a}createGradientBox(t,e,r=0,i=0,a=0){this.createBox(t/1638.4,e/1638.4,r,i+t/2,a+e/2)}_invertInto(t){let e=this.a,r=this.b,i=this.c,a=this.d,o=this.tx,l=this.ty;if(r==0&&i==0){t.b=t.c=0,e==0||a==0?t.a=t.d=t.tx=t.ty=0:(e=t.a=1/e,a=t.d=1/a,t.tx=-e*o,t.ty=-a*l);return}let h=e*a-r*i;if(h==0){t.identity();return}h=1/h;let u=t.a=a*h;r=t.b=-r*h,i=t.c=-i*h,a=t.d=e*h,t.tx=-(u*o+i*l),t.ty=-(r*o+a*l)}getScaleX(){let t=this;if(t.a==1&&t.b==0)return 1;let e=Math.sqrt(t.a*t.a+t.b*t.b);return this.getDeterminant()<0?-e:e}getScaleY(){let t=this;if(t.c==0&&t.d==1)return 1;let e=Math.sqrt(t.c*t.c+t.d*t.d);return this.getDeterminant()<0?-e:e}getSkewX(){return Math.atan2(this.d,this.c)-Math.PI/2}getSkewY(){return Math.atan2(this.b,this.a)}updateScaleAndRotation(t,e,r,i){if((r==0||r==Al)&&(i==0||i==Al)){this.a=t,this.b=this.c=0,this.d=e;return}r=r*ft,i=i*ft;let a=Math.cos(r),o=Math.sin(r);r==i?(this.a=a*t,this.b=o*t):(this.a=Math.cos(i)*t,this.b=Math.sin(i)*t),this.c=-o*e,this.d=a*e}preMultiplyInto(t,e){let r=t.a*this.a,i=0,a=0,o=t.d*this.d,l=t.tx*this.a+this.tx,h=t.ty*this.d+this.ty;(t.b!==0||t.c!==0||this.b!==0||this.c!==0)&&(r+=t.b*this.c,o+=t.c*this.b,i+=t.a*this.b+t.b*this.d,a+=t.c*this.a+t.d*this.c,l+=t.ty*this.c,h+=t.tx*this.b),e.a=r,e.b=i,e.c=a,e.d=o,e.tx=l,e.ty=h}$transformBounds(t){let e=this.a,r=this.b,i=this.c,a=this.d,o=this.tx,l=this.ty,h=t.x,u=t.y,c=h+t.width,f=u+t.height,d=e*h+i*u+o,p=r*h+a*u+l,A=e*c+i*u+o,x=r*c+a*u+l,C=e*c+i*f+o,v=r*c+a*f+l,y=e*h+i*f+o,b=r*h+a*f+l,B=0;d>A&&(B=d,d=A,A=B),C>y&&(B=C,C=y,y=B),t.x=Math.floor(d<C?d:C),t.width=Math.ceil((A>y?A:y)-t.x),p>x&&(B=p,p=x,x=B),v>b&&(B=v,v=b,b=B),t.y=Math.floor(p<v?p:v),t.height=Math.ceil((x>b?x:b)-t.y)}getDeterminant(){return this.a*this.d-this.b*this.c}}class ws extends Qt{constructor(){super(...arguments);s(this,"isGUICanvas",!0);s(this,"index",0)}addChild(e){return this.object3D.addChild(e),this}removeChild(e){return this.object3D.removeChild(e),this}cloneTo(e){e.getOrAddComponent(ws).copyComponent(this)}copyComponent(e){return e.index=e.index,this}}var $e=(n=>(n[n.NONE=0]="NONE",n[n.POSITION=1]="POSITION",n[n.SPRITE=2]="SPRITE",n[n.COLOR=4]="COLOR",n[n.MAX=7]="MAX",n))($e||{});class ko{constructor(t){s(this,"array");s(this,"buffer");this.buffer=new be(t,0),this.array=new Float32Array(this.buffer.memory.shareDataBuffer)}}class Tg extends qt{constructor(e){super();s(this,"_attributeUV");s(this,"_attributeVIndex");s(this,"_faceIndexes");s(this,"_uvSize",2);s(this,"_vIndexSize",1);s(this,"_posAttribute");s(this,"_spriteAttribute");s(this,"_colorAttribute");s(this,"_onPositionChange",!0);s(this,"_onSpriteChange",!0);s(this,"_onColorChange",!0);s(this,"maxQuadCount");this.maxQuadCount=e}updateSubGeometry(e,r,i){let a=this.subGeometries[e];if(a){let o=a.lodLevels[0];o.indexStart=r,o.indexCount=i,o.index=e}else a=this.addSubGeometry({indexStart:r,indexCount:i,vertexStart:0,vertexCount:0,firstStart:0,index:e,topology:0});return a}resetSubGeometries(){for(let e of this.subGeometries){let r=e.lodLevels[0];r.indexStart=0,r.indexCount=0,r.index=0}}updateBounds(e,r){let i=Number.MAX_VALUE*.1;return e=new g(-i,-i,-i),r=new g(i,i,i),this.bounds.setFromMinMax(e,r),this}getPositionBuffer(){return this._onPositionChange&&(this._posAttribute.buffer.apply(),this._onPositionChange=!1),this._posAttribute.buffer}getSpriteBuffer(){return this._onSpriteChange&&(this._spriteAttribute.buffer.apply(),this._onSpriteChange=!1),this._spriteAttribute.buffer}getColorBuffer(){return this._onColorChange&&(this._colorAttribute.buffer.apply(),this._onColorChange=!1),this._colorAttribute.buffer}create(){this.createBuffer(),this.updateBounds();let e=this.maxQuadCount,r=[],i=[];for(let o=0;o<e;o++)r.push(...Nr.attUV);for(let o=0,l=this.maxQuadCount*Nr.vertexCount;o<l;o++)i[o]=o;this._attributeUV=new Float32Array(Nr.vertexCount*e*this._uvSize),this._attributeVIndex=new Float32Array(Nr.vertexCount*e*this._vIndexSize),this._attributeUV.set(r,0),this._attributeVIndex.set(i,0);let a=[];for(let o=0;o<e;o++)for(let l=0;l<Nr.indecies.length;l++){const h=Nr.indecies[l]+o*4;a.push(h)}return this._faceIndexes=new Uint32Array(e*6),this._faceIndexes.set(a,0),this.setIndices(this._faceIndexes),this.setAttribute(O.uv,this._attributeUV),this.setAttribute(O.vIndex,this._attributeVIndex),this.updateSubGeometry(0,0,this._faceIndexes.length),this}createBuffer(){let e=this.maxQuadCount;this._posAttribute=new ko(e*4),this._spriteAttribute=new ko(e*12),this._colorAttribute=new ko(e*4)}fillQuad(e,r){e.dirtyAttributes&$e.POSITION&&this.fillQuadPosition(e,r),e.dirtyAttributes&$e.COLOR&&this.fillQuadColor(e,r),e.dirtyAttributes&$e.SPRITE&&this.fillQuadSprite(e,r)}fillQuadPosition(e,r){vl.setXYZW(this._posAttribute.array,e.z,e.left,e.bottom,e.right,e.top),this._onPositionChange=!0}fillQuadColor(e,r){let i=e.color,a=this._colorAttribute.array;vl.setXYZW(a,e.z,i.r,i.g,i.b,i.a),this._onColorChange=!0}fillQuadSprite(e,r){let i=e.sprite,a=0,o=0;i.isSliced&&e.imageType==Ba.Sliced&&(a=i.trimSize.x,a=(r.width-(i.offsetSize.z-i.trimSize.x))/a,o=i.trimSize.y,o=(r.height-(i.offsetSize.w-i.trimSize.y))/o);let l=i.guiTexture.dynamicId,h=i.uvRec,u=i.uvBorder,c=this._spriteAttribute.array,f=12*e.z;c[f+0]=h.x,c[f+1]=h.y,c[f+2]=h.z,c[f+3]=h.w,c[f+4]=u.x,c[f+5]=u.y,c[f+6]=u.z,c[f+7]=u.w,c[f+8]=a,c[f+9]=o,c[f+10]=l,c[f+11]=e.visible?1:0,this._onSpriteChange=!0}}class Eg{static set(t,e,r,i,...a){let o=e*i+r;for(let l=0,h=a.length;l<h;l++)t[o+l]=a[l]}}class vl extends Eg{static setXYZW(t,e,r,i,a,o){this.set(t,e,0,4,r,i,a,o)}static setXYZ(t,e,r,i,a){this.set(t,e,0,4,r,i,a)}static setZ(t,e,r){this.set(t,e,3,4,r)}}class Nr{}s(Nr,"vertexCount",4),s(Nr,"attUV",[0,0,1,0,1,1,0,1]),s(Nr,"indecies",[0,1,2,0,2,3]);class Bg{constructor(){s(this,"_textureMap",new Map);s(this,"_textureList",[])}build(t,e,r){let i=e._geometry;i.resetSubGeometries();let a=-1,o=0,l=0,h=0,u=0,c=this._textureList,f=this._textureMap;function d(){h>0&&(e.updateDrawCallSegment(u,l,h),e._uiRenderer.materials[u].setTextures(c),f.clear(),c.length=0,u++,l+=h,h=0,o=0)}f.clear(),c.length=0;let p=[],A=e.quadMaxCount-1;for(let x of t){let C=x.needUpdateQuads;p.length=0;const v=this.collectQuads(x.object3D,p);for(let y of v){let b=y.sprite.guiTexture;if(f.has(b.staticId)||(o==7&&d(),f.set(b.staticId,b),b.dynamicId=o,c[o]=b.texture,o+=1),y.z=++a,h+=6,y.cacheTextureId!=b.dynamicId&&(y.dirtyAttributes=$e.MAX,y.cacheTextureId=b.dynamicId),(C||r)&&(y.dirtyAttributes=$e.MAX),y.dirtyAttributes&$e.POSITION&&y.applyTransform(x),y.dirtyAttributes&&y.writeToGeometry(i,x),a==A)return d(),!0}}return d(),!1}collectQuads(t,e){e||(e=[]);let r=t.components.values();for(let i of r){let a=i;if(a.isUIShadow||!a.mainQuads)continue;let o=a.getShadowRender();o&&this.push(o.mainQuads,e),this.push(a.mainQuads,e)}return e}push(t,e){t&&t.length>0&&e.push(...t)}}const ot=class ot{static bindTextureArray(){let t="";for(let e=0;e<7;e++)t+=`
        @group(1) @binding(auto)
        var tex_${e}Sampler: sampler;
        @group(1) @binding(auto)
#if VideoTexture${e}
        var tex_${e}: texture_external;
#else
        var tex_${e}: texture_2d<f32>;
#endif
`;return t}static sampleTexture(t){return`
#if VideoTexture${t}
            let size = textureDimensions(tex_${t}).xy - 1;
            uv.y = 1.0 - uv.y;
            let iuv = vec2<i32>(uv * vec2<f32>(size));
            color = textureLoad(tex_${t}, iuv) ;
#else
            color = textureSampleLevel(tex_${t}, tex_${t}Sampler, uv, 0.0);
#endif        `}};s(ot,"fs",`
        ${Cn}
        ${ot.bindTextureArray()}

        var<private> fragmentOutput: FragmentOutput;
        var<private> uvSlice: vec2<f32>;
        var<private> EPSILON: f32 = 0.001;
        
        fn sliceBorder(uv:f32, scale:f32, border:vec2<f32>) -> f32 
        {
            var s = uv * scale;
            if(s > border.x){
                s -= border.x;
                let centerPartMax = scale - border.x - border.y;
                let centerPartMin = 1.0 - border.x - border.y;
                if(s < centerPartMax){
                    s = border.x + (s / centerPartMax) * centerPartMin;
                }else{
                    s = s - centerPartMax + border.x + centerPartMin;
                }
            }
            return s;
        }

        fn isInsideAlpha(coord:vec2<f32>, rect:vec4<f32>, cornerRadius0:f32, fadeOutSize0:f32) -> f32
        {
            var minX = min(rect.x, rect.z);
            var maxX = max(rect.x, rect.z);
            var minY = min(rect.y, rect.w);
            var maxY = max(rect.y, rect.w);

            var cornerRadius = max(EPSILON, cornerRadius0);

            var center = vec2<f32>(minX + maxX, minY + maxY) * 0.5;
            var extents = vec2<f32>(maxX - minX, maxY - minY) * 0.5;

            cornerRadius = min(extents.x, cornerRadius);
            cornerRadius = min(extents.y, cornerRadius);
            
            var extendsMin = max(vec2<f32>(0.0), extents - cornerRadius);
            
            var toCenter = abs(coord - center);
            var outerDist = toCenter - extents;
            var innerDist = toCenter - extendsMin;
            
            if(innerDist.x <= 0 && innerDist.y <= 0){
                return 1.0;
            }else if(outerDist.x <= 0 && outerDist.y <= 0){
                var fadeOutPercent = clamp(fadeOutSize0, EPSILON, cornerRadius) / cornerRadius;
                innerDist = max(vec2(EPSILON), innerDist);
                var distance = min(cornerRadius, length(innerDist));
                var alpha = 1.0 - distance / cornerRadius;
                alpha /= fadeOutPercent;
                alpha = clamp(alpha, 0.0, 1.0);
                return alpha;
            }
            return 0.0;
        }
        
        @fragment
        fn FragMain( 
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            @builtin(front_facing) face: bool,
            @builtin(position) fragCoord : vec4<f32> 
        ) -> FragmentOutput {

            var scissorAlpha = 1.0;
#if SCISSOR_ENABLE
            scissorAlpha = isInsideAlpha(
                vLocalPos.xy,
                materialUniform.scissorRect,
                materialUniform.scissorCornerRadius,
                materialUniform.scissorFadeOutSize);

            if(scissorAlpha < EPSILON){
                discard;
            }
#endif

            uvSlice = vUvSlice;
            
            var uv:vec2<f32> = vUV;
            if(uvSlice.x > 1.0){ uv.x = sliceBorder(uv.x, uvSlice.x, vUvBorder.xz);}
            if(uvSlice.y > 1.0){ uv.y = sliceBorder(uv.y, uvSlice.y, vUvBorder.yw);}
            uv = uv * vUvRec.zw + vUvRec.xy;
            
            var color = vec4<f32>(0.0,0.0,0.0,1.0);
            let texId = i32(vTextureID + 0.5);
            
            var texSize = vec2<i32>(0);
            var coord = vec2<i32>(0);
            
            if(texId == 0){
                ${ot.sampleTexture(0)}
            }else if(texId == 1){
                ${ot.sampleTexture(1)}
            }else if(texId == 2){
                ${ot.sampleTexture(2)}
            }else if(texId == 3){            
                ${ot.sampleTexture(3)}
            }else if(texId == 4){            
                ${ot.sampleTexture(4)}
            }else if(texId == 5){            
                ${ot.sampleTexture(5)}
            }else if(texId == 6){            
                ${ot.sampleTexture(6)}
            }
            var rgb = color.rgb;
            var alpha = color.a;

            rgb *= vColor4.rgb;
            alpha *= vColor4.a;
            alpha *= scissorAlpha;
            if(color.a < EPSILON)
            { 
                discard;
            }

            fragmentOutput.color = vec4<f32>(rgb, alpha);
            return fragmentOutput ;
        }`),s(ot,"GUI_common_vs",`
        ${xn}
        ${vn}

        struct VertexSpriteBuffer {
            vUvRec: vec4<f32>,
            vUvBorder: vec4<f32>,
            vUvSlice: vec2<f32>,
            vTextureID: f32,
            vVisible: f32
        }
                
        struct MaterialUniform{
            scissorRect:vec4<f32>,

            screenSize:vec2<f32>,
            scissorCornerRadius:f32,
            scissorFadeOutSize:f32,

            pixelRatio:f32,

            v3:vec3<f32>
        }
        
        struct VertexOutput {
            @location(auto) vUV: vec2<f32>,
            @location(auto) vColor4: vec4<f32>,
            @location(auto) vLocalPos: vec2<f32>,
            @location(auto) vUvRec: vec4<f32>,
            @location(auto) vUvBorder: vec4<f32>,
            @location(auto) vUvSlice: vec2<f32>,
            @location(auto) vTextureID: f32,
            
            @builtin(position) member: vec4<f32>
        };
        
         struct VertexInput{
            @builtin(instance_index) index : u32,
            @location(auto) uv: vec2<f32>,
            @location(auto) vIndex: f32,
        }

        @group(2) @binding(0)
        var<uniform> materialUniform : MaterialUniform;
        @group(3) @binding(1)
        var<storage, read> vPositionBuffer: array<vec4<f32>>;
        @group(3) @binding(2)
        var<storage, read> vSpriteBuffer: array<VertexSpriteBuffer>;
        @group(3) @binding(3)
        var<storage, read> vColorBuffer: array<vec4<f32>>;

        var<private> vertexOut: VertexOutput ;

        //quad: (left, bottom, right, top)
        //index: 0~3
        fn getVertexXY(quad:vec4<f32>, index:u32) -> vec2<f32>
        {
            var ret = vec2<f32>(0.0);
            if(index == 0 || index == 3){
                ret.x = quad.x;
            }else{
                ret.x = quad.z;
            }
            if(index == 0 || index == 1){
                ret.y = quad.w;
            }else{
                ret.y = quad.y;
            }
            return ret;
        }
    `),s(ot,"GUI_shader_view",`
        ${ot.GUI_common_vs}

        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var _m = models.matrix[0];
            var _n = globalUniform.frame;
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var vSpriteData = vSpriteBuffer[quadIndex];
            
            var op = vec2<f32>(0.0001);
            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = 2.0 * vertexPosition * materialUniform.pixelRatio  / materialUniform.screenSize;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = vec4<f32>(op.x, op.y, vertexIndex * 0.0001, 1.0);

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${ot.fs}
        `),s(ot,"GUI_shader_world",`
        ${ot.GUI_common_vs}
        @vertex
        fn VertMain( vertex:VertexInput ) -> VertexOutput {
            var modelMatrix = models.matrix[vertex.index];
            
            let vertexIndex = vertex.vIndex;
            let quadIndex = u32(vertex.vIndex * 0.25);
            let vertexPosition = getVertexXY(vPositionBuffer[quadIndex], u32(vertexIndex) % 4u);
            var localPos = vec4<f32>(vertexPosition.xy, vertexIndex * 0.0001, 1.0) ;
            var op = vec4<f32>(0.0001);
            var vSpriteData = vSpriteBuffer[quadIndex];

            let isValidVertex = vSpriteData.vVisible > 0.5;
            if(isValidVertex){
                op = globalUniform.projMat * globalUniform.viewMat * modelMatrix * localPos ;
            }

            vertexOut.vLocalPos = vertexPosition;
            vertexOut.member = op;

            vertexOut.vUV = vec2<f32>(vertex.uv);
            vertexOut.vUvRec = vSpriteData.vUvRec;
            vertexOut.vUvBorder = vSpriteData.vUvBorder;
            vertexOut.vUvSlice = vSpriteData.vUvSlice;
            vertexOut.vTextureID = vSpriteData.vTextureID;
            vertexOut.vColor4 = vColorBuffer[quadIndex];

            return vertexOut;
         }
         
         ${ot.fs}

        `);let Ts=ot;class xl extends $r{constructor(e){super();s(this,"_scissorRect");s(this,"_screenSize",new he(1024,768));s(this,"_scissorEnable",!1);s(this,"_videoTextureFlags",{});H.register("GUI_shader_view",Ts.GUI_shader_view),H.register("GUI_shader_world",Ts.GUI_shader_world);let r=new gt;this.addColorPass(r,J.COLOR,e),this.addColorPass(r,J.UI,e),this.shader=r}addColorPass(e,r,i){let a=i==lr.View?"GUI_shader_view":"GUI_shader_world",o=new Le(a,a);o.passType=r,o.setShaderEntry("VertMain","FragMain"),o.setUniformVector4("scissorRect",new ae),o.setUniformVector2("screenSize",this._screenSize),o.setUniformFloat("scissorCornerRadius",0),o.setUniformFloat("scissorFadeOutSize",0),o.setUniformFloat("pixelRatio",1),o.setUniformVector3("v3",g.ZERO);let l=o.shaderState;l.depthWriteEnabled=!1,o.blendMode=oe.NORMAL,o.depthCompare=i==lr.View?ct.always:ct.less_equal,o.cullMode=Pt.back,e.addRenderPass(o)}setPanelRatio(e){this.shader.setUniformFloat("pixelRatio",e)}setScissorRect(e,r,i,a){this._scissorRect||(this._scissorRect=new ae),this._scissorRect.set(e,r,i,a),this.shader.setUniformVector4("scissorRect",this._scissorRect)}setScissorEnable(e){this._scissorEnable!=e&&(this._scissorEnable=e,e?this.shader.setDefine("SCISSOR_ENABLE",!0):this.shader.deleteDefine("SCISSOR_ENABLE"),this.shader.noticeValueChange())}setScissorCorner(e,r){this.shader.setUniformFloat("scissorCornerRadius",e),this.shader.setUniformFloat("scissorFadeOutSize",r)}setScreenSize(e,r){return this._screenSize.set(e,r),this.shader.setUniformVector2("screenSize",this._screenSize),this}setTextures(e){for(let r=0;r<7;r++){let i=e[r]||m.res.whiteTexture;this.shader.setTexture(`tex_${r}`,i),this.setVideoTextureDefine(r,i.isVideoTexture)}}setVideoTextureDefine(e,r){let i=!1;r!=this._videoTextureFlags[e]&&(r?this.shader.setDefine(`VideoTexture${e}`,!0):this.shader.deleteDefine(`VideoTexture${e}`),this._videoTextureFlags[e]=r,i=!0),i&&this.shader.noticeValueChange()}set envMap(e){}set shadowMap(e){}set baseMap(e){}set normalMap(e){}set emissiveMap(e){}set irradianceMap(e){}set irradianceDepthMap(e){}}class Dg extends ${constructor(){super(...arguments);s(this,"_guiGeometry")}init(e){super.init(),this.addRendererMask(ye.UI),this.removeRendererMask(ye.Default),this.castGI=!1,this.castShadow=!1,this.alwaysRender=!0,this._ignoreEnvMap=this._ignorePrefilterMap=!0}get geometry(){return super.geometry}set geometry(e){super.geometry=e,this._guiGeometry=e}nodeUpdate(e,r,i,a){for(let o=0;o<this.materials.length;o++){let l=this.materials[o].getPass(r),h=this._guiGeometry.getPositionBuffer(),u=this._guiGeometry.getSpriteBuffer(),c=this._guiGeometry.getColorBuffer();if(l)for(let f=0;f<l.length;f++){const d=l[f];d.pipeline||(d.setStorageBuffer("vPositionBuffer",h),d.setStorageBuffer("vSpriteBuffer",u),d.setStorageBuffer("vColorBuffer",c))}}super.nodeUpdate(e,r,i,a)}onUpdate(e){}}class Mg{constructor(){s(this,"_use");s(this,"_unUse");this._use=[],this._unUse=[]}pushBack(t){let e=this._use.indexOf(t);e!=-1&&(this._use.splice(e,1),this._unUse.push(t))}getUseList(){return this._use}getOne(t,e){let r;return this._unUse.length>0?(r=this._unUse[0],this._unUse.splice(0,1),this._use.push(r),r):(r=new t(e),this._use.push(r),r)}hasFree(){return this._unUse.length>0}}let Ua;const ea=class ea{constructor(){s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"width",1);s(this,"height",1);s(this,"_globalX",0);s(this,"_globalY",0);s(this,"_globalWidth",0);s(this,"_globalHeight",0);s(this,"_visible",!0);s(this,"_offsetX",0);s(this,"_offsetY",0);s(this,"_sprite",m.res.defaultGUISprite);s(this,"_color",new K(1,1,1,1));s(this,"_imageType",Ba.Simple);s(this,"dirtyAttributes",$e.MAX);s(this,"cacheTextureId",-1)}static get quadPool(){return this.textPool||(this.textPool=new Mg),this.textPool}static recycleQuad(t){t.sprite=null,t.dirtyAttributes=$e.MAX,t.x=0,t.y=0,t.z=-1,t.cacheTextureId=-1,ea.quadPool.pushBack(t)}static spawnQuad(){return ea.quadPool.getOne(ea)}get imageType(){return this._imageType}set imageType(t){this._imageType=t,this.setAttrChange($e.SPRITE|$e.POSITION)}get color(){return this._color}set color(t){this._color.copyFrom(t),this.setAttrChange($e.COLOR)}get visible(){return this._visible}set visible(t){t!=this._visible&&(this._visible=t,this.setAttrChange($e.SPRITE))}get sprite(){return this._sprite}set sprite(t){this._sprite!=t&&(this._sprite=t,this.setAttrChange($e.SPRITE|$e.POSITION))}get left(){return this._globalX-this._offsetX}get right(){return this.left+this._globalWidth}get top(){return this._globalY-this._offsetY}get bottom(){return this.top+this._globalHeight}setSize(t,e){this.width=t,this.height=e,this.setAttrChange($e.POSITION)}setXY(t,e){this.x=t,this.y=e,this.setAttrChange($e.POSITION)}setAttrChange(t){this.dirtyAttributes=this.dirtyAttributes|t}applyTransform(t){this.setAttrChange($e.POSITION);let e=this._sprite,r=t.getWorldMatrix();(this.x!=0||this.y!=0)&&(r=this.getQuadMatrix(r));let i=r.getScaleX(),a=r.getScaleY(),o=e.isSliced&&this._imageType==Ba.Sliced;if(this._offsetX=t.width*.5*i,this._offsetY=t.height*.5*a,o)this._globalWidth=i*(t.width-(e.offsetSize.z-e.trimSize.x)),this._globalHeight=a*(t.height-(e.offsetSize.w-e.trimSize.y)),this._globalX=r.tx+e.offsetSize.x*i,this._globalY=r.ty+e.offsetSize.y*a;else{let l=this.width/e.offsetSize.z,h=this.height/e.offsetSize.w;this._globalWidth=i*e.trimSize.x*l,this._globalHeight=a*e.trimSize.y*h,this._globalX=r.tx+e.offsetSize.x*l*i,this._globalY=r.ty+e.offsetSize.y*h*a}return this}getQuadMatrix(t){return Ua||(Ua=new Wi),Ua.identity(),Ua.setTranslate(this.x,this.y),Ua.mul(t),Ua}writeToGeometry(t,e){return t.fillQuad(this,e),this.dirtyAttributes=$e.NONE,this}};s(ea,"textPool");let Si=ea;class Pg extends Qt{constructor(){super(...arguments);s(this,"_uiTransform");s(this,"_visible",!0)}destroy(){this._uiTransform.setNeedUpdateUIPanel(),super.destroy()}get uiTransform(){return this._uiTransform}get visible(){return this._visible}set visible(e){var r;this._visible!=e&&(this._visible=e,(r=this.onUIComponentVisible)==null||r.call(this,this._visible))}init(e){var r;(r=super.init)==null||r.call(this,e),this._uiTransform=this.object3D.getOrAddComponent(ri),this._uiTransform.setNeedUpdateUIPanel()}copyComponent(e){return this.visible=e.visible,this}}class Rg extends Pg{constructor(){super(...arguments);s(this,"_mainQuads");s(this,"_shadowRender");s(this,"_shadowSource");s(this,"isUIShadow");s(this,"isShadowless");s(this,"needUpdateShadow")}init(e){var r;(r=super.init)==null||r.call(this,e),this._mainQuads=[]}destroy(){var e,r;this.detachQuads(),(e=this._shadowRender)==null||e.setShadowSource(null),(r=this._shadowSource)==null||r.setShadowRenderer(null),super.destroy(),this._shadowRender=null,this._shadowSource=null}start(){var e;(e=super.start)==null||e.call(this),this.isUIShadow?this.autoBindShadow(null,this):this.isShadowless||this.autoBindShadow(this,null),this.setShadowDirty()}setShadowDirty(){this._shadowRender&&(this._shadowRender.needUpdateShadow=!0)}get mainQuads(){return this._mainQuads}setShadowRenderer(e){this._shadowRender=e}setShadowSource(e){this._shadowSource=e}getShadowRender(){return this._shadowRender}autoBindShadow(e,r){let i=this.object3D.components.values();if(!e)for(let a of i){let o=a;if(!(o.isShadowless||o.isUIShadow)&&o.mainQuads){e=o;break}}if(!r)for(let a of i){let o=a;if(o.isUIShadow&&o.mainQuads){r=o;break}}return e&&r?(e.setShadowRenderer(r),r.setShadowSource(e),!0):!1}recycleQuad(e){if(e&&this._mainQuads){let r=this._mainQuads.indexOf(e);r>=0?(this._mainQuads.splice(r,1),Si.recycleQuad(e)):e=null}return e}attachQuad(e){return this._mainQuads&&this._mainQuads.push(e),this}detachQuads(){if(this._mainQuads)for(;this._mainQuads.length>0;){let e=this._mainQuads.shift();this.recycleQuad(e)}return this}copyComponent(e){return super.copyComponent(e),this.isUIShadow=e.isUIShadow,this.isShadowless=e.isShadowless,this}}class Ki extends Rg{init(t){var e;(e=super.init)==null||e.call(this,t),this.attachQuad(Si.spawnQuad()),this.sprite=m.res.defaultGUISprite}cloneTo(t){t.getOrAddComponent(Ki).copyComponent(this)}copyComponent(t){return super.copyComponent(t),this.sprite=t.sprite,this.color=t.color,this.imageType=t.imageType,this}set sprite(t){t||(t=m.res.defaultGUISprite);for(let e of this._mainQuads)e.sprite=t,e.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}onTransformResize(){this.applyTransformSize()}applyTransformSize(){for(let t of this._mainQuads)t.setSize(this._uiTransform.width,this._uiTransform.height);this.setShadowDirty()}get sprite(){return this._mainQuads[0].sprite}onUIComponentVisible(t){this.applyComponentVisible()}onUITransformVisible(t){this.applyComponentVisible()}applyComponentVisible(){let t=!this._visible||!this._uiTransform.globalVisible;for(let e of this._mainQuads)e.visible=!t;this.setShadowDirty()}get color(){return this._mainQuads[0].color}set color(t){for(let e of this._mainQuads)e.color=t;this.setShadowDirty()}get imageType(){return this._mainQuads[0].imageType}set imageType(t){for(let e of this._mainQuads)e.imageType=t;this.setShadowDirty()}}class Es extends Ki{constructor(){super(...arguments);s(this,"space",lr.World);s(this,"needUpdateGeometry",!0);s(this,"panelOrder",0);s(this,"needSortOnCameraZ");s(this,"_billboard");s(this,"_rebuild");s(this,"scissorEnable",!1);s(this,"scissorCornerRadius",0);s(this,"scissorFadeOutSize",0);s(this,"_uiRenderer");s(this,"_geometry");s(this,"_maxCount",128);s(this,"panelRatio",1);s(this,"isUIPanel",!0);s(this,"_collectTransform",[])}cloneTo(e){e.getOrAddComponent(Es).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.panelOrder=e.panelOrder,this.needSortOnCameraZ=e.needSortOnCameraZ,this.cullMode=e.cullMode,this.billboard=e.billboard,this.scissorEnable=e.scissorEnable,this.scissorCornerRadius=e.scissorCornerRadius,this.scissorFadeOutSize=e.scissorFadeOutSize,this}init(e){super.init(e),this._uiTransform.resize(E.canvas.width,E.canvas.height),this.create(this.space),this.visible=!1}updateDrawCallSegment(e,r,i){this._geometry.updateSubGeometry(e,r,i);let a=this._uiRenderer.material,o=this._uiRenderer.materials[e];if(!o){o=new xl(this.space);let l=this._uiRenderer.materials.slice();l.push(o),this._uiRenderer.materials=l,o.cullMode=a.cullMode,o.depthCompare=a.depthCompare}}create(e){this._maxCount=this.space==lr.World?Zt.quadMaxCountForWorld:Zt.quadMaxCountForView,this._uiRenderer=this.object3D.addComponent(Dg),this._geometry=this._uiRenderer.geometry=new Tg(this._maxCount).create(),this._uiRenderer.material=new xl(e),this._uiRenderer.renderOrder=Zt.SortOrderStartWorld,this._rebuild=new Bg,this.object3D.bound=new Oe(new g,new g(1,1,1).multiplyScalar(Number.MAX_VALUE*.1))}get quadMaxCount(){return this._maxCount}get renderer(){return this._uiRenderer}set billboard(e){this.space==lr.View&&(e=xi.None,console.warn("Cannot enable billboard in view space")),e==xi.BillboardXYZ||e==xi.BillboardY?(this._billboard=this.object3D.getOrAddComponent(Is),this._billboard.type=e):(this.object3D.removeComponent(Is),this._billboard=null)}get billboard(){return this._billboard?this._billboard.type:xi.None}set cullMode(e){if(this.space==lr.World)for(let r of this._uiRenderer.materials)r.cullMode=e;else console.warn("Cannot change cullMode in view space")}get cullMode(){return this._uiRenderer.material.cullMode}onUpdate(e){var r;(r=super.onUpdate)==null||r.call(this,e),this.rebuildGUIMesh(e)}rebuildGUIMesh(e){let r=this,i=r._collectTransform;if(i.length=0,r.object3D.getComponents(ri,i),i.length>0){r._rebuild.build(i,r,r.needUpdateGeometry);for(const h of i)h.needUpdateQuads=!1}let a=r.object3D.getComponentFromParent(ws),o=a?a.index:0;r._uiRenderer.enable=i.length>0;let l=r.isViewPanel?Zt.SortOrderStartView:Zt.SortOrderStartWorld;if(r._uiRenderer.renderOrder=o*Zt.SortOrderCanvasSpan+l+r.panelOrder,r._uiRenderer.needSortOnCameraZ=r.needSortOnCameraZ,this.space==lr.View){let h=E.canvas.clientWidth,u=E.canvas.clientHeight,c=this._uiTransform.width,f=this._uiTransform.height;this.panelRatio=this.updateGUIPixelRatio(h,u,c,f)}else this.panelRatio=1;for(let h of r._uiRenderer.materials){let u=h;if(u.setPanelRatio(this.panelRatio),u.setScreenSize(E.canvas.clientWidth,E.canvas.clientHeight),u.setScissorEnable(r.scissorEnable),r.scissorEnable){let c=r.mainQuads[0];u.setScissorRect(c.left,c.bottom,c.right,c.top),u.setScissorCorner(r.scissorCornerRadius,r.scissorFadeOutSize)}}r.needUpdateGeometry=!1}updateGUIPixelRatio(e,r,i,a){let o=i/a,l=e/r,h=1;return o<l?h=r/a:h=e/i,h}}class zo extends Es{constructor(){super();s(this,"isViewPanel",!0);s(this,"space",lr.View)}cloneTo(e){e.getOrAddComponent(zo).copyComponent(this)}}class Go extends Es{constructor(){super();s(this,"isWorldPanel",!0);s(this,"space",lr.World);s(this,"_depthTest",!0)}cloneTo(e){e.getOrAddComponent(Go).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.depthTest=e.depthTest,this}get depthTest(){return this._depthTest}set depthTest(e){if(this._depthTest!=e){this._depthTest=e;let r=this.depthTest?ct.less_equal:ct.always;for(let i of this._uiRenderer.materials)i.depthCompare=r}}}let Cl;class ri extends Qt{constructor(){super();s(this,"useParentPivot",!1);s(this,"parent");s(this,"pivotX",.5);s(this,"pivotY",.5);s(this,"_width",100);s(this,"_height",100);s(this,"_localVisible",!0);s(this,"_globalVisible",!0);s(this,"_uiInteractiveList");s(this,"_localMatrix");s(this,"_worldMatrix");s(this,"_onChange",!0);s(this,"needUpdateQuads",!0);s(this,"_tempTransforms",[]);this._localMatrix=new Wi,this._worldMatrix=new Wi}get uiInteractiveList(){return this._uiInteractiveList}init(e){var r;super.init(e),this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),this.onParentChange(null,(r=this.object3D.parent)==null?void 0:r.object3D)}onTransformChange(e){this.onChange=!0}addUIInteractive(e){return this._uiInteractiveList||(this._uiInteractiveList=[]),this._uiInteractiveList.push(e),this}removeUIInteractive(e){if(this._uiInteractiveList){let r=this._uiInteractiveList.indexOf(e);if(r>=0)return this._uiInteractiveList.slice(r,1),e}return null}get globalVisible(){return this._globalVisible}set visible(e){if(this._localVisible!=e){this._localVisible=e;let r=this.parent?this.parent._globalVisible:!0;this.onUITransformVisible(this._localVisible&&r)}}get visible(){return this._localVisible}onUITransformVisible(e){let r=this._localVisible&&e;r!=this._globalVisible&&(this._globalVisible=r,this.object3D.components.forEach((i,a)=>{let o=i;if(o.onUITransformVisible)if(o==this)for(let l of this.object3D.entityChildren){let h=l.getComponent(ri);h&&h.onUITransformVisible(this._globalVisible)}else o.onUITransformVisible(this._globalVisible)}))}onParentChange(e,r){var i,a;(i=this.parent)==null||i.setNeedUpdateUIPanel(),this.parent=r==null?void 0:r.getComponent(ri),(a=this.parent)==null||a.setNeedUpdateUIPanel()}get width(){return this._width}get height(){return this._height}resize(e,r){var i;if(this._width!=e||this._height!=r){this._width=e,this._height=r,this.onChange=!0;for(let a of this.object3D.components.values())(i=a.onTransformResize)==null||i.call(a);return!0}return!1}get x(){return this.object3D.x}set x(e){e!=this.object3D.x&&(this.object3D.x=e,this.onChange=!0)}get y(){return this.object3D.y}set y(e){e!=this.object3D.y&&(this.object3D.y=e,this.onChange=!0)}setXY(e,r){let i=this.object3D.localPosition;i.set(e,r,i.z),this.object3D.localPosition=i,this.onChange=!0}get z(){return this.object3D.z}set z(e){e!=this.object3D.z&&(this.object3D.z=e,this.onChange=!0)}get scaleX(){return this.object3D.scaleX}set scaleX(e){this.onChange=!0,this.object3D.scaleX=e}get scaleY(){return this.object3D.scaleY}set scaleY(e){this.onChange=!0,this.object3D.scaleY=e}get scaleZ(){return this.object3D.scaleZ}set scaleZ(e){this.onChange=!0,this.object3D.scaleZ=e}get onChange(){return this._onChange}set onChange(e){if(this._onChange!=e&&(this._onChange=e,e)){this._tempTransforms.length=0;let r=this.object3D.getComponents(ri,this._tempTransforms,!0);for(let i of r)i._onChange=!0,i.needUpdateQuads=!0}}onEnable(){this.setNeedUpdateUIPanel(),this.onChange=!0}onDisable(){this.setNeedUpdateUIPanel(),this.onChange=!0}setNeedUpdateUIPanel(){let e;e=this.object3D.getComponentFromParent(Go),e||(e=this.object3D.getComponentFromParent(zo)),e&&(e.needUpdateGeometry=!0)}cloneTo(e){let r=e.getOrAddComponent(ri);r.visible=this.visible,r.x=this.x,r.y=this.y,r.z=this.z,r.resize(this.width,this.height),r.pivotX=this.pivotX,r.pivotY=this.pivotY,r.scaleX=this.scaleX,r.scaleY=this.scaleY}matrix(){let e=this._localMatrix,r=this.object3D.rotationZ;return this.parent?(e.updateScaleAndRotation(this.object3D.scaleX,this.object3D.scaleY,r,r),e.tx=this.object3D.x,e.ty=this.object3D.y):e.updateScaleAndRotation(1,1,0,0),(this.pivotX!=.5||this.pivotY!=.5)&&(Cl||(Cl=new Wi().identity()),e.mul(Cl.setTo(1,0,0,1,-(this.pivotX-.5)*this.width,-(this.pivotY-.5)*this.height))),e}getWorldMatrix(){let e=this,r=e._worldMatrix;return this._onChange&&(r.copyFrom(e.matrix()),e.parent&&r.mul(e.parent.getWorldMatrix()),e._onChange=!1),r}beforeDestroy(e){var r;this.transform.eventDispatcher.addEventListener(this.transform.eventLocalChange.type,this.onTransformChange,this),(r=super.beforeDestroy)==null||r.call(this,e)}}class Ug{constructor(){s(this,"_ray");s(this,"_mouseCode");s(this,"_clickEvent");s(this,"_outEvent");s(this,"_overEvent");s(this,"_upEvent");s(this,"_downEvent");s(this,"_view");s(this,"_lastDownTarget");s(this,"_lastOverTarget");s(this,"_lastDownPosition",new he);s(this,"_calcDistanceVec2",new he);s(this,"_lastDownTime",0);s(this,"_clickTimeSpan",200);s(this,"_clickDistanceSpan",10);s(this,"_colliderOut",[]);s(this,"_transformList",[]);s(this,"_sortWorldPanelList",[]);s(this,"_iteractive2PanelDict",new Map)}init(t){this._view=t,this._ray=new mi,this._clickEvent=new Xe(Xe.PICK_CLICK_GUI),this._outEvent=new Xe(Xe.PICK_OUT_GUI),this._overEvent=new Xe(Xe.PICK_OVER_GUI),this._upEvent=new Xe(Xe.PICK_UP_GUI),this._downEvent=new Xe(Xe.PICK_DOWN_GUI),m.inputSystem.addEventListener(F.POINTER_DOWN,this.onTouchDown,this,null,1),m.inputSystem.addEventListener(F.POINTER_UP,this.onTouchUp,this,null,1),m.inputSystem.addEventListener(F.POINTER_MOVE,this.onTouchMove,this,null,1),m.inputSystem.addEventListener(F.POINTER_CLICK,this.onTouchClick,this,null,1)}onTouchClick(t){this._lastOverTarget&&t.stopImmediatePropagation()}onTouchMove(t){this._mouseCode=t.mouseCode,this.collectEntities();let e=this.pick(this._colliderOut);if(e){t.stopImmediatePropagation();let r=e.collider;r!=this._lastOverTarget&&(r.mouseStyle=Ge.OVER,Object.assign(this._overEvent,t),this._overEvent.type=Xe.PICK_OVER_GUI,this._overEvent.target=r.object3D,this._overEvent.data=e,r.object3D.dispatchEvent(this._overEvent),this._lastOverTarget&&(this._lastOverTarget.mouseStyle=Ge.NORMAL,Object.assign(this._outEvent,t),this._outEvent.type=Xe.PICK_OUT_GUI,this._outEvent.target=r.object3D,this._outEvent.data=e,this._lastOverTarget.object3D.dispatchEvent(this._outEvent))),this._lastOverTarget=r}else this._lastOverTarget&&(this._lastOverTarget.mouseStyle=Ge.NORMAL,Object.assign(this._outEvent,t),this._outEvent.type=Xe.PICK_OUT_GUI,this._outEvent.target=this._lastOverTarget.object3D,this._outEvent.data=e,this._lastOverTarget.object3D.dispatchEvent(this._outEvent),this._lastOverTarget=null)}onTouchDown(t){this._lastDownTime=me.time,this._lastDownPosition.set(t.mouseX,t.mouseY),this._mouseCode=t.mouseCode,this.collectEntities();let e=this.pick(this._colliderOut);e&&t.stopImmediatePropagation();let r=e?e.collider:null;r&&(r.mouseStyle=Ge.DOWN,Object.assign(this._downEvent,t),this._downEvent.type=Xe.PICK_DOWN_GUI,this._downEvent.target=r.object3D,this._downEvent.data=e,r.object3D.dispatchEvent(this._downEvent)),this._lastDownTarget=r}onTouchUp(t){this._calcDistanceVec2.set(t.mouseX,t.mouseY),this._mouseCode=t.mouseCode,this.collectEntities();let e=this.pick(this._colliderOut);e&&t.stopImmediatePropagation();let r=e?e.collider:null;this._lastDownTarget&&this._lastDownTarget.enable&&(this._lastDownTarget.mouseStyle=Ge.NORMAL),r&&r==this._lastDownTarget&&me.time-this._lastDownTime<=this._clickTimeSpan&&(this._calcDistanceVec2.set(t.mouseX,t.mouseY),this._calcDistanceVec2.distance(this._lastDownPosition)<=this._clickDistanceSpan&&(Object.assign(this._clickEvent,t),this._clickEvent.type=Xe.PICK_CLICK_GUI,this._clickEvent.target=r.object3D,this._clickEvent.data=e,r.object3D.dispatchEvent(this._clickEvent))),this._lastDownTarget=null}collectEntities(){return this._colliderOut.length=0,this._sortWorldPanelList.length=0,this._iteractive2PanelDict.clear(),this._view.canvasList.slice().reverse().forEach(t=>{if(t&&t.transform&&t.transform.parent){let e=t.object3D.getComponentsByProperty("isUIPanel",!0,!0);e.sort((r,i)=>{let a=r._uiRenderer.__renderOrder,o=i._uiRenderer.__renderOrder;return a>o?-1:1});for(let r of e){this._transformList.length=0,r.object3D.getComponents(ri,this._transformList),this._transformList.reverse();for(const i of this._transformList){let a=i.uiInteractiveList;if(a&&a.length>0)for(let o of a)this._colliderOut.push(o),this._iteractive2PanelDict.set(o,r)}}}}),this._colliderOut}pick(t){this._ray=this._view.camera.screenPointToRay(m.inputSystem.mouseX,m.inputSystem.mouseY);let e=new he(m.inputSystem.mouseX,m.inputSystem.mouseY),r=new he(E.canvas.clientWidth,E.canvas.clientHeight),i;for(const a of t)if(a.interactive&&a.enable&&a.interactiveVisible){let o=this._iteractive2PanelDict.get(a);if(i=a.rayPick(this._ray,o,e,r),i)return i.collider=a,i}return null}}var Lg=(n=>(n[n.COLLINEAR=0]="COLLINEAR",n[n.LINES_INTERSECT=1]="LINES_INTERSECT",n[n.SEGMENTS_INTERSECT=2]="SEGMENTS_INTERSECT",n[n.A_BISECTS_B=3]="A_BISECTS_B",n[n.B_BISECTS_A=4]="B_BISECTS_A",n[n.PARALELL=5]="PARALELL",n))(Lg||{}),Og=(n=>(n[n.ON_LINE=0]="ON_LINE",n[n.LEFT_SIDE=1]="LEFT_SIDE",n[n.RIGHT_SIDE=2]="RIGHT_SIDE",n))(Og||{});const At=class At{constructor(t,e){s(this,"start");s(this,"end");s(this,"color",new K(1,1,1,1));s(this,"_normal");s(this,"_normalCalculated",!1);this.start=t,this.end=e}set(t,e){this.start=t,this.end=e}getCenter(){let t=g.HELP_0;return this.start.subtract(this.end,t),t.scaleBy(.5),t.add(this.end),t}inverse(){let t=this.start;this.start=this.end,this.end=t}equals(t){return this.start==t.start&&this.end==t.end||this.start==t.end&&this.end==t.start}toArray(){return[this.start.x,this.start.y,this.start.z,this.end.x,this.end.y,this.end.z]}static getLines(t){let e=[];for(let r=0;r<t.length;r++){let i=r,a=Bn(r+1,t.length),o=t[i],l=t[a];e.push(new At(o,l))}return e}intersection(t,e=null){var r=(t.end.z-t.start.z)*(this.end.x-this.start.x)-(t.end.x-t.start.x)*(this.end.z-this.start.z),i=(t.end.x-t.start.x)*(this.start.z-t.start.z)-(t.end.z-t.start.z)*(this.start.x-t.start.x),a=(t.start.x-this.start.x)*(this.end.z-this.start.z)-(t.start.z-this.start.z)*(this.end.x-this.start.x);if(r==0)return i==0&&a==0?0:5;i=i/r,a=a/r;var o=this.start.x+i*(this.end.x-this.start.x),l=this.start.z+i*(this.end.z-this.start.z);return e!=null&&(e.x=o,e.y=0,e.z=l),i>=0&&i<=1&&a>=0&&a<=1?2:a>=0&&a<=1?3:i>=0&&i<=1?4:1}getDirection(){var t=this.end.subtract(this.start),e=new g(t.x,t.y);return e.normalize()}copyFrom(t){this.start||(this.start=new g),this.end||(this.end=new g),this.start.copyFrom(t.start),this.end.copyFrom(t.end)}static IsEqual(t,e){return Math.abs(t-e)<1e-7}static squreDistanceSegmentToSegment(t,e,r){let i=t.start,a=t.end,o=e.start,l=e.end,h=i.x,u=i.y,c=i.z,f=a.x,d=a.y,p=a.z,A=o.x,x=o.y,C=o.z,v=l.x,y=l.y,b=l.z,B=f-h,I=d-u,w=p-c,D=v-A,L=y-x,M=b-C,G=h-A,N=u-x,q=c-C,ie=B*B+I*I+w*w,ue=B*D+I*L+w*M,Ee=D*D+L*L+M*M,Ie=B*G+I*N+w*q,Ne=D*G+L*N+M*q,Qe=ie*Ee-ue*ue,xe=Qe,Ve=Qe,we=0,Ye=0;this.IsEqual(Qe,0)?(we=0,xe=1,Ye=Ne,Ve=Ee):(we=ue*Ne-Ee*Ie,Ye=ie*Ne-ue*Ie,we<0?(we=0,Ye=Ne,Ve=Ee):we>xe&&(we=xe,Ye=Ne+ue,Ve=Ee)),Ye<0?(Ye=0,-Ie<0?we=0:-Ie>ie?we=xe:(we=-Ie,xe=ie)):Ye>Ve&&(Ye=Ve,-Ie+ue<0?we=0:-Ie+ue>ie?we=xe:(we=-Ie+ue,xe=ie));let vt=0,xt=0;this.IsEqual(we,0)?vt=0:vt=we/xe,this.IsEqual(Ye,0)?xt=0:xt=Ye/Ve;let Nt=G+vt*B-xt*D,Ke=N+vt*I-xt*L,nt=q+vt*w-xt*M;return Nt*Nt+Ke*Ke+nt*nt}isNear(t,e=0,r){let i=g.HELP_0,a=g.HELP_1;i.copyFrom(t.origin),a.copyFrom(t.direction),a.scaleBy(9999),a.add(i,a),At.cacluteLine0.set(i,a),At.cacluteLine1.copyFrom(this),r&&(r.perspectiveMultiplyPoint3(At.cacluteLine1.start,At.cacluteLine1.start),r.perspectiveMultiplyPoint3(At.cacluteLine1.end,At.cacluteLine1.end));let o=At.squreDistanceSegmentToSegment(At.cacluteLine0,At.cacluteLine1,r);return o+1e-4<=e?(t.length=o,!0):(t.length=-999999,!1)}};s(At,"cacluteLine0",new At(null,null)),s(At,"cacluteLine1",new At(null,null));let La=At;const Qs=class Qs{constructor(t,e,r){s(this,"v1");s(this,"v2");s(this,"v3");s(this,"u1");s(this,"u2");s(this,"u3");s(this,"n1");s(this,"n2");s(this,"n3");s(this,"t0");s(this,"t");s(this,"u");s(this,"v");s(this,"min",new g);s(this,"max",new g);s(this,"id",0);this.id=Qs.ID+++200,t&&e&&r&&this.set(t,e,r)}set(t,e,r){this.v1=t,this.v2=e,this.v3=r;let i=this.min,a=this.max;return i.x=Math.min(this.v1.x,this.v2.x,this.v3.x),i.y=Math.min(this.v1.y,this.v2.y,this.v3.y),i.z=Math.min(this.v1.z,this.v2.z,this.v3.z),a.x=Math.max(this.v1.x,this.v2.x,this.v3.x),a.y=Math.max(this.v1.y,this.v2.y,this.v3.y),a.z=Math.max(this.v1.z,this.v2.z,this.v3.z),this}getNormal(){let t=this.v1,e=this.v2,r=this.v3,i=new g(e.x-t.x,e.y-t.y,e.z-t.z),a=new g(r.x-t.x,r.y-t.y,r.z-t.z).crossProduct(i);return a.normalize(),a}turnBack(){let t=this.v3;this.v3=this.v1,this.v1=t}getLines(){let t=this.v1,e=this.v2,r=this.v3;return[new La(t,e),new La(e,r),new La(r,t)]}equals(t){let e=this.getLines(),r=t.getLines(),i=0;for(let a=0;a<e.length;a++)for(let o=0;o<r.length;o++)e[a].equals(r[o])&&i++;return i==3}getCenter(){let t=this.min,e=this.max,r=new g;return r.x=(t.x+e.x)*.5,r.y=(t.y+e.y)*.5,r.z=(t.z+e.z)*.5,r}intersects(t){var e=this.max,r=this.min,i=t.max,a=t.min;return r.x<=i.x&&e.x>=a.x&&r.y<=i.y&&e.y>=a.y&&r.z<=i.z&&e.z>=a.z}sign2D(t,e,r){return(t.x-r.x)*(e.z-r.z)-(e.x-r.x)*(t.z-r.z)}pointInTriangle2D(t){let e=this.v1,r=this.v2,i=this.v3,a,o,l,h,u;return a=this.sign2D(t,e,r),o=this.sign2D(t,r,i),l=this.sign2D(t,i,e),h=a<0||o<0||l<0,u=a>0||o>0||l>0,!(h&&u)}toArray(){return[this.v1.x,this.v1.y,this.v1.z,this.v2.x,this.v2.y,this.v2.z,this.v3.x,this.v3.y,this.v3.z]}};s(Qs,"ID",null);let Bs=Qs;class br{static init(){this._pt0=new g,this._pt1=new g,this._pt2=new g,this._pt3=new g,this._ray=new mi,this._triangle=new Bs,this._hitPoint=new g,this._worldMatrix=new Q}static rayPick(t,e,r,i,a,o,l){this._isInit||(this.init(),this._isInit=!0);let h=this._worldMatrix;if(i==lr.World){let u;this.calculateHotArea_World(o,this._pt0,this._pt1,this._pt2,this._pt3),h.copyFrom(l).invert();let c=this._ray;if(c.copy(t).applyMatrix(h),this._triangle.set(this._pt0,this._pt1,this._pt2),u=c.intersectTriangle(c.origin,c.direction,this._triangle),u||(this._triangle.set(this._pt1,this._pt2,this._pt3),u=c.intersectTriangle(c.origin,c.direction,this._triangle)),u)return{distance:0,intersectPoint:u}}else{this.calculateHotArea_View(o,a,this._pt0,this._pt1,this._pt2,this._pt3);let u=r.x,c=r.y,f=Math.min(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+u*.5,d=Math.min(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+c*.5,p=Math.max(this._pt0.x,this._pt1.x,this._pt2.x,this._pt3.x)+u*.5,A=Math.max(this._pt0.y,this._pt1.y,this._pt2.y,this._pt3.y)+c*.5;return e.x<=p&&e.x>=f&&e.y<=A&&e.y>=d?(this._hitPoint.set(e.x,e.y,0),{distance:0,intersectPoint:this._hitPoint}):null}return null}static calculateHotArea_View(t,e,r,i,a,o){let l=t.getWorldMatrix(),h=l.getScaleX(),u=l.getScaleY(),c=t.width*.5*h,f=t.height*.5*u;r.set(-c,-f,0),i.set(c,-f,0),a.set(-c,f,0),o.set(c,f,0);let d=l.tx;r.x+=d,i.x+=d,a.x+=d,o.x+=d,d=l.ty,r.y-=d,i.y-=d,a.y-=d,o.y-=d,r.multiplyScalar(e),i.multiplyScalar(e),a.multiplyScalar(e),o.multiplyScalar(e)}static calculateHotArea_World(t,e,r,i,a){let o=t.getWorldMatrix(),l=o.getScaleX(),h=o.getScaleY(),u=t.width*.5*l,c=t.height*.5*h;e.set(-u,c,0),r.set(u,c,0),i.set(-u,-c,0),a.set(u,-c,0);let f=o.tx;e.x+=f,r.x+=f,i.x+=f,a.x+=f,f=o.ty,e.y+=f,r.y+=f,i.y+=f,a.y+=f}}s(br,"_pt0"),s(br,"_pt1"),s(br,"_pt2"),s(br,"_pt3"),s(br,"_hitPoint"),s(br,"_worldMatrix"),s(br,"_ray"),s(br,"_triangle"),s(br,"_isInit");var Ng=(n=>(n[n.UpperLeft=0]="UpperLeft",n[n.UpperCenter=1]="UpperCenter",n[n.UpperRight=2]="UpperRight",n[n.MiddleLeft=3]="MiddleLeft",n[n.MiddleCenter=4]="MiddleCenter",n[n.MiddleRight=5]="MiddleRight",n[n.LowerLeft=6]="LowerLeft",n[n.LowerCenter=7]="LowerCenter",n[n.LowerRight=8]="LowerRight",n))(Ng||{}),Fg=(n=>(n[n.Upper=0]="Upper",n[n.Middle=1]="Middle",n[n.Lower=2]="Lower",n))(Fg||{}),kg=(n=>(n[n.Left=0]="Left",n[n.Center=1]="Center",n[n.Right=2]="Right",n))(kg||{});class zg{constructor(){s(this,"charList",[]);s(this,"quadList",[]);s(this,"width",0);s(this,"index",0)}}class Gg{layout(t){let e=[],r=t.originSize,i=Ta.getFontData(t.font,r),a=t.fontSize/r;return this.makeTextLine(t.uiTransform,t.alignment,e,t.font,i,t.text,a,r,t.lineSpacing),e}makeTextLine(t,e,r,i,a,o,l,h,u){let c=-1,f=0,d=h*l,p=d*.5,A=t.width/l,x=t.height/l,C=0,v=t.height,y=()=>{f=0,c++;let I=new zg;return I.index=c,r.push(I),I},b=(I,w)=>{const D=I.charCodeAt(0).toString();let L=Ta.getFnt(i,h,D),M=null;return L?(M=Si.spawnQuad(),M.sprite=L,M.x=(f+L.xoffset)*l-C,M.y=(a.base-L.height-L.yoffset-a.base)*l+v,M.width=L.offsetSize.width*l,M.height=L.offsetSize.height*l,f+=L.xadvance):I==`
`||(I=="	"?f+=d:f+=p),w.width=f,w.quadList.push(M),w.charList.push(I),M},B=()=>{let I=this.getAlignment(e);switch(I.v){case 0:for(let w=0,D=r.length;w<D;w++){let L=r[w];if(w>0){let M=w*d*u;for(let G=0,N=L.quadList.length;G<N;G++){let q=L.quadList[G];q&&(q.y-=M)}}}break;case 1:for(let w=0,D=r.length;w<D;w++){let L=r[w],M=(x-D*h*u)*.5*l+w*d*u;for(let G=0,N=L.quadList.length;G<N;G++){let q=L.quadList[G];q&&(q.y-=M)}}break;case 2:for(let w=0,D=r.length;w<D;w++){let L=r[w],M=(x-D*h*u)*l+w*d*u;for(let G=0,N=L.quadList.length;G<N;G++){let q=L.quadList[G];q&&(q.y-=M)}}break}switch(I.h){case 0:break;case 1:for(let w=0,D=r.length;w<D;w++){let L=r[w],M=(A-L.width)*.5*l;for(let G=0,N=L.quadList.length;G<N;G++){let q=L.quadList[G];q&&(q.x+=M)}}break;case 2:for(let w=0,D=r.length;w<D;w++){let L=r[w],M=(A-L.width)*l;for(let G=0,N=L.quadList.length;G<N;G++){let q=L.quadList[G];q&&(q.x+=M)}}break}};(()=>{let I=null,w=o.length;for(let D=0;D<w;D++){I||(I=y());let L=o.charAt(D);L==`
`||L=="	"?I=null:(b(L,I),I.width+p>=A&&(I=y()))}})(),B()}getAlignment(t){let e={v:0,h:0};switch(t){case 1:e.v=0,e.h=1;break;case 0:e.v=0,e.h=0;break;case 2:e.v=0,e.h=2;break;case 4:e.v=1,e.h=1;break;case 3:e.v=1,e.h=0;break;case 5:e.v=1,e.h=2;break;case 7:e.v=2,e.h=1;break;case 6:e.v=2,e.h=0;break;case 8:e.v=2,e.h=2;break}return e}}class _l extends null{constructor(){super(...arguments);s(this,"_style",Ge.NORMAL);s(this,"_interactive",!1)}set interactive(e){this._interactive=e}get interactive(){return this._interactive}set mouseStyle(e){this._style=e}get interactiveVisible(){return this._uiTransform.globalVisible&&this._visible}init(e){super.init(e),this._uiTransform.addUIInteractive(this)}destroy(){this._uiTransform.removeUIInteractive(this),super.destroy()}rayPick(e,r,i,a){return br.rayPick(e,i,a,r.space,r.panelRatio,this._uiTransform,r.transform.worldMatrix)}cloneTo(e){e.getOrAddComponent(_l).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.enable=e._enable,this.interactive=e._interactive,this.mouseStyle=e._style,this}}var Qg=(n=>(n[n.NONE=0]="NONE",n[n.COLOR=1]="COLOR",n[n.SPRITE=2]="SPRITE",n))(Qg||{});class yl extends null{constructor(){super(...arguments);s(this,"_spriteMap");s(this,"_colorMap");s(this,"_image");s(this,"_isCreateImage");s(this,"_transition",2)}init(e){super.init(e),this._interactive=!0,this._spriteMap=new Map,this._colorMap=new Map,this._image=this.object3D.getComponent(Ki),this._isCreateImage=this._image==null,this._image||(this._image=this.object3D.addComponent(Ki)),this.imageType=Ba.Sliced}onEnable(){this.mouseStyle=Ge.NORMAL}onDisable(){this.mouseStyle=Ge.DISABLE}set transition(e){this._transition!=e&&(this._transition=e,this.validateStyle(this._style,!0))}get transition(){return this._transition}get imageType(){return this._image.imageType}set imageType(e){this._image.imageType=e}setStyleColor(e,r){return this._colorMap.set(e,r),this._style==e&&this.validateStyle(this._style,!0),this}getStyleColor(e){return this._colorMap.get(e)}set mouseStyle(e){super.mouseStyle=e,this.validateStyle(e,!0)}get normalSprite(){return this._spriteMap.get(Ge.NORMAL)}set normalSprite(e){this._spriteMap.set(Ge.NORMAL,e),this._style==Ge.NORMAL&&this.validateStyle(this._style,!0)}get overSprite(){return this._spriteMap.get(Ge.OVER)}set overSprite(e){this._spriteMap.set(Ge.OVER,e),this._style==Ge.OVER&&this.validateStyle(this._style,!0)}set downSprite(e){this._spriteMap.set(Ge.DOWN,e),this._style==Ge.DOWN&&this.validateStyle(this._style,!0)}get downSprite(){return this._spriteMap.get(Ge.DOWN)}set disableSprite(e){this._spriteMap.set(Ge.DISABLE,e),this._style==Ge.DISABLE&&this.validateStyle(this._style,!0)}get disableSprite(){return this._spriteMap.get(Ge.DISABLE)}validateStyle(e,r){if(this._transition&2){let i=this._spriteMap.get(e);this._image.sprite=i}if(this._transition&1){let i=this._colorMap.get(e);i&&(this._image.color=i)}}cloneTo(e){e.getOrAddComponent(yl).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this.imageType=e.imageType,this.transition=e.transition,e._spriteMap.forEach((r,i)=>{r&&this._spriteMap.set(i,r)}),e._colorMap.forEach((r,i)=>{r&&this._colorMap.set(i,r.clone())}),this.mouseStyle=e.mouseStyle,this}destroy(){this._isCreateImage&&this._image&&(this.object3D.removeComponent(Ki),this._image=null),super.destroy()}}class Sl extends null{constructor(){super();s(this,"_count",0)}init(e){var r;(r=super.init)==null||r.call(this,e),this._count=e?e.count:1;for(let i=0;i<this._count;i++)this.attachQuad(Si.spawnQuad());this._uiTransform.resize(0,0)}getQuad(e){return this._mainQuads[e]}cloneTo(e){e.addComponent(Sl,{count:this._count}).copyComponent(this)}copyComponent(e){super.copyComponent(e);for(let r=0;r<e._count;r++)this.setSprite(r,e.getSprite(r)),this.setColor(r,e.getColor(r)),this.setImageType(r,e.getImageType(r));return this}setSprite(e,r){this._mainQuads[e].sprite=r||m.res.defaultGUISprite,this.setShadowDirty()}getSprite(e){return this._mainQuads[e].sprite}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let r of this._mainQuads)r.visible=!e;this.setShadowDirty()}getColor(e){return this._mainQuads[e].color}setColor(e,r){this._mainQuads[e].color=r,this.setShadowDirty()}getImageType(e){return this._mainQuads[e].imageType}setImageType(e,r){this._mainQuads[e].imageType=r,this.setShadowDirty()}setSize(e,r,i){this._mainQuads[e].setSize(r,i),this.setShadowDirty()}setXY(e,r,i){this._mainQuads[e].setXY(r,i),this.setShadowDirty()}getXY(e,r){r||(r=new he);let i=this._mainQuads[e];return r.x=i.x,r.y=i.y,r}}class Il extends null{constructor(){super(...arguments);s(this,"_shadowQuality",1);s(this,"_shadowOffset");s(this,"_shadowRadius");s(this,"_shadowColor");s(this,"_subShadowColor");s(this,"needUpdateShadow",!1)}init(e){var r;(r=super.init)==null||r.call(this,e),this._shadowRadius=2,this._shadowQuality=1,this._shadowOffset=new he(4,-4),this._shadowColor=new K(.1,.1,.1,.8),this._subShadowColor=this._shadowColor.clone(),this.isUIShadow=!0}cloneTo(e){e.getOrAddComponent(Il).copyComponent(this)}copyComponent(e){return super.copyComponent(this),this._shadowColor=e._shadowColor,this._shadowOffset=e._shadowOffset,this._shadowRadius=e._shadowRadius,this._shadowQuality=e.shadowQuality,this}get shadowColor(){return this._shadowColor}set shadowColor(e){this._shadowColor.copyFrom(e),this.needUpdateShadow=!0}set shadowQuality(e){e=se(e,0,4),this._shadowQuality!=e&&(this._shadowQuality=e,this.needUpdateShadow=!0)}get shadowQuality(){return this._shadowQuality}set shadowOffset(e){this._shadowOffset=e,this.needUpdateShadow=!0}get shadowOffset(){return this._shadowOffset||(this._shadowOffset=new he(4,-4)),this._shadowOffset}set shadowRadius(e){this._shadowRadius!=e&&(this._shadowRadius=e,this.applyShadow())}get shadowRadius(){return this._shadowRadius}onUpdate(e){this.needUpdateShadow&&(this.applyShadow(),this.needUpdateShadow=!1)}applyShadow(){if(this.detachQuads(),this._shadowSource&&this._shadowQuality>0){let e=this._shadowSource.mainQuads;if(e.length>0)for(let r of e)this.createQuadShadow(r)}this._uiTransform.setNeedUpdateUIPanel()}createQuadShadow(e){let r=this._shadowQuality,i=Math.PI*2;this._subShadowColor.copyFrom(this._shadowColor),this._subShadowColor.a=1/Math.max(1,r);for(let a=0;a<r;a++){let o=Si.spawnQuad(),l=0,h=0;if(a==0)o.color=this._shadowColor;else{let u=i*(a-1)/(r-1);l=Math.sin(u)*this._shadowRadius,h=Math.cos(u)*this._shadowRadius,o.color=this._subShadowColor}o.setXY(l+this._shadowOffset.x+e.x,h+this._shadowOffset.y+e.y),o.setSize(e.width,e.height),o.sprite=e.sprite,o.visible=e.visible,o.imageType=e.imageType,this.attachQuad(o)}}}class bl extends null{constructor(){super();s(this,"_font","\u5FAE\u8F6F\u96C5\u9ED1");s(this,"_fontSize",14);s(this,"_originSize",42);s(this,"_alignment",0);s(this,"_lineSpacing",1);s(this,"_text","");s(this,"_color",new K(1,1,1,1));s(this,"textLine",null);s(this,"layoutProxy",new Gg)}cloneTo(e){e.getOrAddComponent(bl).copyComponent(this)}copyComponent(e){return super.copyComponent(e),this._font=e._font,this._fontSize=e._fontSize,this._originSize=e._originSize,this._alignment=e._alignment,this._lineSpacing=e._lineSpacing,this._color.copyFrom(e._color),this.text=e.text,this}get originSize(){return this._originSize}get font(){return this._font}set font(e){this._font=e}get fontSize(){return this._fontSize}set fontSize(e){this._fontSize!=e&&(this._fontSize=e,this.layoutText())}get text(){return this._text}set text(e){this._text!=e&&(e||(e=""),this._text=e,this.layoutText())}layoutText(){this.detachQuads(),this.textLine=this.layoutProxy.layout(this);for(let e=0,r=this.textLine.length;e<r;e++){let i=this.textLine[e];for(let a=0,o=i.quadList.length;a<o;a++){let l=i.quadList[a];l&&this.attachQuad(l)}}this.color=this._color,this._uiTransform.setNeedUpdateUIPanel(),this.onUIComponentVisible(this._visible),this.setShadowDirty()}onUIComponentVisible(e){this.applyComponentVisible()}onUITransformVisible(e){this.applyComponentVisible()}applyComponentVisible(){let e=!this._visible||!this._uiTransform.globalVisible;for(let r of this._mainQuads)r&&(r.visible=!e);this.setShadowDirty()}onTransformResize(){this.layoutText()}get color(){return this._color}set color(e){this._color.copyFrom(e);for(let r of this._mainQuads)r.color=e;this.setShadowDirty()}get alignment(){return this._alignment}set alignment(e){this._alignment!=e&&(this._alignment=e,this.layoutText())}get lineSpacing(){return this._lineSpacing}set lineSpacing(e){this._lineSpacing!=e&&(this._lineSpacing=e,this.layoutText())}}var Vg=Object.defineProperty,Yg=Object.getOwnPropertyDescriptor,Hg=(n,t,e,r)=>{for(var i=r>1?void 0:r?Yg(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Vg(t,e,i),i};let Qo=class extends _s{constructor(){super()}init(){super.init(),this.lightData.lightType=tt.PointLight,this.object3D.name==""&&(this.object3D.name="PointLight"+kt())}get range(){return this.lightData.range}set range(n){this.lightData.range=n,this.onChange()}get at(){return this.lightData.linear}set at(n){this.lightData.linear=n,this.onChange()}get radius(){return this.lightData.radius}set radius(n){this.lightData.radius=n,this.onChange()}get quadratic(){return this.lightData.quadratic}set quadratic(n){this.lightData.quadratic=n,this.onChange()}start(){this.transform.rotationX=90,super.start()}onUpdate(){}onGraphic(n){let t=n.scene.getChildByName("graphic3D");if(!t)return;let e=t.createCustomShape(`PointLight_${this.object3D.instanceID}`,this.transform);e.buildAxis(),e.buildCircle(g.ZERO,this.range,32,g.X_AXIS),e.buildCircle(g.ZERO,this.range,32,g.Y_AXIS),e.buildCircle(g.ZERO,this.range,32,g.Z_AXIS)}debug(){}debugDraw(n){}};Qo=Hg([or(Qo,"Light")],Qo);class Xg extends null{constructor(){super();s(this,"index",0);s(this,"drawCallFrame",-1)}}var wl=(n=>(n[n.CastGI=0]="CastGI",n[n.ReceiveGI=1]="ReceiveGI",n[n.CastDepth=2]="CastDepth",n[n.Other=3]="Other",n))(wl||{});class Tl extends null{constructor(t=0,e=0){super(),H.register("GIProbeShader",Qd);let r=new gt,i=new Le("GIProbeShader","GIProbeShader");i.passType=J.COLOR,r.addRenderPass(i),i.setDefine("USE_BRDF",!0),i.setShaderEntry("VertMain","FragMain"),i.setUniformVector4("probeUniform",new ae(e,t,0,0));let a=i.shaderState;a.acceptShadow=!1,a.castShadow=!1,a.receiveEnv=!1,a.acceptGI=!1,a.useLight=!1,r.setTexture("baseMap",m.res.whiteTexture),r.setTexture("normalMap",m.res.normalTexture),r.setTexture("emissiveMap",m.res.blackTexture),this.shader=r}}s(Tl,"count",null);class t0 extends null{constructor(){super(...arguments);s(this,"_probes");s(this,"_volume");s(this,"_debugMr",[])}init(e){var r;e||(e=(r=m.views[0])==null?void 0:r.scene),m.setting.gi.enable=!0,this._volume=re.getLightEntries(e).irradianceVolume,this.initProbe(e)}initProbe(e){let r=this._volume.setting.probeXCount,i=this._volume.setting.probeYCount,a=this._volume.setting.probeZCount,o=new Ea(4,16,16),l=new g;this._probes=[];for(let h=0;h<r;h++)for(let u=0;u<i;u++)for(let c=0;c<a;c++){let f=h+c*r+u*(r*a),d=new Xg;d.index=f,d.name=`${h}_${u}_${c}`;let p=d.addComponent($);p.material=new Tl(wl.CastGI,f),p.geometry=o,p.castGI=!1,p.castShadow=!1,this._debugMr.push(p),this.object3D.addChild(d),this._volume.calcPosition(h,u,c,l),d.x=l.x,d.y=l.y,d.z=l.z,this._probes[f]=d,this._debugMr.push(p)}for(let h=0;h<this._probes.length;h++)X.instance.addGIProbe(e,this._probes[h]);this.object3D.transform.enable=!1,this._volume.setting.debug&&this.debug()}debug(){}debugProbeRay(e,r){const i=m.setting.gi.rayNumber;let a=new Z(0,-.7071067811865475,.7071067811865475,0);for(let o=0;o<i;o++){let l=e*i+o,h=new g(-r[l*4+0],-r[l*4+1],-r[l*4+2],0);a.transformVector(h,h);let u=r[l*4+3],c=this._probes[e].transform.worldPosition.clone(),f=h.scaleBy(u);f.add(c,f)}}changeProbesVolumeData(){this._volume.setVolumeDataChange()}changeProbesPosition(){this._volume.setVolumeDataChange();let e=this._volume.setting.probeXCount,r=this._volume.setting.probeYCount,i=this._volume.setting.probeZCount,a=new g;for(let o=0;o<e;o++)for(let l=0;l<r;l++)for(let h=0;h<i;h++){let u=o+h*e+l*(e*i),c=this._probes[u];this._volume.calcPosition(o,l,h,a),c.x=a.x,c.y=a.y,c.z=a.z}}onUpdate(){m.setting.gi.maxDistance=m.setting.gi.probeSpace*1.5;let e=this.transform.scene3D.view.camera,r=g.distance(e.transform.worldPosition,e.transform.targetPos)/300;if(this._debugMr&&this._debugMr.length>0)for(let i=0;i<this._debugMr.length;i++){const a=this._debugMr[i].transform;a.scaleX=r,a.scaleY=r,a.scaleZ=r}}}class r0 extends null{constructor(){super();s(this,"_keyRenderGroup");s(this,"_keyBufferGroup");s(this,"_keyIdsGroup")}init(e){this._keyRenderGroup=new Map,this._keyBufferGroup=new Map,this._keyIdsGroup=new Map}start(){let e=[];this.object3D.getComponents($,e,!0);for(let r=0;r<e.length;r++){const i=e[r];i.transform.updateWorldMatrix(!0),i.enable=!1;let a=i.geometry.instanceID;for(let o=0;o<i.materials.length;o++){const l=i.materials[o];a+=l.instanceID}if(this._keyRenderGroup.has(a))this._keyRenderGroup.get(a).push(i),this._keyIdsGroup.get(a).push(i.transform.worldMatrix.index);else{let o=new be(e.length);o.visibility=GPUShaderStage.VERTEX,this._keyRenderGroup.set(a,[i]),this._keyBufferGroup.set(a,o),this._keyIdsGroup.set(a,[i.transform.worldMatrix.index])}}this._keyBufferGroup.forEach((r,i)=>{let a=this._keyIdsGroup.get(i),o=this._keyBufferGroup.get(i);o.setInt32Array("matrixIDs",new Int32Array(a)),o.apply()})}reset(){this._keyRenderGroup.size>0&&(this._keyRenderGroup.clear(),this._keyBufferGroup.clear(),this._keyIdsGroup.clear(),this.start())}nodeUpdate(e,r,i,a){this._keyRenderGroup.forEach((o,l)=>{let h=this._keyBufferGroup.get(l),u=o[0];for(let c=0;c<u.materials.length;c++){let f=u.materials[c].getPass(r);if(f)for(let d=0;d<f.length;d++){const p=f[d];p.setDefine("USE_INSTANCEDRAW",!0),p.setStorageBuffer("instanceDrawID",h)}}u.nodeUpdate(e,r,i,a)})}renderPass(e,r,i){this._keyRenderGroup.forEach((a,o)=>{let l=a[0];l.instanceCount=a.length,this.renderItem(e,r,l,i)})}renderItem(e,r,i,a){let o=i.transform._worldMatrix;for(let l=0;l<i.materials.length;l++){let h=i.materials[l].getPass(r);if(!(!h||h.length==0))for(let u=0;u<h.length;u++){let c=h[u];S.bindGeometryBuffer(a.encoder,i.geometry);const f=c;f.shaderState.splitTexture&&(a.endRenderPass(),Vt.WriteSplitColorTexture(i.instanceID),a.beginOpaqueRenderPass(),S.bindCamera(a.encoder,e.camera),S.bindGeometryBuffer(a.encoder,i.geometry)),S.bindPipeline(a.encoder,f);let d=i.geometry.subGeometries[l].lodLevels[i.lodLevel];i.instanceCount>0?S.drawIndexed(a.encoder,d.indexCount,i.instanceCount,d.indexStart,0,0):S.drawIndexed(a.encoder,d.indexCount,1,d.indexStart,0,o.index)}}}beforeDestroy(e){this._keyRenderGroup.clear(),this._keyBufferGroup.clear(),this._keyIdsGroup.clear(),this._keyRenderGroup=this._keyBufferGroup=this._keyIdsGroup=void 0,Te.removeWaitStart(this.object3D,this)}}var Wg=Object.defineProperty,Kg=Object.getOwnPropertyDescriptor,jg=(n,t,e,r)=>{for(var i=r>1?void 0:r?Kg(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Wg(t,e,i),i};let Vo=class extends ${constructor(){super()}get geometry(){return null}set geometry(n){}cloneTo(n){}set meshURL(n){let t=m.res.getGeometry(n);t?this.geometry=t:console.error("no geometry set",n)}};Vo=jg([or(Vo,"MeshFilter")],Vo);var qg=Object.defineProperty,Jg=Object.getOwnPropertyDescriptor,Zg=(n,t,e,r)=>{for(var i=r>1?void 0:r?Jg(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&qg(t,e,i),i};let Ds=class extends ${constructor(){super();s(this,"skinJointsName");s(this,"mInverseBindMatrixData");s(this,"mInverseBindMatrixBuffer");s(this,"mSkeletonAnimation");s(this,"mJointIndexTableBuffer");this.addRendererMask(ye.SkinnedMesh)}start(){if(super.start(),this.skeletonAnimation=this.object3D.getComponent(Ci),!this.skeletonAnimation){let t=this.object3D.parentObject.parentObject.getComponentsInChild(Ci);t.length>0&&(this.skeletonAnimation=t[0]);let e=this.object3D;for(;!this.skeletonAnimation&&e;)this.skeletonAnimation=e.getComponentFromParent(Ci),e.parent&&(e=e.parent.object3D)}}onEnable(){super.onEnable()}get skeletonAnimation(){return this.mSkeletonAnimation}set skeletonAnimation(t){if(this.mSkeletonAnimation=t,!!t&&!this.mJointIndexTableBuffer){let e=this.mSkeletonAnimation.getJointIndexTable(this.skinJointsName);this.mJointIndexTableBuffer=new be(e.length*4,0,new Float32Array(e)),this.mJointIndexTableBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}}get skinInverseBindMatrices(){return this.mInverseBindMatrixData}set skinInverseBindMatrices(t){this.mInverseBindMatrixData=t;var e=new Float32Array(t.length*16);for(let r=0;r<t.length;r++){let i=r*16,a=t[r];e.set(a,i)}this.mInverseBindMatrixBuffer=new be(e.byteLength,0,e),this.mInverseBindMatrixBuffer.visibility=GPUShaderStage.VERTEX|GPUShaderStage.COMPUTE}get inverseBindMatrixBuffer(){return this.mInverseBindMatrixBuffer}get jointIndexTableBuffer(){return this.mJointIndexTableBuffer.buffer}cloneTo(t){let e=t.addComponent(Ds);e.geometry=this.geometry,e.material=this.material.clone(),e.castShadow=this.castShadow,e.castGI=this.castGI,e.receiveShadow=this.receiveShadow,e.rendererMask=this.rendererMask,e.skinJointsName=this.skinJointsName,e.skinInverseBindMatrices=this.skinInverseBindMatrices,e.mJointIndexTableBuffer=this.mJointIndexTableBuffer}nodeUpdate(t,e,r,i){for(let a=0;a<this.materials.length;a++){let o=this.materials[a].getPass(e);if(o)for(let l=0;l<o.length;l++){const h=o[l];!h.pipeline&&this.mSkeletonAnimation&&(h.setStorageBuffer("jointsMatrixIndexTable",this.mSkeletonAnimation.jointMatrixIndexTableBuffer),h.setStorageBuffer("jointsInverseMatrix",this.mInverseBindMatrixBuffer),h.setStorageBuffer("jointsIndexMapingTable",this.mJointIndexTableBuffer))}}super.nodeUpdate(t,e,r,i)}};Ds=Zg([or(Ds,"SkinnedMeshRenderer")],Ds);class i0 extends null{constructor(){super();s(this,"radius",2.5);s(this,"height",10);this._shapeType=Da.Capsule}}const Ei=class Ei extends null{constructor(){super();s(this,"mesh");s(this,"_pickRet");this._shapeType=Da.Mesh}rayPick(e,r){if(this.mesh){Ei.triangle||(Ei.triangle=new Bs(new g,new g,new g));let i=this.mesh.getAttribute(O.position),a=this.mesh.getAttribute(O.indices),o=$t.helpMatrix;o.copyFrom(r).invert();let l=$t.helpRay.copy(e);if(l.applyMatrix(o),l.intersectBox(this.mesh.bounds),!l.intersectBox(this.mesh.bounds,$t.v3_help_0))return null;if(a&&i&&a.data.length>0){let h=i.data;for(let u=0,c=a.data.length/3;u<c;u++){let f=u*3;const d=a.data[f+0]*3,p=a.data[f+1]*3,A=a.data[f+2]*3;let x=Ei.triangle,C=x.v1.set(h[d+0],h[d+1],h[d+2]),v=x.v2.set(h[p+0],h[p+1],h[p+2]),y=x.v3.set(h[A+0],h[A+1],h[A+2]);x.set(C,v,y);let b=l.intersectTriangle(l.origin,l.direction,x);if(b){this._pickRet||(this._pickRet={intersectPoint:new g,distance:0}),this._pickRet.intersectPoint=b,this._pickRet.distance=g.distance(l.origin,b);let B=this.mesh.getAttribute(O.normal);if(B){let I=B.data,w=new g(I[d],I[d+1],I[d+2]);r.transformVector(w,w),w.normalize(),this._pickRet.normal=w}return this._pickRet}}}}return null}};s(Ei,"triangle");let El=Ei;class a0 extends null{constructor(e){super();s(this,"_pickRet");s(this,"box");s(this,"radius",.5);this._shapeType=Da.Sphere,this.radius=e,this.box=new Ss(new g,1)}rayPick(e,r){this.box.setFromCenterAndSize(this.center,this.radius);let i=$t.helpMatrix;i.copyFrom(r).invert();let a=$t.helpRay.copy(e);a.applyMatrix(i);let o=a.intersectSphere(a.origin,a.direction,this.box.center,this.box.radius);return o?(this._pickRet||(this._pickRet={intersect:!1,intersectPoint:new g,distance:0}),this._pickRet.intersect=!0,this._pickRet.intersectPoint=o,this._pickRet.distance=g.distance(a.origin,$t.v3_help_0),this._pickRet):null}}class $g extends ee{constructor(){super();s(this,"_envMap");s(this,"skyObject");s(this,"envMapChange",!0);s(this,"view");this.transform.scene3D=this,this.skyObject=new ee,this.addChild(this.skyObject),this._isScene3D=!0,this.envMap||(this.envMap=m.res.defaultSky)}get envMap(){return this._envMap}set envMap(e){this._envMap!=e&&(this.envMapChange=!0),this._envMap=e,X.instance.sky&&"map"in X.instance.sky&&(X.instance.sky.map=e)}get exposure(){return X.instance.sky&&"exposure"in X.instance.sky?X.instance.sky.exposure:0}set exposure(e){X.instance.sky&&"exposure"in X.instance.sky&&(X.instance.sky.exposure=e,m.setting.sky.skyExposure=e)}get roughness(){if(X.instance.sky&&"roughness"in X.instance.sky)return X.instance.sky.roughness}set roughness(e){X.instance.sky&&"roughness"in X.instance.sky&&(X.instance.sky.roughness=e)}}class ep{constructor(){s(this,"_computeShader");s(this,"_outBuffer")}init(){let t=fe.getGBufferFrame(fe.colorPass_GBuffer);this._computeShader=new ce(yd),this._outBuffer=new xa(32),this._computeShader.setStorageBuffer("outBuffer",this._outBuffer),this._computeShader.setSamplerTexture("gBufferTexture",t.getCompressGBufferTexture())}compute(t){let e=re.getCameraGroup(t.camera);this._computeShader.setStorageBuffer("globalUniform",e.uniformGPUBuffer);let r=S.beginCommandEncoder();S.computeCommand(r,[this._computeShader]),S.endCommandEncoder(r),this._outBuffer.readBuffer()}getPickMeshID(){var t=this._outBuffer.outFloat32Array[0]+.1;return Math.floor(t)}getPickWorldPosition(t){t||(t=new g);var e=this._outBuffer.outFloat32Array[4],r=this._outBuffer.outFloat32Array[5],i=this._outBuffer.outFloat32Array[6];return t.set(e,r,i),t}getPickWorldNormal(t){t||(t=new g);var e=this._outBuffer.outFloat32Array[8],r=this._outBuffer.outFloat32Array[9],i=this._outBuffer.outFloat32Array[10];return t.set(e*2-1,r*2-1,i*2-1).normalize(),t}getPickScreenUV(t){t||(t=new he);var e=this._outBuffer.outFloat32Array[2],r=this._outBuffer.outFloat32Array[3];return t.set(e,r),t}}class tp extends ir{constructor(e){super();s(this,"ray");s(this,"isTouching",!1);s(this,"_mouseCode");s(this,"_pickEvent");s(this,"_outEvent");s(this,"_overEvent");s(this,"_upEvent");s(this,"_downEvent");s(this,"_mouseMove");s(this,"_pickCompute");s(this,"_lastDownTarget");s(this,"mouseEnableMap");s(this,"_view");s(this,"_lastFocus");s(this,"_interestList",[]);this._view=e,this.init()}init(){this.ray=new mi,this.mouseEnableMap=new Map,this._pickEvent=new F(F.PICK_CLICK),this._outEvent=new F(F.PICK_OUT),this._overEvent=new F(F.PICK_OVER),this._mouseMove=new F(F.PICK_MOVE),this._upEvent=new F(F.PICK_UP),this._downEvent=new F(F.PICK_DOWN)}start(){m.setting.pick.enable&&(m.inputSystem.addEventListener(F.POINTER_DOWN,this.onTouchStart,this),m.inputSystem.addEventListener(F.POINTER_UP,this.onTouchEnd,this),m.inputSystem.addEventListener(F.POINTER_CLICK,this.onTouchOnce,this),m.inputSystem.addEventListener(F.POINTER_RIGHT_CLICK,this.onTouchOnce,this),m.inputSystem.addEventListener(F.POINTER_MOVE,this.onTouchMove,this)),m.setting.pick.mode=="pixel"&&(this._pickCompute=new ep,this._pickCompute.init())}stop(){m.inputSystem.removeEventListener(F.POINTER_DOWN,this.onTouchStart,this),m.inputSystem.removeEventListener(F.POINTER_UP,this.onTouchEnd,this),m.inputSystem.removeEventListener(F.POINTER_CLICK,this.onTouchOnce,this),m.inputSystem.removeEventListener(F.POINTER_RIGHT_CLICK,this.onTouchOnce,this),m.inputSystem.removeEventListener(F.POINTER_MOVE,this.onTouchMove,this)}onTouchStart(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let r=this.findNearestObj(this._interestList,this._view.camera);this._lastDownTarget=r,r&&(Object.assign(this._downEvent,e),this._downEvent.type=F.PICK_DOWN,this._downEvent.target=r.object3D,this._downEvent.data=this.getPickInfo(),this.dispatchEvent(this._downEvent),r.object3D.containEventListener(F.PICK_DOWN)&&r.object3D.dispatchEvent(this._downEvent))}onTouchEnd(e){this.isTouching=!1,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let r=this.findNearestObj(this._interestList,this._view.camera);r&&(Object.assign(this._upEvent,e),this._upEvent.type=F.PICK_UP,this._upEvent.target=r.object3D,this._upEvent.data=this.getPickInfo(),this.dispatchEvent(this._upEvent),r.object3D.containEventListener(F.PICK_UP)&&r.object3D.dispatchEvent(this._upEvent))}getPickInfo(){if(m.setting.pick.mode=="pixel")return{worldPos:this._pickCompute.getPickWorldPosition(),worldNormal:this._pickCompute.getPickWorldNormal(),screenUv:this._pickCompute.getPickScreenUV(),meshID:this._pickCompute.getPickMeshID()};{let e=this._interestList[0];return{worldPos:e.intersectPoint,worldNormal:e.normal,meshID:e.collider.transform.worldMatrix.index,distance:e.distance}}}onTouchMove(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let r=this.findNearestObj(this._interestList,this._view.camera);r&&(Object.assign(this._mouseMove,e),this._mouseMove.type=F.PICK_MOVE,this._mouseMove.target=r.object3D,this._mouseMove.data=this.getPickInfo(),this.dispatchEvent(this._mouseMove),r.object3D.containEventListener(F.PICK_MOVE)&&r.object3D.dispatchEvent(this._mouseMove)),r!=this._lastFocus&&(this._lastFocus&&this._lastFocus.object3D&&(Object.assign(this._outEvent,e),this._outEvent.type=F.PICK_OUT,this._outEvent.target=this._lastFocus.object3D,this._outEvent.data=this.getPickInfo(),this.dispatchEvent(this._outEvent),this._lastFocus.object3D.containEventListener(F.PICK_OUT)&&this._lastFocus.object3D.dispatchEvent(this._outEvent)),r&&(Object.assign(this._overEvent,e),this._overEvent.type=F.PICK_OVER,this._overEvent.target=r.object3D,this._overEvent.data=this.getPickInfo(),this.dispatchEvent(this._overEvent),r.object3D.containEventListener(F.PICK_OVER)&&r.object3D.dispatchEvent(this._overEvent))),this._lastFocus=r}onTouchOnce(e){this.isTouching=!0,this._mouseCode=e.mouseCode,this.pick(this._view.camera);let r=this.findNearestObj(this._interestList,this._view.camera);if(r){let i=this.getPickInfo();Object.assign(this._pickEvent,e),this._pickEvent.type=F.PICK_CLICK,this._pickEvent.target=r.object3D,this._pickEvent.data=i,this.dispatchEvent(this._pickEvent),r===this._lastDownTarget&&r.object3D.containEventListener(F.PICK_CLICK)&&r.object3D.dispatchEvent(this._pickEvent)}this._lastDownTarget=null}findNearestObj(e,r){var i;return e.sort((a,o)=>a.distance>o.distance?1:-1),(i=e[0])==null?void 0:i.collider}pick(e){if(this._interestList.length=0,m.setting.pick.mode=="pixel"){this._pickCompute.compute(this._view);let r=this._pickCompute.getPickMeshID(),i=this.mouseEnableMap.get(r);if(i){let a=this._pickCompute.getPickWorldPosition(),o=g.distance(a,this.ray.origin);this._interestList.push({distance:o,collider:i,intersectPoint:a})}}else if(m.setting.pick.mode=="bound"){this.ray=e.screenPointToRay(m.inputSystem.mouseX,m.inputSystem.mouseY);let r,i=Te.componentsEnablePickerList.get(this._view);if(i)for(const a of i){let o=a[0];o.enable&&(r=o.rayPick(this.ray),r&&(r.collider=o,this._interestList.push(r)))}}}}class rp extends Xt{constructor(e=0,r=0,i=0,a=0){super();s(this,"_camera");s(this,"_scene");s(this,"_viewPort");s(this,"_enablePick",!1);s(this,"_enable",!0);s(this,"pickFire");s(this,"guiPick");s(this,"canvasList");this.canvasList=[],this._viewPort=new ae(e,r,i,a)}get enable(){return this._enable}set enable(e){this._enable=e}get enablePick(){return this._enablePick}set enablePick(e){this._enablePick!=e&&(this.pickFire=new tp(this),this.pickFire.start()),this._enablePick=e}get scene(){return this._scene}set scene(e){this._scene=e,e.view=this,Kt.createBuffer(this),e&&this.canvasList.forEach(r=>{r&&e.addChild(r.object3D)})}get camera(){return this._camera}set camera(e){this._camera=e}get viewPort(){return this._viewPort}set viewPort(e){this._viewPort=e}enableUICanvas(e=0){let r=this.canvasList[e];if(!r){let i=new ee;i.name="Canvas "+e,r=i.addComponent(ws),r.index=e,this.canvasList[e]=r}return this.scene.addChild(r.object3D),this.guiPick||(this.guiPick=new Ug,this.guiPick.init(this)),r}disableUICanvas(e=0){let r=this.canvasList[e];r&&r.object3D&&r.object3D.removeFromParent()}}class ip{constructor(t){s(this,"normal");s(this,"fixNormal");s(this,"center");s(this,"rotateShape");s(this,"distance",0);s(this,"index");this.index=t,this.rotateShape=[]}}class s0 extends null{constructor(){super(...arguments);s(this,"vScale");s(this,"uNegate");s(this,"sections")}build(e,r,i,a=1,o=!0){if(i.length<2)throw new Error("path length is not enough");return this.vScale=a,this.uNegate=o,e=e.slice(),r&&e.push(e[0]),this.sections=this.buildSections(e,i),this.buildGeometry(e,this.sections),this.bounds=new Oe(g.ZERO.clone(),new g(100,100,100)),this}buildSections(e,r){let i,a,o,l=[],h=r.length;for(let c=0;c<h;c++){let f=new ip(c);i=r[c],a=r[c+1],f.center=i.clone(),a==null?(f.normal=o.clone(),f.distance=0):(o=a.subtract(i),f.distance=o.length,f.normal=o.normalize()),l.push(f)}l[0].fixNormal=l[0].normal.clone();for(let c=1;c<h;c++){let f=l[c-1],d=l[c];d.fixNormal=d.normal.add(f.normal).normalize()}let u=new Q().identity();for(let c=0;c<h;c++){let f=l[c],d,p;if(c==0)d=g.UP,p=e;else{let A=l[c-1];d=A.fixNormal,p=A.rotateShape}Q.fromToRotation(d,f.fixNormal,u);for(let A=0,x=e.length;A<x;A++){let C=u.multiplyPoint3(p[A]);f.rotateShape.push(C)}}return l}buildGeometry(e,r){let i=r.length,a=e.length,o=i*a,l=i-1,h=new Float32Array(o*3),u=new Float32Array(o*3),c=new Float32Array(o*2),f=new Uint32Array(l*(a-1)*6),d=a-1,p=0,A=0,x=[0];for(let v=1;v<a;v++)A+=e[v-1].subtract(e[v]).length,x.push(A);for(let v=0;v<i;v++){let y=r[v];for(let b=0;b<a;b++){let B=(v*a+b)*3,I=y.rotateShape[b].add(y.center);h[B]=I.x,h[B+1]=I.y,h[B+2]=I.z,u[B+1]=1;let w=(v*a+b)*2,D=x[b]/A;c[w]=this.uNegate?1-D:D,c[w+1]=p*this.vScale}p+=y.distance}let C=0;for(let v=0;v<l;v++){let y=v*a;for(let b=0;b<d;b++){let B=b,I=b+1,w=B+a,D=I+a;f[C++]=B+y,f[C++]=I+y,f[C++]=w+y,f[C++]=I+y,f[C++]=D+y,f[C++]=w+y}}return this.setIndices(f),this.setAttribute(O.position,h),this.setAttribute(O.normal,u),this.setAttribute(O.uv,c),this.setAttribute(O.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0}),this.computeNormals(),this}}class o0{constructor(){s(this,"name");s(this,"offset");s(this,"size");s(this,"arrayStride");s(this,"stepMode");s(this,"attributes")}}class n0{constructor(){s(this,"name");s(this,"format");s(this,"offset");s(this,"shaderLocation");s(this,"stride")}}var ap=(n=>(n[n.position=3]="position",n[n.normal=3]="normal",n[n.TANGENT=4]="TANGENT",n[n.uv=2]="uv",n[n.TEXCOORD_1=2]="TEXCOORD_1",n[n.color=4]="color",n[n.joints0=4]="joints0",n[n.weights0=4]="weights0",n[n.joints1=4]="joints1",n[n.weights1=4]="weights1",n[n.vIndex=1]="vIndex",n[n.weight=1]="weight",n[n.a_morphPositions_0=3]="a_morphPositions_0",n))(ap||{});class l0{constructor(){}}class h0{constructor(){s(this,"entity")}get data(){return null}}class sp{constructor(){s(this,"min",0);s(this,"max",0)}set(t,e){return this.max=e,this.min=t,this}copy(t){return this.max=t.max,this.min=t.min,this}isInterestRange(t){return!(this.max>t.min||t.max<this.min)}}class op{constructor(){s(this,"_spaceDesc")}getRange(t){return this._spaceDesc[t]}initSpace(t){this._spaceDesc={};for(let e of t)(this._spaceDesc[e]=new sp).set(-Number.MAX_VALUE,Number.MAX_VALUE);return this}isContain(t,e){let r=this._spaceDesc[t];return e>=r.min&&e<r.max}isInterestRange(t,e){let r=this._spaceDesc[t];return r?e.isInterestRange(r):!1}splitSpace(t,e,r){let i=this._spaceDesc[t];return e?i.max=r:i.min=r,this}copySpace(t){for(let e in t._spaceDesc){let r=t._spaceDesc[e];this._spaceDesc[e].copy(r)}return this}}const ta=class ta{};s(ta,"MaxEntityCountInLeaf",4),s(ta,"MaxLayer",10),s(ta,"ClearLeafLayer",ta.MaxLayer-4);let Oa=ta;const Vs=class Vs{constructor(){s(this,"uuid","0");this.uuid=(Vs.UUID++).toString()}};s(Vs,"UUID",0);let Yo=Vs;class np{constructor(){s(this,"map",{});s(this,"_count",0)}get count(){return this._count}push(t){return this.map[t.uuid]?!1:(this.map[t.uuid]=t,this._count++,!0)}remove(t){return this.map[t]?(delete this.map[t],this._count--,!0):!1}}const Mr=class Mr extends Yo{constructor(e=0){super();s(this,"_dimensionIndex",0);s(this,"_dimensions");s(this,"_dimension");s(this,"_left");s(this,"_right");s(this,"_space");s(this,"_parent");s(this,"_entities");s(this,"layer");s(this,"_splitEntityList",[]);s(this,"pointIntersect",new g);this.layer=e,Mr.nodeCount++}get dimension(){return this._dimension}initNode(e,r,i){return this._dimensions=r,this._dimensionIndex=i,this._dimension=r[i],this._space=new op().initSpace(r),e&&this._space.copySpace(e._space),this._parent=e,this._entities=new np,this}updateEntity(e){if(e.isInNode(this,this._dimension)&&(e.attachTreeNode(this),this.autoSplit(),this._left&&this._right)){let r=(this._dimensionIndex+1)%this._dimensions.length,i=this._dimensions[r];e.isInNode(this._right,i)?this._right.updateEntity(e):e.isInNode(this._left,i)&&this._left.updateEntity(e)}}buildRoot(e){for(const r of e)r.entity.attachTreeNode(this);this.autoSplit()}autoSplit(){if(this._entities.count>Oa.MaxEntityCountInLeaf&&!this._right&&!this._left&&this.layer<Oa.MaxLayer){let e=this._splitEntityList,r=(this._dimensionIndex+1)%this._dimensions.length,i=this._dimensions[r],a=0;for(const o in this._entities.map){let l=this._entities.map[o];a+=l.centerValue(i),e.push(l)}a/=this._entities.count,this._left=new Mr(this.layer+1),this._right=new Mr(this.layer+1),this._left.initNode(this,this._dimensions,r),this._right.initNode(this,this._dimensions,r),this._left.setSpace(!0,a),this._right.setSpace(!1,a);for(let o of e)o.isInNode(this._right,i)?o.attachTreeNode(this._right):o.isInNode(this._left,i)&&o.attachTreeNode(this._left)}this._left&&this._left.autoSplit(),this._right&&this._right.autoSplit()}setSpace(e,r){return this._parent&&this._space.splitSpace(this._dimension,e,r),this}isEmpty(){return this._left==null&&this._right==null&&this._entities.count==0}pushEntity(e){return this._entities.push(e)}removeEntity(e){return this._entities.remove(e.uuid)}autoClear(){let e=this;for(;e&&e.layer>Oa.ClearLeafLayer&&e.clearLeaf();)e=e._parent}clearLeaf(){let e=!this._left&&!this._right,r=!e&&this._left.isEmpty()&&this._right.isEmpty();return r&&(this._left=this._right=null,Mr.nodeCount-=2),e||r}isContain(e){return this._space.isContain(this._dimension,e)}nodeIntersectsBox(e){let r=this._space.getRange("x"),i=this._space.getRange("y"),a=this._space.getRange("z"),o=Mr.rangeBox;return o.min.set(r.min,i.min,a.min),o.max.set(r.max,i.max,a.max),o.intersectsBox(e)}nodeIntersectsRay(e){let r=this._space.getRange("x"),i=this._space.getRange("y"),a=this._space.getRange("z"),o=Mr.rangeBox;return o.min.set(r.min,i.min,a.min),o.max.set(r.max,i.max,a.max),!0}pointCast(e,r=0,i){if(i=i||[],this._entities.count>0){let a=this._entities.map;for(let o in a){let l=a[o],h=l.entityContainPoint(e);!h&&r>0&&(h=l.squareDistanceTo(e,this._dimensions)<=r),h&&i.push(l)}}this._left&&this._left.isContain(e[this._left.dimension])&&this._left.pointCast(e,r,i),this._right&&this._right.isContain(e[this._right.dimension])&&this._right.pointCast(e,r,i)}boxCast(e,r){if(r=r||[],this._entities.count>0){let i=this._entities.map;for(let a in i){let o=i[a];o.entityIntersectsBox(e)&&r.push(o)}}this._left&&this._left.nodeIntersectsBox(e)&&this._left.boxCast(e,r),this._right&&this._right.nodeIntersectsBox(e)&&this._right.boxCast(e,r)}rayCast(e,r,i){r=r||[],i=i||[];let a=this.pointIntersect;if(this._entities.count>0){let o=this._entities.map;for(let l in o){let h=o[l];h.entityIntersectsRay(e,a)&&(i.push(new g().copyFrom(a)),r.push(h))}}this._left&&this._left.nodeIntersectsRay(e)&&this._left.rayCast(e,r,i),this._right&&this._right.nodeIntersectsRay(e)&&this._right.rayCast(e,r,i)}};s(Mr,"nodeCount",0),s(Mr,"rangeBox",new Oe(new g(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),new g(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE)));let Bl=Mr;class u0 extends null{constructor(e){super();s(this,"userData");s(this,"node");this.userData=e}centerValue(e){return 0}isInNode(e,r){return!1}entityContainPoint(e){return!1}squareDistanceTo(e,r){return Number.MAX_VALUE}entityIntersectsBox(e){return!1}entityIntersectsRay(e,r){return!1}attachTreeNode(e){return this.node&&this.detachTreeNode(),this.node=e,this.node.pushEntity(this)}detachTreeNode(){let e=this.node.removeEntity(this);return this.node=null,e}updateNode(e){let r=this.node;r&&this.detachTreeNode(),e.updateEntity(this),r&&r.autoClear()}}const tr=class tr{constructor(){s(this,"minPosX",0);s(this,"minPosY",0);s(this,"maxPosX",0);s(this,"maxPosY",0);s(this,"testID",0);s(this,"points");s(this,"offsetPosition");this.points=new Array,this.offsetPosition=new g(0,0,0,0),this.clear()}setAABox(t,e,r,i){this.minPosX=t-r/2-tr.TINY,this.maxPosX=t+r/2+tr.TINY,this.minPosY=e-i/2-tr.TINY,this.maxPosY=e+i/2+tr.TINY,this.offsetPosition.setTo(0,0,0)}setOffset(t){this.maxPosX+=t.x-this.offsetPosition.x,this.minPosX+=t.x-this.offsetPosition.x,this.minPosY+=t.z-this.offsetPosition.z,this.maxPosY+=t.z-this.offsetPosition.z,this.offsetPosition.copyFrom(t)}setContainRect(t,e,r,i){this.minPosX>t&&(this.minPosX=t),this.minPosY>e&&(this.minPosY=e),this.maxPosX<r&&(this.maxPosX=r),this.maxPosY<i&&(this.maxPosY=i)}clear(){var t=1e9;this.minPosX=this.minPosY=t,this.maxPosX=this.maxPosY=-t,this.points.length=0,this.testID=0,this.offsetPosition.setTo(0,0,0)}addPoint(t){this.points.indexOf(t)==-1&&(t.x<this.minPosX&&(this.minPosX=t.x-tr.TINY),t.x>this.maxPosX&&(this.maxPosX=t.x+tr.TINY),t.z<this.minPosY&&(this.minPosY=t.z-tr.TINY),t.z>this.maxPosY&&(this.maxPosY=t.z+tr.TINY),this.points.push(t))}clone(){var t=new tr;return t.minPosX=this.minPosX,t.minPosY=this.minPosY,t.maxPosX=this.maxPosX,t.maxPosY=this.maxPosY,t}get radius(){return Math.sqrt((this.maxPosY-this.minPosY)*(this.maxPosY-this.minPosY)+(this.maxPosX-this.minPosX)*(this.maxPosX-this.minPosX))}get sideX(){return this.maxPosX-this.minPosX}get sideY(){return this.maxPosY-this.minPosY}get centreX(){return(this.maxPosX-this.minPosX)*.5+this.minPosX}get centreY(){return(this.maxPosY-this.minPosY)*.5+this.minPosY}overlapTest(t){return!(this.minPosY>=t.maxPosY||this.maxPosY<=t.minPosY||this.minPosX>=t.maxPosX||this.maxPosX<=t.minPosX)}isPointInside(t){return t.x>=this.minPosX&&t.x<=this.maxPosX&&t.z>=this.minPosY&&t.z<=this.maxPosY}isIntersectLineSegment(t,e,r,i){var a=!1,o=e-i,l=r-t,h=t*i-r*e,u=(-h-o*this.minPosX)/l;u<=this.maxPosY&&u>=this.minPosY&&(a=!0),u=(-h-o*this.maxPosX)/l,u<=this.maxPosY&&u>=this.minPosY&&(a=!0);var c=(-h-l*this.minPosY)/o;return c<=this.maxPosX&&c>=this.minPosX&&(a=!0),c=(-h-l*this.maxPosY)/o,c<=this.maxPosX&&c>=this.minPosX&&(a=!0),a}};s(tr,"TINY",null);let Ii=tr;const Qa=class Qa{constructor(t){s(this,"childCellIndices");s(this,"nodeIndices");s(this,"aabb");s(this,"points");this.childCellIndices=new Array,this.childCellIndices.length=Qa.NUM_CHILDREN,this.nodeIndices=new Array,this.clear(),t?this.aabb=t.clone():this.aabb=new Ii}isLeaf(){return this.childCellIndices[0]==-1}clear(){for(var t=0;t<Qa.NUM_CHILDREN;t++)this.childCellIndices[t]=-1;this.nodeIndices.splice(0,this.nodeIndices.length)}};s(Qa,"NUM_CHILDREN",null);let ji=Qa;class lp{constructor(){s(this,"_cells");s(this,"_rootCell");s(this,"_quadNodes");s(this,"_aabb");s(this,"_cellsToTest");s(this,"_testID");s(this,"logDeep",0);this._testID=0,this._cells=new Array,this._quadNodes=new Array,this._cellsToTest=new Array,this._aabb=new Ii}getQuadNode(t){return this._quadNodes[t]}clear(){this._cells.length=0,this._quadNodes.length=0}initNodes(t){this.clear();for(var e=0,r=t.length;e<r;)t[e].calcGlobalQuadAABB(),this._quadNodes.push(t[e]),e++}buildQuadTree(t,e){this._aabb.clear();for(var r of this._quadNodes)if(r.isTriangle)for(var i of r.aabb.points)this._aabb.addPoint(i);else this._aabb.setContainRect(r.aabb.minPosX,r.aabb.minPosY,r.aabb.maxPosX,r.aabb.maxPosY);this._cells.length=0,this._rootCell=new ji(this._aabb),this._cells.push(this._rootCell);for(var a=this._quadNodes.length,o=0;o<a;o++)this._cells[0].nodeIndices[o]=o;var l=new Array;l.push(0);for(var h,u,c;l.length!=0;)if(u=l.pop(),!(this._cells[u].nodeIndices.length<=t||this._cells[u].aabb.radius<e)){for(o=0;o<ji.NUM_CHILDREN;o++){this._cells[u].childCellIndices[o]=this._cells.length,l.push(this._cells.length),this._cells.push(new ji(this.createAABox(this._cells[u].aabb,o))),c=this._cells[this._cells.length-1],a=this._cells[u].nodeIndices.length;for(var f=0;f<a;f++)h=this._cells[u].nodeIndices[f],this.doesNodeIntersectCell(this._quadNodes[h],c)&&c.nodeIndices.push(h)}this._cells[u].nodeIndices.length=0}}createAABox(t,e){var r=t.centreX,i=t.centreY,a=t.sideX,o=t.sideY,l=new Ii;switch(e){case 0:l.setAABox(r+a/4,i+o/4,a/2,o/2);break;case 1:l.setAABox(r-a/4,i+o/4,a/2,o/2);break;case 2:l.setAABox(r-a/4,i-o/4,a/2,o/2);break;case 3:l.setAABox(r+a/4,i-o/4,a/2,o/2);break;default:l.setAABox(r+a/4,i-o/4,a/2,o/2);break}return l}doesNodeIntersectCell(t,e){var r=t.aabb;if(!r.overlapTest(e.aabb))return!1;if(!t.isTriangle)return!0;var i=r.points,a=i[0],o=i[1],l=i[2];if(e.aabb.isPointInside(a)||e.aabb.isPointInside(o)||e.aabb.isPointInside(l))return!0;var h=this.pointInTriangle(e.aabb.minPosX,e.aabb.minPosY,a,o,l)||this.pointInTriangle(e.aabb.minPosX,e.aabb.maxPosY,a,o,l)||this.pointInTriangle(e.aabb.maxPosX,e.aabb.maxPosY,a,o,l)||this.pointInTriangle(e.aabb.maxPosX,e.aabb.minPosY,a,o,l);return h?!0:(h=e.aabb.isIntersectLineSegment(a.x,a.z,o.x,o.z)||e.aabb.isIntersectLineSegment(a.x,a.z,l.x,l.z)||e.aabb.isIntersectLineSegment(o.x,o.z,l.x,l.z),h)}getNodesIntersectingtAABox(t,e){if(this._cells.length==0)return 0;this._cellsToTest.length=0,this._cellsToTest.push(0),this.incrementTestCounter();for(var r,i,a,o,l=0;this._cellsToTest.length!=0;)if(r=this._cellsToTest.pop(),a=this._cells[r],!!e.overlapTest(a.aabb))if(a.isLeaf())for(i=a.nodeIndices.length,l=0;l<i;l++)o=this.getQuadNode(a.nodeIndices[l]).aabb,o.testID!=this._testID&&(o.testID=this._testID,e.overlapTest(o)&&t.push(a.nodeIndices[l]));else for(l=0;l<ji.NUM_CHILDREN;l++)this._cellsToTest.push(a.childCellIndices[l]);return t.length}pointInTriangle(t,e,r,i,a){var o=r,l=i,h=a,u=o.z-l.z,c=l.x-o.x,f=o.x*l.z-l.x*o.z,d=l.z-h.z,p=h.x-l.x,A=l.x*h.z-h.x*l.z,x=h.z-o.z,C=o.x-h.x,v=h.x*o.z-o.x*h.z,y=!1,b=u*t+c*e+f,B=d*t+p*e+A,I=x*t+C*e+v;const w=.01;return(b>=-w&&B>=-w&&I>=-w||b<=w&&B<=w&&I<=w)&&(y=!0),y}incrementTestCounter(){if(++this._testID,this._testID==0){for(var t=this._quadNodes.length,e=0;e<t;e++)this._quadNodes[e].aabb.testID=0;this._testID=1}}logTree(t){if(!(t<0)){this.logDeep++;for(var e=this._cells[t],r="",i=0;i<this.logDeep-1;i++)r+="-|";console.log(r+"i="+t+" "+e.aabb.minPosX.toFixed(2)+" "+e.aabb.maxPosX.toFixed(2)+" "+e.aabb.minPosY.toFixed(2)+" "+e.aabb.maxPosY.toFixed(2));var a;for(a=0;a<e.nodeIndices.length;a++)if(e.nodeIndices[a]>=0){var o=this._quadNodes[e.nodeIndices[a]];console.log(r+" t="+e.nodeIndices[a]+" "+o.aabb.minPosX.toFixed(2)+" "+o.aabb.maxPosX.toFixed(2)+" "+o.aabb.minPosY.toFixed(2)+" "+o.aabb.maxPosY.toFixed(2))}for(a=0;a<e.childCellIndices.length;a++)e.childCellIndices[a]>=0&&this.logTree(e.childCellIndices[a]);this.logDeep--}}}class hp{constructor(t=10,e=500){s(this,"_maxNodesPerCell");s(this,"_minCellSize");s(this,"_quadTree");s(this,"_collisionNodesIdx");s(this,"_segBox");s(this,"_collisionNodes");this._maxNodesPerCell=t,this._minCellSize=e,this._segBox=new Ii,this._collisionNodesIdx=new Array,this._collisionNodes=new Array}createQuadTree(t){this._quadTree=new lp,this._quadTree.initNodes(t),this._quadTree.buildQuadTree(this._maxNodesPerCell,this._minCellSize)}getNodesByAABB(t,e,r,i){this._segBox.clear(),this._segBox.maxPosX=r,this._segBox.maxPosY=i,this._segBox.minPosX=t,this._segBox.minPosY=e,this._collisionNodesIdx.length=0,this._collisionNodes.length=0,this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx,this._segBox);for(var a,o=0;o<this._collisionNodesIdx.length;o++)a=this._quadTree.getQuadNode(this._collisionNodesIdx[o]),this._collisionNodes.push(a);return this._collisionNodes}getTriangleAtPoint(t,e=5){this._segBox.clear(),this._segBox.setAABox(t.x,t.z,1,1),this._collisionNodesIdx.length=0,this._collisionNodes.length=0,this._quadTree.getNodesIntersectingtAABox(this._collisionNodesIdx,this._segBox);for(var r=4294967295,i=0,a,o,l,h,u=0;u<this._collisionNodesIdx.length;u++)o=this._quadTree.getQuadNode(this._collisionNodesIdx[u]),h=o.aabb,g.pointInsideTriangle(t,h.points[0],h.points[1],h.points[2])&&(l=o,i=Math.abs(l.plane.distance(t)),!(i>e)&&(o==null||i<=r)&&(a=l,r=i));return a}}var Ho=(n=>(n[n.MOUSE_LEFT=0]="MOUSE_LEFT",n[n.MOUSE_MID=1]="MOUSE_MID",n[n.MOUSE_RIGHT=2]="MOUSE_RIGHT",n))(Ho||{});class Dl extends null{}s(Dl,"LOADER_PROGRESS",null),s(Dl,"LOADER_COMPLETE",null);class Ms extends null{}s(Ms,"ADDED",null),s(Ms,"REMOVED",null),s(Ms,"CHILD_ADD_EVENT",null),s(Ms,"CHILD_REMOVED",null);class Xo extends null{}s(Xo,"SHOW",null),s(Xo,"HIDE",null),s(Xo,"UPDATE",null);class c0{static merge(t,e,r,i){let a=0,o=0;a=Math.max(t.width,a),a=Math.max(e.width,a),a=Math.max(r.width,a),a=Math.max(i.width,a),o=Math.max(t.height,o),o=Math.max(e.height,o),o=Math.max(r.height,o),o=Math.max(i.height,o);let l=new pe(a,o,j.rgba8unorm),h=new ce(vd);h.setSamplerTexture("textureR",t),h.setSamplerTexture("textureG",e),h.setSamplerTexture("textureB",r),h.setSamplerTexture("textureA",i),h.setStorageTexture("outTex",l),h.workerSizeX=Math.ceil(a/8),h.workerSizeY=Math.ceil(o/8);let u=S.beginCommandEncoder();return S.computeCommand(u,[h]),S.endCommandEncoder(u),l}}class up{constructor(){s(this,"computeShader")}setInputes(t,e,r){this.computeShader=new ce(Ud(t,e,r,8,8,1));for(let i=0;i<e.length;i++)this.computeShader.setSamplerTexture(`source${i}Map`,e[i]);for(let i=0;i<r.length;i++)this.computeShader.setStorageTexture(`dest${i}Map`,r[i]);t&&this.computeShader.setSamplerTexture("colorMap",t),this.computeShader.workerSizeX=r[0].width/8,this.computeShader.workerSizeY=r[0].height/8,this.computeShader.workerSizeZ=1}}class cp{constructor(t,e){s(this,"sourceShader");s(this,"compute");s(this,"needUpdate",!0);this.sourceShader=e,this.compute=new ce(t),this.init()}init(){}onUpdate(){this.onFrame&&this.onFrame(),this.onOnce&&this.needUpdate&&(this.needUpdate=!1,this.onFrame())}}class fp extends cp{constructor(t){super(Sd,t)}init(){let t=new pe(256,256,j.rgba8unorm,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING);return this.compute.setStorageTexture("sssMap",t),this.sourceShader.setTexture("lutMap",t),t}onFrame(){this.compute.workerSizeX=256/8,this.compute.workerSizeY=256/8;let t=S.beginCommandEncoder();S.computeCommand(t,[this.compute]),S.endCommandEncoder(t)}}class f0{constructor(){s(this,"gpuBuffer");s(this,"probes");s(this,"memoryDo");s(this,"_probeInfoList")}initDataUniform(t){this.memoryDo=new ua,this.probes=t,this._probeInfoList=[],this.memoryDo.destroy(),this.memoryDo.allocation(t.length*17*4);for(let r=0;r<t.length;r++){var e=17;let i=this.memoryDo.allocation_node(e*4);this._probeInfoList.push(i);let a=t[r].transform.worldPosition;i.setArray(0,[a.x,a.y,a.z])}this.gpuBuffer=E.device.createBuffer({size:this.memoryDo.shareDataBuffer.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.STORAGE,label:"ProbeBuffer",mappedAtCreation:!1})}updateGPUBuffer(){const t=this.memoryDo.shareDataBuffer;let e=this.memoryDo.shareDataBuffer.byteLength,r=0;const i=5e3*64;for(;r<e;)E.device.queue.writeBuffer(this.gpuBuffer,r,t,r,Math.floor(Math.min(i,e-r))),r+=i}}class d0 extends null{constructor(t,e,r=0){super(),this.bufferType=vr.StructStorageGPUBuffer,this.createBufferByStruct(GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST|r,t,e)}}class Ps{static createMipmap(t,e){const r=E.device;this._pipelineMax||(this._pipelineMax=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMax}),entryPoint:"main"}})),this._pipelineMin||(this._pipelineMin=r.createComputePipeline({layout:"auto",compute:{module:r.createShaderModule({code:this.codeMin}),entryPoint:"main"}}));let i=Math.ceil(t.width*.5),a=Math.ceil(t.height*.5),o={mipmapCount:e,texture:t,srcView:null,mipLevel:1,dstHeight:a,dstWidth:i};o.srcView=t.getGPUTexture().createView({format:t.format,dimension:"2d",baseMipLevel:0,mipLevelCount:1}),t.width>1024&&t.height>1024?this.mipmap(this._pipelineMax,o):this.mipmap(this._pipelineMin,o)}static mipmap(t,e){const r=E.device,i=S.beginCommandEncoder();let a=t==this._pipelineMax,o,l;for(let h=e.mipLevel;h<e.mipmapCount;h++){let u=[],c=0;u.push({binding:c++,resource:e.srcView}),u.push({binding:c++,resource:e.texture.gpuSampler}),o=e.texture.getGPUTexture().createView({format:e.texture.format,dimension:"2d",baseMipLevel:h,mipLevelCount:1}),u.push({binding:c++,resource:o});const f=r.createBindGroup({layout:t.getBindGroupLayout(0),entries:u}),d=i.beginComputePass();d.setPipeline(t),d.setBindGroup(0,f);let p=e.dstWidth,A=e.dstHeight;if(a&&(p=Math.max(1,Math.floor(e.dstWidth/8)),A=Math.max(1,Math.floor(e.dstHeight/8))),d.dispatchWorkgroups(p,A),e.dstHeight*=.5,e.dstWidth*=.5,e.srcView=o,e.mipLevel=h+1,l=a&&(e.dstWidth<8||e.dstHeight<8),d.end(),l)break}S.endCommandEncoder(i),l&&this.mipmap(this._pipelineMin,e)}}s(Ps,"codeMax",null),s(Ps,"codeMin",null),s(Ps,"_pipelineMax"),s(Ps,"_pipelineMin");class dp{constructor(){s(this,"name","");s(this,"passMap",new Map)}}class gp{constructor(){s(this,"passType","");s(this,"shaderState",new Map);s(this,"vertexShader","");s(this,"fragmentShader","")}}class Na{static parser(t,e){t=xr.filterComment(t);let r=new dp,i=t.indexOf(this.shaderKeyword),a=t.indexOf("{",i),o=t.substring(i+this.shaderKeyword.length,a).trim();r.name=o.substring(1,o.length-1),o=t.substring(t.indexOf("{")+1,t.lastIndexOf("}"));let l=this.splitPassBlock(o);for(let h of l){let u=this.parserPassBlock(h),c;r.passMap.has(u.passType)?c=r.passMap.get(u.passType):(c=[],r.passMap.set(u.passType,c)),c.push(u),u.vertexShader.length>0&&(u.vertexShader=xr.parse(u.vertexShader,e)),u.fragmentShader.length>0&&(u.fragmentShader=xr.parse(u.fragmentShader,e))}return r}static splitPassBlock(t){let e=0,r=[];for(;e<t.length;){let i=t.indexOf(this.passKeyword,e);if(i==-1){r.push(t.substring(e));break}e!=0&&r.push(t.substring(e,i)),e=i+this.passKeyword.length}return r}static parserPassBlock(t){let e=new gp,r=t.indexOf(this.passTypeKeyword),i=t.indexOf('"',r);return r=t.indexOf('"',i+1),e.passType=t.substring(r+1,i).trim(),this.parserShaderState(e,t),r=t.indexOf(this.vertexKeyword),r!=-1&&(e.vertexShader=this.extractBlock(t.substring(r+this.vertexKeyword.length),"{","}")),r=t.indexOf(this.fragmentKeyword),r!=-1&&(e.fragmentShader=this.extractBlock(t.substring(r+this.fragmentKeyword.length),"{","}")),e}static parserShaderState(t,e){let r=e.indexOf("ShaderState");if(r==-1)return!1;r=e.indexOf("{",r);let i=e.indexOf("}",r),a=e.substring(r+1,i).split(",");for(let o of a){let l=o.split(":"),h=l[0].trim(),u=this.convertValue(l[1].trim());t.shaderState.set(h,u)}return!0}static convertValue(t){return t.length==4&&t.toLowerCase()=="true"?!0:t.length==5&&t.toLowerCase()=="false"?!1:t[0]=='"'?t.substring(1,t.length-1):Number.parseInt(t)}static extractBlock(t,e,r){let i=t.indexOf(e);if(i==-1)return"";let a=0,o=0;t=t.substring(i);for(let l of t){if(l==e?a++:l==r&&a--,a<=0)break;o++}return t.substring(1,o).trim()}}s(Na,"passKeyword",null),s(Na,"shaderKeyword",null),s(Na,"vertexKeyword",null),s(Na,"fragmentKeyword",null),s(Na,"passTypeKeyword",null);let pp=new lt("IrradianceDataReaderCompleteEvent");class Rs extends ir{constructor(){super(...arguments);s(this,"readFlag",!1);s(this,"probeRenderer");s(this,"opColorBuffer");s(this,"opDepthBuffer");s(this,"srcColorMap");s(this,"srcDepthMap");s(this,"opDepthArray");s(this,"opColorArray")}initReader(e,r,i){this.probeRenderer=e,this.srcColorMap=r,this.srcDepthMap=i;let a=m.setting.gi,o=a.octRTMaxSize*a.octRTMaxSize;this.opColorBuffer=E.device.createBuffer({size:o*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opColorArray=new Float32Array(o*4),this.opDepthBuffer=E.device.createBuffer({size:o*4*4,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ,mappedAtCreation:!1}),this.opDepthArray=new Float32Array(o*4),this.probeRenderer.addEventListener(Gn.type,()=>{this.onProbeRenderComplete()},this),this.probeRenderer.addEventListener(po.type,()=>{console.log("GIRenderStartEvent")},this)}onProbeRenderComplete(){return V(this,null,function*(){if(console.log("GIRenderCompleteEvent"),this.readFlag)console.log("irradianceDataReader is reading yet!!!");else{this.readFlag=!0;let e=Date.now();console.log("irradianceDataReader start reading "),yield Rs.read(this.srcColorMap.getGPUTexture(),this.opColorBuffer,this.opColorArray),yield Rs.read(this.srcDepthMap.getGPUTexture(),this.opDepthBuffer,this.opDepthArray),this.readFlag=!1,console.log("process time :",Date.now()-e),console.log("irradianceDataReader read complete"),this.dispatchEvent(pp)}})}static read(e,r,i){return V(this,null,function*(){let a=S.beginCommandEncoder();a.copyTextureToBuffer({texture:e},{buffer:r,bytesPerRow:e.width*16},[e.width,e.height]),S.endCommandEncoder(a),yield r.mapAsync(GPUMapMode.READ);const o=r.getMappedRange();i.set(new Float32Array(o),0),r.unmap()})}}let g0=new Rs;class p0{constructor(){s(this,"computeShader");s(this,"visibleBuffer");s(this,"texture");this.computeShader=new ce(kd),this.visibleBuffer=new xa(8192*2),this.computeShader.setStorageBuffer("visibleBuffer",this.visibleBuffer),this.texture=Vt.getTexture(ht.zBufferTexture_NAME),this.computeShader.setSamplerTexture("zBufferTexture",this.texture),this.computeShader.workerSizeX=Math.ceil(this.texture.width/8),this.computeShader.workerSizeY=Math.ceil(this.texture.height/8),this.computeShader.workerSizeZ=1}compute(t,e){this.visibleBuffer.reset(!0,0),this.visibleBuffer.apply();let r=S.beginCommandEncoder();S.computeCommand(r,[this.computeShader]),this.visibleBuffer.readBuffer(),e.zVisibleList=this.visibleBuffer.outFloat32Array}}class m0 extends null{constructor(){super();s(this,"RT_BloomUp");s(this,"RT_BloomDown");s(this,"RT_threshold");s(this,"thresholdCompute");s(this,"downSampleComputes");s(this,"upSampleComputes");s(this,"postCompute");s(this,"bloomSetting");s(this,"rtFrame");s(this,"Render")}onAttach(e){m.setting.render.postProcessing.bloom.enable=!0,this.createGUI()}onDetach(e){m.setting.render.postProcessing.bloom.enable=!1,this.removeGUI()}createGUI(){}removeGUI(){}get downSampleBlurSize(){return m.setting.render.postProcessing.bloom.downSampleBlurSize}set downSampleBlurSize(e){m.setting.render.postProcessing.bloom.downSampleBlurSize=e}get downSampleBlurSigma(){return m.setting.render.postProcessing.bloom.downSampleBlurSigma}set downSampleBlurSigma(e){m.setting.render.postProcessing.bloom.downSampleBlurSigma=e}get upSampleBlurSize(){return m.setting.render.postProcessing.bloom.upSampleBlurSize}set upSampleBlurSize(e){m.setting.render.postProcessing.bloom.upSampleBlurSize=e}get upSampleBlurSigma(){return m.setting.render.postProcessing.bloom.upSampleBlurSigma}set upSampleBlurSigma(e){m.setting.render.postProcessing.bloom.upSampleBlurSigma=e}get luminanceThreshole(){return m.setting.render.postProcessing.bloom.luminanceThreshole}set luminanceThreshole(e){m.setting.render.postProcessing.bloom.luminanceThreshole=e}get bloomIntensity(){return m.setting.render.postProcessing.bloom.bloomIntensity}set bloomIntensity(e){m.setting.render.postProcessing.bloom.bloomIntensity=e}get hdr(){return m.setting.render.postProcessing.bloom.hdr}set hdr(e){m.setting.render.postProcessing.bloom.hdr=e}createThreshouldCompute(){this.thresholdCompute=new ce(fd),this.thresholdCompute.setSamplerTexture("inTex",this.getLastRenderTexture()),this.thresholdCompute.setStorageTexture("outTex",this.RT_threshold),this.thresholdCompute.setUniformBuffer("bloomCfg",this.bloomSetting),this.thresholdCompute.workerSizeX=Math.ceil(this.RT_threshold.width/8),this.thresholdCompute.workerSizeY=Math.ceil(this.RT_threshold.height/8),this.thresholdCompute.workerSizeZ=1}createDownSampleComputes(){const e=m.setting.render.postProcessing.bloom.downSampleStep;this.downSampleComputes=[];for(let r=0;r<e;r++){let i=new ce(dd),a=this.RT_BloomDown[r],o=r==0?this.RT_threshold:this.RT_BloomDown[r-1];i.setSamplerTexture("inTex",o),i.setStorageTexture("outTex",a),i.setUniformBuffer("bloomCfg",this.bloomSetting),i.workerSizeX=Math.ceil(a.width/8),i.workerSizeY=Math.ceil(a.height/8),i.workerSizeZ=1,this.downSampleComputes.push(i)}}createUpSampleComputes(){const e=m.setting.render.postProcessing.bloom.downSampleStep;this.upSampleComputes=[];{let r=new ce(ul),i=this.RT_BloomUp[0],a=this.RT_BloomDown[e-2];r.setSamplerTexture("_MainTex",a),r.setSamplerTexture("_PrevMip",this.RT_BloomDown[e-1]),r.setStorageTexture("outTex",i),r.setUniformBuffer("bloomCfg",this.bloomSetting),r.workerSizeX=Math.ceil(i.width/8),r.workerSizeY=Math.ceil(i.height/8),r.workerSizeZ=1,this.upSampleComputes.push(r)}for(let r=1;r<e-1;r++){let i=new ce(ul),a=this.RT_BloomUp[r],o=this.RT_BloomDown[e-2-r];i.setSamplerTexture("_MainTex",o),i.setSamplerTexture("_PrevMip",this.RT_BloomUp[r-1]),i.setStorageTexture("outTex",a),i.setUniformBuffer("bloomCfg",this.bloomSetting),i.workerSizeX=Math.ceil(a.width/8),i.workerSizeY=Math.ceil(a.height/8),i.workerSizeZ=1,this.upSampleComputes.push(i)}}createPostCompute(){const e=m.setting.render.postProcessing.bloom.downSampleStep;this.postCompute=new ce(gd),this.postCompute.setSamplerTexture("_MainTex",this.getLastRenderTexture()),this.postCompute.setSamplerTexture("_BloomTex",this.RT_BloomUp[e-2]),this.postCompute.setStorageTexture("outTex",this.RT_threshold),this.postCompute.setUniformBuffer("bloomCfg",this.bloomSetting),this.postCompute.workerSizeX=Math.ceil(this.RT_threshold.width/8),this.postCompute.workerSizeY=Math.ceil(this.RT_threshold.height/8),this.postCompute.workerSizeZ=1}createResource(){let e=m.setting.render.postProcessing.bloom;this.bloomSetting=new Ct(4*2);let[r,i]=E.presentationSize,a=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING;this.RT_threshold=new pe(r,i,j.rgba16float,!1,a);const o=e.downSampleStep;{this.RT_BloomDown=[];let h=Math.ceil(r/4),u=Math.ceil(i/4);for(let c=0;c<o;c++)this.RT_BloomDown[c]=new pe(h,u,j.rgba16float,!1,a),h=Math.ceil(h/2),u=Math.ceil(u/2)}{this.RT_BloomUp=[];for(let h=0;h<o-1;h++){let u=this.RT_BloomDown[o-2-h].width,c=this.RT_BloomDown[o-2-h].height;this.RT_BloomUp[h]=new pe(u,c,j.rgba16float,!1,a)}}let l=new Me;l.loadOp="load",this.rtFrame=new Je([this.RT_threshold],[l])}render(e,r){this.thresholdCompute||(this.createResource(),this.createThreshouldCompute(),this.createDownSampleComputes(),this.createUpSampleComputes(),this.createPostCompute(),this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="Bloom");let i=m.setting.render.postProcessing.bloom;this.bloomSetting.setFloat("downSampleStep",i.downSampleStep),this.bloomSetting.setFloat("downSampleBlurSize",i.downSampleBlurSize),this.bloomSetting.setFloat("downSampleBlurSigma",i.downSampleBlurSigma),this.bloomSetting.setFloat("upSampleBlurSize",i.upSampleBlurSize),this.bloomSetting.setFloat("upSampleBlurSigma",i.upSampleBlurSigma),this.bloomSetting.setFloat("luminanceThreshole",i.luminanceThreshole),this.bloomSetting.setFloat("bloomIntensity",i.bloomIntensity),this.bloomSetting.setFloat("hdr",i.hdr),this.bloomSetting.apply(),S.computeCommand(r,[this.thresholdCompute,...this.downSampleComputes,...this.upSampleComputes,this.postCompute]),S.lastRenderPassState=this.rendererPassState}onResize(){let e=m.setting.render.postProcessing.bloom,[r,i]=E.presentationSize;this.RT_threshold.resize(r,i);const a=e.downSampleStep;let o=Math.ceil(r/4),l=Math.ceil(i/4);for(let h=0;h<a;h++)this.RT_BloomDown[h].resize(o,l),o=Math.ceil(o/2),l=Math.ceil(l/2);for(let h=0;h<a-1;h++){let u=this.RT_BloomDown[a-2-h].width,c=this.RT_BloomDown[a-2-h].height;this.RT_BloomUp[h].resize(u,c)}this.thresholdCompute.workerSizeX=Math.ceil(this.RT_threshold.width/8),this.thresholdCompute.workerSizeY=Math.ceil(this.RT_threshold.height/8),this.thresholdCompute.workerSizeZ=1;for(let h=0;h<a;h++){let u=this.downSampleComputes[h],c=this.RT_BloomDown[h];u.workerSizeX=Math.ceil(c.width/8),u.workerSizeY=Math.ceil(c.height/8),u.workerSizeZ=1}{let h=this.RT_BloomUp[0],u=this.upSampleComputes[0];u.workerSizeX=Math.ceil(h.width/8),u.workerSizeY=Math.ceil(h.height/8),u.workerSizeZ=1}for(let h=1;h<a-1;h++){let u=this.RT_BloomUp[h],c=this.upSampleComputes[h];c.workerSizeX=Math.ceil(u.width/8),c.workerSizeY=Math.ceil(u.height/8),c.workerSizeZ=1}this.postCompute.workerSizeX=Math.ceil(this.RT_threshold.width/8),this.postCompute.workerSizeY=Math.ceil(this.RT_threshold.height/8),this.postCompute.workerSizeZ=1}}class A0 extends null{constructor(){super();s(this,"blurTexture1");s(this,"blurTexture2");s(this,"blurComputes");s(this,"blurSettings");s(this,"outTexture");s(this,"rtFrame")}onAttach(e){m.setting.render.postProcessing.depthOfView.enable=!0}onDetach(e){m.setting.render.postProcessing.depthOfView.enable=!1}get pixelOffset(){return m.setting.render.postProcessing.depthOfView.pixelOffset}set pixelOffset(e){e=Math.max(0,e);let r=m.setting.render.postProcessing.depthOfView;r.pixelOffset=e}get near(){return m.setting.render.postProcessing.depthOfView.near}set near(e){e=Math.max(0,e);let r=m.setting.render.postProcessing.depthOfView;r.near=e}get far(){return m.setting.render.postProcessing.depthOfView.far}set far(e){e=Math.max(0,e);let r=m.setting.render.postProcessing.depthOfView;r.far=e}createBlurCompute(){this.blurSettings=[],this.blurComputes=[];let e=m.setting.render.postProcessing.depthOfView;for(let r=0;r<e.iterationCount;r++){let i=new Ct(4),a=new ce(pd);this.blurComputes.push(a),this.blurSettings.push(i),a.setUniformBuffer("blurSetting",i);let o=fe.getGBufferFrame(fe.colorPass_GBuffer);a.setSamplerTexture("gBufferTexture",o.getCompressGBufferTexture());let l=r%2==0?this.blurTexture1:this.blurTexture2,h=r%2==1?this.blurTexture1:this.blurTexture2;a.setSamplerTexture("inTex",l),a.setStorageTexture("outTex",h),a.workerSizeX=Math.ceil(this.blurTexture1.width/8),a.workerSizeY=Math.ceil(this.blurTexture1.height/8),a.workerSizeZ=1,this.outTexture=h}this.blurComputes[0].setSamplerTexture("inTex",this.getLastRenderTexture())}createResource(){let e=E.presentationSize,r=e[0],i=e[1];this.blurTexture1=new pe(r,i,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture1.name="dof1";let a=new Me;a.clearValue=[0,0,0,1],a.loadOp="clear",this.blurTexture2=new pe(r,i,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.blurTexture2.name="dof2";let o=new Me;o.clearValue=[0,0,0,1],o.loadOp="clear",this.rtFrame=new Je([this.blurTexture1,this.blurTexture2],[a,o])}render(e,r){if(!this.blurComputes){this.createResource(),this.createBlurCompute();let a=re.getCameraGroup(e.camera);for(let o=0;o<this.blurComputes.length;o++)this.blurComputes[o].setUniformBuffer("globalUniform",a.uniformGPUBuffer);this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null)}let i=m.setting.render.postProcessing.depthOfView;i.far=Math.max(i.near,i.far)+1e-4;for(let a=0;a<i.iterationCount;a++){let o=this.blurComputes[a],l=this.blurSettings[a];l.setFloat("near",i.near),l.setFloat("far",i.far),l.setFloat("pixelOffset",(a+1)*i.pixelOffset),l.apply(),o.setStorageBuffer("blurSetting",l)}S.computeCommand(r,this.blurComputes),S.lastRenderPassState=this.rendererPassState}onResize(){let e=E.presentationSize,r=e[0],i=e[1],a=m.setting.render.postProcessing.depthOfView;a.far=Math.max(a.near,a.far)+1e-4,this.blurTexture1.resize(r,i),this.blurTexture2.resize(r,i);for(let o=0;o<a.iterationCount;o++){let l=this.blurComputes[o];l.workerSizeX=Math.ceil(this.blurTexture1.width/8),l.workerSizeY=Math.ceil(this.blurTexture1.height/8),l.workerSizeZ=1}}}class v0 extends null{constructor(){super();s(this,"outTexture");s(this,"rtFrame");s(this,"view");s(this,"gBufferTexture");s(this,"testCompute");s(this,"_state",0);s(this,"_state1",256);s(this,"_state2",256);s(this,"uniformBuffer");s(this,"currentRenderTexture");s(this,"Render")}onAttach(e){this.view=e}onDetach(e){}set state(e){this._state=e,this.uniformBuffer.setInt32("state",e),this.uniformBuffer.apply()}get state(){return this._state}set size1(e){this._state1=e,this.uniformBuffer.setInt32("state1",e),this.uniformBuffer.apply()}get size1(){return this._state1}set size2(e){this._state2=e,this.uniformBuffer.setInt32("state2",e),this.uniformBuffer.apply()}get size2(){return this._state2}createResource(){let e=fe.getGBufferFrame("ColorPassGBuffer");this.currentRenderTexture=e.getColorTexture(),this.gBufferTexture=e.getCompressGBufferTexture();let[r,i]=E.presentationSize;this.outTexture=new pe(r,i,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outTexture.name="outTexture";let a=new Me;a.loadOp="load",this.rtFrame=new Je([this.outTexture],[a])}createCompute(){this.uniformBuffer=new Ct(4),this.uniformBuffer.setInt32("state",this._state);let e=re.getCameraGroup(this.view.camera),r=fe.getGBufferFrame("ColorPassGBuffer").getCompressGBufferTexture(),i=m.setting.reflectionSetting,a=fe.getGBufferFrame(fe.reflections_GBuffer,i.width,i.height).getCompressGBufferTexture(),o=m.renderJobs.get(this.view).reflectionRenderer.outTexture;this.testCompute=new ce(Rd),this.testCompute.setUniformBuffer("globalUniform",e.uniformGPUBuffer),this.testCompute.setUniformBuffer("uniformData",this.uniformBuffer),this.testCompute.setSamplerTexture("gBufferTexture",r),this.testCompute.setSamplerTexture("currentRenderTexture",this.currentRenderTexture),this.testCompute.setSamplerTexture("reflectionsGBufferTexture",a),this.testCompute.setSamplerTexture("envMap",o),this.testCompute.setStorageTexture("outputTexture",this.outTexture),this.testCompute.workerSizeX=Math.ceil(this.outTexture.width/16),this.testCompute.workerSizeY=Math.ceil(this.outTexture.height/16),this.testCompute.workerSizeZ=1}render(e,r){}compute(e){this.testCompute||(this.createResource(),this.createCompute(),this.onResize(),this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="test");let r=S.beginCommandEncoder();S.computeCommand(r,[this.testCompute]),S.endCommandEncoder(r),S.lastRenderPassState=this.rendererPassState}onResize(){let[e,r]=E.presentationSize;this.outTexture.resize(e,r),this.testCompute.workerSizeX=Math.ceil(this.outTexture.width/16),this.testCompute.workerSizeY=Math.ceil(this.outTexture.height/16)}}class x0 extends null{constructor(){super();s(this,"gtaoTexture");s(this,"gtaoCompute");s(this,"gtaoSetting");s(this,"aoBuffer");s(this,"directionsBuffer");s(this,"directionsArray");s(this,"rtFrame");s(this,"Render");s(this,"randomCount",0)}onAttach(e){m.setting.render.postProcessing.gtao.enable=!0}onDetach(e){m.setting.render.postProcessing.gtao.enable=!1}get maxDistance(){return m.setting.render.postProcessing.gtao.maxDistance}set maxDistance(e){e=se(e,.1,50);let r=m.setting.render.postProcessing.gtao;r.maxDistance=e}get maxPixel(){return m.setting.render.postProcessing.gtao.maxPixel}set maxPixel(e){e=se(e,5,100);let r=m.setting.render.postProcessing.gtao;r.maxPixel=e}get darkFactor(){return m.setting.render.postProcessing.gtao.darkFactor}set darkFactor(e){e=se(e,.01,1);let r=m.setting.render.postProcessing.gtao;r.darkFactor=e}get rayMarchSegment(){return m.setting.render.postProcessing.gtao.rayMarchSegment}set rayMarchSegment(e){e=se(e,4,10);let r=m.setting.render.postProcessing.gtao;r.rayMarchSegment=e}get multiBounce(){return m.setting.render.postProcessing.gtao.multiBounce}set multiBounce(e){let r=m.setting.render.postProcessing.gtao;r.multiBounce=e}get blendColor(){return m.setting.render.postProcessing.gtao.blendColor}set blendColor(e){let r=m.setting.render.postProcessing.gtao;r.blendColor=e}get usePosFloat32(){return m.setting.render.postProcessing.gtao.usePosFloat32}set usePosFloat32(e){let r=m.setting.render.postProcessing.gtao;r.usePosFloat32=e}createCompute(){this.gtaoCompute=new ce(md);let e=new Ct(4*2);this.gtaoCompute.setUniformBuffer("gtaoData",e),this.directionsArray=new Float32Array(8*2),this.directionsBuffer=new be(8*2),this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply(),this.gtaoCompute.setStorageBuffer("directions",this.directionsBuffer),this.aoBuffer=new be(this.gtaoTexture.width*this.gtaoTexture.height),this.gtaoCompute.setStorageBuffer("aoBuffer",this.aoBuffer);let r=fe.getGBufferFrame(fe.colorPass_GBuffer);this.gtaoCompute.setSamplerTexture("gBufferTexture",r.getCompressGBufferTexture()),this.gtaoCompute.setSamplerTexture("inTex",this.getLastRenderTexture()),this.gtaoCompute.setStorageTexture("outTex",this.gtaoTexture),this.gtaoSetting=e}createResource(){let[e,r]=E.presentationSize;this.gtaoTexture=new pe(e,r,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.gtaoTexture.name="gtaoTex";let i=new Me;i.loadOp="load",this.rtFrame=new Je([this.gtaoTexture],[i])}randomDirection(){this.randomCount=0;let e=Math.PI*2*this.randomCount/16,r=Math.PI*2/8;for(let i=0;i<8;i++){let a=e+i*r;this.directionsArray[i*2]=Math.sin(a),this.directionsArray[i*2+1]=Math.cos(a)}return this.directionsArray}render(e,r){if(!this.gtaoCompute){this.createResource(),this.createCompute(),this.onResize(),this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GTAO";let u=re.getCameraGroup(e.camera);this.gtaoCompute.setUniformBuffer("globalUniform",u.uniformGPUBuffer)}let i=m.setting.render.postProcessing.gtao;this.directionsBuffer.setFloat32Array("array",this.randomDirection()),this.directionsBuffer.apply();let a=1-.2*(me.frame%2),o=i.maxDistance*a,l=i.maxPixel*a;this.gtaoSetting.setFloat("maxDistance",o),this.gtaoSetting.setFloat("maxPixel",l),this.gtaoSetting.setFloat("darkFactor",i.darkFactor),this.gtaoSetting.setFloat("rayMarchSegment",i.rayMarchSegment);let h=e.camera;this.gtaoSetting.setFloat("cameraNear",h.near),this.gtaoSetting.setFloat("cameraFar",h.far),this.gtaoSetting.setFloat("multiBounce",i.multiBounce?1:0),this.gtaoSetting.setFloat("blendColor",i.blendColor?1:0),this.gtaoSetting.apply(),S.computeCommand(r,[this.gtaoCompute]),S.lastRenderPassState=this.rendererPassState}onResize(){let[e,r]=E.presentationSize;this.gtaoTexture.resize(e,r),this.gtaoCompute.workerSizeX=Math.ceil(this.gtaoTexture.width/8),this.gtaoCompute.workerSizeY=Math.ceil(this.gtaoTexture.height/8),this.gtaoCompute.workerSizeZ=1}}class C0 extends null{constructor(){super();s(this,"fogSetting");s(this,"fogOpTexture");s(this,"fogCompute");s(this,"fogUniform");s(this,"rtFrame");s(this,"_lastSkyTexture");this.fogSetting=m.setting.render.postProcessing.globalFog}createCompute(e){H.register("GlobalFog_shader",fl),this.fogCompute=new ce(fl),this.fogUniform=new Ct(4*5),this.fogCompute.setUniformBuffer("fogUniform",this.fogUniform);let r=fe.getGBufferFrame(fe.colorPass_GBuffer);this.fogCompute.setSamplerTexture("gBufferTexture",r.getCompressGBufferTexture()),this.fogCompute.setSamplerTexture("inTex",r.getColorTexture()),this._lastSkyTexture=this.getSkyTexture(),this.fogCompute.setSamplerTexture("prefilterMap",this._lastSkyTexture),this.fogCompute.setStorageTexture("outTex",this.fogOpTexture),this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="FOG";let i=re.getLightEntries(e.scene);this.fogCompute.setStorageBuffer("lightBuffer",i.storageGPUBuffer)}uploadSetting(){let e=this.fogUniform,r=this.fogSetting;e.setColor("fogColor",r.fogColor),e.setFloat("fogType",r.fogType),e.setFloat("fogHeightScale",r.fogHeightScale),e.setFloat("start",r.start),e.setFloat("end",r.end),e.setFloat("density",r.density),e.setFloat("ins",r.ins),e.setFloat("falloff",r.falloff),e.setFloat("rayLength",r.rayLength),e.setFloat("scatteringExponent",r.scatteringExponent),e.setFloat("dirHeightLine",r.dirHeightLine),e.setFloat("skyFactor",r.skyFactor),e.setFloat("skyRoughness",r.skyRoughness),e.setFloat("overrideSkyFactor",r.overrideSkyFactor),e.setFloat("isSkyHDR",0),e.apply(),this.fogCompute.setUniformBuffer("fogUniform",this.fogUniform)}createResource(){let[e,r]=E.presentationSize;this.fogOpTexture=new pe(e,r,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.fogOpTexture.name="fogTex";let i=new Me;i.loadOp="load",this.rtFrame=new Je([this.fogOpTexture],[i])}onAttach(e){m.setting.render.postProcessing.globalFog.enable=!0}onDetach(e){m.setting.render.postProcessing.globalFog.enable=!1}set fogType(e){this.fogSetting.fogType=e}get fogType(){return this.fogSetting.fogType}set fogHeightScale(e){this.fogSetting.fogHeightScale=e}get fogHeightScale(){return this.fogSetting.fogHeightScale}set start(e){this.fogSetting.start=e}get start(){return this.fogSetting.start}set end(e){this.fogSetting.end=e}get end(){return this.fogSetting.end}set ins(e){this.fogSetting.ins=e}get ins(){return this.fogSetting.ins}set density(e){this.fogSetting.density=e}get density(){return this.fogSetting.density}set skyRoughness(e){this.fogSetting.skyRoughness=e}get skyRoughness(){return this.fogSetting.skyRoughness}set skyFactor(e){this.fogSetting.skyFactor=e}get skyFactor(){return this.fogSetting.skyFactor}set overrideSkyFactor(e){this.fogSetting.overrideSkyFactor=e}get overrideSkyFactor(){return this.fogSetting.overrideSkyFactor}get fogColor(){return this.fogSetting.fogColor}set fogColor(e){this.fogSetting.fogColor.copyFrom(e)}set falloff(e){this.fogSetting.falloff=e}get falloff(){return this.fogSetting.falloff}set rayLength(e){this.fogSetting.rayLength=e}get rayLength(){return this.fogSetting.rayLength}set scatteringExponent(e){this.fogSetting.scatteringExponent=e}get scatteringExponent(){return this.fogSetting.scatteringExponent}set dirHeightLine(e){this.fogSetting.dirHeightLine=e}get dirHeightLine(){return this.fogSetting.dirHeightLine}getSkyTexture(){let e=m.res.defaultSky;return X.instance.sky instanceof Oo&&(e=X.instance.sky.map),e}render(e,r){if(!this.fogCompute){this.createResource(),this.createCompute(e),this.onResize();let a=re.getCameraGroup(e.camera);this.fogCompute.setUniformBuffer("globalUniform",a.uniformGPUBuffer)}let i=this.getSkyTexture();i!=this._lastSkyTexture&&(this._lastSkyTexture=i,this.fogCompute.setSamplerTexture("prefilterMap",this._lastSkyTexture)),this.fogCompute.setUniformFloat("isSkyHDR",i.isHDRTexture?1:0),this.uploadSetting(),S.computeCommand(r,[this.fogCompute]),S.lastRenderPassState=this.rendererPassState}onResize(){let[e,r]=E.presentationSize;this.fogOpTexture.resize(e,r),this.fogCompute.workerSizeX=Math.ceil(this.fogOpTexture.width/8),this.fogCompute.workerSizeY=Math.ceil(this.fogOpTexture.height/8),this.fogCompute.workerSizeZ=1}}class _0 extends null{constructor(){super();s(this,"godRayTexture");s(this,"godRayCompute");s(this,"historyGodRayData");s(this,"godRaySetting");s(this,"rtFrame");s(this,"Render")}onAttach(e){m.setting.render.postProcessing.godRay.enable=!0,this.createGUI()}onDetach(e){m.setting.render.postProcessing.godRay.enable=!1,this.removeGUI()}get blendColor(){return m.setting.render.postProcessing.godRay.blendColor}set blendColor(e){m.setting.render.postProcessing.godRay.blendColor=e}get rayMarchCount(){return m.setting.render.postProcessing.godRay.rayMarchCount}set rayMarchCount(e){e=se(e,8,20),m.setting.render.postProcessing.godRay.rayMarchCount=e}get scatteringExponent(){return m.setting.render.postProcessing.godRay.scatteringExponent}set scatteringExponent(e){e=se(e,1,40),m.setting.render.postProcessing.godRay.scatteringExponent=e}get intensity(){return m.setting.render.postProcessing.godRay.intensity}set intensity(e){e=se(e,.01,5),m.setting.render.postProcessing.godRay.intensity=e}createGUI(){}removeGUI(){}createCompute(e){this.godRayCompute=new ce(Ad);let r=new Ct(4*3);this.godRayCompute.setUniformBuffer("godRayUniform",r),this.historyGodRayData=new be(4*this.godRayTexture.width*this.godRayTexture.height),this.godRayCompute.setStorageBuffer("historyGodRayData",this.historyGodRayData);let i=fe.getGBufferFrame(fe.colorPass_GBuffer);this.godRayCompute.setSamplerTexture("gBufferTexture",i.getCompressGBufferTexture()),this.godRayCompute.setSamplerTexture("inTex",this.getLastRenderTexture()),this.godRayCompute.setStorageTexture("outTex",this.godRayTexture);let a=m.getRenderJob(e).shadowMapPassRenderer;this.godRayCompute.setSamplerTexture("shadowMap",a.depth2DArrayTexture),this.godRaySetting=r,this.onResize()}createResource(){let e=E.presentationSize,[r,i]=e;this.godRayTexture=new pe(r,i,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.godRayTexture.name="godRayTexture";let a=new Me;a.loadOp="load",this.rtFrame=new Je([this.godRayTexture],[a])}onResize(){let e=E.presentationSize,[r,i]=e;this.godRayTexture.resize(r,i),this.historyGodRayData.resizeBuffer(4*this.godRayTexture.width*this.godRayTexture.height),this.godRayCompute.setStorageBuffer("historyGodRayData",this.historyGodRayData),this.godRayCompute.workerSizeX=Math.ceil(this.godRayTexture.width/8),this.godRayCompute.workerSizeY=Math.ceil(this.godRayTexture.height/8),this.godRayCompute.workerSizeZ=1}render(e,r){if(!this.godRayCompute){this.createResource(),this.createCompute(e);let h=re.getLightEntries(e.scene);this.godRayCompute.setStorageBuffer("lightBuffer",h.storageGPUBuffer),this.godRayCompute.setStorageBuffer("models",re.modelMatrixBindGroup.matrixBufferDst),this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="GodRay";let u=re.getCameraGroup(e.camera);this.godRayCompute.setUniformBuffer("globalUniform",u.uniformGPUBuffer)}let i=m.setting.render.postProcessing.godRay;this.godRaySetting.setFloat("intensity",i.intensity),this.godRaySetting.setFloat("rayMarchCount",i.rayMarchCount);let a=E.presentationSize,[o,l]=a;this.godRaySetting.setFloat("viewPortWidth",o),this.godRaySetting.setFloat("viewPortHeight",l),this.godRaySetting.setFloat("blendColor",i.blendColor?1:0),this.godRaySetting.setFloat("scatteringExponent",i.scatteringExponent),this.godRaySetting.apply(),S.computeCommand(r,[this.godRayCompute]),S.lastRenderPassState=this.rendererPassState}}class mp{constructor(){s(this,"indexList");s(this,"color");s(this,"count")}}class Ap{constructor(){s(this,"SlotCount",8);s(this,"MaxEntities",16);s(this,"defaultColor",new K(.2,1,1,1));s(this,"slots",[]);s(this,"dataDirty",!0);let t=m.setting.render.postProcessing.outline.groupCount;this.SlotCount=Math.max(1,Math.min(t,this.SlotCount));for(let e=0;e<this.SlotCount;e++){let r=this.slots[e]=new mp;r.indexList=new Float32Array(this.MaxEntities),r.color=this.defaultColor.clone(),r.count=0}}clear(){for(let t=0;t<this.SlotCount;t++)this.clearAt(t)}clearAt(t){this.dataDirty=!0;let e=this.slots[t];return e.color.copyFrom(this.defaultColor),e.indexList.fill(-1),e.count=0,this}fillDataAt(t,e,r){this.dataDirty=!0;let i=this.slots[t];if(i){i.indexList.fill(-1);for(let a=0,o=e.length;a<o;a++)i.indexList[a]=e[a];i.count=e.length,i.color.copyFrom(r)}return this}fetchData(t){return t.dirty=this.dataDirty,t.slots=this.slots,this.dataDirty=!1,this}}let wr=new Ap;class y0 extends null{constructor(){super();s(this,"outlineTex");s(this,"lowTex");s(this,"calcWeightCompute");s(this,"outlineCompute");s(this,"blendCompute");s(this,"outlineSetting");s(this,"slotsBuffer");s(this,"slotsArray");s(this,"entitiesArray");s(this,"entitiesBuffer");s(this,"weightBuffer");s(this,"lowTexSize");s(this,"oldOutlineColor");s(this,"rtFrame");s(this,"view");s(this,"fetchData");s(this,"computeList")}onAttach(e){this.view=e,m.setting.render.postProcessing.outline.enable=!0}onDetach(e){m.setting.render.postProcessing.outline.enable=!1}set outlinePixel(e){e=se(e,0,8);let r=m.setting.render.postProcessing.outline;r.outlinePixel!=e&&(r.outlinePixel=e)}get outlinePixel(){return m.setting.render.postProcessing.outline.outlinePixel}set fadeOutlinePixel(e){let r=m.setting.render.postProcessing.outline;e=se(e,0,8),r.fadeOutlinePixel!=e&&(r.fadeOutlinePixel=e)}get fadeOutlinePixel(){return m.setting.render.postProcessing.outline.fadeOutlinePixel}set strength(e){e=se(e,0,1);let r=m.setting.render.postProcessing.outline;r.strength!=e&&(r.strength=e)}get strength(){return m.setting.render.postProcessing.outline.strength}set useAddMode(e){m.setting.render.postProcessing.outline.useAddMode=e}get useAddMode(){return m.setting.render.postProcessing.outline.useAddMode}createGUI(){}createCompute(){let e=fe.getGBufferFrame(fe.colorPass_GBuffer);this.calcWeightCompute=new ce(Cd);let r=re.getCameraGroup(this.view.camera);this.calcWeightCompute.setUniformBuffer("globalUniform",r.uniformGPUBuffer),this.calcWeightCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.calcWeightCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.calcWeightCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.calcWeightCompute.setStorageBuffer("entitiesBuffer",this.entitiesBuffer),this.calcWeightCompute.setSamplerTexture("gBufferTexture",e.getCompressGBufferTexture()),this.calcWeightCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.calcWeightCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.calcWeightCompute.workerSizeZ=1,this.outlineCompute=new ce(_d),this.outlineCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.outlineCompute.setStorageBuffer("slotsBuffer",this.slotsBuffer),this.outlineCompute.setStorageBuffer("weightBuffer",this.weightBuffer),this.outlineCompute.setStorageBuffer("oldOutlineColor",this.oldOutlineColor),this.outlineCompute.setStorageTexture("lowTex",this.lowTex),this.outlineCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.outlineCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.outlineCompute.workerSizeZ=1,this.blendCompute=new ce(xd),this.blendCompute.setStorageBuffer("outlineSetting",this.outlineSetting),this.blendCompute.setSamplerTexture("inTex",this.getLastRenderTexture()),this.blendCompute.setSamplerTexture("lowTex",this.lowTex),this.blendCompute.setStorageTexture("outlineTex",this.outlineTex),this.blendCompute.workerSizeX=Math.ceil(this.outlineTex.width/8),this.blendCompute.workerSizeY=Math.ceil(this.outlineTex.height/8),this.blendCompute.workerSizeZ=1}createResource(){let e=E.presentationSize,r=e[0],i=e[1],a=m.setting.render.postProcessing.outline.textureScale;this.lowTexSize=new he(Math.ceil(r*a),Math.ceil(i*a)),this.lowTex=new pe(this.lowTexSize.x,this.lowTexSize.y,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.lowTex.name="lowTex";let o=new Me;o.clearValue=[0,0,0,1],o.loadOp="clear",this.outlineTex=new pe(r,i,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outlineTex.name="outlineTex";let l=new Me;l.clearValue=[0,0,0,1],l.loadOp="clear",this.rtFrame=new Je([this.outlineTex],[l]),this.outlineSetting=new Ct(8),this.weightBuffer=new be(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.oldOutlineColor=new be(this.lowTexSize.x*this.lowTexSize.y*4,GPUBufferUsage.COPY_SRC),this.slotsArray=new Float32Array(wr.SlotCount*4),this.slotsBuffer=new be(this.slotsArray.length),this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesArray=new Float32Array(wr.SlotCount*wr.MaxEntities),this.entitiesBuffer=new be(this.entitiesArray.length),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.slotsBuffer.apply(),this.fetchData||(this.fetchData={})}fetchOutlineData(){if(wr.fetchData(this.fetchData),this.fetchData.dirty){let e=wr.SlotCount,r=wr.MaxEntities;for(let i=0;i<e;i++){let a=4*i,o=this.fetchData.slots[i];this.slotsArray[a+0]=o.color.r,this.slotsArray[a+1]=o.color.g,this.slotsArray[a+2]=o.color.b,this.slotsArray[a+3]=o.count,a=r*i,this.entitiesArray.set(o.indexList,a)}this.slotsBuffer.setFloat32Array("slotsArray",this.slotsArray),this.slotsBuffer.apply(),this.entitiesBuffer.setFloat32Array("entitiesArray",this.entitiesArray),this.entitiesBuffer.apply()}}render(e,r){this.calcWeightCompute||(this.createResource(),this.createCompute(),this.createGUI(),this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null)),this.computeList||(this.computeList=[this.calcWeightCompute,this.outlineCompute,this.blendCompute]);let i=m.setting.render.postProcessing.outline;this.outlineSetting.setFloat("strength",i.strength),this.outlineSetting.setFloat("useAddMode",i.useAddMode?1:0),this.outlineSetting.setFloat("outlinePixel",i.outlinePixel),this.outlineSetting.setFloat("fadeOutlinePixel",i.fadeOutlinePixel),this.outlineSetting.setFloat("lowTexWidth",this.lowTexSize.x),this.outlineSetting.setFloat("lowTexHeight",this.lowTexSize.y),this.outlineSetting.apply(),this.fetchOutlineData(),S.computeCommand(r,this.computeList),S.lastRenderPassState=this.rendererPassState}onResize(){let e=E.presentationSize,r=e[0],i=e[1],a=m.setting.render.postProcessing.outline.textureScale;this.lowTexSize=new he(Math.ceil(r*a),Math.ceil(i*a)),this.lowTex.resize(this.lowTexSize.x,this.lowTexSize.y),this.outlineTex.resize(r,i),this.weightBuffer.resizeBuffer(this.lowTexSize.x*this.lowTexSize.y*4),this.oldOutlineColor.resizeBuffer(this.lowTexSize.x*this.lowTexSize.y*4),this.calcWeightCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.calcWeightCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.calcWeightCompute.workerSizeZ=1,this.outlineCompute.workerSizeX=Math.ceil(this.lowTex.width/8),this.outlineCompute.workerSizeY=Math.ceil(this.lowTex.height/8),this.outlineCompute.workerSizeZ=1,this.blendCompute.workerSizeX=Math.ceil(this.outlineTex.width/8),this.blendCompute.workerSizeY=Math.ceil(this.outlineTex.height/8),this.blendCompute.workerSizeZ=1}}class S0 extends null{constructor(){super();s(this,"outTexture");s(this,"newTexture");s(this,"oldTexture");s(this,"combineTexture");s(this,"ssgiCompute");s(this,"delayCompute");s(this,"combineCompute");s(this,"rtFrame");s(this,"textureScaleSmallCompute");s(this,"textureScaleBigCompute");s(this,"view");s(this,"colorTexture");s(this,"posTexture");s(this,"normalTexture");s(this,"gBufferTexture");s(this,"lastPosTexture");s(this,"downSampleCofe",1);s(this,"debugChanal","0");s(this,"updateBuffer");s(this,"Render");s(this,"frame",0);this.updateBuffer=new be(8*4),this.updateBuffer.setFloat("frameCount",10),this.updateBuffer.setFloat("indirectIns",1.5),this.updateBuffer.setFloat("delay",.02),this.updateBuffer.setFloat("colorIns",1),this.updateBuffer.setFloat("d1",.03),this.updateBuffer.apply()}onAttach(e){this.view=e,e.camera.transform.onPositionChange=e.camera.transform.onPositionChange?qs(e.camera.transform.onPositionChange,(r,i)=>this.onCameraChange(r,i)):(r,i)=>this.onCameraChange(r,i)}onCameraChange(e,r){console.log("a");let i=g.distance(e,r);i=Math.min(.45,i)+.01,this.updateBuffer.setFloat("delay",i)}onDetach(e){}set ins(e){this.updateBuffer.setFloat("indirectIns",e),this.updateBuffer.apply()}get ins(){return this.updateBuffer.getFloat("indirectIns")}set delay(e){this.updateBuffer.setFloat("delay",e),this.updateBuffer.apply()}get delay(){return this.updateBuffer.getFloat("delay")}set colorIns(e){this.updateBuffer.setFloat("colorIns",e),this.updateBuffer.apply()}get colorIns(){return this.updateBuffer.getFloat("colorIns")}set frameCount(e){this.updateBuffer.setFloat("frameCount",e),this.updateBuffer.apply()}get frameCount(){return this.updateBuffer.getFloat("frameCount")}set d1(e){this.updateBuffer.setFloat("d1",e),this.updateBuffer.apply()}get d1(){return this.updateBuffer.getFloat("d1")}createResource(){let e=fe.getGBufferFrame("ColorPassGBuffer");this.gBufferTexture=e.getCompressGBufferTexture();let r=E.presentationSize,i=r[0],a=r[1];this.lastPosTexture=new pe(i,a,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.lastPosTexture.name="lastPosTexture",this.outTexture=new pe(i,a,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outTexture.name="outTexture";let o=Math.floor(i*this.downSampleCofe),l=Math.floor(a*this.downSampleCofe);this.newTexture=new pe(o,l,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.newTexture.name="newTexture",this.oldTexture=new pe(o,l,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.oldTexture.name="oldTexture",this.combineTexture=new pe(o,l,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.combineTexture.name="combineTexture";let h=new Me;h.loadOp="load",this.rtFrame=new Je([this.outTexture],[h])}createCompute(){this.ssgiCompute=new ce(Id),this.delayCompute=new ce(Pd),this.combineCompute=new ce(Md);let e=re.getCameraGroup(this.view.camera);this.ssgiCompute.setSamplerTexture("gBufferTexture",this.gBufferTexture),this.ssgiCompute.setSamplerTexture("combineTexture",this.combineTexture),this.ssgiCompute.setSamplerTexture("oldTexture",this.oldTexture),this.ssgiCompute.setStorageTexture("newTexture",this.newTexture),this.ssgiCompute.setUniformBuffer("globalUniform",e.uniformGPUBuffer),this.ssgiCompute.setStorageBuffer("updateBuffer",this.updateBuffer),this.ssgiCompute.setSamplerTexture("inTex",this.getLastRenderTexture()),this.delayCompute.setSamplerTexture("newTexture",this.newTexture),this.delayCompute.setSamplerTexture("oldTexture",this.oldTexture),this.delayCompute.setStorageTexture("combineTexture",this.combineTexture),this.delayCompute.setStorageBuffer("updateBuffer",this.updateBuffer),this.combineCompute.setSamplerTexture("inputBTexture",this.combineTexture),this.combineCompute.setSamplerTexture("gBufferTexture",this.gBufferTexture),this.combineCompute.setUniformBuffer("globalUniform",e.uniformGPUBuffer),this.combineCompute.setStorageTexture("outTexture",this.outTexture),this.combineCompute.setStorageBuffer("updateBuffer",this.updateBuffer),this.textureScaleBigCompute=new up,this.textureScaleBigCompute.setInputes(null,[this.combineTexture],[this.outTexture])}render(e,r){}compute(e){this.ssgiCompute||(this.createResource(),this.createCompute(),this.onResize(),this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null),this.rendererPassState.label="SSGI"),this.frameCount=this.frame,this.frame++;let r=S.beginCommandEncoder();switch(parseInt(this.debugChanal)){case 0:S.copyTexture(r,this.combineTexture,this.oldTexture),S.computeCommand(r,[this.ssgiCompute,this.delayCompute,this.combineCompute]);break;case 1:S.copyTexture(r,this.posTexture,this.lastPosTexture),S.copyTexture(r,this.lastPosTexture,this.outTexture);break;case 2:S.copyTexture(r,this.normalTexture,this.outTexture);break;case 3:S.copyTexture(r,this.posTexture,this.outTexture);break;case 4:S.copyTexture(r,this.colorTexture,this.outTexture);break;case 5:S.copyTexture(r,this.gBufferTexture,this.outTexture);break}S.lastRenderPassState=this.rendererPassState,this.updateBuffer.setFloat("delay",.01)}onResize(){let e=E.presentationSize,r=e[0],i=e[1];this.outTexture.resize(r,i),this.ssgiCompute.workerSizeX=Math.ceil(this.newTexture.width/16),this.ssgiCompute.workerSizeY=Math.ceil(this.newTexture.height/16),this.ssgiCompute.workerSizeZ=1,this.delayCompute.workerSizeX=Math.ceil(this.combineTexture.width/16),this.delayCompute.workerSizeY=Math.ceil(this.combineTexture.height/16),this.delayCompute.workerSizeZ=1,this.combineCompute.workerSizeX=Math.ceil(this.outTexture.width/16),this.combineCompute.workerSizeY=Math.ceil(this.outTexture.height/16),this.combineCompute.workerSizeZ=1}}class I0 extends null{constructor(){super(...arguments);s(this,"SSR_RayTraceCompute");s(this,"SSR_IS_Compute");s(this,"SSR_Blend_Compute");s(this,"isRetTexture");s(this,"finalTexture");s(this,"ssrUniformBuffer");s(this,"rayTraceData");s(this,"ssrColorData");s(this,"rtFrame");s(this,"historyPosition");s(this,"view");s(this,"reflectionRatio",.5)}onAttach(e){this.view=e,m.setting.render.postProcessing.ssr.enable=!0}onDetach(e){m.setting.render.postProcessing.ssr.enable=!1}get fadeEdgeRatio(){return m.setting.render.postProcessing.ssr.fadeEdgeRatio}set fadeEdgeRatio(e){e=se(e,0,1);let r=m.setting.render.postProcessing.ssr;r.fadeEdgeRatio=e}get rayMarchRatio(){return m.setting.render.postProcessing.ssr.rayMarchRatio}set rayMarchRatio(e){e=se(e,0,1);let r=m.setting.render.postProcessing.ssr;r.rayMarchRatio=e}get roughnessThreshold(){return m.setting.render.postProcessing.ssr.roughnessThreshold}set roughnessThreshold(e){e=se(e,0,1);let r=m.setting.render.postProcessing.ssr;r.roughnessThreshold=e}get fadeDistanceMin(){return m.setting.render.postProcessing.ssr.fadeDistanceMin}set fadeDistanceMin(e){e=se(e,0,1e4);let r=m.setting.render.postProcessing.ssr;r.fadeDistanceMin=e}get fadeDistanceMax(){return m.setting.render.postProcessing.ssr.fadeDistanceMax}set fadeDistanceMax(e){e=se(e,0,1e4);let r=m.setting.render.postProcessing.ssr;r.fadeDistanceMax=e}get powDotRN(){return m.setting.render.postProcessing.ssr.powDotRN}set powDotRN(e){e=se(e,0,1);let r=m.setting.render.postProcessing.ssr;r.powDotRN=e}createRayTraceShader(){let e=re.getCameraGroup(this.view.camera);this.SSR_RayTraceCompute=new ce(Td),this.SSR_RayTraceCompute.setUniformBuffer("globalUniform",e.uniformGPUBuffer),this.SSR_RayTraceCompute.setUniformBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_RayTraceCompute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_RayTraceCompute.setStorageBuffer("historyPosition",this.historyPosition);let r=fe.getGBufferFrame("ColorPassGBuffer").getCompressGBufferTexture();this.SSR_RayTraceCompute.setSamplerTexture("gBufferTexture",r),X.instance.sky instanceof Oo&&this.SSR_RayTraceCompute.setSamplerTexture("prefilterMap",X.instance.sky.map),this.SSR_RayTraceCompute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_RayTraceCompute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_RayTraceCompute.workerSizeZ=1}createISShader(){this.SSR_IS_Compute=new ce(wd),this.SSR_IS_Compute.setStorageBuffer("ssrUniform",this.ssrUniformBuffer),this.SSR_IS_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_IS_Compute.setStorageBuffer("ssrColorData",this.ssrColorData),this.SSR_IS_Compute.setStorageBuffer("historyPosition",this.historyPosition),this.SSR_IS_Compute.setSamplerTexture("colorMap",this.getLastRenderTexture()),this.SSR_IS_Compute.setStorageTexture("outTex",this.isRetTexture),this.SSR_IS_Compute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_IS_Compute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_IS_Compute.workerSizeZ=1}createBlendShader(e){let r=re.getCameraGroup(this.view.camera);this.SSR_Blend_Compute=new ce(bd),this.SSR_Blend_Compute.setStorageBuffer("rayTraceBuffer",this.rayTraceData),this.SSR_Blend_Compute.setUniformBuffer("globalUniform",r.uniformGPUBuffer);let i=fe.getGBufferFrame("ColorPassGBuffer").getCompressGBufferTexture();this.SSR_Blend_Compute.setSamplerTexture("gBufferTexture",i),this.SSR_Blend_Compute.setSamplerTexture("colorMap",this.getLastRenderTexture()),this.SSR_Blend_Compute.setSamplerTexture("ssrMap",e),this.SSR_Blend_Compute.setStorageTexture("outTex",this.finalTexture),this.SSR_Blend_Compute.workerSizeX=Math.ceil(this.finalTexture.width/8),this.SSR_Blend_Compute.workerSizeY=Math.ceil(this.finalTexture.height/8),this.SSR_Blend_Compute.workerSizeZ=1}createResource(){let[e,r]=E.presentationSize;this.finalTexture=new pe(e,r,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.finalTexture.name="ssrOutTex";let i=new Me;i.clearValue=[0,0,0,0],i.loadOp="clear";let a=Math.ceil(e*m.setting.render.postProcessing.ssr.pixelRatio),o=Math.ceil(r*m.setting.render.postProcessing.ssr.pixelRatio);this.isRetTexture=new pe(a,o,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.TEXTURE_BINDING),this.isRetTexture.name="ssrTextureIn";let l=new Me;l.clearValue=[0,0,0,0],l.loadOp="clear",this.rtFrame=new Je([this.finalTexture,this.isRetTexture],[i,l]),this.rayTraceData=new be(a*o*8,GPUBufferUsage.COPY_SRC),this.ssrColorData=new be(a*o*4,GPUBufferUsage.COPY_SRC),this.historyPosition=new be(a*o*4,GPUBufferUsage.COPY_SRC),this.ssrUniformBuffer=new Ct(4*8),this.ssrUniformBuffer.setFloat("ssrBufferSizeX",this.isRetTexture.width),this.ssrUniformBuffer.setFloat("ssrBufferSizeY",this.isRetTexture.height),this.ssrUniformBuffer.setFloat("colorMapSizeX",this.finalTexture.width),this.ssrUniformBuffer.setFloat("colorMapSizeY",this.finalTexture.height),this.ssrUniformBuffer.apply()}render(e,r){if(!this.SSR_RayTraceCompute){this.createResource(),this.createISShader(),this.createRayTraceShader(),this.createBlendShader(this.isRetTexture),this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null);let o=re.getCameraGroup(e.camera);this.SSR_RayTraceCompute.setUniformBuffer("standUniform",o.uniformGPUBuffer)}let i=m.setting.render.postProcessing.ssr;this.ssrUniformBuffer.setFloat("fadeEdgeRatio",i.fadeEdgeRatio),this.ssrUniformBuffer.setFloat("rayMarchRatio",i.rayMarchRatio),this.ssrUniformBuffer.setFloat("fadeDistanceMin",i.fadeDistanceMin),this.ssrUniformBuffer.setFloat("fadeDistanceMax",i.fadeDistanceMax),this.ssrUniformBuffer.setFloat("mixThreshold",i.mixThreshold),this.ssrUniformBuffer.setFloat("roughnessThreshold",i.roughnessThreshold),this.ssrUniformBuffer.setFloat("reflectionRatio",this.reflectionRatio),this.ssrUniformBuffer.setFloat("powDotRN",i.powDotRN),this.ssrUniformBuffer.setFloat("randomSeedX",Math.random()),this.ssrUniformBuffer.setFloat("randomSeedY",Math.random()),this.ssrUniformBuffer.apply();let a=[this.SSR_RayTraceCompute,this.SSR_IS_Compute,this.SSR_Blend_Compute];S.computeCommand(r,a),S.lastRenderPassState=this.rendererPassState}onResize(){let[e,r]=E.presentationSize,i=Math.ceil(e*m.setting.render.postProcessing.ssr.pixelRatio),a=Math.ceil(r*m.setting.render.postProcessing.ssr.pixelRatio);this.finalTexture.resize(e,r),this.isRetTexture.resize(i,a),this.rayTraceData.resizeBuffer(i*a*8),this.ssrColorData.resizeBuffer(i*a*4),this.historyPosition.resizeBuffer(i*a*4),this.ssrUniformBuffer.setFloat("ssrBufferSizeX",this.isRetTexture.width),this.ssrUniformBuffer.setFloat("ssrBufferSizeY",this.isRetTexture.height),this.ssrUniformBuffer.setFloat("colorMapSizeX",this.finalTexture.width),this.ssrUniformBuffer.setFloat("colorMapSizeY",this.finalTexture.height),this.SSR_RayTraceCompute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_RayTraceCompute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_RayTraceCompute.workerSizeZ=1,this.SSR_IS_Compute.workerSizeX=Math.ceil(this.isRetTexture.width/8),this.SSR_IS_Compute.workerSizeY=Math.ceil(this.isRetTexture.height/8),this.SSR_IS_Compute.workerSizeZ=1,this.SSR_Blend_Compute.workerSizeX=Math.ceil(this.finalTexture.width/8),this.SSR_Blend_Compute.workerSizeY=Math.ceil(this.finalTexture.height/8),this.SSR_Blend_Compute.workerSizeZ=1}}class b0{static createSeeds(){let t=20,e=32,r=[new g(0,0,t)],i=0,a=.02;for(let o=1;o<e;o++){let l=new g;r.push(l),i+=1-(1-.618)*o/e,a+=o*.01,l.x=Math.sin(i)*a,l.y=Math.cos(i)*a,l.z=1-o/e,l.multiplyScalar(t)}return r}}class w0 extends null{constructor(){super();s(this,"taaTexture");s(this,"outTexture");s(this,"taaCompute");s(this,"copyTexCompute");s(this,"sharpCompute");s(this,"taaSetting");s(this,"preColorBuffer");s(this,"preColorTex");s(this,"preProjMatrix");s(this,"preViewMatrix");s(this,"rtFrame")}onAttach(e){m.setting.render.postProcessing.taa.enable=!0,e.camera.enableJitterProjection(!0),this.createGUI()}onDetach(e){m.setting.render.postProcessing.taa.enable=!1,e.camera.enableJitterProjection(!1)}get jitterSeedCount(){return m.setting.render.postProcessing.taa.jitterSeedCount}set jitterSeedCount(e){e=se(e,2,32),e=Math.round(e);let r=m.setting.render.postProcessing.taa;r.jitterSeedCount=e}get blendFactor(){return m.setting.render.postProcessing.taa.blendFactor}set blendFactor(e){e=se(e,0,1);let r=m.setting.render.postProcessing.taa;r.blendFactor=e}get sharpFactor(){return m.setting.render.postProcessing.taa.sharpFactor}set sharpFactor(e){e=se(e,.1,.99);let r=m.setting.render.postProcessing.taa;r.sharpFactor=e}get sharpPreBlurFactor(){return m.setting.render.postProcessing.taa.sharpPreBlurFactor}set sharpPreBlurFactor(e){e=se(e,.1,.99);let r=m.setting.render.postProcessing.taa;r.sharpPreBlurFactor=e}get temporalJitterScale(){return m.setting.render.postProcessing.taa.temporalJitterScale}set temporalJitterScale(e){e=se(e,0,1);let r=m.setting.render.postProcessing.taa;r.temporalJitterScale=e}createGUI(){}createCompute(e){let r=new ce(Dd),i=new Ct(16*2+4*3),a=re.getCameraGroup(e.camera);r.setUniformBuffer("globalUniform",a.uniformGPUBuffer),r.setUniformBuffer("taaData",i),r.setStorageBuffer("preColorBuffer",this.preColorBuffer);let o=fe.getGBufferFrame(fe.colorPass_GBuffer);r.setSamplerTexture("preColorTex",this.preColorTex),r.setSamplerTexture("gBufferTexture",o.getCompressGBufferTexture()),r.setSamplerTexture("inTex",this.getLastRenderTexture()),r.setStorageTexture("outTex",this.taaTexture),r.workerSizeX=Math.ceil(this.taaTexture.width/8),r.workerSizeY=Math.ceil(this.taaTexture.height/8),r.workerSizeZ=1,this.taaCompute=r,this.taaSetting=i,this.copyTexCompute=new ce(Ed),this.copyTexCompute.setStorageBuffer("preColor",this.preColorBuffer),this.copyTexCompute.setStorageTexture("preColorTex",this.preColorTex),this.copyTexCompute.workerSizeX=Math.ceil(this.taaTexture.width/8),this.copyTexCompute.workerSizeY=Math.ceil(this.taaTexture.height/8),this.copyTexCompute.workerSizeZ=1,this.sharpCompute=new ce(Bd),this.sharpCompute.setUniformBuffer("taaData",i),this.sharpCompute.setSamplerTexture("inTex",this.taaTexture),this.sharpCompute.setStorageTexture("outTex",this.outTexture),this.sharpCompute.workerSizeX=Math.ceil(this.outTexture.width/8),this.sharpCompute.workerSizeY=Math.ceil(this.outTexture.height/8),this.sharpCompute.workerSizeZ=1}createResource(){this.preProjMatrix=new Q().identity(),this.preViewMatrix=new Q().identity();let[e,r]=E.presentationSize;this.preColorBuffer=new be(e*r*4,GPUBufferUsage.COPY_SRC),this.preColorTex=new pe(e,r,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.preColorTex.name="taaTex";let i=new Me;i.clearValue=[0,0,0,1],i.loadOp="clear",this.taaTexture=new pe(e,r,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.taaTexture.name="taaTex";let a=new Me;a.clearValue=[0,0,0,1],a.loadOp="clear",this.outTexture=new pe(e,r,j.rgba16float,!1,GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC|GPUTextureUsage.TEXTURE_BINDING),this.outTexture.name="sharpTaaTex";let o=new Me;o.clearValue=[0,0,0,1],o.loadOp="clear",this.rtFrame=new Je([this.preColorTex,this.taaTexture,this.outTexture],[i,a,o])}render(e,r){this.taaCompute||(this.createResource(),this.createCompute(e),this.rendererPassState=Ze.createRendererPassState(this.rtFrame,null));let i=m.setting.render.postProcessing.taa;this.taaSetting.setMatrix("preProjMatrix",this.preProjMatrix),this.taaSetting.setMatrix("preViewMatrix",this.preViewMatrix),this.taaSetting.setFloat("jitterFrameIndex",e.camera.jitterFrameIndex),this.taaSetting.setFloat("blendFactor",i.blendFactor),this.taaSetting.setFloat("sharpFactor",i.sharpFactor),this.taaSetting.setFloat("sharpPreBlurFactor",i.sharpPreBlurFactor),this.taaSetting.setFloat("jitterX",e.camera.jitterX),this.taaSetting.setFloat("jitterY",e.camera.jitterY),this.taaSetting.apply(),S.computeCommand(r,[this.copyTexCompute,this.taaCompute,this.sharpCompute]),S.lastRenderPassState=this.rendererPassState,this.preProjMatrix.copyFrom(e.camera.projectionMatrix),this.preViewMatrix.copyFrom(e.camera.viewMatrix)}onResize(){let[e,r]=E.presentationSize;this.preColorBuffer.resizeBuffer(e*r*4),this.taaTexture.resize(e,r),this.outTexture.resize(e,r),this.preColorTex.resize(e,r),this.taaCompute.workerSizeX=Math.ceil(this.taaTexture.width/8),this.taaCompute.workerSizeY=Math.ceil(this.taaTexture.height/8),this.taaCompute.workerSizeZ=1,this.copyTexCompute.workerSizeX=Math.ceil(this.taaTexture.width/8),this.copyTexCompute.workerSizeY=Math.ceil(this.taaTexture.height/8),this.copyTexCompute.workerSizeZ=1,this.sharpCompute.workerSizeX=Math.ceil(this.outTexture.width/8),this.sharpCompute.workerSizeY=Math.ceil(this.outTexture.height/8),this.sharpCompute.workerSizeZ=1}}class vp{constructor(){s(this,"_tempIndexArray",[]);s(this,"_rendererList",[])}setOutline(t,e){this.setOutlineList([t],e?[e]:null)}setOutlineList(t,e){t||(t=[]);let r=wr.defaultColor,i=wr.SlotCount;for(let a=0;a<i;a++){this._tempIndexArray.length=0;let o=t[a],l=(e?e[a]:null)||r;if(o)for(const h of o)this.getEntityIdList(h,this._tempIndexArray);wr.fillDataAt(a,this._tempIndexArray,l)}}clearOutline(){return wr.clear(),this}getEntityIdList(t,e){this._rendererList.length=0;let r=t.getComponents($,this._rendererList);for(const i of r)e.push(i.object3D.transform._worldMatrix.index)}}let T0=new vp;class xp{constructor(){s(this,"localPosition",new g);s(this,"worldPosition",new g);s(this,"uv",new he);s(this,"faceIndex");s(this,"isIn",!1);s(this,"t",0);s(this,"u",0);s(this,"v",0);s(this,"triangle");s(this,"v0");s(this,"v1");s(this,"v2");s(this,"pickList");s(this,"color")}}const rr=class rr{static distPtTri(t,e,r,i){let a=new g,o=new g,l=new g;i.subtract(e,a),r.subtract(e,o),t.subtract(e,l);let h=St(a,a),u=St(a,o),c=St(a,l),f=St(o,o),d=St(o,l),p=1/(h*f-u*u),A=(f*c-u*d)*p,x=(h*d-u*c)*p;if(A>=-rr.EPS&&x>=-rr.EPS&&A+x<=1+rr.EPS){let C=e[1]+a[1]*A+o[1]*x;return Math.abs(C-t[1])}return rr.FLT_MAX}static IntersectTriangle(t,e,r){let i=e.v1,a=e.v2,o=e.v3,l=a.subtract(i,g.HELP_3),h=o.subtract(i,g.HELP_4),u=t.direction.crossProduct(h,g.HELP_5),c=St(l,u),f;if(c>0){if(r)return null;f=t.origin.subtract(i,g.HELP_2)}else f=i.subtract(t.origin,g.HELP_2),c=-c;if(c<1e-4)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let d=St(f,u);if(d<0||d>c)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let p=f.crossProduct(l,g.HELP_1),A=St(t.direction,p);if(A<0||d+A>c)return this._info.isIn=!1,this._info.t=0,this._info.u=0,this._info.v=0,this._info;let x=St(h,p),C=1/c;x*=C,d*=C,A*=C,this._info.isIn=!0,this._info.t=x,this._info.u=d,this._info.v=A;let v=1-d-A;return this._u0.copyFrom(e.u1),this._u0.scale(v),this._u1.copyFrom(e.u2),this._u1.scale(d),this._u2.copyFrom(e.u3),this._u2.scale(A),this._info.uv.copyFrom(this._u0),this._info.uv.add(this._u1,this._info.uv),this._info.uv.add(this._u2,this._info.uv),this._info.localPosition.copyFrom(t.direction).multiplyScalar(x),this._info.localPosition.add(t.origin,this._info.localPosition),this._info}};s(rr,"EPS",1e-4),s(rr,"FLT_MAX",3402823466e29),s(rr,"_info",new xp),s(rr,"_u0",new he),s(rr,"_u1",new he),s(rr,"_u2",new he);let Ml=rr;const Va=class Va extends null{constructor(){super();s(this,"_maxRetry",3);if(Va._instance)throw new Error("LoadManager is singleton class...")}loadAll(e,r){return new Promise((i,a)=>{let o=e.length,l=[];e.forEach((h,u)=>{let c=new r;this.load(h,r).then(f=>{c.parse(f),l.push(c),o--,o===0&&i(l)})})})}static getInstance(){return this._instance||(this._instance=new Va)}loadUrls(e,r){return new Promise((i,a)=>{let o=e.length,l=[];e.forEach((h,u)=>{this.load(h,r).then(c=>{l.push(c),o--,o===0&&i(l),o<0&&console.error(`loadUrls ${e} error`)})})})}get maxRetry(){return this._maxRetry}set maxRetry(e){this._maxRetry=e}load(e,r){return new Promise((i,a)=>{switch(r.format){}})}};s(Va,"_instance");let Pl=Va;var Wo=(n=>(n.Point="Point",n.LineString="LineString",n.MultiPolygon="MultiPolygon",n))(Wo||{});class Cp extends Et{constructor(){super(...arguments);s(this,"json")}parseString(e){return V(this,null,function*(){this.json=e,this.data=JSON.parse(e)})}}s(Cp,"format",at.JSON);class E0{static getPath(t){let e=[];for(let r=0;r<t.features.length;r++){const i=t.features[r];switch(i.geometry.type){case Wo.LineString:break;case Wo.MultiPolygon:let a=[];for(let o=0;o<i.geometry.coordinates.length;o++){const l=i.geometry.coordinates[o];for(const h of l)for(const u of h){let c=new g(u[0],0,u[1]);a.push(c)}}e.push(a);break}}return e}}class B0{constructor(){s(this,"name");s(this,"defines");s(this,"doubleSided");s(this,"baseColorFactor");s(this,"emissiveFactor");s(this,"metallicFactor");s(this,"roughnessFactor");s(this,"alphaCutoff");s(this,"enableBlend");s(this,"baseColorTexture");s(this,"metallicRoughnessTexture");s(this,"normalTexture");s(this,"occlusionTexture");s(this,"emissiveTexture");s(this,"extensions");s(this,"baseMapOffsetSize");s(this,"normalMapOffsetSize");s(this,"emissiveMapOffsetSize");s(this,"roughnessMapOffsetSize");s(this,"metallicMapOffsetSize");s(this,"aoMapOffsetSize")}}class D0{}class M0{}class P0{}class R0{}class U0{}class L0{}class O0{}class N0{}class F0{}class k0{}class Rl{constructor(){s(this,"boneName");s(this,"bonePath");s(this,"parentBoneName");s(this,"boneID");s(this,"parentBoneID");s(this,"instanceID");s(this,"parentInstanceID");s(this,"t");s(this,"q");s(this,"s")}formBytes(t){this.boneName=t.readUTF(),this.bonePath=t.readUTF(),this.parentBoneName=t.readUTF(),this.boneID=t.readInt32(),this.parentBoneID=t.readInt32(),this.instanceID=t.readUTF(),this.parentInstanceID=t.readUTF(),this.t=t.readVector3(),this.q=t.readQuaternion(),this.s=t.readVector3()}}class Ul{constructor(){s(this,"name");s(this,"count");s(this,"boneData");s(this,"boneMap")}formBytes(t){this.boneData=[],this.boneMap=new Map,this.name=t.readUTF(),this.count=t.readInt32();for(let e=0;e<this.count;e++){let r=new Rl;r.formBytes(t.readBytesArray()),this.boneData[e]=r,this.boneMap.set(r.boneName,r)}}}class Ll extends Et{static parser(t,e){let r=t.readInt32();for(let i=0;i<r;i++){let a=new Ul;a.formBytes(t.readBytesArray()),m.res.addObj(a.name,a)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(Ll,"format",at.BIN),O.position,O.normal,O.color,O.TANGENT,O.uv,O.TEXCOORD_1,O.TEXCOORD_2,O.TEXCOORD_2,O.TEXCOORD_4,O.TEXCOORD_5,O.TEXCOORD_6,O.TEXCOORD_7,O.joints0,O.weights0;var Y=(n=>(n[n.single=0]="single",n[n.boolean=1]="boolean",n[n.int=2]="int",n[n.int16=3]="int16",n[n.int32=4]="int32",n[n.float=5]="float",n[n.long=6]="long",n[n.uint=7]="uint",n[n.uint32=8]="uint32",n[n.uint64=9]="uint64",n[n.double=10]="double",n[n.string=11]="string",n[n.singleArray=12]="singleArray",n[n.stringArray=13]="stringArray",n[n.floatArray=14]="floatArray",n[n.vector2=15]="vector2",n[n.vector3=16]="vector3",n[n.vector4=17]="vector4",n[n.color=18]="color",n[n.color32=19]="color32",n[n.animationCurve=20]="animationCurve",n[n.quaternion=21]="quaternion",n[n.matrix4x4=22]="matrix4x4",n[n.mesh=23]="mesh",n[n.texture=24]="texture",n[n.material=25]="material",n[n.materials=26]="materials",n[n.skeleton=27]="skeleton",n[n.animClip=28]="animClip",n[n.vector2Int=29]="vector2Int",n[n.int32List=30]="int32List",n[n.colorList=31]="colorList",n[n.color32List=32]="color32List",n))(Y||{});class Ko{static GetMaterial(t){let e=t,r=e.split("/");e=r[r.length-1],r=e.split("."),e=r[r.length-1];let i=uh(e);if(i){let a=new $r;return a.shader=new i,a}else throw new Error("not found shader, shader name is "+e)}static applyMaterialTexture(t,e){for(let r=0;r<e.length;r++){const i=e[r];i.property in t?t[i.property]=i.texture:i.property in t.shader?t.shader[i.property]=i.texture:t.setTexture(i.property,i.texture)}}static applyMaterialProperties(t,e){for(let r=0;r<e.length;r++){const i=e[r],a=i.key;switch(i.type){case Y.color:case Y.color32:{let o=i.getValue();a in t?t[a]=o:a in t.shader?t.shader[a]=o:t.setUniformColor(a,o)}break;case Y.single:case Y.float:case Y.int:case Y.int16:case Y.int32:case Y.uint:case Y.uint32:case Y.uint64:{let o=i.getValue();a in t?t[a]=o:a in t.shader?t.shader[a]=o:t.setUniformFloat(a,o)}break;case Y.singleArray:{let o=i.getValue()[0];a in t?t[a]=o:a in t.shader?t.shader[a]=o:t.setUniformFloat(a,o)}break;case Y.vector2:case Y.vector2Int:{let o=i.getValue();a in t?t[a]=o:a in t.shader?t.shader[a]=o:t.setUniformVector2(a,o)}break;case Y.vector3:{let o=i.getValue();a in t?t[a]=o:a in t.shader?t.shader[a]=o:t.setUniformVector3(a,o)}break;case Y.vector4:{let o=i.getValue();a in t?t[a]=o:a in t.shader?t.shader[a]=o:t.setUniformVector4(a,o)}break}}}}class Fr{static parser(t){switch(t.readInt32()){case Y.single:return{t:Y.single,v:t.readFloat32()};case Y.boolean:return{t:Y.boolean,v:t.readBoolean()};case Y.int:return{t:Y.int,v:t.readInt32()};case Y.int16:return{t:Y.int16,v:t.readInt16()};case Y.int32:return{t:Y.int32,v:t.readInt32()};case Y.float:return{t:Y.float,v:t.readFloat32()};case Y.long:return{t:Y.long,v:t.readFloat64()};case Y.uint:return{t:Y.uint,v:t.readUnit32()};case Y.uint32:return{t:Y.uint32,v:t.readUnit32()};case Y.uint64:return{t:Y.uint64,v:t.readUnit32()};case Y.double:return{t:Y.double,v:t.readFloat64()};case Y.string:return{t:Y.string,v:t.readUTF()};case Y.singleArray:return{t:Y.singleArray,v:t.readFloatArray()};case Y.stringArray:return{t:Y.stringArray,v:t.readStringArray()};case Y.floatArray:return{t:Y.floatArray,v:t.readFloatArray()};case Y.vector2:return{t:Y.vector2,v:t.readVector2()};case Y.vector3:return{t:Y.vector3,v:t.readVector3()};case Y.vector4:return{t:Y.vector4,v:t.readVector4()};case Y.color:return{t:Y.color,v:t.readColor()};case Y.color32:return{t:Y.color32,v:t.readColor()};case Y.animationCurve:return{t:Y.animationCurve,v:null};case Y.quaternion:return{t:Y.quaternion,v:t.readQuaternion()};case Y.matrix4x4:return{t:Y.matrix4x4,v:null};case Y.mesh:{let o=t.readUTF(),l=m.res.getGeometry(o);return{t:Y.mesh,v:l}}case Y.texture:{let o=t.readUTF(),l=m.res.getTexture(o);return{t:Y.texture,v:l}}case Y.material:{let o=t.readUTF(),l=m.res.getMat(o);return{t:Y.material,v:l}}case Y.materials:{let o=t.readStringArray(),l=[];for(let h=0;h<o.length;h++){const u=o[h];let c=m.res.getMat(u);l.push(c)}return{t:Y.materials,v:l}}case Y.skeleton:break;case Y.animClip:{let o=[],l=t.readInt32();for(let h=0;h<l;h++){let u=new Xl;u.formBytes(t),o.push(u)}return{t:Y.animClip,v:o}}case Y.vector2Int:return{t:Y.vector2Int,v:t.readVector2int()};case Y.int32List:return{t:Y.int32List,v:t.readInt32List()};case Y.colorList:let e=t.readInt32(),r=[];for(let o=0;o<e;o++){const l=Fr.parser(t).v;r.push(l)}return{t:Y.colorList,v:r};case Y.color32List:let i=t.readInt32(),a=[];for(let o=0;o<i;o++){const l=Fr.parser(t).v;a.push(l)}return{t:Y.color32List,v:a}}}}class Ol{constructor(){s(this,"key");s(this,"type");s(this,"_data")}getValue(){return this._data}formBytes(t){this.key=t.readUTF();let{t:e,v:r}=Fr.parser(t);this.type=e,this._data=r}}class _p{constructor(){s(this,"property");s(this,"name");s(this,"texture");s(this,"texelSize");s(this,"wrapModeU");s(this,"wrapModeV");s(this,"wrapModeW");s(this,"wrapMode");s(this,"anisoLevel");s(this,"dimension");s(this,"filterMode")}}class Nl extends Et{static parserMaterial(t,e){let r=t.readInt32();for(let i=0;i<r;i++){let a=t.readBytesArray(),o=a.readUTF(),l=a.readUTF();a.readUTF();let h=a.readStringArray();a.readVector4(),a.readVector4();let u=a.readUTF(),c=[],f=[],d=a.readInt32();for(let x=0;x<d;x++){let C=new Ol;C.formBytes(a),c.push(C)}let p=a.readInt32();for(let x=0;x<p;x++){let C=a.readBytesArray(),v=new _p;v.property=C.readUTF(),v.name=C.readUTF(),v.texture=m.res.getTexture(v.name),v.texelSize=C.readVector2(),v.wrapModeU=C.readUnit32(),v.wrapModeV=C.readUnit32(),v.wrapModeW=C.readUnit32(),v.wrapMode=C.readUnit32(),v.anisoLevel=C.readUnit32(),v.dimension=C.readUnit32(),v.filterMode=C.readUnit32(),f.push(v)}let A=Ko.GetMaterial(u);A.name=o;for(let x=0;x<h.length;x++){const C=h[x];A.shader.setDefine(C,!0)}Ko.applyMaterialTexture(A,f),Ko.applyMaterialProperties(A,c),m.res.addMat(l,A)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(Nl,"format",at.TEXT);class Fl{constructor(){s(this,"shapeName");s(this,"shapeIndex");s(this,"frameCount");s(this,"blendPositionList",new Float32Array);s(this,"blendNormalList",new Float32Array)}formBytes(t){let e=t.readBytesArray();this.shapeName=e.readUTF(),this.shapeIndex=e.readInt32(),this.frameCount=e.readInt32();let r=e.readInt32();this.blendPositionList=e.readFloat32Array(r*3);let i=e.readInt32();this.blendNormalList=e.readFloat32Array(i*3)}}class kl{constructor(){s(this,"vertexCount");s(this,"shapeNames");s(this,"shapeIndexs");s(this,"blendCount");s(this,"blendShapePropertyDatas");s(this,"blendShapeMap")}formBytes(t){this.blendShapeMap=new Map,this.blendShapePropertyDatas=[];let e=t.readBytesArray();this.vertexCount=e.readInt32(),this.shapeNames=e.readStringArray(),this.shapeIndexs=e.readIntArray(),this.blendCount=e.readInt32();for(let r=0;r<this.blendCount;r++){let i=new Fl;i.formBytes(e),this.blendShapePropertyDatas.push(i),this.blendShapeMap.set(i.shapeName,i)}return t}}class yp{constructor(){s(this,"name");s(this,"meshName");s(this,"meshID");s(this,"vertexCount");s(this,"vertexStrip");s(this,"vertexBuffer");s(this,"indices");s(this,"attributes");s(this,"bones");s(this,"bindPose");s(this,"blendShapeData")}}class zl extends Et{parseBuffer(t){return V(this,null,function*(){})}static parserMeshs(t,e){let r=t.readInt32();for(let i=0;i<r;i++){let a=new yp,o=t.readBytesArray();a.meshName=o.readUTF(),a.meshID=o.readUTF(),o.readFloat32()>0,o.readFloat32()>0,o.readFloat32()>0;let l=o.readFloat32()>0,h=o.readFloat32()>0;l&&(a.bones=o.readStringArray(),a.bindPose=o.readMatrix44Array()),h&&(a.blendShapeData=new kl,a.blendShapeData.formBytes(o));let u=o.readBytesArray(),c=o.readBytesArray(),f=u.readInt32(),d=0,p=[];for(let y=0;y<f;y++)p[y]={},p[y].att=Sp[u.readUTF()],p[y].dim=u.readInt32(),d+=p[y].dim,p[y].format=u.readUTF();a.vertexCount=u.readInt32(),a.vertexBuffer=c.getFloat32Array();let A=o.readInt32Array(),x=[],C=o.readInt32();for(let y=0;y<C;y++){let b=o.readInt32(),B=o.readInt32(),I=o.readInt32(),w=o.readInt32(),D=o.readInt32(),L=o.readInt32();o.readVector3(),o.readVector3();let M={indexStart:B,indexCount:I,vertexStart:w,vertexCount:L,firstStart:D,topology:b,index:y};x.push(M)}A.length>65535?a.indices=new Uint32Array(A):a.indices=new Uint16Array(A);let v=new qt;if(v.vertexDim=d,v.geometryType=wt.compose_bin,v.setIndices(a.indices),v.setAttribute(O.all,a.vertexBuffer),l&&(v.skinNames=a.bones,v.bindPose=a.bindPose),h){v.blendShapeData=a.blendShapeData,v.morphTargetsRelative=!0,v.morphTargetDictionary={};for(let y=0;y<a.blendShapeData.blendCount;y++){v.setAttribute("a_morphPositions_"+y,a.blendShapeData.blendShapePropertyDatas[y].blendPositionList),v.setAttribute("a_morphNormals_"+y,a.blendShapeData.blendShapePropertyDatas[y].blendNormalList);for(let b=0;b<a.blendShapeData.blendCount;b++){let B=a.blendShapeData.shapeNames[b],I=a.blendShapeData.shapeIndexs[b];v.morphTargetDictionary[B]=I}}}for(let y=0;y<p.length;y++){const b=p[y].att;v.setAttribute(b,null)}for(let y=0;y<x.length;y++){const b=x[y];v.addSubGeometry(b)}v.name=a.meshName,m.res.addGeometry(a.meshID,v)}}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(zl,"format",at.BIN);let Sp={Position:O.position,Normal:O.normal,Color:O.color,Tangent:O.TANGENT,TexCoord0:O.uv,TexCoord1:O.TEXCOORD_1,TexCoord2:O.TEXCOORD_2,TexCoord3:O.TEXCOORD_2,TexCoord4:O.TEXCOORD_4,TexCoord5:O.TEXCOORD_5,TexCoord6:O.TEXCOORD_6,TexCoord7:O.vIndex,BlendIndices:O.joints0,BlendWeight:O.weights0};class jo extends DataView{constructor(e,r,i){super(e,r,i);s(this,"position",0);s(this,"littleEndian",!0);this.position=0,this.position+=this.byteOffset}readUTF(){let e=this.readInt32(),r=e%4;r>0&&r<4&&(r=4-r);let i="",a=new Int8Array(this.buffer,this.position,e);return this.position+=e*Int8Array.BYTES_PER_ELEMENT,i+=String.fromCharCode.apply(null,a),this.position+=r*Int8Array.BYTES_PER_ELEMENT,i}readStringArray(){let e=[],r=this.readInt32();for(let i=0;i<r;i++)e.push(this.readUTF());return e}readByte(){let e=this.buffer[this.position];return this.position+=1,e}readBoolean(){let e=this.readInt32();return this.position+=4,e==1}readBytes(e){let r=new DataView(this.buffer,this.position,e);return this.position+=e,r.buffer}readBytesArray(){let e=this.readInt32(),r=new jo(this.buffer.slice(this.position,this.position+e));return this.position+=e,r}readUnit8(){let e=this.getUint8(this.position);return this.position+=Uint8Array.BYTES_PER_ELEMENT,e}readUnit16(){let e=this.getUint16(this.position);return this.position+=Uint16Array.BYTES_PER_ELEMENT,e}readUnit32(){let e=this.getUint32(this.position);return this.position+=Uint32Array.BYTES_PER_ELEMENT,e}readInt8(){let e=this.getInt8(this.position);return this.position+=Int8Array.BYTES_PER_ELEMENT,e}readInt16(){let e=this.getInt16(this.position,this.littleEndian);return this.position+=Int16Array.BYTES_PER_ELEMENT,e}readInt32(){let e=this.getInt32(this.position,this.littleEndian);return this.position+=Int32Array.BYTES_PER_ELEMENT,e}readFloat32(){let e=this.getFloat32(this.position,this.littleEndian);return this.position+=Float32Array.BYTES_PER_ELEMENT,e}readFloat64(){let e=this.getFloat64(this.position,this.littleEndian);return this.position+=Float64Array.BYTES_PER_ELEMENT,e}readInt32Array(){let e=this.readInt32(),r=new Int32Array(this.buffer,this.position,e);return r=r.slice(0,e),this.position+=r.byteLength,r}readInt32List(){let e=this.readInt32(),r=[];for(let i=0;i<e;i++)r.push(this.readInt32());return r}readFloatArray(){let e=this.readInt32(),r=[];for(let i=0;i<e;i++){let a=this.readFloat32();r.push(a)}return r}readIntArray(){let e=this.readInt32(),r=[];for(let i=0;i<e;i++){let a=this.readInt32();r.push(a)}return r}readVector2int(){let e=new he;return e.x=this.readInt32(),e.y=this.readInt32(),e}readVector2(){let e=new he;return e.x=this.readFloat32(),e.y=this.readFloat32(),e}readVector3(){let e=new g;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e}readVector3Array(){let e=[],r=this.readInt32();for(let i=0;i<r;i++)e.push(this.readVector3());return e}readVector4(){let e=new ae;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e.w=this.readFloat32(),e}readVector4Array(){let e=[],r=this.readInt32();for(let i=0;i<r;i++)e.push(this.readVector4());return e}readColor(){let e=new K;return e.r=this.readFloat32(),e.g=this.readFloat32(),e.b=this.readFloat32(),e.a=this.readFloat32(),e}readColorArray(){let e=[],r=this.readInt32();for(let i=0;i<r;i++)e.push(this.readColor());return e}readQuaternion(){let e=new Z;return e.x=this.readFloat32(),e.y=this.readFloat32(),e.z=this.readFloat32(),e.w=this.readFloat32(),e}readQuaternionArray(){let e=[],r=this.readInt32();for(let i=0;i<r;i++)e.push(this.readQuaternion());return e}readMatrix44(){let e=new Q,r=e.rawData;return r[0]=this.readFloat32(),r[1]=this.readFloat32(),r[2]=this.readFloat32(),r[3]=this.readFloat32(),r[4]=this.readFloat32(),r[5]=this.readFloat32(),r[6]=this.readFloat32(),r[7]=this.readFloat32(),r[8]=this.readFloat32(),r[9]=this.readFloat32(),r[10]=this.readFloat32(),r[11]=this.readFloat32(),r[12]=this.readFloat32(),r[13]=this.readFloat32(),r[14]=this.readFloat32(),r[15]=this.readFloat32(),e}readMatrix44Array(){let e=this.readInt32(),r=[];for(let i=0;i<e;i++){let a=this.readMatrix44();r.push(a)}return r}readFloat32Array(e){let r=new Float32Array(this.buffer,this.position,e);return r=r.slice(0,this.byteLength),this.position+=e*Float32Array.BYTES_PER_ELEMENT,r}getFloat32Array(){let e=new Float32Array(this.buffer,this.byteOffset,this.byteLength/Float32Array.BYTES_PER_ELEMENT);return e=e.slice(0,this.byteLength),e}}class Gl extends Et{static parserTexture(t,e,r){return V(this,null,function*(){let i=t.readInt32(),a=[];for(let l=0;l<i;l++){let h=t.readUTF();Jo.useWebp?(h=h.replace("png","webp"),h=h.replace("jpb","webp"),a.push(e.baseUrl+"webp/"+h)):a.push(e.baseUrl+h)}let o=yield m.res.loadBitmapTextures(a,m.setting.loader.numConcurrent,r,!0);for(const l of o)m.res.addTexture(l.name,l)})}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(Gl,"format",at.TEXT);var Ip=Object.defineProperty,bp=Object.getOwnPropertyDescriptor,wp=(n,t,e,r)=>{for(var i=r>1?void 0:r?bp(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Ip(t,e,i),i};let Ql=class extends gt{constructor(){super(),H.register("PBRLitSSSShader",Xd);let n=new Le("PBRLitSSSShader","PBRLitSSSShader");n.setShaderEntry("VertMain","FragMain"),this.addRenderPass(n);let t=n.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefine("USE_CUSTOMUNIFORM",!0),this.setDefault(),this.debug(),this.computes=[new fp(this)]}debug(){}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new ae(0,0,1,1)),this.setUniformVector4("transformUV2",new ae(0,0,1,1)),this.setUniformColor("baseColor",new K),this.setUniformColor("emissiveColor",new K(1,1,1)),this.setUniformVector4("materialF0",new ae(.04,.04,.04,1)),this.setUniformColor("specularColor",new K(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",0),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new K(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this.setUniformColor("skinColor",new K(1,0,0)),this.setUniformFloat("skinPower",3.4),this.setUniformFloat("skinColorIns",.5),this.setUniformFloat("curveFactor",1)}set _MainTex(n){this.setTexture("baseMap",n)}set _BumpMap(n){this.setTexture("normalMap",n)}set _SSSMap(n){this.setTexture("sssMap",n)}set _MaskTex(n){this.setTexture("maskMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _MainColor(n){this.setUniformColor("baseColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _DoubleSidedEnable(n){let t=this.getDefaultColorShader();t.shaderState.cullMode=n?Pt.none:t.shaderState.cullMode}set _SkinColor(n){this.setUniformColor("skinColor",n)}set _SkinPower(n){this.setUniformFloat("skinPower",n)}set _SkinColorIns(n){this.setUniformFloat("skinColorIns",n)}set curveFactor(n){this.setUniformFloat("curveFactor",n)}set _SurfaceType(n){let t=this.getDefaultColorShader();n==0?t.blendMode=oe.NONE:t.blendMode=oe.ALPHA}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Ql=wp([ci],Ql);var Tp=Object.defineProperty,Ep=Object.getOwnPropertyDescriptor,Bp=(n,t,e,r)=>{for(var i=r>1?void 0:r?Ep(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Tp(t,e,i),i};let Vl=class extends gt{constructor(){super();let n=new Le("PBRLItShader","PBRLItShader");n.setShaderEntry("VertMain","FragMain"),this.addRenderPass(n);let t=n.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,this.setDefine("USE_BRDF",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new ae(0,0,1,1)),this.setUniformVector4("transformUV2",new ae(0,0,1,1)),this.setUniformColor("baseColor",new K),this.setUniformColor("emissiveColor",new K(0,0,0)),this.setUniformVector4("materialF0",new ae(.04,.04,.04,1)),this.setUniformColor("specularColor",new K(.04,.04,.04)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",1),this.setUniformFloat("metallic",0),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",0),this.setUniformFloat("ior",1.5),this.setUniformFloat("clearcoatFactor",0),this.setUniformFloat("clearcoatRoughnessFactor",0),this.setUniformColor("clearcoatColor",new K(1,1,1)),this.setUniformFloat("clearcoatWeight",0),this._MainTex=m.res.grayTexture,this._BumpMap=m.res.normalTexture,this._MaskTex=m.res.maskTexture}set _MainTex(n){this.setTexture("baseMap",n)}set _BumpMap(n){this.setTexture("normalMap",n)}set _MaskTex(n){this.setTexture("maskMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _MainColor(n){this.setUniformColor("baseColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _DoubleSidedEnable(n){let t=this.getDefaultColorShader();t.shaderState.cullMode=n?Pt.none:t.shaderState.cullMode}set _SurfaceType(n){let t=this.getDefaultColorShader();n==0?t.blendMode=oe.NONE:t.blendMode=oe.ALPHA}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Vl=Bp([ci],Vl);class qo{constructor(){s(this,"comName");s(this,"data")}static parser(t){let e=t.readBytesArray(),r=new qo;r.comName=e.readUTF(),r.data=[];let i=e.readInt32();for(let a=0;a<i;a++){let o=new Ol;o.formBytes(e),r.data.push(o)}return r}}class Us{constructor(){s(this,"name");s(this,"parentName");s(this,"position");s(this,"rotation");s(this,"scale");s(this,"comDatas");s(this,"child")}static parser(t){let e=t.readBytesArray(),r=new Us;r.name=e.readUTF(),r.parentName=e.readUTF(),r.position=e.readVector3(),r.rotation=e.readQuaternion(),r.scale=e.readVector3(),r.comDatas=[],r.child=[];let i=e.readInt32();for(let o=0;o<i;o++){const l=qo.parser(e);r.comDatas.push(l)}let a=e.readInt32();for(let o=0;o<a;o++){const l=Us.parser(e);r.child.push(l)}return r}}class Jo extends Et{constructor(){super(...arguments);s(this,"avatarDic");s(this,"nodeData")}parseBuffer(e){return V(this,null,function*(){this.avatarDic={};let r=new jo(e,0);yield Gl.parserTexture(r,this,this.loaderFunctions),Ll.parser(r,this),zl.parserMeshs(r,this),Nl.parserMaterial(r,this),this.nodeData=this.parserPrefabNode(r),this.data=this.data=this.parserNodeTree(this.nodeData)})}parserPrefabNode(e){return Us.parser(e)}parserNodeTree(e){let r=new ee;if(r.localPosition=g.serialize(e.position),r.localQuaternion=Z.serialize(e.rotation),r.localScale=g.serialize(e.scale),r.name=e.name,e.comDatas)for(let i=0;i<e.comDatas.length;i++){const a=e.comDatas[i];let o=null,l=hh(a.comName);if(l){o=r.getOrAddComponent(l);for(let h=0;h<a.data.length;h++){const u=a.data[h];u.key in o&&(o[u.key]=u.getValue())}}}if(e.child&&e.child.length>0)for(let i=0;i<e.child.length;i++){let a=this.parserNodeTree(e.child[i]);r.addChild(a)}return r}verification(){if(this.data)return!0;throw new Error("verify failed.")}}s(Jo,"useWebp",!0),s(Jo,"format",at.BIN);class z0{static getNumber(t){return parseFloat(t)}static getInt(t){return parseInt(t)}static getBoolean(t){return t=="true"}static getNumberArray(t){let e=t.replaceAll("[","");e=e.replaceAll("]","");let r=e.split(",");for(let i=0;i<r.length;i++)parseFloat(r[i]);return e}static getStringArray(t){let e=t.replaceAll("[","");e=e.replaceAll("]","");let r=e.split(","),i=[];for(let a=0;a<r.length;a++){const o=r[a];i.push(o)}return i}static getVector2(t){}static getVector3(t){}static getVector4(t){}static getQuaternion(t){}static getColor(t){}}var Dp=Object.defineProperty,Mp=Object.getOwnPropertyDescriptor,Pp=(n,t,e,r)=>{for(var i=r>1?void 0:r?Mp(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Dp(t,e,i),i};let Yl=class extends gt{constructor(){super(),this.create_opPass(),this.setDefine("USEC",!0),this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefine("USE_HAIR",!0),this.setDefine("USE_CUSTOMUNIFORM",!0),this.setDefine("USE_HAIRCOLOR",!0),this.setDefault(),this.debug()}create_opPass(){H.register("HairShader_op",Yd);let n=new Le("HairShader_op","HairShader_op");this.addRenderPass(n),n.setShaderEntry("VertMain","FragMain");let t=n.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,t.blendMode=oe.NONE,t.cullMode=Pt.none,t.writeMasks[0]=GPUColorWrite.ALL}create_trPass(){H.register("HairShader_tr",Hd);let n=new Le("HairShader_tr","HairShader_tr");this.addRenderPass(n),n.setShaderEntry("VertMain","FragMain");let t=n.shaderState;t.acceptShadow=!0,t.castShadow=!0,t.receiveEnv=!0,t.acceptGI=!0,t.useLight=!0,t.depthWriteEnabled=!1,t.blendMode=oe.NORMAL,t.cullMode=Pt.none,t.writeMasks[0]=GPUColorWrite.ALL,t.writeMasks[1]=0,t.writeMasks[2]=0,t.writeMasks[3]=0}debug(){}setDefault(){this.setUniformFloat("shadowBias",35e-5),this.setUniformVector4("transformUV1",new ae(0,0,1,1)),this.setUniformVector4("transformUV2",new ae(0,0,1,1)),this.setUniformColor("baseColor0",new K(3/255,2/255,2/255)),this.setUniformColor("baseColor1",new K(2/255,2/255,2/255)),this.setUniformColor("emissiveColor",new K(1,1,1)),this.setUniformVector4("materialF0",new ae(.04,.04,.04,1)),this.setUniformColor("specularColor",new K(36/255,36/255,36/255)),this.setUniformFloat("envIntensity",1),this.setUniformFloat("normalScale",1),this.setUniformFloat("roughness",.1),this.setUniformFloat("metallic",.3),this.setUniformFloat("ao",1),this.setUniformFloat("roughness_min",0),this.setUniformFloat("roughness_max",1),this.setUniformFloat("metallic_min",0),this.setUniformFloat("metallic_max",1),this.setUniformFloat("emissiveIntensity",0),this.setUniformFloat("alphaCutoff",.1),this.setUniformFloat("ior",1.5),this.setUniformFloat("backlit",.3987),this.setUniformFloat("area",.0615)}set _MainTex(n){this.setTexture("baseMap",n)}set _IDMap(n){this.setTexture("idMap",n)}set _DepthMap(n){this.setTexture("depthMap",n)}set _RootMap(n){this.setTexture("rootMap",n)}set _AlphaMap(n){this.setTexture("alphaMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _HairColor0(n){this.setUniformColor("baseColor0",n)}set _HairColor1(n){this.setUniformColor("baseColor1",n)}set _SpecularColor(n){this.setUniformColor("specularColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _BackLit(n){this.setUniformFloat("backlit",n)}set _Area(n){this.setUniformFloat("area",n)}set _DoubleSidedEnable(n){let t=this.getSubShaders(J.COLOR)[0];t.shaderState.cullMode=n?Pt.none:t.shaderState.cullMode}set _SurfaceType(n){}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Yl=Pp([ci],Yl);var Rp=Object.defineProperty,Up=Object.getOwnPropertyDescriptor,Lp=(n,t,e,r)=>{for(var i=r>1?void 0:r?Up(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Rp(t,e,i),i};let Zo=class extends gt{constructor(){super();let n=new Le("UnLit","UnLit");n.setShaderEntry("VertMain","FragMain"),this.addRenderPass(n);let t=n.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new ae(0,0,1,1)),this.setUniformVector4("transformUV2",new ae(0,0,1,1)),this.setUniformColor("baseColor",new K),this.setUniformFloat("alphaCutoff",0)}set _MainTex(n){this.setTexture("baseMap",n)}set _BumpMap(n){this.setTexture("normalMap",n)}set _MaskTex(n){this.setTexture("maskMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _MainColor(n){this.setUniformColor("baseColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _DoubleSidedEnable(n){let t=this.getDefaultColorShader();t.shaderState.cullMode=n?Pt.none:t.shaderState.cullMode}set _SurfaceType(n){let t=this.getDefaultColorShader();n==0?t.blendMode=oe.NONE:t.blendMode=oe.ALPHA}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};Zo=Lp([ci],Zo);var Op=Object.defineProperty,Np=Object.getOwnPropertyDescriptor,Fp=(n,t,e,r)=>{for(var i=r>1?void 0:r?Np(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&Op(t,e,i),i};let $o=class extends gt{constructor(){super(),H.register("VertexAttributeIndexShader",zd),H.register("UnLitTextureArray",Wd);let n=new Le("UnLitTextureArray","UnLitTextureArray");n.setShaderEntry("VertMain","FragMain"),this.addRenderPass(n);let t=n.shaderState;t.acceptShadow=!1,t.castShadow=!1,t.receiveEnv=!1,t.acceptGI=!1,t.useLight=!1,this.setDefine("USE_BRDF",!0),this.setDefine("USE_AO_R",!0),this.setDefine("USE_ROUGHNESS_G",!0),this.setDefine("USE_METALLIC_B",!0),this.setDefine("USE_ALPHA_A",!0),this.setDefault()}setDefault(){this.setUniformVector4("transformUV1",new ae(0,0,1,1)),this.setUniformVector4("transformUV2",new ae(0,0,1,1)),this.setUniformColor("baseColor",new K),this.setUniformFloat("alphaCutoff",0)}set _MainTex(n){this.setTexture("baseMap",n)}set _BumpMap(n){this.setTexture("normalMap",n)}set _MaskTex(n){this.setTexture("maskMap",n)}set _UVTransform(n){this.setUniformVector4("transformUV1",n)}set _Metallic(n){this.setUniformFloat("metallic",n)}set _Roughness(n){this.setUniformFloat("roughness",n)}set _MainColor(n){this.setUniformColor("baseColor",n)}set _AlphaCutoff(n){this.setUniformFloat("alphaCutoff",n)}set _DoubleSidedEnable(n){let t=this.getDefaultColorShader();t.shaderState.cullMode=n?Pt.none:t.shaderState.cullMode}set _SurfaceType(n){let t=this.getDefaultColorShader();n==0?t.blendMode=oe.NONE:t.blendMode=oe.ALPHA}set _AlphaCutoffEnable(n){n==0?this.setDefine("USE_ALPHACUT",!1):this.setDefine("USE_ALPHACUT",!0)}};$o=Fp([ci],$o);var kp=Object.defineProperty,zp=Object.getOwnPropertyDescriptor,Gp=(n,t,e,r)=>{for(var i=r>1?void 0:r?zp(t,e):t,a=n.length-1,o;a>=0;a--)(o=n[a])&&(i=(r?o(t,e,i):o(i))||i);return r&&i&&kp(t,e,i),i};let en=class extends Qt{constructor(){super(...arguments);s(this,"size");s(this,"blockSize");s(this,"walk");s(this,"obs");s(this,"colors");s(this,"aPaths")}onGraphic(t){}};en=Gp([or(en,"APatch")],en);class G0{constructor(){s(this,"weight");s(this,"deltaVertices");s(this,"deltaNormals");s(this,"deltaTangents")}formBytes(t){let e=t.readBytesArray();this.weight=e.readFloat32();let r=0;r=e.readInt32(),this.deltaVertices=e.readFloat32Array(r*3),r=e.readInt32(),this.deltaNormals=e.readFloat32Array(r*3),r=e.readInt32(),this.deltaTangents=e.readFloat32Array(r*3)}}class Q0{constructor(){s(this,"asset");s(this,"extras");s(this,"geometricError");s(this,"properties");s(this,"refine");s(this,"root")}}class V0{constructor(){s(this,"boundingVolume");s(this,"children");s(this,"geometricError");s(this,"transform")}}class Y0{constructor(){s(this,"boundingVolume");s(this,"geometricError");s(this,"refine");s(this,"content");s(this,"contents")}}class H0{constructor(){s(this,"uri");s(this,"group");s(this,"metadata")}}class X0{constructor(){s(this,"class");s(this,"properties")}}class Hl{constructor(){s(this,"group");s(this,"_modelList");s(this,"_tileSet");s(this,"_rootPath");this.group=new ee}loadTileSet(t,e){return V(this,null,function*(){this._modelList=[],this._rootPath=t;let r=t+"/"+e;if(this._tileSet=yield m.res.loadJSON(r),this._tileSet.root.transform){let o=new Q;for(let l=0;l<16;l++)o.rawData[l]=this._tileSet.root.transform[l]}let i=new Q;switch((this._tileSet.asset&&this._tileSet.asset.gltfUpAxis||"y").toLowerCase()){case"x":i.makeRotationAxis(g.Y_AXIS,-Math.PI/2);break;case"y":i.makeRotationAxis(g.X_AXIS,Math.PI/2);break;case"z":i.identity();break}let a=i.clone();a.invert(),this.applyTransform(this.group.transform,a);for(let o of this._tileSet.root.children){let l=[];if(o.content&&o.content.uri&&l.push(o.content.uri),o.contents)for(let h of o.contents)l.push(h.uri);for(let h of l){let u=this._rootPath+"/"+h,c={onProgress:d=>this.onLoadProgress(d),onComplete:d=>this.onComplete(d)},f;if(u.endsWith(".glb"))f=yield m.res.loadGltf(u,c),this.applyTransform(f.transform,i);else if(u.endsWith("tileset.json")){let d=u.replace("/tileset.json",""),p=new Hl;yield p.loadTileSet(d,"tileset.json"),f=p.group}else u.endsWith(".i3dm")?f=yield m.res.loadI3DM(u,c,i):u.endsWith(".b3dm")&&(f=yield m.res.loadB3DM(u,c,i));f&&(this._modelList.push(f),this.group.addChild(f))}}})}onLoadProgress(t){}onComplete(t){}applyTransform(t,e){let r=e.decompose(Gt.QUATERNION);t.localRotQuat.copyFrom(r[1]),t.localRotQuat=t.localRotQuat,t.localPosition.copyFrom(r[0]),t.localPosition=t.localPosition,t.localScale.copyFrom(r[2]),t.localScale=t.localScale}}class Qp extends null{constructor(){super(),H.register("ColorLitShader",Gd),this.shader=new gt;let t=new Le("ColorLitShader","ColorLitShader");t.passType=J.COLOR,this.shader.addRenderPass(t),t.setDefine("USE_BRDF",!0),t.setShaderEntry("VertMain","FragMain"),t.setUniformColor("baseColor",new K),t.setUniformColor("emissiveColor",new K),t.setUniformFloat("envIntensity",1),t.setUniformFloat("normalScale",1),t.setUniformFloat("roughness",0),t.setUniformFloat("metallic",0),t.setUniformFloat("ao",1),t.setUniformFloat("alphaCutoff",0);let e=t.shaderState;e.acceptShadow=!0,e.receiveEnv=!0,e.acceptGI=!0,e.useLight=!0,t.setTexture("normalMap",m.res.normalTexture),t.setTexture("emissiveMap",m.res.blackTexture)}clone(){return null}debug(){}}s(Qp,"count",null);class W0 extends null{constructor(){super(),H.register("GlassShader",Vd),this.shader=new gt;let t=new Le("GlassShader","GlassShader");t.passType=J.COLOR,t.setDefine("USE_BRDF",!0),t.setShaderEntry("VertMain","FragMain");let e=t.shaderState;e.acceptShadow=!0,e.castShadow=!0,e.receiveEnv=!0,e.acceptGI=!0,e.useLight=!0,this.shader.setTexture("baseMap",m.res.whiteTexture),this.shader.setTexture("normalMap",m.res.normalTexture),this.shader.setTexture("emissiveMap",m.res.blackTexture)}}class K0 extends null{constructor(){super();let t=new Le("LambertShader","LambertShader");t.setShaderEntry("VertMain","FragMain"),t.passType=J.COLOR,t.setUniformVector4("transformUV1",new ae(0,0,1,1)),t.setUniformVector4("transformUV2",new ae(0,0,1,1)),t.setUniformColor("baseColor",new K(1,1,1,1)),t.setUniformFloat("alphaCutoff",.5);let e=t.shaderState;e.acceptShadow=!1,e.castShadow=!1,e.receiveEnv=!1,e.acceptGI=!1,e.useLight=!1;let r=new gt;r.addRenderPass(t),this.shader=r,this.baseMap=m.res.grayTexture}set baseMap(t){this.shader.setTexture("baseMap",t)}get baseMap(){return this.shader.getTexture("baseMap")}set baseColor(t){this.shader.setUniformColor("baseColor",t)}get baseColor(){return this.shader.getUniformColor("baseColor")}set envMap(t){}set shadowMap(t){}}function j0(n,t){}class Yt extends null{constructor(){super(),this.shader=new Zo,this.baseMap=m.res.whiteTexture}set baseMap(t){this.shader.setTexture("baseMap",t)}get baseMap(){return this.shader.getTexture("baseMap")}set baseColor(t){this.shader.setUniformColor("baseColor",t)}get baseColor(){return this.shader.getUniformColor("baseColor")}set envMap(t){}set shadowMap(t){}}class q0 extends null{constructor(){super(),this.shader=new $o,this.baseMap=m.res.whiteTexture}set baseMap(t){this.shader.setTexture("baseMap",t)}get baseMap(){return this.shader.getTexture("baseMap")}set baseColor(t){this.shader.setUniformColor("baseColor",t)}get baseColor(){return this.shader.getUniformColor("baseColor")}set shadowMap(t){}}class Xl{constructor(){s(this,"clipName");s(this,"loopTime");s(this,"startTime");s(this,"stopTime");s(this,"sampleRate");s(this,"useSkeletonPos");s(this,"useSkeletonScale");s(this,"positionCurves",new Map);s(this,"rotationCurves",new Map);s(this,"scaleCurves",new Map);s(this,"floatCurves",new Map)}formBytes(t){if(this.clipName=t.readUTF(),this.loopTime=!t.readInt32(),this.startTime=t.readFloat32(),this.stopTime=t.readFloat32(),this.sampleRate=t.readInt32(),this.useSkeletonPos=t.readInt32()>0,this.useSkeletonScale=t.readInt32()>0,this.useSkeletonPos){let i=t.readInt32();for(let a=0;a<i;a++){let o=new bi;o.formBytes(t),this.positionCurves.set(o.path,o)}}let e=t.readInt32();for(let i=0;i<e;i++){let a=new bi;a.formBytes(t),this.rotationCurves.set(a.path,a)}if(this.useSkeletonScale){let i=t.readInt32();for(let a=0;a<i;a++){let o=new bi;o.formBytes(t),this.scaleCurves.set(o.path,o)}}let r=t.readInt32();for(let i=0;i<r;i++){let a=new bi;a.formBytes(t),this.floatCurves.set(a.attribute,a)}}}class bi{constructor(t=1){s(this,"path");s(this,"attribute");s(this,"propertys");s(this,"preInfinity");s(this,"postInfinity");s(this,"rotationOrder");s(this,"m_curves");s(this,"k",0);s(this,"_cacheValue");s(this,"_kValue");this.k=t,this.m_curves=[],this.check()}check(){var t;for(let e=0;e<this.k;e++)(t=this.m_curves)[e]||(t[e]=new Fo);switch(this.k){case 1:this._cacheValue=0;break;case 2:this._cacheValue=new he;break;case 3:this._cacheValue=new g;break;case 4:this._cacheValue=new ae;break}}get totalTime(){return this.m_curves[0].totalTime}addKeyFrame(t){for(let e=0;e<this.k;e++)this.m_curves[e].addKeyFrame(t.getK(e))}removeKeyFrame(t){for(let e=0;e<this.k;e++)this.m_curves[e].removeKeyFrame(t.getK(e))}getValue(t){switch(this.k){case 1:this._cacheValue=this.m_curves[0].getValue(t);break;case 2:this._cacheValue.x=this.m_curves[0].getValue(t),this._cacheValue.y=this.m_curves[1].getValue(t);break;case 3:this._cacheValue.x=this.m_curves[0].getValue(t),this._cacheValue.y=this.m_curves[1].getValue(t),this._cacheValue.z=this.m_curves[2].getValue(t);break;case 4:const e=this.m_curves[0].getCurveFramesExtent(t),r=e.lhsIndex,i=e.rhsIndex;t=e.time;let a=this.m_curves[0].getKey(r),o=this.m_curves[0].getKey(i);t%=this.m_curves[0].totalTime;let l=(t-a.time)/(o.time-a.time);Z.HELP_0.set(this.m_curves[0].getKey(r).value,this.m_curves[1].getKey(r).value,this.m_curves[2].getKey(r).value,this.m_curves[3].getKey(r).value),Z.HELP_1.set(this.m_curves[0].getKey(i).value,this.m_curves[1].getKey(i).value,this.m_curves[2].getKey(i).value,this.m_curves[3].getKey(i).value),Z.HELP_2.slerp(Z.HELP_0,Z.HELP_1,l),this._cacheValue.x=Z.HELP_2.x,this._cacheValue.y=Z.HELP_2.y,this._cacheValue.z=Z.HELP_2.z,this._cacheValue.w=Z.HELP_2.w;break}return this._cacheValue}getKeyCount(){return this.m_curves[0].getKeyCount()}getKey(t){let e=[];for(let r=0;r<this.k;r++)e.push(this.m_curves[r].getKey(t));return e}formBytes(t){this.path=t.readUTF(),this.k=t.readInt32(),this.check(),this.attribute=t.readUTF(),this.propertys=this.attribute.split("."),this.preInfinity=t.readInt32(),this.postInfinity=t.readInt32(),this.rotationOrder=t.readInt32();let e=t.readInt32();for(let r=0;r<e;r++){let i=new Fs(0);i.formBytes(t),this.addKeyFrame(i)}}}class tn{constructor(t=[]){s(this,"_points");s(this,"_cacheValue");this.points=t,this._cacheValue=new he}get points(){return this._points}set points(t){this._points=t}getValue(t){t<0&&(t=0),t>1&&(t=1);let e=this.points.length-1,r=Math.floor(e*t),i=r+1,a=yt.fract((e+1)*t);return i>=e&&(i=r,a=0),this._cacheValue.x=this.points[r].x+(this.points[i].x-this.points[r].x)*a,this._cacheValue.y=this.points[r].y+(this.points[i].y-this.points[r].y)*a,this._cacheValue}static createBezierPoints(t,e){for(var r=new tn,i=0;i<e;i++){var a=tn.multiPointBezier(t,i/e);r.points.push(a)}return r}static multiPointBezier(t,e){for(var r=t.length,i=0,a=0,o=function(u,c){for(var f=1,d=1;c>0;)f*=u,d*=c,u--,c--;return f/d},l=0;l<r;l++){var h=t[l];i+=h.x*Math.pow(1-e,r-1-l)*Math.pow(e,l)*o(r-1,l),a+=h.y*Math.pow(1-e,r-1-l)*Math.pow(e,l)*o(r-1,l)}return new he(i,a)}}class Vp{static calculateCubicBezierPoint(t,e,r,i,a){t>1&&(t=1),t<0&&(t=0);let o=1-t,l=o*o,h=o*o*o,u=t*t,c=t*t*t,f=e.mul(h),d=r.mul(3);d=d.mul(t),d=d.mul(l);let p=i.mul(3);p=p.mul(u),p=p.mul(o);let A=a.mul(c);return f=f.add(d),f=f.add(p),f=f.add(A),f}static bezierPoint(t,e,r,i){t>1&&(t=1),t<0&&(t=0);let a=1-t,o=a*a,l=t*t,h=e.mul(o),u=r.mul(2);u.scaleBy(a),u.scaleBy(t);let c=i.mul(l);return h=h.add(u),h=h.add(c),h}static calculateCubicBezierPoints(t,e,r){t>1&&(t=1),t<0&&(t=0);let i=1-t,a=i*i,o=i*i*i,l=t*t,h=t*t*t,u=e[r].mul(o),c=e[r+1].mul(3);c=c.mul(t),c=c.mul(a);let f=e[r+2].mul(3);f=f.mul(l),f=f.mul(i);let d=e[r+3].mul(h);return u=u.add(c),u=u.add(f),u=u.add(d),u}static bezierPathValue(t,e){t>1&&(t=1),t<0&&(t=0);let r=e.length,i=this.tmp_points;i.length=0;for(let a=1;a<r;++a)for(let o=0;o<r-a;++o){if(a==1){let h=new g;h.x=e[o].x*(1-t)+e[o+1].x*t,h.y=e[o].y*(1-t)+e[o+1].y*t,h.z=e[o].z*(1-t)+e[o+1].z*t,this.tmp_points.push(h);continue}let l=new g;l.x=i[o].x*(1-t)+i[o+1].x*t,l.y=i[o].y*(1-t)+i[o+1].y*t,l.z=i[o].z*(1-t)+i[o+1].z*t,i.push(l)}return i[0]}}s(Vp,"tmp_points",null);class J0 extends null{constructor(e){super(e);s(this,"negtive");if(this.negtive=new Map,e)for(let r of e)this.negtive.set(r[1],r[0])}delete(e){if(this.has(e)){let r=this.get(e);return this.negtive.delete(r),super.delete(e)}return!1}getKey(e){return this.negtive.get(e)}deleteValue(e){let r=this.negtive.get(e);return r&&this.delete(r),this.negtive.delete(e)}set(e,r){return super.set(e,r),this.negtive.set(r,e),this}clear(){this.negtive.clear(),super.clear()}}class Z0{constructor(t){s(this,"colorArray");this.colorArray=t}getColor(t){let e=t*this.colorArray.length,r=Math.floor(e),i=Math.min(r+1,this.colorArray.length-1),a=this.colorArray[r],o=this.colorArray[i];return K.lerp(e-r,a,o)}}class rn{constructor(t){s(this,"controlVertices");this.setControlVertices(t)}setControlVertices(t){t.length==4&&(this.controlVertices=t.concat())}getPoint(t){if(!(t>=0&&t<=1))return g.ZERO;let e=1-t,r=e*e*e,i=3*t*e*e,a=3*t*t*e,o=t*t*t;return this.controlVertices[0].mul(r).add(this.controlVertices[1].mul(i)).add(this.controlVertices[2].mul(a)).add(this.controlVertices[3].mul(o))}getTangent(t){if(!(t>=0&&t<=1))return g.ZERO;let e=this.controlVertices,r=e[0].add(e[1].add(e[0]).mul(t)),i=e[1].add(e[2].add(e[1]).mul(t)),a=e[2].add(e[3].add(e[2]).mul(t)),o=r.add(i.subtract(r).mul(t));return i.add(a.subtract(i).mul(t)).subtract(o)}getClosestParam(t,e=1e-6){return this.getClosestParamRec(t,0,1,e)}getClosestParamRec(t,e,r,i){let a=(e+r)/2;if(r-e<i)return a;let o=(e+a)/2,l=(a+r)/2,h=this.getPoint(o),u=this.getPoint(l),c=h.subtract(t).lengthSquared,f=u.subtract(t).lengthSquared;return c<f?r=a:e=a,this.getClosestParamRec(t,e,r,i)}}var Yp=(n=>(n[n.Open=0]="Open",n[n.Closed=1]="Closed",n))(Yp||{});class $0{constructor(t,e=0){s(this,"type",0);s(this,"numCurveSegments",0);s(this,"numControlVertices",0);s(this,"controlVertices",[]);this.setControlVertices(t,e)}getPathType(){return this.type}isClosed(){return this.type==1}isValid(){return this.numCurveSegments>0}clear(){this.controlVertices.length=0,this.type=0,this.numCurveSegments=0,this.numControlVertices=0}computeApproxLength(){if(!this.isValid())return 0;let t=this.numCurveSegments+1;if(t<2)return 0;let e=0,r=this.controlVertices;for(let i=1;i<t;i++){let a=r[(i-1)*3],o=r[i*3];e+=a.subtract(o).lengthSquared}return e==0?0:e}computeApproxParamPerUnitLength(){let t=this.computeApproxLength();return this.numCurveSegments/t}computeApproxNormParamPerUnitLength(){return 1/this.computeApproxLength()}interpolatePoints(t,e){let r=t.length;r<2&&console.error("point count must great 1"),this.clear(),this.type=e;let i=this.controlVertices;switch(e){case 0:{this.numCurveSegments=r-1,this.numControlVertices=3*r-2,i.length=this.numControlVertices;for(let l=0;l<r;l++)i[l*3]=t[l];let a=t[1].subtract(t[0]).mul(.25);i[1]=t[0].add(a);let o=t[r-2].subtract(t[r-1]).mul(.25);i[this.numControlVertices-2]=t[r-1].add(o);for(let l=1;l<this.numCurveSegments;l++){let h=t[l-1].subtract(t[l]),u=t[l+1].subtract(t[l]),c=h.lengthSquared,f=u.lengthSquared;if(c>0&&f>0){let d=(c+f)/8,p=u.div(f).subtract(h.div(c));p.normalize(),p=p.mul(d),i[l*3-1]=t[l].subtract(p),i[l*3+1]=t[l].add(p)}else i[l*3-1]=t[l],i[l*3+1]=t[l]}break}case 1:{this.numCurveSegments=r,this.numControlVertices=3*r+1,i.length=this.numControlVertices;for(let a=0;a<r;a++)i[a*3]=t[a];i[this.numControlVertices-1]=t[0];for(let a=1;a<=this.numCurveSegments;a++){let o=a-1,l=(a+1)%this.numCurveSegments,h=a%this.numCurveSegments,u=t[o].subtract(t[h]),c=t[l].subtract(t[h]),f=u.lengthSquared,d=c.lengthSquared,p=3*a-1,A=(3*a+1)%(this.numControlVertices-1);if(f>0&&d>0){let x=(f+d)/8,C=c.div(d).subtract(u.div(f));C.normalize(),C=C.mul(x),i[p]=t[h].subtract(C),i[A]=t[h].add(C)}else i[p]=t[h],i[A]=t[h]}break}}}setControlVertices(t,e){let r=t.length;r<=0||e==0&&r<4||e==1&&r<7||(r-1)%3==0&&(this.clear(),this.type=e,this.numControlVertices=r,this.numCurveSegments=(r-1)/3,this.controlVertices=t)}getPoint(t){if(this.type==1){for(;t<0;)t+=this.numCurveSegments;for(;t>this.numCurveSegments;)t-=this.numCurveSegments}else t=yt.clampf(t,0,this.numCurveSegments);if(!(t>=0)&&t<=this.numCurveSegments)return;let e=Math.floor(t);e>=this.numCurveSegments&&(e=this.numCurveSegments-1);let r=[],i=this.controlVertices;return r[0]=i[3*e+0],r[1]=i[3*e+1],r[2]=i[3*e+2],r[3]=i[3*e+3],new rn(r).getPoint(t-e)}getPointNorm(t){return this.getPoint(t*this.numCurveSegments)}getTangent(t){if(this.type==1){for(;t<0;)t+=this.numCurveSegments;for(;t>this.numCurveSegments;)t-=this.numCurveSegments}else t=yt.clampf(t,0,this.numCurveSegments);if(!(t>=0)&&t<=this.numCurveSegments)return;let e=Math.floor(t);e>=this.numCurveSegments&&(e=this.numCurveSegments-1);let r=this.controlVertices,i=[];return i[0]=r[3*e+0],i[1]=r[3*e+1],i[2]=r[3*e+2],i[3]=r[3*e+3],new rn(i).getTangent(t-e)}getTangentNorm(t){return this.getTangent(t*this.numCurveSegments)}computeClosestParam(t,e){let r=Number.MAX_SAFE_INTEGER,i=0,a=[],o=new rn(a);for(let l=0;l<this.controlVertices.length-1;l+=3){for(let c=0;c<4;c++)a[c]=this.controlVertices[l+c];o.setControlVertices(a);let h=o.getClosestParam(t,e),u=o.getPoint(h).subtract(t).lengthSquared;u<r&&(r=u,i=l/3+h)}return i}computeClosestNormParam(t,e){return this.computeClosestParam(t,e*this.numCurveSegments)}}class ev extends null{constructor(e,r,i){var a,o;super(e);s(this,"valueList");s(this,"keyList");s(this,"isChange",!0);if(r&&(this.keyList=[]),i&&(this.valueList=[]),e)for(let l of e)(a=this.valueList)==null||a.push(l[1]),(o=this.keyList)==null||o.push(l[0])}delete(e){if(this.has(e)){let r=this.get(e);return this.valueList&&this.deleteValue(r),this.keyList&&this.deleteKey(e),this.isChange=!0,super.delete(e)}return!1}deleteValue(e){let r=this.valueList.indexOf(e);return r>=0&&this.valueList.splice(r,1),this}deleteKey(e){let r=this.keyList.indexOf(e);return r>=0&&this.keyList.splice(r,1),this}set(e,r){var i,a;return this.delete(e),(i=this.keyList)==null||i.push(e),(a=this.valueList)==null||a.push(r),super.set(e,r),this.isChange=!0,this}clear(){this.valueList&&(this.valueList.length=0),this.keyList&&(this.keyList.length=0),this.isChange=!0,super.clear()}}var Hp=(n=>(n[n.kParticleSystemClampVelocityCurveId=322376503]="kParticleSystemClampVelocityCurveId",n[n.kParticleSystemForceCurveId=306581307]="kParticleSystemForceCurveId",n[n.kParticleSystemRotationCurveId=1793934638]="kParticleSystemRotationCurveId",n[n.kParticleSystemRotationBySpeedCurveId=3737431713]="kParticleSystemRotationBySpeedCurveId",n[n.kParticleSystemStartSpeedCurveId=2527743459]="kParticleSystemStartSpeedCurveId",n[n.kParticleSystemSizeCurveId=2368504881]="kParticleSystemSizeCurveId",n[n.kParticleSystemSizeBySpeedCurveId=4085612399]="kParticleSystemSizeBySpeedCurveId",n[n.kParticleSystemVelocityCurveId=3774601268]="kParticleSystemVelocityCurveId",n[n.kParticleSystemUVCurveId=326370691]="kParticleSystemUVCurveId",n[n.kParticleSystemColorGradientId=1494990940]="kParticleSystemColorGradientId",n[n.kParticleSystemColorByVelocityGradientId=1089181156]="kParticleSystemColorByVelocityGradientId",n[n.kParticleSystemMeshSelectionId=3159510623]="kParticleSystemMeshSelectionId",n[n.kParticleSystemUVRowSelectionId=2941263940]="kParticleSystemUVRowSelectionId",n))(Hp||{});const tv=3.141592653589793;class rv{}function Xp(n,t,e){let r=.3333333333333333,i=.5,a=n*r,o=a*a,l=o*a-a*t*i+e*i,h=-o+t*r,u=h*h*h,c=u+l*l;if(c>=0){let p=Math.sqrt(c)-l;return p=p>0?Math.pow(p,r):-Math.pow(-p,r),-a-h/p+p}let f=Math.sqrt(-u),d=Math.acos(-l/f);return f=Math.pow(f,r),f=f-h/f,d=-a+f*Math.cos(d*r),d}function an(n,t,e,r){let i=1e-5;if(Math.abs(n)<i)return Math.abs(t)>i?(r.r0=-e/t,1):0;let a=t*t-4*n*e;if(a<0)return 0;let o=.5/n,l=Math.sqrt(a);return r.r0=(l-t)*o,r.r1=(-l-t)*o,2}function Wp(n,t,e,r,i){let a=0;if(Math.abs(t)>=1e-4){let o=e/t,l=r/t,h=i/t;n[0]=Xp(o,l,h),a++;let u=t,c=e+t*n[0],f=r+e*n[0]+t*n[0]*n[0];a+=an(u,c,f,{r0:n[1],r1:n[2]})}else a+=an(e,r,i,{r0:n[1],r1:n[2]});return a}class kr{constructor(){s(this,"coeff",[])}static EvalSegment(t,e){return t*(t*(t*e[0]+e[1])+e[2])+e[3]}}const li=class li{constructor(){s(this,"segments",[]);s(this,"integrationCache",[]);s(this,"doubleIntegrationCache",[]);s(this,"times",[]);s(this,"segmentCount");this.segments[li.kMaxNumSegments]=new kr,this.integrationCache[li.kMaxNumSegments]=0,this.doubleIntegrationCache[li.kMaxNumSegments]=0,this.times[li.kMaxNumSegments]=0}calculateMinMax(t,e){t.x=Math.min(t.x,e),t.y=Math.max(t.y,e)}findMinMaxDoubleIntegrated(){let t=he.ZERO.clone(),e=20,r=1/e,i=r;for(let a=0;a<e;a++)this.calculateMinMax(t,this.evaluateDoubleIntegrated(i)),i+=r;return t}findMinMaxIntegrated(){let t=he.ZERO.clone(),e=[],r=[];for(let i=0;i<this.segmentCount;i++){let a=4*this.segments[i].coeff[0],o=3*this.segments[i].coeff[1],l=2*this.segments[i].coeff[2],h=1*this.segments[i].coeff[3],u=[],c=Wp(u,a,o,l,h);for(let f=0;f<c;f++){let d=u[f]+e[i];d>=e[i]&&d<r[i]&&this.calculateMinMax(t,this.evaluateIntegrated(d))}this.calculateMinMax(t,this.evaluateIntegrated(r[i])),this.times[i]}return t}generateIntegrationCache(t){t.integrationCache[0]=0;let e=t.times[0],r=0;for(let i=1;i<t.segmentCount;i++){let a=t.segments[i-1].coeff;Wl(a);let o=e-r;t.integrationCache[i]=t.integrationCache[i-1]+kr.EvalSegment(o,a)*o,r=e,e=t.times[i]}}generateDoubleIntegrationCache(t){let e=0,r=0;for(let i=0;i<t.segmentCount;i++){t.doubleIntegrationCache[i]=e;let a=t.times[i]-r;a=Math.max(a,0),e+=kr.EvalSegment(a,t.segments[i].coeff)*a*a+t.integrationCache[i]*a,r=t.times[i]}}integrate(){this.generateIntegrationCache(this);for(let t=0;t<this.segmentCount;t++)Wl(this.segments[t].coeff)}doubleIntegrate(){this.generateIntegrationCache(this);for(let t=0;t<this.segmentCount;t++)Kp(this.segments[t].coeff);this.generateDoubleIntegrationCache(this)}static isValidCurve(t){let e=t.getKeyCount(),r=e-1;return t.getKey(0).time!=0&&r++,t.getKey(e-1).time!=1&&r++,r<=li.kMaxNumSegments}evaluateDoubleIntegrated(t){let e=0;for(let r=0;r<this.segmentCount;r++){if(t<=this.times[r]){let i=t-e;return this.doubleIntegrationCache[r]+this.integrationCache[r]*i+kr.EvalSegment(i,this.segments[r].coeff)*i*i}e=this.times[r]}return 1}evaluateIntegrated(t){let e=0;for(let r=0;r<this.segmentCount;r++){if(t<=this.times[r]){let i=t-e;return this.integrationCache[r]+kr.EvalSegment(i,this.segments[r].coeff)*i}e=this.times[r]}return 1}evaluate(t){let e=0;for(let r=0;r<this.segmentCount;r++){if(t<=this.times[r])return kr.EvalSegment(t-e,this.segments[r].coeff);e=this.times[r]}return 1}buildCurve(t,e){let r=t.getKeyCount();this.segmentCount=1;let i=1.01;if(this.segments.length=0,this.integrationCache.length=0,this.doubleIntegrationCache.length=0,this.times.length=0,this.times[0]=i,r!=0)if(r==1)this.segments[0]=new kr,this.segments[0].coeff[3]=t.getKey(0).value*e;else{this.segmentCount=r-1;let a=0;t.getKey(0).time!=0&&(this.segments[0].coeff[3]=t.getKey(0).value,this.times[0]=t.getKey(0).time,a=1);for(let o=0;o<this.segmentCount;o++){let l;t.calculateCacheData(l,o,o+1,0),this.segments[o+a].coeff=l.coeff.concat(),this.times[o+a]=t.getKey(o+1).time}this.segmentCount+=a,t.getKey(r-1).time!=1&&(this.segments[this.segmentCount].coeff[3]=t.getKey(r-1).value,this.segmentCount++),this.times[this.segmentCount-1]=i;for(let o=0;o<this.segmentCount;o++)this.segments[o].coeff[0]*=e,this.segments[o].coeff[1]*=e,this.segments[o].coeff[2]*=e,this.segments[o].coeff[3]*=e}return!0}};s(li,"kMaxNumSegments",null);let Ls=li;function Kp(n){n[0]/=20,n[1]/=12,n[2]/=6,n[3]/=2}function Wl(n){n[0]/=4,n[1]/=3,n[2]/=2,n[3]/=1}var jp=(n=>(n[n.kEMScalar=0]="kEMScalar",n[n.kEMOptimized=1]="kEMOptimized",n[n.kEMOptimizedMinMax=2]="kEMOptimizedMinMax",n[n.kEMSlow=3]="kEMSlow",n))(jp||{}),qp=(n=>(n[n.kMMCScalar=0]="kMMCScalar",n[n.kMMCCurve=1]="kMMCCurve",n[n.kMMCTwoCurves=2]="kMMCTwoCurves",n[n.kMMCTwoConstants=3]="kMMCTwoConstants",n))(qp||{});class iv{constructor(){s(this,"max");s(this,"min")}}class av{constructor(){s(this,"max");s(this,"min")}integrate(){this.max.integrate(),this.min.integrate()}doubleIntegrate(){this.max.doubleIntegrate(),this.min.doubleIntegrate()}findMinMaxIntegrated(){return null}findMinMaxDoubleIntegrated(){return null}}class Jp{constructor(t=1){s(this,"minMaxState");s(this,"minCurve");s(this,"maxCurve");s(this,"_scalar",1);s(this,"_minScalar");this._scalar=t,this.minMaxState=0,this.minCurve=new Fo,this.maxCurve=new Fo}setScalar(t){this._scalar=t}getScalar(){return this._scalar}static evaluateSlow(t,e,r){let i=t.maxCurve.getValue(e)*t.getScalar();return t.minMaxState==2?Ni(t.minCurve.getValue(e)*t.getScalar(),i,r):i}static evaluate(t,e,r=1){if(t.minMaxState==0)return t.getScalar();let i=t.maxCurve.getValue(e)*t.getScalar();return t.minMaxState==1?Ni(t.minCurve.getValue(e)*t.getScalar(),i,r):t.minMaxState==3?Ni(t._minScalar,t._scalar,r):t.minMaxState==2?Ni(t.minCurve.getValue(e)*t.getScalar(),i,1*Math.random()):this.evaluateSlow(t,e,1)}unSerialized(t){this.minMaxState=t.minMaxState,this._scalar=t.scalar,this._minScalar=t.minScalar,this.maxCurve.unSerialized(t.maxCurve),this.minCurve.unSerialized(t.minCurve)}}class sv{constructor(){s(this,"value",0);s(this,"mode",0);s(this,"spread",0);s(this,"speed",new Jp)}unSerialized(t){this.value=t.value,this.mode=t.mode,this.spread=t.spread,this.speed.unSerialized(t.speed)}}function ov(n,t){let e=Ls.isValidCurve(n.max);return t!=2&&t!=3?e:e&&Ls.isValidCurve(n.min)}function nv(n,t,e,r){n.max.buildCurve(t.max,e),r!=2&&r!=3?n.min.buildCurve(t.max,e):n.min.buildCurve(t.min,e)}function lv(n,t){let e=t.getKeyCount();if(e!=0)if(e==1)Os(n,t.getKey(0).value);else{let r=e-1;Os(n,t.getKey(0).value);for(let i=0;i<r;i++){let a=new gl;t.calculateCacheData(a,i,i+1,0);let o=3*a.coeff[0],l=2*a.coeff[1],h=1*a.coeff[2],u=t.getKey(i).time,c=t.getKey(i+1).time,f=[],d=an(o,l,h,{r0:f[0],r1:f[1]});for(let p=0;p<d;p++)f[p]>=0&&f[p]+u<c&&Os(n,kr.EvalSegment(f[p],a.coeff));Os(n,kr.EvalSegment(c-u,a.coeff))}}}function Os(n,t){n.x=Math.min(n.x,t),n.y=Math.max(n.y,t)}class Kl{constructor(t,e){s(this,"point",new g);s(this,"normal",g.UP);s(this,"_tmpVecA",new g);this.point=t,this.normal=e}clone(){return new Kl(this.point.clone(),this.normal.clone())}intersectsLine(t,e,r){var i=-this.normal.dotProduct(this.point),a=this.normal.dotProduct(t)+i,o=this.normal.dotProduct(e)+i,l=a/(a-o),h=l>=0&&l<=1;return h&&r&&r.lerp(t,e,l),h}intersectsRay(t,e){e||(e=this._tmpVecA),e.copy(this.point).subtract(t.origin,e);var r=this.normal.dotProduct(e)/this.normal.dotProduct(t.direction),i=r>=0;return i&&e.copyFrom(t.direction).multiplyScalar(r).add(t.origin,e),i}}class ur{}s(ur,"BACK",0),s(ur,"FRONT",1),s(ur,"IN",0),s(ur,"OUT",1),s(ur,"INTERSECT",2);class Fa{constructor(t=0,e=0,r=0,i=0){s(this,"a");s(this,"b");s(this,"c");s(this,"d");this.a=t,this.b=e,this.c=r,this.d=i}setTo(t=0,e=0,r=0,i=0){this.a=t,this.b=e,this.c=r,this.d=i}fromPoints(t,e,r){var i=e.x-t.x,a=e.y-t.y,o=e.z-t.z,l=r.x-t.x,h=r.y-t.y,u=r.z-t.z;this.a=a*u-o*h,this.b=o*l-i*u,this.c=i*h-a*l,this.d=-(this.a*t.x+this.b*t.y+this.c*t.z)}fromNormalAndPoint(t,e){this.a=t.x,this.b=t.y,this.c=t.z,this.d=-(this.a*e.x+this.b*e.y+this.c*e.z)}normalize(){var t=Math.sqrt(this.a*this.a+this.b*this.b+this.c*this.c);if(t>0){var e=1/t;this.a*=e,this.b*=e,this.c*=e,this.d*=e}return t}distance(t){return this.a*t.x+this.b*t.y+this.c*t.z+this.d}classifyPoint(t,e=.01){var r=this.distance(t);return r<-e?ur.BACK:r>e?ur.FRONT:ur.INTERSECT}toString(){return"Plane3D [a:"+this.a+", b:"+this.b+", c:"+this.c+", d:"+this.d+"]"}}s(Fa,"ALIGN_ANY",null),s(Fa,"ALIGN_XY_AXIS",null),s(Fa,"ALIGN_YZ_AXIS",null),s(Fa,"ALIGN_XZ_AXIS",null);function hv(n,t){return Math.random()*t+Math.random()*n+(t-n)*Math.random()}function uv(n,t,e){let r=e*Math.random();return Math.random()*t*r+Math.random()*n*r+(t-n)*Math.random()*r}function Zp(n,t,e){let r=0,i=0;for(;r===0;)r=Math.random();for(;i===0;)i=Math.random();let a=Math.sqrt(-2*Math.log(r))*Math.cos(2*Math.PI*i);return a=a/10+.5,(a>1||a<0)&&(a=Zp(n,t,e)),a=Math.pow(a,e),a*=t-n,a+=n,a}function Tr(n){return n>0?Math.floor(n):Math.floor(n)-1}let le=null;function jl(n,t){let e=n&15,r=1+(e&7);return e&8&&(r=-r),r*t}function sn(n,t,e){let r=n&7,i=r<4?t:e,a=r<4?e:t;return(r&1?-i:i)+(r&2?-2*a:2*a)}function Ns(n,t,e,r){let i=n&15,a=i<8?t:e,o=i<4?e:i==12||i==14?t:r;return(i&1?-a:a)+(i&2?-o:o)}function ka(n,t,e,r,i){let a=n&31,o=a<24?t:e,l=a<16?e:r,h=a<8?r:i;return(a&1?-o:o)+(a&2?-l:l)+(a&4?-h:h)}let er=null;function cv(n){let t=Tr(n),e=t+1,r=n-t,i=r-1,a,o,l=1-r*r;l*=l,a=l*l*jl(le[t&255],r);let h=1-i*i;return h*=h,o=h*h*jl(le[e&255],i),.25*(a+o)}function fv(n,t){const e=.366025403,r=.211324865;let i,a,o,l=(n+t)*e,h=n+l,u=t+l,c=Tr(h),f=Tr(u),d=(c+f)*r,p=c-d,A=f-d,x=n-p,C=t-A,v,y;x>C?(v=1,y=0):(v=0,y=1);let b=x-v+r,B=C-y+r,I=x-1+2*r,w=C-1+2*r,D=c&255,L=f&255,M=.5-x*x-C*C;M<0?i=0:(M*=M,i=M*M*sn(le[D+le[L]],x,C));let G=.5-b*b-B*B;G<0?a=0:(G*=G,a=G*G*sn(le[D+v+le[L+y]],b,B));let N=.5-I*I-w*w;return N<0?o=0:(N*=N,o=N*N*sn(le[D+1+le[L+1]],I,w)),40*(i+a+o)}function dv(n,t,e){const r=.333333333,i=.166666667;let a,o,l,h,u=(n+t+e)*r,c=n+u,f=t+u,d=e+u,p=Tr(c),A=Tr(f),x=Tr(d),C=(p+A+x)*i,v=p-C,y=A-C,b=x-C,B=n-v,I=t-y,w=e-b,D,L,M,G,N,q;B>=I?I>=w?(D=1,L=0,M=0,G=1,N=1,q=0):B>=w?(D=1,L=0,M=0,G=1,N=0,q=1):(D=0,L=0,M=1,G=1,N=0,q=1):I<w?(D=0,L=0,M=1,G=0,N=1,q=1):B<w?(D=0,L=1,M=0,G=0,N=1,q=1):(D=0,L=1,M=0,G=1,N=1,q=0);let ie=B-D+i,ue=I-L+i,Ee=w-M+i,Ie=B-G+2*i,Ne=I-N+2*i,Qe=w-q+2*i,xe=B-1+3*i,Ve=I-1+3*i,we=w-1+3*i,Ye=p&255,vt=A&255,xt=x&255,Nt=.6-B*B-I*I-w*w;Nt<0?a=0:(Nt*=Nt,a=Nt*Nt*Ns(le[Ye+le[vt+le[xt]]],B,I,w));let Ke=.6-ie*ie-ue*ue-Ee*Ee;Ke<0?o=0:(Ke*=Ke,o=Ke*Ke*Ns(le[Ye+D+le[vt+L+le[xt+M]]],ie,ue,Ee));let nt=.6-Ie*Ie-Ne*Ne-Qe*Qe;nt<0?l=0:(nt*=nt,l=nt*nt*Ns(le[Ye+G+le[vt+N+le[xt+q]]],Ie,Ne,Qe));let mr=.6-xe*xe-Ve*Ve-we*we;return mr<0?h=0:(mr*=mr,h=mr*mr*Ns(le[Ye+1+le[vt+1+le[xt+1]]],xe,Ve,we)),32*(a+o+l+h)}function gv(n,t,e,r){const i=.309016994,a=.138196601;let o,l,h,u,c,f=(n+t+e+r)*i,d=n+f,p=t+f,A=e+f,x=r+f,C=Tr(d),v=Tr(p),y=Tr(A),b=Tr(x),B=(C+v+y+b)*a,I=C-B,w=v-B,D=y-B,L=b-B,M=n-I,G=t-w,N=e-D,q=r-L,ie=M>G?32:0,ue=M>N?16:0,Ee=G>N?8:0,Ie=M>q?4:0,Ne=G>q?2:0,Qe=N>q?1:0,xe=ie+ue+Ee+Ie+Ne+Qe,Ve,we,Ye,vt,xt,Nt,Ke,nt,mr,Ya,ia,aa;Ve=er[xe][0]>=3?1:0,we=er[xe][1]>=3?1:0,Ye=er[xe][2]>=3?1:0,vt=er[xe][3]>=3?1:0,xt=er[xe][0]>=2?1:0,Nt=er[xe][1]>=2?1:0,Ke=er[xe][2]>=2?1:0,nt=er[xe][3]>=2?1:0,mr=er[xe][0]>=1?1:0,Ya=er[xe][1]>=1?1:0,ia=er[xe][2]>=1?1:0,aa=er[xe][3]>=1?1:0;let sa=M-Ve+a,Ha=G-we+a,Pr=N-Ye+a,Xa=q-vt+a,Wa=M-xt+2*a,Ka=G-Nt+2*a,ja=N-Ke+2*a,qa=q-nt+2*a,oa=M-mr+3*a,hi=G-Ya+3*a,Ja=N-ia+3*a,Za=q-aa+3*a,na=M-1+4*a,$a=G-1+4*a,es=N-1+4*a,ts=q-1+4*a,Bi=C&255,Di=v&255,Mi=y&255,Pi=b&255,ui=.6-M*M-G*G-N*N-q*q;ui<0?o=0:(ui*=ui,o=ui*ui*ka(le[Bi+le[Di+le[Mi+le[Pi]]]],M,G,N,q));let Ri=.6-sa*sa-Ha*Ha-Pr*Pr-Xa*Xa;Ri<0?l=0:(Ri*=Ri,l=Ri*Ri*ka(le[Bi+Ve+le[Di+we+le[Mi+Ye+le[Pi+vt]]]],sa,Ha,Pr,Xa));let Ui=.6-Wa*Wa-Ka*Ka-ja*ja-qa*qa;Ui<0?h=0:(Ui*=Ui,h=Ui*Ui*ka(le[Bi+xt+le[Di+Nt+le[Mi+Ke+le[Pi+nt]]]],Wa,Ka,ja,qa));let Li=.6-oa*oa-hi*hi-Ja*Ja-Za*Za;Li<0?u=0:(Li*=Li,u=Li*Li*ka(le[Bi+mr+le[Di+Ya+le[Mi+ia+le[Pi+aa]]]],oa,hi,Ja,Za));let Oi=.6-na*na-$a*$a-es*es-ts*ts;return Oi<0?c=0:(Oi*=Oi,c=Oi*Oi*ka(le[Bi+1+le[Di+1+le[Mi+1+le[Pi+1]]]],na,$a,es,ts)),27*(o+l+h+u+c)}const Ys=class Ys extends he{constructor(e=0,r=0){super(e,r);s(this,"u",0);s(this,"v",0);this.u=e,this.v=r}length(){return 0}static getUVSheet(e,r,i){let a=Math.floor(e%(r*i)),o=Math.floor(a/r),l=a%r;return new ae(o/r,l/i,1/r,1/i)}};s(Ys,"uv_0",new Ys);let ql=Ys;class Fs{constructor(t=0){s(this,"serializedVersion","2");s(this,"time");s(this,"tangentMode",0);s(this,"weightedMode",0);s(this,"propertyKeyFrame");this.time=t,this.propertyKeyFrame={}}getK(t){return this.propertyKeyFrame[t]}split(t,e,r){switch(t){case Y.single:{let i=this.getKeyFrame(0);i[r]=e}break;case Y.float:{let i=this.getKeyFrame(0);i[r]=e}break;case Y.vector2:{let i=e,a=this.getKeyFrame(0);a[r]=i.x;let o=this.getKeyFrame(1);o[r]=i.y}break;case Y.vector3:{let i=e,a=this.getKeyFrame(0);a[r]=i.x;let o=this.getKeyFrame(1);o[r]=i.y;let l=this.getKeyFrame(2);l[r]=i.z}break;case Y.vector4:{let i=e,a=this.getKeyFrame(0);a[r]=i.x;let o=this.getKeyFrame(1);o[r]=i.y;let l=this.getKeyFrame(2);l[r]=i.z;let h=this.getKeyFrame(3);h[r]=i.w}break;case Y.quaternion:{let i=e,a=this.getKeyFrame(0);a[r]=i.x;let o=this.getKeyFrame(1);o[r]=i.y;let l=this.getKeyFrame(2);l[r]=i.z;let h=this.getKeyFrame(3);h[r]=i.w}break}}getKeyFrame(t){let e=this.propertyKeyFrame[t];return e||(e=new No,e.time=this.time,e.tangentMode=this.tangentMode,e.weightedMode=this.weightedMode,this.propertyKeyFrame[t]=e),e}formBytes(t){this.time=t.readFloat32();{let{t:e,v:r}=Fr.parser(t);this.split(e,r,"value")}{let{t:e,v:r}=Fr.parser(t);this.split(e,r,"inSlope")}{let{t:e,v:r}=Fr.parser(t);this.split(e,r,"outSlope")}this.tangentMode=t.readInt32(),this.weightedMode=t.readInt32();{let{t:e,v:r}=Fr.parser(t);this.split(e,r,"inWeight")}{let{t:e,v:r}=Fr.parser(t);this.split(e,r,"outWeight")}}}class pv{static sub(t,e){switch(t.constructor.name){case"number":return t-e;case"Vector2":{let r=t,i=e;return new he(r.x-i.x,r.y-i.y)}case"Vector3":{let r=t,i=e;return new g(r.x-i.x,r.y-i.y,r.z-i.z)}case"Vector4":{let r=t,i=e;return new ae(r.x-i.x,r.y-i.y,r.z-i.z,r.w-i.w)}case"Quaternion":{let r=t,i=e;return new Z(r.x-i.x,r.y-i.y,r.z-i.z,r.w-i.w)}}}}class ks{constructor(){s(this,"_keys",new Array);s(this,"_values",new Array)}getIndexByKey(t){return this._keys.indexOf(t)}getValueByKey(t){var e=this.getIndexByKey(t);return e>-1?this._values[e]:null}put(t,e){if(t==null)return null;var r=this.remove(t);return this._keys.push(t),this._values.push(e),r}remove(t){var e=this._keys.indexOf(t),r;return e>-1&&(r=this._values[e],this._keys.splice(e,1),this._values.splice(e,1)),r}getValues(){return this._values}getKeys(){return this._keys}clear(){this._values.length=0,this._keys.length=0}}class ii{}s(ii,"WalkAble",1);const ra=class ra{static SetConst(t){this.EPSILON=t,this.POWER_EPSILON=t*t}};s(ra,"EPSILON",.1),s(ra,"POWER_EPSILON",ra.EPSILON*ra.EPSILON);let qi=ra;const Hr=class Hr extends g{constructor(e,r,i,a){super(r,i,a,0);s(this,"_pointId",0);this._pointId=e}get id(){return this._pointId}static equalPoint(e,r){return(e.x-r.x)*(e.x-r.x)+(e.y-r.y)*(e.y-r.y)+(e.z-r.z)*(e.z-r.z)<qi.POWER_EPSILON}static calcDistance(e,r){return Hr.CALC_VECTOR3D3.setTo(e.x-r.x,e.y-r.y,e.z-r.z),Hr.CALC_VECTOR3D3.length}};s(Hr,"CALC_VECTOR3D1",new g),s(Hr,"CALC_VECTOR3D2",new g),s(Hr,"CALC_VECTOR3D3",new g),s(Hr,"CALC_VECTOR3D4",new g),s(Hr,"CALC_VECTOR3D5",new g);let Ut=Hr;class $p{constructor(){s(this,"_openedList");s(this,"_closedList");s(this,"_endNode");s(this,"_startNode");s(this,"_triangleChannel");s(this,"_navMesh");s(this,"_findIndex",0);this._openedList=new Array,this._closedList=new Array}findPath(t,e,r){return this._findIndex++,this._navMesh=t,this._startNode=e,this._endNode=r,this._openedList.length=0,this._closedList.length=0,this._startNode&&this._endNode?(this._startNode.gg=0,this._startNode.h=0,this._startNode.f=0,this._startNode.parent=null,this.search()):!1}search(){for(var t=this._startNode,e=[],r;t!=this._endNode;){e=t.getNeibourTriangles(e,ii.WalkAble,ii.WalkAble);for(r of e)if(r.closeId!=this._findIndex&&!(r==t||!r.walkAble)){var i=t.gg+Ut.calcDistance(r,t)*r.costMultiplier,a=Ut.calcDistance(r,this._endNode),o=i+a;r.openId==this._findIndex?r.f>o&&(r.f=o,r.gg=i,r.h=a,r.parent=t):(r.f=o,r.gg=i,r.h=a,r.parent=t,r.openId=this._findIndex,this._openedList.push(r))}if(t.closeId=this._findIndex,this._closedList.push(t),this._openedList.length==0)return!1;this._openedList.sort(function(l,h){return l.f-h.f}),t=this._openedList.shift()}return this.buildPath(),!0}buildPath(){this._triangleChannel=[];var t=this._endNode;for(this._triangleChannel.push(t);t!=this._startNode;)t=t.parent,this._triangleChannel.unshift(t)}get channel(){return this._triangleChannel}}class Er extends Ut{constructor(e,r){super(e.id,0,0,0);s(this,"_ownerPoint");s(this,"_ownerEdge");s(this,"radius",0);this._ownerEdge=r,this._ownerPoint=e}get ownerPoint(){return this._ownerPoint}get ownerEdge(){return this._ownerEdge}scalePoint(e=.7){var r=new Er(this._ownerPoint,this._ownerEdge);return r.copyFrom(this),r.decrementBy(this._ownerPoint),r.scaleBy(e),r.radius=r.length,r.incrementBy(this._ownerPoint),r}}const pr=class pr{constructor(t,e){s(this,"_edgeMask",0);s(this,"_edgeSize",0);s(this,"_pointA");s(this,"_pointB");s(this,"_triangleOwners");s(this,"_centerPoint");s(this,"_edgeDirA2B");s(this,"crossPoint");s(this,"fatPointA");s(this,"fatPointB");if(this._pointA=t,this._pointB=e,t.id>=e.id)throw new Error("edge point order error!!!");this._triangleOwners=new Array,this._centerPoint=new g,this._edgeMask=ii.WalkAble,Ut.CALC_VECTOR3D1.setTo(t.x-e.x,t.y-e.y,t.z-e.z),this._edgeSize=Ut.CALC_VECTOR3D1.length,this._centerPoint.setTo((t.x+e.x)/2,(t.y+e.y)/2,(t.z+e.z)/2)}get size(){return this._edgeSize}get triangleOwners(){return this._triangleOwners}get centerPoint(){return this._centerPoint}initFatPoints(t){this._edgeDirA2B=this._pointB.subtract(this._pointA),this._edgeDirA2B.normalize(),this.fatPointA=this.fatPointA||new Er(this._pointA,this),this.fatPointB=this.fatPointB||new Er(this._pointB,this),this.fatPointA.radius!=t&&(pr.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B),pr.CALC_FAT_VECTOR.scaleBy(t),pr.CALC_FAT_VECTOR.incrementBy(this._pointA),this.fatPointA.copyFrom(pr.CALC_FAT_VECTOR),this.fatPointA.radius=t),this.fatPointB.radius!=t&&(pr.CALC_FAT_VECTOR.copyFrom(this._edgeDirA2B),pr.CALC_FAT_VECTOR.scaleBy(-t),pr.CALC_FAT_VECTOR.incrementBy(this._pointB),this.fatPointB.copyFrom(pr.CALC_FAT_VECTOR),this.fatPointB.radius=t)}getFatPoint(t){return t==this._pointA?this.fatPointA:this.fatPointB}getAnotherFatPoint(t){return t==this._pointA?this.fatPointB:this.fatPointA}getAnotherPoint(t){return t==this._pointA?this._pointB:this._pointA}containsPoint(t){return Ut.equalPoint(t,this._pointA)?this._pointA:Ut.equalPoint(t,this._pointB)?this._pointB:null}addTriangleOwners(t){if(t.edges.indexOf(this)==-1)throw new Error("the edge is not belong triangle!!!");this._triangleOwners.indexOf(t)==-1&&this._triangleOwners.push(t)}getPublicPoint(t){return this._pointA==t._pointA||this._pointA==t._pointB?this._pointA:this._pointB==t._pointA||this._pointB==t._pointB?this._pointB:null}getEqualPoint(t){return Ut.equalPoint(t,this._pointA)?this._pointA:Ut.equalPoint(t,this._pointB)?this._pointB:null}get pointA(){return this._pointA}get pointB(){return this._pointB}get walkAble(){return(this._edgeMask&ii.WalkAble)==ii.WalkAble}testMask(t){return(this._edgeMask&t)==t}};s(pr,"CALC_FAT_VECTOR",new g);let on=pr;const te=class te{constructor(){s(this,"endPoint");s(this,"curPoint");s(this,"rayA");s(this,"rayB");s(this,"rayAPoint");s(this,"rayBPoint");s(this,"cornerPoint");s(this,"cornerEdge")}continuePass(t,e,r){this.resetData(),this.curPoint=t,this.endPoint=e,this.cornerEdge=r}passEdge(t,e,r,i){if((this.rayA==null||this.rayB==null)&&(this.rayA=te.RAY_1,this.rayB=te.RAY_2,this.rayAPoint=t.pointA,this.rayBPoint=t.pointB,this.rayA.setTo(this.rayAPoint.x-this.curPoint.x,0,this.rayAPoint.z-this.curPoint.z),this.rayB.setTo(this.rayBPoint.x-this.curPoint.x,0,this.rayBPoint.z-this.curPoint.z)),i)return this.checkEndPoint(r);if(te.TEST_RAY.setTo(r.x-this.curPoint.x,0,r.z-this.curPoint.z),this.isPointAtCenter(te.TEST_RAY,this.rayA,this.rayB)){this.hasCrossPoint(e.pointA,e.pointB,this.rayAPoint,this.rayA)?(this.rayB.copyFrom(te.TEST_RAY),r instanceof Ut?this.rayBPoint=r:this.rayBPoint=null):(this.rayA.copyFrom(te.TEST_RAY),r instanceof Ut?this.rayAPoint=r:this.rayAPoint=null);var a=e.getAnotherPoint(r);te.TEST_RAY.setTo(a.x-this.curPoint.x,0,a.z-this.curPoint.z),(a==this.rayAPoint||a==this.rayBPoint||this.isPointAtCenter(te.TEST_RAY,this.rayA,this.rayB))&&(this.cornerEdge=e)}else{var o;if(te.TEST_RAY_1.copyFrom(e.pointA),te.TEST_RAY_1.decrementBy(this.curPoint),te.TEST_RAY_2.copyFrom(e.pointB),te.TEST_RAY_2.decrementBy(this.curPoint),te.TEST_RAY_1.y=0,te.TEST_RAY_2.y=0,this.isPointAtCenter(this.rayA,te.TEST_RAY_1,te.TEST_RAY_2)||this.isPointAtCenter(this.rayB,te.TEST_RAY_1,te.TEST_RAY_2)?o=!1:o=!0,o)return this.isPointAtCenter(this.rayA,te.TEST_RAY,this.rayB)?this.cornerPoint=this.rayAPoint:this.cornerPoint=this.rayBPoint,this.cornerEdge.crossPoint=this.cornerPoint,!1}return!0}checkEndPoint(t){return te.TEST_RAY.setTo(t.x-this.curPoint.x,0,t.z-this.curPoint.z),this.isPointAtCenter(te.TEST_RAY,this.rayA,this.rayB)?!0:(this.isPointAtCenter(this.rayA,te.TEST_RAY,this.rayB)?this.cornerPoint=this.rayAPoint:this.cornerPoint=this.rayBPoint,this.cornerEdge.crossPoint=this.cornerPoint,!1)}calcCrossEdge(t,e,r){return this.calcCrossPoint(t.fatPointA,t.fatPointB,e,r)}calcCrossPoint(t,e,r,i){te.CALC_CROSS_POINT.copyFrom(e),te.CALC_CROSS_POINT.decrementBy(t);let a=te.CALC_CROSS_POINT.x*i.z-i.x*te.CALC_CROSS_POINT.z;var o=0;return a!=0&&(o=((t.z-r.z)*i.x-(t.x-r.x)*i.z)/a),o>1?o=1:o<0&&(o=0),te.CALC_CROSS_POINT.scaleBy(o),te.CALC_CROSS_POINT.incrementBy(t),te.CALC_CROSS_POINT.clone()}calcCrossPointOut(t,e,r,i){te.CALC_CROSS_POINT.copyFrom(e),te.CALC_CROSS_POINT.decrementBy(t);var a=((t.z-r.z)*i.x-(t.x-r.x)*i.z)/(te.CALC_CROSS_POINT.x*i.z-i.x*te.CALC_CROSS_POINT.z);return a<=1&&a>=0?null:(te.CALC_CROSS_POINT.scaleBy(a),te.CALC_CROSS_POINT.incrementBy(t),te.CALC_CROSS_POINT.clone())}hasCrossPoint(t,e,r,i){te.CALC_CROSS_TEST.copyFrom(e),te.CALC_CROSS_TEST.decrementBy(t);var a=((t.z-r.z)*i.x-(t.x-r.x)*i.z)/(te.CALC_CROSS_TEST.x*i.z-i.x*te.CALC_CROSS_TEST.z);return a<=1&&a>=0}isPointAtCenter(t,e,r){var i=e.crossProduct(t);if(i.length==0&&t.length<e.length)return!0;var a=r.crossProduct(t);return a.length==0&&t.length<r.length?!0:(i.normalize(),a.normalize(),i.incrementBy(a),i.length<.01)}resetData(){this.cornerEdge=null,this.cornerPoint=null,this.curPoint=null,this.rayA=this.rayB=null,this.rayAPoint=this.rayBPoint=null,te.RAY_1.setTo(0,0,0),te.RAY_2.setTo(0,0,0)}};s(te,"RAY_1",new g),s(te,"RAY_2",new g),s(te,"TEST_RAY",new g),s(te,"TEST_RAY_1",new g),s(te,"TEST_RAY_2",new g),s(te,"CALC_CROSS_POINT",new g),s(te,"CALC_CROSS_TEST",new g);let nn=te;const Xr=class Xr{constructor(){s(this,"_aiRadius",0);s(this,"_router");s(this,"_result");s(this,"_tempPublicEdgeList",new Array);s(this,"_tempSamePlaneList",new Array);this._router=new nn}searchPath(t,e,r,i=0){return i<=0&&(i=1),this._aiRadius=i*1.5,this.searchEnable(t,e,r)?(this.search(t,e,r),!0):!1}get path(){return this._result}searchEnable(t,e,r){return!(t==null||e==null||r==null||r[0].plane.classifyPoint(t,qi.EPSILON)!=ur.INTERSECT||r[r.length-1].plane.classifyPoint(e,qi.EPSILON)!=ur.INTERSECT)}search(t,e,r){this._tempPublicEdgeList.length=0,this._tempSamePlaneList.length=0;var i=0,a=r.length-1,o,l,h,u;for(i=0;i<a;i++)l=r[i].getPublicEdge(r[i+1]),l.crossPoint=null,l.initFatPoints(this._aiRadius),this._tempPublicEdgeList.push(l),o=r[i],u=o.plane,o=r[i+1],h=o.getEdgeAgainstPoint(l),this._tempSamePlaneList.push(u.classifyPoint(h,qi.EPSILON)==ur.INTERSECT);this._router.continuePass(t,e,this._tempPublicEdgeList[0]),a=this._tempPublicEdgeList.length;var c,f,d,p;for(i=0;i<a;i++)l=this._tempPublicEdgeList[i],o=r[i+1],p=i==a-1,p?h=e:h=o.getEdgeAgainstPoint(l),d=this._router.passEdge(l,this._tempPublicEdgeList[i+1],h,p),d||(c=this._router.cornerPoint,f=this._router.cornerEdge,i=this._tempPublicEdgeList.indexOf(f),this._router.continuePass(c,e,this._tempPublicEdgeList[i+1]));this.pushAllPathPoint2(t,e),this._result.length>=3&&(this.optimusTerminusFat(),this.optimusByRadius());let A=[];for(let x of this._result)A.push(new g().copyFrom(x));this._result=A}optimusTerminusFat(){var t,e,r;r=this._result[1],r instanceof Er&&(t=r),r=this._result[this._result.length-2],r instanceof Er&&(e=r),t&&(this._result[1]=t.scalePoint()),e&&t!=e&&(this._result[this._result.length-2]=e.scalePoint())}pushAllPathPoint2(t,e){var r=this._tempPublicEdgeList.length,i,a;this._result=new Array,this._result.push(t);for(var o=t,l,h,u,c=0;c<r;c++)if(i=this._tempPublicEdgeList[c],h=null,i.crossPoint)h=this.getFatPoint(i,i.crossPoint),h?this._result.push(h):this._result.push(i.crossPoint),o=i.crossPoint;else{a=null,l=null;for(var f=c+1;f<r&&(a=this._tempPublicEdgeList[f],l=a.crossPoint,!l);f++);l==null&&(l=e),h=this.getFatPoint(i,l),h?this._result.push(h):(l==o?u=l.clone():(Xr.CROSS_TEST_DIRECTION.setTo(l.x-o.x,0,l.z-o.z),u=this._router.calcCrossEdge(i,o,Xr.CROSS_TEST_DIRECTION)),this._result.push(u))}this._result.push(e)}optimusByRadius(){var t=new Array;t.length=this._result.length;var e=this._result.length-2,r,i,a,o,l,h,u,c,f,d,p,A,x;for(x=0;x<e;x++)u=c=f=null,o=l=h=null,p=!1,A=null,r=this._result[x],i=this._result[x+1],a=this._result[x+2],r instanceof Er&&(o=r),i instanceof Er&&(l=i),a instanceof Er&&(h=a),o&&(u=o.ownerPoint),l&&(c=l.ownerPoint),h&&(f=h.ownerPoint),u&&c&&u==c&&c!=f&&(p=!0),f&&c&&f==c&&u!=c&&(p=!0),p&&(Xr.CROSS_TEST_DIRECTION.copyFrom(r),Xr.CROSS_TEST_DIRECTION.decrementBy(a),d=l.ownerEdge,p=this._router.hasCrossPoint(d.pointA,d.pointB,a,Xr.CROSS_TEST_DIRECTION),p&&(A=this._router.calcCrossPointOut(c,i,a,Xr.CROSS_TEST_DIRECTION)),A&&(t[x+1]=A))}getFatPoint(t,e){if(t==null)return null;var r;e instanceof Er&&(r=e);var i;return r?i=r.ownerPoint:i=t.getEqualPoint(e),i==null?null:(r=t.getFatPoint(i),r)}};s(Xr,"CROSS_TEST_DIRECTION",new g);let ln=Xr;class mv{constructor(){s(this,"vertex");s(this,"indices")}merge(t,e=.1){let r=t.getAttribute(O.position).data;this.makeOriginVertex(r);let i=new Map,a=[],o=0;for(let h=0,u=this.vertex.length;h<u;h++){let c=this.vertex[h],f=-1;i.forEach((d,p)=>{g.distance(d,c)<e&&(f=p)}),f>-1?(a[h]=f,o++):(i.set(h,c),a[h]=h)}console.log("mergePointCount\uFF1A",o),this.indices=[];let l=t.getAttribute(O.indices).data;for(const h of l)this.indices.push(a[h]);return this}parse(t){let e=t.getAttribute(O.position).data;this.makeOriginVertex(e),this.indices=[];let r=t.getAttribute(O.indices).data;for(const i of r)this.indices.push(i);return this}makeOriginVertex(t){this.vertex=[];for(let e=0,r=t.length/3;e<r;e++){let i=new g(t[e*3],t[e*3+1],t[e*3+2]);this.vertex.push(i)}}}class em extends null{constructor(e,r,i,a){super(0,0,0,0);s(this,"_id",0);s(this,"_plane");s(this,"_points",new Array);s(this,"_edges",new Array);s(this,"_neibourTriangles",new ks);s(this,"_pointAgainstEdge",new ks);s(this,"_edgeAgainstPoint",new ks);s(this,"_mask",0);s(this,"_aabbBox");s(this,"f",0);s(this,"gg",0);s(this,"h",0);s(this,"parent");s(this,"costMultiplier",1);s(this,"openId",0);s(this,"closeId",0);this._id=e,this._mask=ii.WalkAble,this._edges.push(r,i,a);var o;for(o of this._edges)this._points.indexOf(o.pointA)==-1&&this._points.push(o.pointA),this._points.indexOf(o.pointB)==-1&&this._points.push(o.pointB);this.x=(this._points[0].x+this._points[1].x+this._points[2].x)/3,this.y=(this._points[0].y+this._points[1].y+this._points[2].y)/3,this.z=(this._points[0].z+this._points[1].z+this._points[2].z)/3,this._plane=new Fa,this._plane.fromPoints(this._points[0],this._points[1],this._points[2]),this._plane.normalize(),this.genarateAgainstData(),this.initAABB()}get aabb(){return this._aabbBox}initAABB(){this._aabbBox=new Ii,this._aabbBox.addPoint(this._points[0]),this._aabbBox.addPoint(this._points[1]),this._aabbBox.addPoint(this._points[2])}calcGlobalQuadAABB(){}get isTriangle(){return!0}genarateAgainstData(){var e,r;for(e of this._edges)for(r of this._points)e.pointA!=r&&e.pointB!=r&&(this._edgeAgainstPoint.put(e,r),this._pointAgainstEdge.put(r,e))}get id(){return this._id}get plane(){return this._plane}get points(){return this._points}addNeibour(e,r){if(this._edges.indexOf(e)>=0)this._neibourTriangles.put(e,r);else throw new Error("the edge is not in triangle!!!")}getNeibourTriangles(e=null,r=1,i=1){e=e||new Array,e.length=0;var a,o,l=this._neibourTriangles.getKeys(),h;for(h of l)o=h,o.testMask(r)&&(a=this._neibourTriangles.getValueByKey(o),a.testMask(i)&&e.push(a));return e}getEdges(e=null,r=1){e=e||new Array,e.length=0;var i;for(i of this._edges)i.testMask(r)&&e.push(i);return e}get walkAble(){return this.testMask(ii.WalkAble)}get edges(){return this._edges}testMask(e){return(this._mask&e)==e}getEdgeAgainstPoint(e){return this._edgeAgainstPoint.getValueByKey(e)}getPointAgainstEdge(e){return this._pointAgainstEdge.getValueByKey(e)}getPublicEdge(e){if(e&&e!=this){var r=this._neibourTriangles.getKeys(),i;for(i of r)if(this._neibourTriangles.getValueByKey(i)==e)return i}return null}loopPublicEdge(e){var r,i;if(e&&e!=this){for(r of this._edges)for(i of e._edges)if(r==i)return r}return null}randomPoint(){var e=this._points[2].subtract(this._points[0]);e.scaleBy(Math.random()),e.incrementBy(this._points[0]);var r=this._points[1].subtract(e);return r.scaleBy(Math.random()),r.incrementBy(e),r}}class Av{constructor(t,e){s(this,"_nav3dPoints");s(this,"_nav3dEdges");s(this,"_nav3dTriangles");s(this,"_path");s(this,"_edgesDict");s(this,"_nav3dAstar");s(this,"_nav3dFunnel");s(this,"_terrainQuad");s(this,"_triangleList");this._nav3dPoints=new Array,this._nav3dEdges=new Array,this._nav3dTriangles=new Array,this._edgesDict=new ks,this.initPoints(t),this.initEdgesAndTriangles(e),this.createConnections(),this._nav3dAstar=new $p,this._nav3dFunnel=new ln,this._terrainQuad=new hp(8,128),this._terrainQuad.createQuadTree(this._nav3dTriangles)}get edges(){return this._nav3dEdges}get points(){return this._nav3dPoints}get path(){return this._path}get triangles(){return this._nav3dTriangles}getTriangleAtPoint(t,e=5){return this._terrainQuad.getTriangleAtPoint(t,e)}findPath(t,e,r=5){this._path=null,this._triangleList=null;var i=this.getTriangleAtPoint(t,10),a=this.getTriangleAtPoint(e,10),o=this._nav3dAstar.findPath(this,i,a);return o?(this._triangleList=this._nav3dAstar.channel,o=this._nav3dFunnel.searchPath(t,e,this._triangleList,r),this._path=this._nav3dFunnel.path,o):!1}initPoints(t){for(var e,r,i=t.length,a=0;a<i;a++)e=t[a],r=new Ut(a,e.x,e.y,e.z),this._nav3dPoints.push(r)}initEdgesAndTriangles(t){for(var e,r,i,a,o,l=t.length,h=0;h<l;h++)e=t[h],r=this.tryCreateEdge(e[0],e[1]),i=this.tryCreateEdge(e[1],e[2]),a=this.tryCreateEdge(e[2],e[0]),!(r==null||i==null||a==null)&&(o=new em(h,r,i,a),this._nav3dTriangles.push(o))}tryCreateEdge(t,e){if(t==e)throw new Error("edge point index error!!!");if(t>e){var r=t;t=e,e=r}var i=this._edgesDict.getValueByKey(t+"_"+e);return i==null&&(i=new on(this._nav3dPoints[t],this._nav3dPoints[e]),this._nav3dEdges.push(i),this._edgesDict.put(t+"_"+e,i)),i}createConnections(){for(var t=this._nav3dTriangles.length,e=this._nav3dTriangles.length,r,i,a,o,l=0;l<t;l++){r=this._nav3dTriangles[l];for(a of r.edges)a.addTriangleOwners(r);for(var h=0;h<e;h++)i=this._nav3dTriangles[h],r!=i&&(o=r.loopPublicEdge(i),o&&(r.addNeibour(o,i),i.addNeibour(o,r)))}}}class Jl{constructor(){s(this,"x");s(this,"y")}setTo(t,e){this.x=t,this.y=e}equals(t,e){return t==this.x&&e==this.y}equalPoint(t){return this.equals(t.x,t.y)}get length(){return Math.sqrt(this.x*this.x+this.y*this.y)}clone(){var t=new Jl;return t.setTo(this.x,this.y),t}normalize(){var t=length;t!=0&&this.setTo(this.x/t,this.y/t)}}class Br extends qt{constructor(e=1,r=1,i=1){super();s(this,"width");s(this,"height");s(this,"depth");this.width=e,this.height=r,this.depth=i,this.initVertex()}initVertex(){let e=this.width/2,r=this.height/2,i=this.depth/2;this.bounds=new Oe(g.ZERO.clone(),new g(this.width,this.height,this.depth));let a=new Float32Array([-e,r,i,e,r,i,e,r,-i,-e,r,-i,-e,r,i,e,r,-i,e,-r,i,-e,-r,i,-e,-r,-i,e,-r,-i,e,-r,i,-e,-r,-i,-e,-r,i,-e,r,i,-e,r,-i,-e,-r,-i,-e,-r,i,-e,r,-i,e,r,i,e,-r,i,e,-r,-i,e,r,-i,e,r,i,e,-r,-i,e,r,i,-e,r,i,-e,-r,i,-e,-r,i,e,-r,i,e,r,i,e,-r,-i,-e,-r,-i,-e,r,-i,e,r,-i,e,-r,-i,-e,r,-i]),o=new Float32Array([0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1,0,0,-1]),l=new Float32Array([1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,0,1,1,0,0,1,1,0,1,0,0,0,0,1,0,1,1,1,1,0,1,0,0,1,0,1,1,0,0]),h=[0,2,1,3,5,4,6,8,7,9,11,10,12,14,13,15,17,16,18,20,19,21,23,22,24,26,25,27,29,28,30,32,31,33,35,34],u=new Uint16Array(h.reverse());this.setIndices(u),this.setAttribute(O.position,a),this.setAttribute(O.normal,o),this.setAttribute(O.uv,l),this.setAttribute(O.TEXCOORD_1,l),this.addSubGeometry({indexStart:0,indexCount:h.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class tm extends null{constructor(e=1,r=1,i=1,a=8,o=8,l=!1,h=0,u=Math.PI*2){super();s(this,"radiusTop");s(this,"radiusBottom");s(this,"height");s(this,"radialSegments");s(this,"heightSegments");s(this,"openEnded");s(this,"thetaStart");s(this,"thetaLength");this.radiusTop=e,this.radiusBottom=r,this.height=i,this.radialSegments=a,this.heightSegments=o,this.openEnded=l,this.thetaStart=h,this.thetaLength=u,this.instanceID=kt(),this.buildGeometry()}addGroup(e,r,i){this.addSubGeometry({indexStart:e,indexCount:r,vertexStart:e,vertexCount:0,firstStart:0,index:i,topology:0})}buildGeometry(){const e=this;this.radialSegments=Math.floor(this.radialSegments),this.heightSegments=Math.floor(this.heightSegments);const r=[],i=[],a=[],o=[];let l=0;const h=[],u=this.height/2;let c=0;x(),this.openEnded===!1&&(this.radiusTop>0&&C(!0),this.radiusBottom>0&&C(!1));let f=new Float32Array(r),d=new Float32Array(i),p=new Float32Array(a),A=new Uint16Array(o);this.setAttribute(O.position,f),this.setAttribute(O.normal,d),this.setAttribute(O.uv,p),this.setAttribute(O.TEXCOORD_1,p),this.setIndices(A);function x(){const v=new g,y=new g;let b=0;const B=(e.radiusBottom-e.radiusTop)/e.height;for(let I=0;I<=e.heightSegments;I++){const w=[],D=I/e.heightSegments,L=D*(e.radiusBottom-e.radiusTop)+e.radiusTop;for(let M=0;M<=e.radialSegments;M++){const G=M/e.radialSegments;let N=G*e.thetaLength+e.thetaStart;M==e.radialSegments&&Math.abs(e.thetaLength-e.thetaStart)==Math.PI*2&&(N=0);const q=Math.sin(N),ie=Math.cos(N);y.x=L*q,y.y=-D*e.height+u,y.z=L*ie,r.push(y.x,y.y,y.z),v.set(q,B,ie).normalize(),i.push(v.x,v.y,v.z),a.push(G,1-D),w.push(l++)}h.push(w)}for(let I=0;I<e.radialSegments;I++)for(let w=0;w<e.heightSegments;w++){const D=h[w][I],L=h[w+1][I],M=h[w+1][I+1],G=h[w][I+1];o.push(D,L,G),o.push(L,M,G),b+=6}e.addGroup(c,b,0),c+=b}function C(v){const y=l,b=new he,B=new g;let I=0;const w=v===!0?e.radiusTop:e.radiusBottom,D=v===!0?1:-1;for(let M=1;M<=e.radialSegments;M++)r.push(0,u*D,0),i.push(0,D,0),a.push(.5,.5),l++;const L=l;for(let M=0;M<=e.radialSegments;M++){const G=M/e.radialSegments*e.thetaLength+e.thetaStart,N=Math.cos(G),q=Math.sin(G);B.x=w*q,B.y=u*D,B.z=w*N,r.push(B.x,B.y,B.z),i.push(0,D,0),b.x=N*.5+.5,b.y=q*.5*D+.5,a.push(b.x,b.y),l++}for(let M=0;M<e.radialSegments;M++){const G=y+M,N=L+M;v===!0?o.push(N,N+1,G):o.push(N+1,N,G),I+=3}e.addGroup(c,I,v===!0?1:2),c+=I}}}class vv extends null{constructor(e){super();s(this,"segments");this.segments=e,this.buildGeometry()}buildGeometry(){this.bounds=new Oe;let e=(this.segments.length-1)*2*3,r=this.segments.length*2,i=new Float32Array(r*3),a=new Float32Array(r*3),o=new Float32Array(r*2),l=new Uint16Array(e),h=0;for(let c of this.segments)i[h++]=c[0].x,i[h++]=c[0].y,i[h++]=c[0].z,i[h++]=c[1].x,i[h++]=c[1].y,i[h++]=c[1].z;h=0;let u=0;for(;h<e;)l[h++]=2+u,l[h++]=1+u,l[h++]=0+u,l[h++]=1+u,l[h++]=2+u,l[h++]=3+u,u+=2;this.setIndices(l),this.setAttribute(O.position,i),this.setAttribute(O.normal,a),this.setAttribute(O.uv,o),this.setAttribute(O.TEXCOORD_1,o),this.addSubGeometry({indexStart:0,indexCount:l.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0}),this.computeNormals()}}class rm extends null{constructor(e=.4,r=.1,i=32,a=32){super();s(this,"radius");s(this,"tube");s(this,"radialSegments");s(this,"tubularSegments");this.radius=e,this.tube=r,this.radialSegments=i,this.tubularSegments=a,this.initVertex()}initVertex(){const e=2*Math.PI,r=this.radius,i=this.tube,a=this.radialSegments,o=this.tubularSegments;this.bounds=new Oe(g.ZERO.clone(),new g(r*2,i*2,r*2));var l=(a+1)*(o+1);let h=new Float32Array(l*3),u=new Float32Array(l*3),c=new Float32Array(l*2),f=new Uint16Array(a*o*2*3),d=0,p=0,A=0,x=0;for(let C=0;C<=a;C++)for(let v=0;v<=o;v++){const y=v/o,b=C/a,B=y*e,I=b*Math.PI*2;if(h[d++]=(r+i*Math.cos(I))*Math.sin(B),h[d++]=i*Math.sin(I),h[d++]=(r+i*Math.cos(I))*Math.cos(B),u[p++]=Math.sin(B)*Math.cos(I),u[p++]=Math.sin(I),u[p++]=Math.cos(B)*Math.cos(I),c[A++]=y,c[A++]=b,v<o&&C<a){const w=o+1,D=w*C+v,L=w*(C+1)+v,M=w*(C+1)+v+1,G=w*C+v+1;f[x++]=D,f[x++]=G,f[x++]=L,f[x++]=G,f[x++]=M,f[x++]=L}}this.setIndices(f),this.setAttribute(O.position,h),this.setAttribute(O.normal,u),this.setAttribute(O.uv,c),this.setAttribute(O.TEXCOORD_1,c),this.addSubGeometry({indexStart:0,indexCount:f.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class xv extends null{constructor(e){super();s(this,"segment");s(this,"row",0);this.segment=e,this.buildGeometry()}buildGeometry(){this.row=this.segment+1;let e=new Uint32Array(this.segment*6),r=new Float32Array(this.row*3*2),i=new Float32Array(this.row*3*2),a=new Float32Array(this.row*2*2);for(let o=0;o<this.row;o++){r[o*3*2+0]=0,r[o*3*2+1]=0,r[o*3*2+2]=0,r[o*3*2+3]=0,r[o*3*2+4]=0,r[o*3*2+5]=0,i[o*3*2+0]=0,i[o*3*2+1]=0,i[o*3*2+2]=1,i[o*3*2+3]=0,i[o*3*2+4]=0,i[o*3*2+5]=1,a[o*2*2+0]=0,a[o*2*2+1]=o/this.segment,a[o*2*2+2]=1,a[o*2*2+3]=o/this.segment;let l=o*2,h=l,u=l+1,c=l+2,f=l+3;e[o*6+0]=h,e[o*6+1]=u,e[o*6+2]=c,e[o*6+3]=u,e[o*6+4]=f,e[o*6+5]=c}this.setIndices(e),this.setAttribute(O.position,r),this.setAttribute(O.normal,i),this.setAttribute(O.uv,a),this.setAttribute(O.TEXCOORD_1,a),this.addSubGeometry({indexStart:0,indexCount:e.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class Cv extends null{constructor(e){super();s(this,"faceCount",0);this.faceCount=e,this.buildGeometry()}buildGeometry(){let e=new Uint32Array(this.faceCount*3),r=new Float32Array(this.faceCount*3*3),i=new Float32Array(this.faceCount*3*3),a=new Float32Array(this.faceCount*3*2),o=new Float32Array(this.faceCount*3*1);for(let l=0;l<this.faceCount;l++){let h=l*3+0,u=l*3+1,c=l*3+2;e[h]=h,e[u]=u,e[c]=c}this.setIndices(e),this.setAttribute(O.position,r),this.setAttribute(O.normal,i),this.setAttribute(O.uv,a),this.setAttribute(O.TEXCOORD_1,a),this.setAttribute(O.vIndex,o),this.addSubGeometry({indexStart:0,indexCount:e.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0})}}class _v extends null{constructor(e,r){super(e,r,6);s(this,"width",4);s(this,"height",4);s(this,"depthOrArrayLayers",6);s(this,"visibility",GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT|GPUShaderStage.COMPUTE);this.format=j.depth24plus,this.mipmapCount=1,this.init()}internalCreateBindingLayoutDesc(){this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.textureBindingLayout.viewDimension="cube"}internalCreateTexture(){this.textureDescriptor={format:"depth24plus",size:{width:this.width,height:this.height,depthOrArrayLayers:6},dimension:"2d",usage:GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING},this.gpuTexture=this.getGPUTexture()}internalCreateView(){this.viewDescriptor={dimension:"cube"},this.view=this.getGPUView()}internalCreateSampler(){this.gpuSampler=E.device.createSampler({}),this.gpuSampler_comparison=E.device.createSampler({compare:"less",label:"sampler_comparison"})}}class im extends null{constructor(){super(...arguments);s(this,"uint16Array");s(this,"floatArray");s(this,"_dataBuffer")}create(e,r,i=null,a=!0){if(i==null){i=[];for(let o=0,l=e*r*4;o<l;o++)i[o]=0}return this.updateTexture(e,r,i,a),this}updateTexture(e,r,i,a=!0){(e!=this.width||r!=this.height)&&(this._dataBuffer&&this._dataBuffer.destroy(),this._dataBuffer=null,this.gpuTexture&&this.gpuTexture.destroy(),this.gpuTexture=null),this.floatArray=i;let o=E.device;const l=e*4*2;this.format=j.rgba16float,this.mipmapCount=Math.floor(a?Math.log2(e):1),this.createTextureDescriptor(e,r,this.mipmapCount,this.format),(!this.uint16Array||this.uint16Array.length!=i.length)&&(this.uint16Array=new Uint16Array(i.length));let h=this.uint16Array;for(let f=0,d=h.length;f<d;f++)h[f]=Sa(i[f]);const u=this._dataBuffer=o.createBuffer({size:h.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});o.queue.writeBuffer(u,0,h);const c=S.beginCommandEncoder();c.copyBufferToTexture({buffer:u,bytesPerRow:l},{texture:this.getGPUTexture()},{width:e,height:r,depthOrArrayLayers:1}),this.useMipmap||(this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float"),S.endCommandEncoder(c),this.gpuSampler=o.createSampler(this),this.gpuTexture=this.getGPUTexture(),this.mipmapCount>1&&jr.webGPUGenerateMipmap(this)}}class yv extends null{create(t,e,r,i=!0){let a=E.device;const o=t*4*4;this.format=j.rgba32float,this.createTextureDescriptor(t,e,1,this.format);const l=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,r);const h=S.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:o},{texture:this.getGPUTexture()},{width:t,height:e,depthOrArrayLayers:1}),S.endCommandEncoder(h),i&&(this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float"),this.gpuSampler=a.createSampler({})}fromBuffer(t,e,r){let i=E.device;const a=t*4*4;this.format=j.rgba32float,this.mipmapCount=1,this.createTextureDescriptor(t,e,this.mipmapCount,this.format);const o=S.beginCommandEncoder();return o.copyBufferToTexture({buffer:r,bytesPerRow:a},{texture:this.getGPUTexture()},{width:t,height:e,depthOrArrayLayers:1}),S.endCommandEncoder(o),this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.gpuSampler=i.createSampler({}),this}}class Sv extends null{constructor(e){super();s(this,"_internalTexture");s(this,"_minSize",32);s(this,"_skyColor");this._skyColor=e,this._internalTexture=new im;let r=[];return m.res.fillColor(r,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.create(this._minSize,this._minSize,r,!1),this.createFromTexture(this._minSize,this._internalTexture),this}changeColor(e){return this._skyColor=e,m.res.fillColor(this._internalTexture.floatArray,this._minSize,this._minSize,this.color.r,this.color.g,this.color.b,this.color.a),this._internalTexture.updateTexture(this._minSize,this._minSize,this._internalTexture.floatArray,!1),this._faceData.uploadTexture(0,this._internalTexture),this}get color(){return this._skyColor}set color(e){this.changeColor(e)}}class Iv extends null{create(t,e,r,i=!0){let a=E.device;const o=t*4*4;this.format=j.rgba16float,this.mipmapCount=Math.floor(i?Math.log2(t):1),this.createTextureDescriptor(t,e,this.mipmapCount,this.format);const l=a.createBuffer({size:r.byteLength,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.COPY_SRC});a.queue.writeBuffer(l,0,r);const h=S.beginCommandEncoder();h.copyBufferToTexture({buffer:l,bytesPerRow:o},{texture:this.getGPUTexture()},{width:t,height:e,depthOrArrayLayers:1}),S.endCommandEncoder(h),this.minFilter="nearest",this.magFilter="nearest",this.mipmapFilter="nearest",this.samplerBindingLayout.type="non-filtering",this.textureBindingLayout.sampleType="unfilterable-float",this.minFilter="linear",this.magFilter="linear",this.mipmapFilter="nearest",this.samplerBindingLayout.type="filtering",this.textureBindingLayout.sampleType="float",this.gpuSampler=a.createSampler(this),this.mipmapCount>1&&jr.webGPUGenerateMipmap(this)}}class bv extends null{constructor(e,r=.1){super();s(this,"length",100);s(this,"thickness",.1);this.length=e,this.thickness=r,this.init()}init(){let e=new ee,r=new ee,i=new ee,a=new Br(2,2,2),o=new Br(2,2,2),l=new Br(2,2,2),h=new Yt;h.baseColor=new K(1,0,0);let u=new Yt;u.baseColor=new K(0,1,0);let c=new Yt;c.baseColor=new K(0,0,1);let f=e.addComponent($),d=r.addComponent($),p=i.addComponent($);f.geometry=a,f.material=h,f.castShadow=!1,d.geometry=o,d.material=u,d.castShadow=!1,p.geometry=l,p.material=c,p.castShadow=!1,e.localScale=new g(this.length,this.thickness,this.thickness),e.x=this.length,r.localScale=new g(this.thickness,this.length,this.thickness),r.y=this.length,i.localScale=new g(this.thickness,this.thickness,this.length),i.z=this.length,this.addChild(e),this.addChild(r),this.addChild(i)}}let wv=function(n){return V(this,null,function*(){return new Promise((t,e)=>{setTimeout(()=>{t(!0)},n)})})},Tv=function(n){return V(this,null,function*(){return new Promise((t,e)=>{n=Math.max(1,n);let r=function(){n<0?t(!0):requestAnimationFrame(r),n--};requestAnimationFrame(r)})})};class Ev{static merge(t,e,r){}static mergeNumber(t,e,r){let i=r||new qt,a=t.getAttribute(O.position).data.length/3,o=new Float32Array(a*e);for(const c of t.vertexAttributeMap){let f=c[1].attribute;if(f==O.indices)continue;let d=t.getAttribute(f).data,p=d.length,A=new Float32Array(p*e);for(let x=0;x<e;x++){A.set(d,p*x);for(let C=0;C<a;C++)o[a*x+C]=x}i.setAttribute(f,A)}i.setAttribute(O.vIndex,o);let l=t.getAttribute(O.indices).data,h=l.length,u=new Uint32Array(l.length*e);for(let c=0;c<e;c++)for(let f=0;f<h;f++){let d=c*a,p=c*h;const A=l[f]+d;u[p+f]=A}return i.setIndices(u),i.addSubGeometry({indexStart:0,indexCount:u.length,vertexStart:0,index:0,vertexCount:0,firstStart:0,topology:0}),i}static generateNormal(){}static generateTangent(){}static packUV(){}}class Bv extends null{constructor(e=100,r=10){super();s(this,"size",100);s(this,"divisions",10);this.size=e,this.divisions=r,this.buildGeometry(),this.addAxis()}buildGeometry(){const e=[],r=[],i=this.size/this.divisions,a=this.size/2,o=this.divisions/2;for(let c=0,f=-a;c<=this.divisions;c++,f+=i)c!==o&&(e.push(-a,0,f,a,0,f),e.push(f,0,-a,f,0,a));for(let c=0;c<e.length/3;c+=2)r.push(c,c+1);let l=new qt;l.setIndices(r.length>Uint16Array.length?new Uint32Array(r):new Uint16Array(r)),l.setAttribute(O.position,new Float32Array(e)),l.addSubGeometry({indexStart:0,indexCount:r.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0});let h=new Yt;h.topology="line-list",h.baseColor=new K(1,1,1,.15),h.blendMode=oe.ADD,h.castReflection=!1;let u=this.addComponent($);u.geometry=l,u.material=h}addAxis(){const e=this.size/2;let r=new Float32Array([-e,0,0,e,0,0]),i=new Uint16Array([0,1,2,3]),a=new qt;a.setIndices(i),a.setAttribute(O.position,r),a.addSubGeometry({indexStart:0,indexCount:i.length,vertexStart:0,vertexCount:0,firstStart:0,index:0,topology:0});{let o=new ee,l=o.addComponent($);l.geometry=a;let h=l.material=new Yt;h.baseColor=new K(1,0,0,.5),h.blendMode=oe.ADD,h.castReflection=!1,h.topology="line-list",this.addChild(o)}{let o=new ee;o.rotationY=90;let l=o.addComponent($);l.geometry=a;let h=l.material=new Yt;h.baseColor=new K(0,1,0,.5),h.blendMode=oe.ADD,h.castReflection=!1,h.topology="line-list",this.addChild(o)}}}class Dv{static color_temperature_to_rgb(t){t<1e3?t=1e3:t>4e4&&(t=4e4);let e=t/100,r=this.get_red(e),i=this.get_green(e),a=this.get_blue(e);return new K(r/255,i/255,a/255,1)}static get_red(t){if(t<=66)return 255;let e=329.698727446*Math.pow(t-60,-.1332047592);return this.bound(e)}static get_green(t){let e=0;return t<=66?e=99.4708025861*Math.log(t)-161.1195681661:e=288.1221695283*Math.pow(t-60,-.0755148492),this.bound(e)}static get_blue(t){let e=0;return t>=66?255:t<=19?0:(e=138.5177312231*Math.log(t-10)-305.0447927307,this.bound(e))}static bound(t,e=0,r=255){let i=Math.max(t,e);return Math.min(i,r)}}class za{static initHeap(){this.boxGeo||(this.boxGeo=new Br),this.planeGeo||(this.planeGeo=new va(1,1,1,1,g.UP)),this.sphere||(this.sphere=new Ea(1,35,35)),this.material||(this.material=new Ir),this.materialMap||(this.materialMap=new Map)}static get CubeMesh(){return this.initHeap(),this.boxGeo}static get SphereMesh(){return this.initHeap(),this.sphere}static GetCube(){this.initHeap();let t=new ee,e=t.addComponent($);return e.geometry=this.boxGeo,e.material=this.material.clone(),e.castShadow=!0,t}static GetMaterial(t){let e=this.materialMap.get(t);return e||(e=new Ir,e.baseMap=t,this.materialMap.set(t,e)),e.clone()}static GetPlane(t){this.initHeap();let e=new ee,r=e.addComponent($);r.geometry=this.planeGeo;let i=this.GetMaterial(t);return i.blendMode=oe.ADD,i.castShadow=!1,r.material=i,r.castGI=!1,r.castReflection=!1,e}static GetSingleCube(t,e,r,i,a,o){this.initHeap();let l=new Ir;l.roughness=.5,l.metallic=.1,l.baseColor=new K(i,a,o,1);let h=new ee,u=h.addComponent($);return u.castGI=!0,u.geometry=new Br(t,e,r),u.material=l,h}static GetSingleSphere(t,e,r,i){this.initHeap();let a=new Ir;a.baseColor=new K(e,r,i,1);let o=new ee,l=o.addComponent($);return l.castGI=!0,l.geometry=new Ea(t,20,20),l.material=a,o}static get Sphere(){this.initHeap();let t=new ee,e=t.addComponent($);return e.geometry=this.sphere,e.material=this.material,t}static GetSingleCube2(t,e=10){this.initHeap();let r=new ee,i=r.addComponent($);return i.castShadow=!1,i.geometry=new Br(e,e,e),i.material=t,r}static GetPointLight(t,e,r,i,a,o,l=1,h=!0){let u=new ee,c=u.addComponent(_a);c.lightColor=new K(i,a,o,1),c.intensity=l,c.range=r,c.at=8,c.radius=0,c.castShadow=h,u.localPosition=t,u.localRotation=e;let f=this.GetSingleSphere(.1,1,1,1);return u.addChild(f),c}}s(za,"boxGeo"),s(za,"planeGeo"),s(za,"sphere"),s(za,"material"),s(za,"materialMap");const Hs=class Hs{static load(t){let e=localStorage.getItem(t);return e?this.localData=JSON.parse(e):(this.localData={},Hs.save(t,this.localData)),this.localData}static save(t,e){let r=JSON.stringify(e);localStorage.setItem(t,r)}};s(Hs,"localData");let Zl=Hs;class Mv extends null{}class Pv extends null{}class Rv extends null{}class Uv extends null{constructor(){super(...arguments);s(this,"x",0);s(this,"y",0);s(this,"z",0);s(this,"w",0)}}var P=(n=>(n[n.X=0]="X",n[n.Y=1]="Y",n[n.Z=2]="Z",n[n.XY=3]="XY",n[n.XZ=4]="XZ",n[n.YZ=5]="YZ",n[n.XYZ=6]="XYZ",n[n.MAX=7]="MAX",n[n.NONE=8]="NONE",n))(P||{}),cr=(n=>(n[n.Local=0]="Local",n[n.Global=1]="Global",n))(cr||{});class Lv extends null{constructor(){super();s(this,"mAxis");s(this,"mAxisColor");s(this,"mContainer");s(this,"mAxisMaterial");s(this,"mAxisCollider");s(this,"currentAxis",P.NONE);s(this,"beginPoint",new g);s(this,"beginMousePos",new g);s(this,"currentPoint",new g);s(this,"lastMoveObj");s(this,"lastMoveAxis");this._enable=!1,this.mAxis=new Array(P.MAX),this.mAxisColor=new Array(P.MAX),this.mAxisMaterial=new Array(P.MAX),this.mAxisCollider=new Array(P.MAX)}get target(){return this.object3D.target}get mX(){return this.object3D.mXObj}get mY(){return this.object3D.mYObj}get mZ(){return this.object3D.mZObj}get transformSpaceMode(){return this.object3D.transformSpaceMode}init(e){this.mContainer=new ee;let r=new Yt;r.baseColor=new K(1,0,0),r.depthCompare=ct.always,this.mAxisColor[P.X]=r.baseColor,this.mAxisMaterial[P.X]=r;let i=new Yt;i.baseColor=new K(0,1,0),i.depthCompare=ct.always,this.mAxisColor[P.Y]=i.baseColor,this.mAxisMaterial[P.Y]=i;let a=new Yt;a.baseColor=new K(0,0,1),a.depthCompare=ct.always,this.mAxisColor[P.Z]=a.baseColor,this.mAxisMaterial[P.Z]=a;let o=this.createCustomAxis(P.X),l=this.createCustomAxis(P.Y),h=this.createCustomAxis(P.Z);this.mContainer.addChild(this.mAxis[P.X]=o),this.mContainer.addChild(this.mAxis[P.Y]=l),this.mContainer.addChild(this.mAxis[P.Z]=h),this.mAxisCollider[P.X]=o.getComponent(hr),this.mAxisCollider[P.Y]=l.getComponent(hr),this.mAxisCollider[P.Z]=h.getComponent(hr)}start(){}onEnable(e){this.object3D.addChild(this.mContainer),this.reset()}onDisable(e){this.object3D.removeChild(this.mContainer)}reset(){switch(this.transformSpaceMode){case cr.Local:{let e=Q.help_matrix_0.copyFrom(this.mX.transform.worldMatrix).decompose();this.object3D.scaleX=1,this.object3D.scaleY=1,this.object3D.scaleZ=1,this.object3D.rotationX=e[1].x,this.object3D.rotationY=e[1].y,this.object3D.rotationZ=e[1].z,this.object3D.x=e[0].x,this.object3D.y=e[0].y,this.object3D.z=e[0].z}break;case cr.Global:{this.object3D.scaleX=1,this.object3D.scaleY=1,this.object3D.scaleZ=1,this.object3D.rotationX=0,this.object3D.rotationY=0,this.object3D.rotationZ=0;const e=this.mX.transform.worldPosition;this.object3D.x=e.x,this.object3D.y=e.y,this.object3D.z=e.z}break}}pickAxis(){let e=this.object3D.transform.scene3D.view.camera.screenPointToRay(m.inputSystem.mouseX,m.inputSystem.mouseY),r,i;for(let a=0;a<=P.MAX;a++){let o=this.mAxisCollider[a];if(o&&(r=o.rayPick(e),r&&(!i||i.distance>r.distance||a==P.XYZ)&&(i={axis:a,obj:o.object3D,distance:r.distance,intersectPoint:r.intersectPoint},a==P.XYZ)))break}return i}onMouseDown(e){if(e.mouseCode!=Ho.MOUSE_LEFT)return;let r=this.pickAxis();if(!r)return;this.currentAxis=r.axis,e.stopImmediatePropagation();const i=this.object3D.transform.scene3D.view.camera;let a=i.worldToScreenPoint(this.mX.transform.worldPosition),o=i.screenPointToWorld(m.inputSystem.mouseX,m.inputSystem.mouseY,a.z);this.beginPoint.copyFrom(o),this.beginMousePos.x=m.inputSystem.mouseX,this.beginMousePos.y=m.inputSystem.mouseY}onMouseMove(e){if(this.currentAxis==P.NONE){let r=this.lastMoveObj.getComponent($).material;this.lastMoveObj&&"baseColor"in r&&(r.baseColor=this.mAxisColor[this.lastMoveAxis],this.lastMoveObj=null,this.lastMoveAxis==P.XYZ&&(this.mAxis[P.X].getComponent($).material.setUniformColor("baseColor",this.mAxisColor[P.X]),this.mAxis[P.Y].getComponent($).material.setUniformColor("baseColor",this.mAxisColor[P.Y]),this.mAxis[P.Z].getComponent($).material.setUniformColor("baseColor",this.mAxisColor[P.Z])),this.lastMoveAxis=P.NONE);let i=this.pickAxis();if(!i)return;r.setUniformColor("baseColor",new K(1,1,1)),this.lastMoveObj=i.obj,this.lastMoveAxis=i.axis,this.lastMoveAxis==P.XYZ&&(this.mAxis[P.X].getComponent($).material.setUniformColor("baseColor",new K(1,1,1)),this.mAxis[P.Y].getComponent($).material.setUniformColor("baseColor",new K(1,1,1)),this.mAxis[P.Z].getComponent($).material.setUniformColor("baseColor",new K(1,1,1)))}else{const r=this.object3D.transform.scene3D.view.camera;let i=r.worldToScreenPoint(this.mX.transform.worldPosition),a=r.screenPointToWorld(m.inputSystem.mouseX,m.inputSystem.mouseY,i.z);this.currentPoint.copyFrom(a);let o=a.subtract(this.beginPoint);g.HELP_0.set(m.inputSystem.mouseX,m.inputSystem.mouseY,0);let l=g.distance(g.HELP_0,this.beginMousePos);switch(this.beginMousePos.copyFrom(g.HELP_0),this.transformSpaceMode){case cr.Local:this.applyLocalTransform(this.currentAxis,o,l);break;case cr.Global:this.applyGlobalTransform(this.currentAxis,o,l);break}this.beginPoint.copyFrom(a),this.reset()}}onMouseUp(e){e.mouseCode==Ho.MOUSE_LEFT&&(this.currentAxis=P.NONE,this.reset())}onUpdate(e){let r=g.distance(e.camera.transform.worldPosition,this.object3D.transform.worldPosition)/100;if(this.mContainer.scaleX=this.mContainer.scaleY=this.mContainer.scaleZ=r,this.mX){const i=this.mX.transform.worldPosition;this.object3D.x=i.x,this.object3D.y=i.y,this.object3D.z=i.z}}applyLocalTransform(e,r,i){console.warn("not imp")}applyGlobalTransform(e,r,i){console.warn("not imp")}createCustomAxis(e){return this.createAxis(e)}createAxis(e){let r=0,i=0,a=0;switch(e){case P.X:r=1;break;case P.Y:i=1;break;case P.Z:a=1;break}let o=.4+r*20,l=.4+i*20,h=.4+a*20,u=new ee;u.x=o*.5,u.y=l*.5,u.z=h*.5;let c=u.addComponent($);c.geometry=new Br(o,l,h),c.material=this.mAxisMaterial[e];let f=u.addComponent(hr),d=new Ma;return d.setFromCenterAndSize(new g(0,0,0),new g(o+1,l+1,h+1)),f.shape=d,u}}class am extends null{init(t){super.init(t);let e=new Yt;e.doubleSide=!0,e.baseColor=new K(.9,.9,.9),e.depthCompare=ct.always,this.mAxisColor[P.XYZ]=e.baseColor,this.mAxisMaterial[P.XYZ]=e;let r=new ee,i=r.addComponent($);i.geometry=new Br(2,2,2),i.material=this.mAxisMaterial[P.XYZ];let a=r.addComponent(hr),o=new Ma;o.setFromCenterAndSize(new g(0,0,0),new g(2,2,2)),a.shape=o,this.mContainer.addChild(this.mAxis[P.XYZ]=r),this.mAxisCollider[P.XYZ]=r.getComponent(hr)}applyLocalTransform(t,e,r){switch(this.currentAxis){case P.XYZ:{let i=0;Math.abs(e.x)>Math.abs(e.y)?Math.abs(e.x)>Math.abs(e.z)?i=e.x:i=e.z:i=e.y,this.mX.scaleX+=i,this.mX.scaleY+=i,this.mX.scaleZ+=i}break;default:this.mX.transform.worldMatrix.transformVector(e,e),(this.currentAxis==P.X||this.currentAxis==P.XY||this.currentAxis==P.XZ)&&(this.mX.scaleX=Math.abs(this.mX.scaleX+e.x)),(this.currentAxis==P.Y||this.currentAxis==P.XY||this.currentAxis==P.YZ)&&(this.mX.scaleY=Math.abs(this.mX.scaleY+e.y)),(this.currentAxis==P.Z||this.currentAxis==P.XZ||this.currentAxis==P.YZ)&&(this.mX.scaleZ=Math.abs(this.mX.scaleZ+e.z));break}}applyGlobalTransform(t,e,r){let i=g.HELP_0;i.set(0,0,0),(this.currentAxis==P.X||this.currentAxis==P.XY||this.currentAxis==P.XZ)&&(i.x=e.x),(this.currentAxis==P.Y||this.currentAxis==P.XY||this.currentAxis==P.YZ)&&(i.y=e.y),(this.currentAxis==P.Z||this.currentAxis==P.XZ||this.currentAxis==P.YZ)&&(i.z=e.z),this.mX.transform.worldMatrix.transformVector(i,g.HELP_1),this.mX.scaleX+=g.HELP_1.x,this.mX.scaleY+=g.HELP_1.y,this.mX.scaleZ+=g.HELP_1.z}createCustomAxis(t){let e=super.createAxis(t),r=this.createBox(t);return e.addChild(r),e}createBox(t){let e=0,r=0,i=0,a=new ee;switch(t){case P.X:e=1,a.rotationZ=-90;break;case P.Y:r=1;break;case P.Z:i=1,a.rotationX=90;break}let o=.2+e*20,l=.2+r*20,h=.2+i*20;a.x=o*.5,a.y=l*.5,a.z=h*.5;let u=a.addComponent($);return u.geometry=new Br(2,2,2),u.material=this.mAxisMaterial[t],a}}var ut=(n=>(n[n.Scale=0]="Scale",n[n.Rotation=1]="Rotation",n[n.Translation=2]="Translation",n[n.NONE=3]="NONE",n))(ut||{});class sm extends null{constructor(){super(...arguments);s(this,"mLastAngle",0)}applyLocalTransform(e,r,i){if(this.currentAxis==P.X||this.currentAxis==P.XY||this.currentAxis==P.XZ,this.currentAxis==P.Y||this.currentAxis==P.XY||this.currentAxis==P.YZ){Q.help_matrix_0.copyFrom(this.mX.transform.worldMatrix),Q.help_matrix_1.identity(),Q.help_matrix_1.createByRotation(1,g.Y_AXIS),Q.help_matrix_2.multiplyMatrices(Q.help_matrix_1,Q.help_matrix_0),Q.help_matrix_2.invert(),Q.help_matrix_1.multiplyMatrices(Q.help_matrix_2,Q.help_matrix_0);let a=Q.help_matrix_1.decompose();this.mX.rotationX+=a[1].x,this.mY.rotationY+=a[1].y,this.mZ.rotationZ+=a[1].z}this.currentAxis==P.Z||this.currentAxis==P.XZ||this.currentAxis==P.YZ}getAngle(){const e=this.object3D.transform.scene3D.view.camera,r=this.mZ.transform.worldPosition;if(e.screenPointToRay(m.inputSystem.mouseX,m.inputSystem.mouseY),this.currentAxis==P.X){let i=e.worldToScreenPoint(r);g.HELP_1.set(i.x,i.y,0),g.HELP_2.set(m.inputSystem.mouseX,m.inputSystem.mouseY,0);let a=g.HELP_2.subtract(g.HELP_1),o=g.getAngle(g.X_AXIS,a);return a.y>0&&(o=360-o),e.transform.worldPosition.x-r.x>0&&(o=360-o),o}if(this.currentAxis==P.Y){let i=e.worldToScreenPoint(r);g.HELP_1.set(i.x,i.y,0),g.HELP_2.set(m.inputSystem.mouseX,m.inputSystem.mouseY,0);let a=g.HELP_2.subtract(g.HELP_1),o=g.getAngle(g.X_AXIS,a);return a.y>0&&(o=360-o),e.transform.worldPosition.y-r.y>0&&(o=360-o),o}if(this.currentAxis==P.Z){let i=e.worldToScreenPoint(r);g.HELP_1.set(i.x,i.y,0),g.HELP_2.set(m.inputSystem.mouseX,m.inputSystem.mouseY,0);let a=g.HELP_2.subtract(g.HELP_1),o=g.getAngle(g.X_AXIS,a);return a.y>0&&(o=360-o),e.transform.worldPosition.z-r.z>0&&(o=360-o),o}return 0}applyGlobalTransform(e,r,i){if(this.currentAxis==P.X||this.currentAxis==P.Y||this.currentAxis==P.Z){let a=this.getAngle();switch(Q.help_matrix_0.identity(),this.currentAxis){case P.X:Q.help_matrix_0.createByRotation(this.mLastAngle-a,g.X_AXIS);break;case P.Y:Q.help_matrix_0.createByRotation(this.mLastAngle-a,g.Y_AXIS);break;case P.Z:Q.help_matrix_0.createByRotation(this.mLastAngle-a,g.Z_AXIS);break}Q.help_matrix_1.copyFrom(this.mX.transform.worldMatrix),Q.help_matrix_1.append(Q.help_matrix_0),this.mX.parent&&(Q.help_matrix_2.copyFrom(this.mX.parent.worldMatrix),Q.help_matrix_2.invert(),Q.help_matrix_1.multiply(Q.help_matrix_2));let o=Q.help_matrix_1.decompose(Gt.QUATERNION)[1];Z.HELP_0.set(o.x,o.y,o.z,o.w),this.mLastAngle=a,this.mX.transform.localRotQuat=Z.HELP_0}}onMouseDown(e){super.onMouseDown(e),this.currentAxis!=P.NONE&&(this.mAxis[P.X].getComponent($).enable=!1,this.mAxis[P.Y].getComponent($).enable=!1,this.mAxis[P.Z].getComponent($).enable=!1,this.mAxis[this.currentAxis].getComponent($).enable=!0,this.mLastAngle=this.getAngle())}onMouseUp(e){super.onMouseUp(e),this.currentAxis==P.NONE&&(this.mAxis[P.X].getComponent($).enable=!0,this.mAxis[P.Y].getComponent($).enable=!0,this.mAxis[P.Z].getComponent($).enable=!0)}createCustomAxis(e){return this.createAxis(e)}createAxis(e){let r=new ee;switch(e){case P.X:r.rotationZ=90;break;case P.Y:break;case P.Z:r.rotationX=90;break}let i=r.addComponent($);i.geometry=new rm(20,.4),i.material=this.mAxisMaterial[e];let a=r.addComponent(hr),o=new Ma;return o.setFromCenterAndSize(new g,new g(40,.4,40)),a.shape=o,r}pickAxis(){let e=this.object3D.transform.scene3D.view.camera.screenPointToRay(m.inputSystem.mouseX,m.inputSystem.mouseY),r,i;for(let a=0;a<=P.MAX;a++){let o=this.mAxisCollider[a];if(o&&(r=o.rayPick(e),r)){let l=g.distance(r.intersectPoint,o.shape.center);if(l>20+.8||l<20-.8)continue;(!i||i.distance>r.distance)&&(i={axis:a,obj:o.object3D,distance:r.distance,intersectPoint:r.intersectPoint})}}return i}}class om extends null{init(t){super.init(t);let e=new Yt;e.doubleSide=!0,e.baseColor=new K(0,0,1),e.depthCompare=ct.always,this.mAxisColor[P.XY]=e.baseColor,this.mAxisMaterial[P.XY]=e;let r=new Yt;r.doubleSide=!0,r.baseColor=new K(0,1,0),r.depthCompare=ct.always,this.mAxisColor[P.XZ]=r.baseColor,this.mAxisMaterial[P.XZ]=r;let i=new Yt;i.doubleSide=!0,i.baseColor=new K(1,0,0),i.depthCompare=ct.always,this.mAxisColor[P.YZ]=i.baseColor,this.mAxisMaterial[P.YZ]=i;let a=this.createPlane(P.XY),o=this.createPlane(P.XZ),l=this.createPlane(P.YZ);this.mContainer.addChild(this.mAxis[P.XY]=a),this.mContainer.addChild(this.mAxis[P.XZ]=o),this.mContainer.addChild(this.mAxis[P.YZ]=l),this.mAxisCollider[P.XY]=a.getComponent(hr),this.mAxisCollider[P.XZ]=o.getComponent(hr),this.mAxisCollider[P.YZ]=l.getComponent(hr)}applyLocalTransform(t,e,r){Q.help_matrix_0.copyFrom(this.mX.transform.worldMatrix).invert(),Q.help_matrix_0.transformVector(e,g.HELP_0),this.currentAxis==P.X||this.currentAxis==P.XY||this.currentAxis==P.XZ||(g.HELP_0.x=0),this.currentAxis==P.Y||this.currentAxis==P.XY||this.currentAxis==P.YZ||(g.HELP_0.y=0),this.currentAxis==P.Z||this.currentAxis==P.XZ||this.currentAxis==P.YZ||(g.HELP_0.z=0),this.mX.transform.worldMatrix.transformVector(g.HELP_0,g.HELP_1),this.mX.x+=g.HELP_1.x,this.mX.y+=g.HELP_1.y,this.mX.z+=g.HELP_1.z}applyGlobalTransform(t,e,r){Q.help_matrix_0.identity(),(this.currentAxis==P.X||this.currentAxis==P.XY||this.currentAxis==P.XZ)&&Q.help_matrix_0.appendTranslation(e.x,0,0),(this.currentAxis==P.Y||this.currentAxis==P.XY||this.currentAxis==P.YZ)&&Q.help_matrix_0.appendTranslation(0,e.y,0),(this.currentAxis==P.Z||this.currentAxis==P.XZ||this.currentAxis==P.YZ)&&Q.help_matrix_0.appendTranslation(0,0,e.z),Q.help_matrix_1.copyFrom(this.mX.transform.worldMatrix),Q.help_matrix_1.append(Q.help_matrix_0),this.mX.parent&&(Q.help_matrix_2.copyFrom(this.mX.parent.worldMatrix),Q.help_matrix_2.invert(),Q.help_matrix_1.multiply(Q.help_matrix_2));let i=Q.help_matrix_1.decompose(Gt.QUATERNION);this.mX.transform.localPosition=i[0],console.log(this.target.localPosition)}createCustomAxis(t){let e=super.createAxis(t),r=this.createArrows(t);return e.addChild(r),e}createArrows(t){let e=0,r=0,i=0,a=new ee;switch(t){case P.X:e=1,a.rotationZ=-90;break;case P.Y:r=1,a.rotationY=-90;break;case P.Z:i=1,a.rotationX=90;break}let o=.2+e*20,l=.2+r*20,h=.2+i*20;a.x=o*.5,a.y=l*.5,a.z=h*.5;let u=a.addComponent($);return u.geometry=new tm(0,1,4),u.material=this.mAxisMaterial[t],a}createPlane(t){let e=new ee,r=e.addComponent($);r.material=this.mAxisMaterial[t];let i=e.addComponent(hr),a=new Ma;switch(i.shape=a,t){case P.XY:r.geometry=new va(4,4,1,1,g.Z_AXIS),e.x=8,e.y=8,a.setFromCenterAndSize(new g(0,0,0),new g(4,4,.1));break;case P.XZ:r.geometry=new va(4,4,1,1,g.Y_AXIS),e.x=8,e.z=8,a.setFromCenterAndSize(new g(0,0,0),new g(4,.1,4));break;case P.YZ:r.geometry=new va(4,4,1,1,g.X_AXIS),e.y=8,e.z=8,a.setFromCenterAndSize(new g(0,0,0),new g(.1,4,4));break}return e}}const Xs=class Xs extends null{constructor(){super();s(this,"mTarget");s(this,"mTransformMode",ut.NONE);s(this,"mTransformSpaceType",cr.Global);s(this,"mControllers");s(this,"mXObj");s(this,"mYObj");s(this,"mZObj");this.mControllers=[null,null,null],this.mControllers[ut.Scale]=this.addComponent(am),this.mControllers[ut.Rotation]=this.addComponent(sm),this.mControllers[ut.Translation]=this.addComponent(om),this.mControllers[ut.Scale].enable=!1,this.mControllers[ut.Rotation].enable=!1,this.mControllers[ut.Translation].enable=!1,this.mXObj=new ee,this.mYObj=new ee,this.mZObj=new ee,this.mXObj.addChild(this.mYObj),this.mYObj.addChild(this.mZObj)}static get instance(){return this._instance||(this._instance=new Xs),this._instance}get transformMode(){return this.mTransformMode}get transformSpaceMode(){return this.mTransformSpaceType}active(e){e.addChild(this),e.addChild(this.mXObj)}unActive(e){e.removeChild(this)}get target(){return this.mTarget}selectObject(e,r,i){this.mTarget!=e&&(e?this.activate():this.unactivate(),this.mTarget=e,this.mXObj.localPosition=e.transform.worldPosition.clone()),r!=null&&this.selectTransformMode(r),i!=null&&this.selectTransformSpaceMode(i)}selectTransformMode(e){this.mTransformMode!=e&&(this.mTransformMode!=ut.NONE&&(this.mControllers[this.mTransformMode].enable=!1),this.mTransformMode=e,this.mTransformMode!=ut.NONE&&(this.mControllers[this.mTransformMode].enable=!0))}selectTransformSpaceMode(e){this.mTransformSpaceType!=e&&(this.mTransformSpaceType=e,this.mTransformMode!=ut.NONE&&this.mControllers[this.mTransformMode].reset())}activate(){m.inputSystem.addEventListener(ar.KEY_DOWN,this.onKeyDown,this),m.inputSystem.addEventListener(F.POINTER_DOWN,this.onMouseDown,this,null,99999),m.inputSystem.addEventListener(F.POINTER_MOVE,this.onMouseMove,this,null,99999),m.inputSystem.addEventListener(F.POINTER_UP,this.onMouseUp,this,null,99999)}unactivate(){m.inputSystem.removeEventListener(ar.KEY_DOWN,this.onKeyDown,this),m.inputSystem.removeEventListener(F.POINTER_DOWN,this.onMouseDown,this),m.inputSystem.removeEventListener(F.POINTER_MOVE,this.onMouseMove,this),m.inputSystem.removeEventListener(F.POINTER_UP,this.onMouseUp,this)}onKeyDown(e){switch(e.keyCode){case ze.Key_R:this.selectTransformMode(ut.Scale),this.selectTransformSpaceMode(cr.Local);break;case ze.Key_E:this.selectTransformMode(ut.Rotation),this.selectTransformSpaceMode(cr.Global);break;case ze.Key_W:this.selectTransformMode(ut.Translation),this.selectTransformSpaceMode(cr.Global);break;case ze.Key_A:this.selectTransformSpaceMode(cr.Local);break;case ze.Key_S:this.selectTransformSpaceMode(cr.Global);break}}onMouseDown(e){this.mTransformMode!=ut.NONE&&this.mControllers[this.mTransformMode].onMouseDown(e)}onMouseMove(e){this.mTransformMode!=ut.NONE&&this.mControllers[this.mTransformMode].onMouseMove(e)}onMouseUp(e){this.mTransformMode!=ut.NONE&&this.mControllers[this.mTransformMode].onMouseUp(e)}};s(Xs,"_instance");let $l=Xs;const nm=Object.freeze(Object.defineProperty({__proto__:null},Symbol.toStringTag,{value:"Module"}))}}]);
}());